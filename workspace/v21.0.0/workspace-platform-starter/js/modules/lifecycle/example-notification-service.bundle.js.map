{"version":3,"file":"example-notification-service.bundle.js","mappings":"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","sources":["webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/utils.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/lifecycle/example-notification-service/index.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/lifecycle/example-notification-service/lifecycle.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/fdc3/errors.ts"],"sourcesContent":["/**\n * Test if a value is a undefined or null.\n * @param value The value to test.\n * @returns True if the value is null or undefined.\n */\nexport function isEmpty(value: unknown): value is null | undefined {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value === undefined || value === null;\n}\n\n/**\n * Test if a value is an object.\n * @param value The value to test.\n * @returns True if the value is an object.\n */\nexport function isObject(value: unknown): value is object {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n/**\n * Test if a value is a string.\n * @param value The value to test.\n * @returns True if the value is a string.\n */\nexport function isString(value: unknown): value is string {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"string\";\n}\n\n/**\n * Test if a value is a string that is not empty.\n * @param value The value to test.\n * @returns True if the value is a string that is not empty.\n */\nexport function isStringValue(value: unknown): value is string {\n\treturn isString(value) && value.trim().length > 0;\n}\n\n/**\n * Test if a value is a number.\n * @param value The value to test.\n * @returns True if the value is a number.\n */\nexport function isNumber(value: unknown): value is number {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"number\";\n}\n\n/**\n * Test if a value is a number with a real value i.e. not NaN or Infinite.\n * @param value The value to test.\n * @returns True if the value is a number.\n */\nexport function isNumberValue(value: unknown): value is number {\n\treturn isNumber(value) && !Number.isNaN(value) && Number.isFinite(value);\n}\n\n/**\n * Test if a value is a boolean.\n * @param value The value to test.\n * @returns True if the value is a boolean.\n */\nexport function isBoolean(value: unknown): value is boolean {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"boolean\";\n}\n\n/**\n * Test if a value is an integer.\n * @param value The value to test.\n * @returns True if the value is an integer.\n */\nexport function isInteger(value: unknown): value is number {\n\treturn isNumber(value) && Number.isInteger(value);\n}\n\n/**\n * Deep clone an object.\n * @param obj The object to clone.\n * @returns The clone of the object.\n */\nexport function objectClone<T>(obj: T): T {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn obj === undefined ? (undefined as T) : JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Do a deep comparison of the objects.\n * @param obj1 The first object to compare.\n * @param obj2 The second object to compare.\n * @param matchPropertyOrder If true the properties must be in the same order.\n * @returns True if the objects are the same.\n */\nexport function deepEqual(obj1: unknown, obj2: unknown, matchPropertyOrder: boolean = true): boolean {\n\tif (isObject(obj1) && isObject(obj2)) {\n\t\tconst objKeys1 = Object.keys(obj1);\n\t\tconst objKeys2 = Object.keys(obj2);\n\n\t\tif (objKeys1.length !== objKeys2.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (matchPropertyOrder && JSON.stringify(objKeys1) !== JSON.stringify(objKeys2)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const key of objKeys1) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst value1 = (obj1 as any)[key];\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst value2 = (obj2 as any)[key];\n\n\t\t\tif (!deepEqual(value1, value2, matchPropertyOrder)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t} else if (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\tif (obj1.length !== obj2.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < obj1.length; i++) {\n\t\t\tif (!deepEqual(obj1[i], obj2[i], matchPropertyOrder)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn JSON.stringify(obj1) === JSON.stringify(obj2);\n}\n\n/**\n * Deep merge two objects.\n * @param target The object to be merged into.\n * @param sources The objects to merge into the target.\n * @returns The merged object.\n */\nexport function deepMerge<T = unknown>(target: T, ...sources: T[]): T {\n\tif (!Array.isArray(sources) || sources.length === 0) {\n\t\treturn target;\n\t}\n\n\tconst targetAsMap = target as { [id: string]: unknown };\n\tconst source = sources.shift();\n\n\tlet keys;\n\tif (isObject(targetAsMap) && isObject(source)) {\n\t\tkeys = Object.keys(source);\n\t} else if (Array.isArray(source)) {\n\t\tif (!Array.isArray(target)) {\n\t\t\treturn source;\n\t\t}\n\t\tkeys = Object.keys(source).map((k) => Number.parseInt(k, 10));\n\t}\n\n\tif (keys) {\n\t\tconst sourceAsMap = source as { [id: string]: unknown };\n\t\tfor (const key of keys) {\n\t\t\tconst value = sourceAsMap[key];\n\t\t\tif (isObject(value)) {\n\t\t\t\tif (isEmpty(targetAsMap[key])) {\n\t\t\t\t\ttargetAsMap[key] = {};\n\t\t\t\t}\n\t\t\t\tdeepMerge(targetAsMap[key], value);\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tif (isEmpty(targetAsMap[key])) {\n\t\t\t\t\ttargetAsMap[key] = [];\n\t\t\t\t}\n\t\t\t\tdeepMerge(targetAsMap[key], value);\n\t\t\t} else {\n\t\t\t\ttargetAsMap[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Polyfills randomUUID if running in a non-secure context.\n * @returns The random UUID.\n */\nexport function randomUUID(): string {\n\tif (\"randomUUID\" in globalThis.crypto) {\n\t\t// eslint-disable-next-line no-restricted-syntax\n\t\treturn globalThis.crypto.randomUUID();\n\t}\n\t// Polyfill the window.crypto.randomUUID if we are running in a non secure context that doesn't have it\n\t// we are still using window.crypto.getRandomValues which is always available\n\t// https://stackoverflow.com/a/2117523/2800218\n\t/**\n\t * Get random hex value.\n\t * @param c The number to base the random value on.\n\t * @returns The random value.\n\t */\n\tfunction getRandomHex(c: string): string {\n\t\t// eslint-disable-next-line no-bitwise\n\t\tconst rnd = globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (Number(c) / 4));\n\t\treturn (\n\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t(Number(c) ^ rnd).toString(16)\n\t\t);\n\t}\n\treturn \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, getRandomHex);\n}\n\n/**\n * Format an error to a readable string.\n * @param err The error to format.\n * @returns The formatted error.\n */\nexport function formatError(err: unknown): string {\n\tif (isEmpty(err)) {\n\t\treturn \"\";\n\t} else if (err instanceof Error) {\n\t\treturn err.message;\n\t} else if (isStringValue(err)) {\n\t\treturn err;\n\t} else if (isObject(err) && \"message\" in err && isString(err.message)) {\n\t\treturn err.message;\n\t}\n\treturn JSON.stringify(err);\n}\n\n/**\n * A basic string sanitize function that removes angle brackets <> from a string.\n * @param content the content to sanitize\n * @returns a string without angle brackets <>\n */\nexport function sanitizeString(content: unknown): string {\n\tif (isStringValue(content)) {\n\t\treturn content\n\t\t\t.replace(/<[^>]*>?/gm, \"\")\n\t\t\t.replace(/&gt;/g, \">\")\n\t\t\t.replace(/&lt;/g, \"<\")\n\t\t\t.replace(/&amp;/g, \"&\")\n\t\t\t.replace(/&nbsp;/g, \" \")\n\t\t\t.replace(/\\n\\s*\\n/g, \"\\n\");\n\t}\n\treturn \"\";\n}\n\n/**\n * Get the command line arguments from a command line string.\n * Examples of command line strings: arg1 key1=value1 key2=\"value with spaces\" key3='value3' key4='value with more spaces'`.\n * @param commandLine The command line string.\n * @returns The command line arguments or an empty array if none\n */\nexport function getCommandLineArgs(commandLine: string): string[] {\n\tif (!isStringValue(commandLine)) {\n\t\treturn [];\n\t}\n\tconst matches = commandLine.match(/(\\w+=)?(\"[^\"]*\"|'[^']*'|[^ ]+)/g);\n\tif (isEmpty(matches)) {\n\t\treturn [];\n\t}\n\treturn matches;\n}\n","import type { ModuleImplementation, ModuleTypes } from \"workspace-platform-starter/shapes/module-shapes\";\nimport { ExampleNotificationServiceProvider } from \"./lifecycle\";\n\n/**\n * Define the entry points for the module.\n */\nexport const entryPoints: { [type in ModuleTypes]?: ModuleImplementation } = {\n\tlifecycle: new ExampleNotificationServiceProvider()\n};\n","import type { AppIdentifier } from \"@finos/fdc3\";\nimport type OpenFin from \"@openfin/core\";\nimport type { WorkspacePlatformModule } from \"@openfin/workspace-platform\";\nimport type {\n\tNotificationActionEvent,\n\tNotificationClosedEvent,\n\tNotificationFormSubmittedEvent,\n\tNotificationOptions,\n\tUpdatableNotificationOptions\n} from \"@openfin/workspace/notifications\";\nimport { OPEN_ERROR } from \"workspace-platform-starter/fdc3/errors\";\nimport type { EndpointClient } from \"workspace-platform-starter/shapes/endpoint-shapes\";\nimport type { Lifecycle, LifecycleEventMap } from \"workspace-platform-starter/shapes/lifecycle-shapes\";\nimport type { Logger, LoggerCreator } from \"workspace-platform-starter/shapes/logger-shapes\";\nimport type { ModuleDefinition, ModuleHelpers } from \"workspace-platform-starter/shapes/module-shapes\";\nimport type {\n\tNotificationClient,\n\tNotificationsEventMap,\n\tNotificationSourceClearEvent,\n\tNotificationSourceCloseEvent,\n\tNotificationSourceCreateEvent,\n\tNotificationSourceUpdateEvent\n} from \"workspace-platform-starter/shapes/notification-shapes\";\nimport { isEmpty } from \"workspace-platform-starter/utils\";\nimport type { ExampleNotificationServiceProviderOptions, NotificationCustomData } from \"./shapes\";\n\n/**\n * Implementation for the example notification service lifecycle provider.\n */\nexport class ExampleNotificationServiceProvider\n\timplements Lifecycle<ExampleNotificationServiceProviderOptions>\n{\n\t/**\n\t * The module definition including settings.\n\t * @internal\n\t */\n\tprivate _definition: ModuleDefinition<ExampleNotificationServiceProviderOptions> | undefined;\n\n\t/**\n\t * The logger for displaying information from the module.\n\t * @internal\n\t */\n\tprivate _logger?: Logger;\n\n\t/**\n\t * Helper methods for the module.\n\t * @internal\n\t */\n\tprivate _helpers: ModuleHelpers | undefined;\n\n\t/**\n\t * An object containing current subscriptions.\n\t * @internal\n\t */\n\tprivate _notificationSubscriptions:\n\t\t| { [key in keyof NotificationsEventMap]?: (event: NotificationsEventMap[key]) => void }\n\t\t| undefined;\n\n\t/**\n\t * A notification client if available.\n\t * @internal\n\t */\n\tprivate _notificationClient: NotificationClient | undefined;\n\n\t/**\n\t * A endpoint client if available.\n\t * @internal\n\t */\n\tprivate _endpointClient: EndpointClient | undefined;\n\n\t/**\n\t * A interop client if available.\n\t * @internal\n\t */\n\tprivate _interopClient: OpenFin.InteropClient | undefined;\n\n\tprivate _fdc3Client: OpenFin.FDC3.v2_0.DesktopAgent | undefined;\n\n\t/**\n\t * Initialize the module.\n\t * @param definition The definition of the module from configuration include custom options.\n\t * @param loggerCreator For logging entries.\n\t * @param helpers Helper methods for the module to interact with the application core.\n\t * @returns Nothing.\n\t */\n\tpublic async initialize(\n\t\tdefinition: ModuleDefinition<ExampleNotificationServiceProviderOptions>,\n\t\tloggerCreator: LoggerCreator,\n\t\thelpers: ModuleHelpers\n\t): Promise<void> {\n\t\tthis._definition = definition;\n\t\tthis._logger = loggerCreator(\"ExampleNotificationServiceProvider\");\n\t\tthis._helpers = helpers;\n\n\t\tthis._logger.info(\"Initializing\");\n\t}\n\n\t/**\n\t * Close down any resources being used by the module.\n\t * @returns Nothing.\n\t */\n\tpublic async closedown(): Promise<void> {\n\t\tthis._logger?.info(\"Closedown\");\n\t\t// disconnect from websocket/server sent event source for example\n\t\tawait this.stopNotificationService();\n\t}\n\n\t/**\n\t * Get the lifecycle events.\n\t * @returns The map of lifecycle events.\n\t */\n\tpublic async get(): Promise<LifecycleEventMap> {\n\t\tconst lifecycleMap: LifecycleEventMap = {};\n\n\t\tlifecycleMap[\"after-bootstrap\"] = async (\n\t\t\tplatform: WorkspacePlatformModule,\n\t\t\tcustomData?: unknown\n\t\t): Promise<void> => {\n\t\t\tawait this.startNotificationService();\n\t\t};\n\n\t\treturn lifecycleMap;\n\t}\n\n\t/**\n\t * Starts the notification service.\n\t */\n\tprivate async startNotificationService(): Promise<void> {\n\t\tconst notificationSourceRootEndpointId =\n\t\t\tthis._definition?.data?.notificationSourceRootEndpointId ?? \"notification-source\";\n\t\tconst createEndpointId = `${notificationSourceRootEndpointId}-create`;\n\t\tconst updateEndpointId = `${notificationSourceRootEndpointId}-update`;\n\t\tconst clearEndpointId = `${notificationSourceRootEndpointId}-clear`;\n\t\tconst closeEndpointId = `${notificationSourceRootEndpointId}-close`;\n\t\tconst streamEndpointId = `${notificationSourceRootEndpointId}-stream`;\n\n\t\tconst createNotificationContextType = \"openfin.notificationoptions\";\n\t\tconst updateNotificationContextType = \"openfin.updatablenotificationoptions\";\n\t\tconst clearNotificationContextType = \"openfin.notification\";\n\n\t\tif (!isEmpty(this._helpers?.getEndpointClient)) {\n\t\t\tconst endpointClient = await this._helpers.getEndpointClient();\n\t\t\tif (\n\t\t\t\t!isEmpty(endpointClient) &&\n\t\t\t\tendpointClient.hasEndpoint(createEndpointId) &&\n\t\t\t\tendpointClient.hasEndpoint(updateEndpointId) &&\n\t\t\t\tendpointClient.hasEndpoint(clearEndpointId) &&\n\t\t\t\tendpointClient.hasEndpoint(closeEndpointId) &&\n\t\t\t\tendpointClient.hasEndpoint(streamEndpointId)\n\t\t\t) {\n\t\t\t\tthis._endpointClient = endpointClient;\n\t\t\t}\n\t\t}\n\n\t\tif (!isEmpty(this._helpers?.getInteropClient)) {\n\t\t\tconst interopClient = await this._helpers.getInteropClient();\n\n\t\t\tif (interopClient) {\n\t\t\t\tthis._fdc3Client = await interopClient.getFDC3(\"2.0\");\n\t\t\t}\n\t\t\tif (\n\t\t\t\tinteropClient &&\n\t\t\t\t!isEmpty(this._endpointClient) &&\n\t\t\t\tthis._definition?.data?.intentHandler?.enabled !== false\n\t\t\t) {\n\t\t\t\tthis._interopClient = interopClient;\n\t\t\t\tthis._logger?.info(\"Registering intent service.\");\n\t\t\t\tawait this._interopClient?.registerIntentHandler(async (intentRequest) => {\n\t\t\t\t\tif (intentRequest.context.type === createNotificationContextType) {\n\t\t\t\t\t\tconst notification = (intentRequest.context as unknown as { notification: NotificationOptions })\n\t\t\t\t\t\t\t.notification;\n\t\t\t\t\t\t// eslint-disable-next-line max-len\n\t\t\t\t\t\tconst sent = await this._endpointClient?.action<NotificationSourceCreateEvent>(createEndpointId, {\n\t\t\t\t\t\t\teventId: \"create\",\n\t\t\t\t\t\t\tpayload: notification\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._logger?.info(`Intent handler called and notification sent: ${sent}.`, intentRequest);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\t`A create notification intent was raised but it wasn't passed and ${createNotificationContextType} context. Type: ${intentRequest.context.type}.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}, this._definition?.data?.intentHandler?.name?.create ?? \"CreateNotification\");\n\n\t\t\t\tawait this._interopClient?.registerIntentHandler(async (intentRequest) => {\n\t\t\t\t\tif (intentRequest.context.type === updateNotificationContextType) {\n\t\t\t\t\t\tconst notification = (\n\t\t\t\t\t\t\tintentRequest.context as unknown as { notification: UpdatableNotificationOptions }\n\t\t\t\t\t\t).notification;\n\t\t\t\t\t\t// eslint-disable-next-line max-len\n\t\t\t\t\t\tconst sent = await this._endpointClient?.action<NotificationSourceUpdateEvent>(updateEndpointId, {\n\t\t\t\t\t\t\teventId: \"update\",\n\t\t\t\t\t\t\tpayload: notification\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._logger?.info(`Intent handler called and notification sent: ${sent}.`, intentRequest);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\t`A update notification intent was raised but it wasn't passed an ${updateNotificationContextType} context. Type: ${intentRequest.context.type}.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}, this._definition?.data?.intentHandler?.name?.update ?? \"UpdateNotification\");\n\n\t\t\t\tawait this._interopClient?.registerIntentHandler(async (intentRequest) => {\n\t\t\t\t\tif (intentRequest.context.type === clearNotificationContextType) {\n\t\t\t\t\t\tconst notification = (intentRequest.context as unknown as { notification: { id: string } })\n\t\t\t\t\t\t\t.notification;\n\t\t\t\t\t\tconst notificationId = notification?.id;\n\t\t\t\t\t\tif (!isEmpty(notificationId)) {\n\t\t\t\t\t\t\t// eslint-disable-next-line max-len\n\t\t\t\t\t\t\tconst sent = await this._endpointClient?.action<NotificationSourceClearEvent>(clearEndpointId, {\n\t\t\t\t\t\t\t\teventId: \"clear\",\n\t\t\t\t\t\t\t\tpayload: { id: notificationId }\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tthis._logger?.info(\n\t\t\t\t\t\t\t\t`Intent handler called and notification clear request sent: ${sent}.`,\n\t\t\t\t\t\t\t\tintentRequest\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\t\t\"A clear notification intent was raised but it wasn't passed a notification id.\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\t`A clear notification intent was raised but it wasn't passed and ${clearNotificationContextType} context. Type: ${intentRequest.context.type}.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}, this._definition?.data?.intentHandler?.name?.clear ?? \"ClearNotification\");\n\t\t\t}\n\t\t}\n\n\t\tif (!isEmpty(this._definition?.data?.channelHandler?.enabled !== false)) {\n\t\t\tconst notificationChannelName = `${fin.me.identity.uuid}/${this._definition?.data?.channelHandler?.name ?? \"notification-service\"}`;\n\t\t\tconst notificationChannel = await fin.InterApplicationBus.Channel.create(notificationChannelName);\n\t\t\tnotificationChannel.onConnection(async (identity, payload) => {\n\t\t\t\tthis._logger?.info(`Channel connection request from: ${identity.uuid}`, payload);\n\t\t\t\tif (this._helpers?.getConnectionClient) {\n\t\t\t\t\tconst connectionClient = await this._helpers.getConnectionClient();\n\t\t\t\t\tconst isValid = await connectionClient.isConnectionValid(identity, payload);\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tthis._logger?.info(`Channel connection request from: ${identity.uuid} is valid.`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\t`Channel connection request from: ${identity.uuid} to ${notificationChannelName} is not valid.`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthrow new Error(`Connection to ${notificationChannelName} is not valid.`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tnotificationChannel.register(\"create\", async (payload) => {\n\t\t\t\tconst request = payload as { type: string; notification: NotificationOptions };\n\t\t\t\tif (request.type === createNotificationContextType) {\n\t\t\t\t\tconst notification = request.notification;\n\t\t\t\t\tconst sent = await this._endpointClient?.action<NotificationSourceCreateEvent>(createEndpointId, {\n\t\t\t\t\t\teventId: \"create\",\n\t\t\t\t\t\tpayload: notification\n\t\t\t\t\t});\n\t\t\t\t\tthis._logger?.info(\n\t\t\t\t\t\t`${notificationChannelName} channel create function called and notification sent: ${sent}.`,\n\t\t\t\t\t\tpayload\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t`${notificationChannelName} channel create function called but it wasn't passed an ${createNotificationContextType} context. Type: ${request.type}.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tnotificationChannel.register(\"update\", async (payload) => {\n\t\t\t\tconst request = payload as { type: string; notification: UpdatableNotificationOptions };\n\t\t\t\tif (request.type === updateNotificationContextType) {\n\t\t\t\t\tconst notification = request.notification;\n\t\t\t\t\tconst sent = await this._endpointClient?.action<NotificationSourceUpdateEvent>(updateEndpointId, {\n\t\t\t\t\t\teventId: \"update\",\n\t\t\t\t\t\tpayload: notification\n\t\t\t\t\t});\n\t\t\t\t\tthis._logger?.info(\n\t\t\t\t\t\t`${notificationChannelName} channel update function called and event sent: ${sent}.`,\n\t\t\t\t\t\tpayload\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t`${notificationChannelName} channel update function called but it wasn't passed an ${updateNotificationContextType} context. Type: ${request.type}.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tnotificationChannel.register(\"clear\", async (payload) => {\n\t\t\t\tconst request = payload as { type: string; notification: { id: string } };\n\t\t\t\tif (request.type === clearNotificationContextType) {\n\t\t\t\t\tconst notificationId = request.notification.id;\n\t\t\t\t\tif (!isEmpty(notificationId)) {\n\t\t\t\t\t\tconst sent = await this._endpointClient?.action<NotificationSourceClearEvent>(clearEndpointId, {\n\t\t\t\t\t\t\teventId: \"clear\",\n\t\t\t\t\t\t\tpayload: { id: notificationId }\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._logger?.info(\n\t\t\t\t\t\t\t`${notificationChannelName} channel clear function called and event sent: ${sent}.`,\n\t\t\t\t\t\t\tpayload\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\t`${notificationChannelName} channel clear function called but it wasn't passed a notification id.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t`${notificationChannelName} channel clear function called but it wasn't passed an ${clearNotificationContextType} context. Type: ${request.type}.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (this._helpers?.getNotificationClient) {\n\t\t\tif (!this._notificationSubscriptions) {\n\t\t\t\tthis._notificationSubscriptions = {};\n\t\t\t}\n\t\t\tthis._notificationClient = await this._helpers.getNotificationClient();\n\n\t\t\tif (this._notificationClient) {\n\t\t\t\tawait this.setupNotificationEventListeners(closeEndpointId);\n\t\t\t\tif (this._endpointClient) {\n\t\t\t\t\tconst stream = await this._endpointClient.requestStream<\n\t\t\t\t\t\tunknown,\n\t\t\t\t\t\t| NotificationSourceCreateEvent\n\t\t\t\t\t\t| NotificationSourceUpdateEvent\n\t\t\t\t\t\t| NotificationSourceClearEvent\n\t\t\t\t\t\t| NotificationSourceCloseEvent\n\t\t\t\t\t>(streamEndpointId);\n\t\t\t\t\tif (!isEmpty(stream)) {\n\t\t\t\t\t\tconst reader = stream.getReader();\n\t\t\t\t\t\tthis._logger?.info(\"Reading from stream\");\n\t\t\t\t\t\tconst logger = this._logger;\n\t\t\t\t\t\tconst notificationClient = this._notificationClient;\n\t\t\t\t\t\treader\n\t\t\t\t\t\t\t.read()\n\t\t\t\t\t\t\t.then(function pump({ done, value }): unknown {\n\t\t\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\t\t\tlogger?.info(\"Stream ended\");\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (value.eventId === \"create\") {\n\t\t\t\t\t\t\t\t\tnotificationClient?.create(value.payload);\n\t\t\t\t\t\t\t\t} else if (value.eventId === \"update\") {\n\t\t\t\t\t\t\t\t\tnotificationClient?.update(value.payload);\n\t\t\t\t\t\t\t\t} else if (value.eventId === \"clear\") {\n\t\t\t\t\t\t\t\t\tnotificationClient?.clear(value.payload.id);\n\t\t\t\t\t\t\t\t} else if (value.eventId === \"close\") {\n\t\t\t\t\t\t\t\t\t// in a real system the source would know that the close event\n\t\t\t\t\t\t\t\t\t// was sent from this user/machine and app and would not send it back\n\t\t\t\t\t\t\t\t\t// to trigger a clear that would never clear it as it has already been\n\t\t\t\t\t\t\t\t\t// closed. This is just an example.\n\t\t\t\t\t\t\t\t\tnotificationClient?.clear(value.payload.id);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlogger?.warn(\"Unknown event type: received\", value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// eslint-disable-next-line promise/no-nesting\n\t\t\t\t\t\t\t\treturn reader.read().then(pump);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\t\t\tthis._logger?.error(`Error reading stream: ${error}`);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stops the notification service.\n\t */\n\tprivate async stopNotificationService(): Promise<void> {\n\t\tthis._logger?.info(\"Stopping notification service (This is an example.)\");\n\t\tawait this.removeNotificationEventListeners();\n\t}\n\n\t/**\n\t * Setup listeners using the notification client fetched via a helper.\n\t * @param closeEndpointId The endpoint id to indicate a notification has been closed.\n\t */\n\tprivate async setupNotificationEventListeners(closeEndpointId: string): Promise<void> {\n\t\tif (!isEmpty(this._notificationClient) && !isEmpty(this._notificationSubscriptions)) {\n\t\t\tconst actionEventHandler = async (event: NotificationActionEvent): Promise<void> => {\n\t\t\t\tif (isEmpty(event?.result)) {\n\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\"Event for notification action received but it was empty or didn't have a result.\"\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._logger?.info(\"Event for notification action received.\", event);\n\t\t\t\tconst action = event.result.task;\n\t\t\t\tconst customData = event.result.customData as NotificationCustomData;\n\t\t\t\tawait this.handleNotificationResponse(event.notification.id, action, customData);\n\t\t\t};\n\n\t\t\tawait this._notificationClient.addEventListener(\"notification-action\", actionEventHandler);\n\t\t\tthis._notificationSubscriptions[\"notification-action\"] = actionEventHandler;\n\n\t\t\tconst formSubmittedEventHandler = async (event: NotificationFormSubmittedEvent): Promise<void> => {\n\t\t\t\tif (isEmpty(event?.form)) {\n\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\"Event for notification form received but it was empty or didn't have a form result.\"\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (isEmpty(event?.button?.onClick?.task) || isEmpty(event?.button?.onClick?.customData)) {\n\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\"Event for notification form received but it was empty or didn't have a onclick customData result or task.\"\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._logger?.info(\"Event for notification form submitted received.\", event);\n\t\t\t\tconst notificationCustomData: NotificationCustomData = event.button.onClick.customData;\n\t\t\t\tconst task = event.button?.onClick?.task;\n\t\t\t\tif (!notificationCustomData.context) {\n\t\t\t\t\tnotificationCustomData.context = {\n\t\t\t\t\t\ttype: \"openfin.notification.form\"\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tnotificationCustomData.context.form = event.form;\n\t\t\t\tawait this.handleNotificationResponse(event.notification.id, task, notificationCustomData);\n\t\t\t};\n\n\t\t\tawait this._notificationClient.addEventListener(\n\t\t\t\t\"notification-form-submitted\",\n\t\t\t\tformSubmittedEventHandler\n\t\t\t);\n\t\t\tthis._notificationSubscriptions[\"notification-form-submitted\"] = formSubmittedEventHandler;\n\n\t\t\tconst closedEventHandler = (event: NotificationClosedEvent): void => {\n\t\t\t\tthis._logger?.info(\"Event for notification closed received.\", event);\n\t\t\t\tconst notificationId = event.notification.id;\n\t\t\t\tif (!isEmpty(notificationId)) {\n\t\t\t\t\tthis._endpointClient\n\t\t\t\t\t\t?.action<NotificationSourceCloseEvent>(closeEndpointId, {\n\t\t\t\t\t\t\teventId: \"close\",\n\t\t\t\t\t\t\tpayload: { id: notificationId }\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then((sent) => {\n\t\t\t\t\t\t\tthis._logger?.info(\n\t\t\t\t\t\t\t\t`Notification was closed, sending clear request for other machines. Notification Id: ${notificationId}. Sent: ${sent}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\t\tthis._logger?.error(\"A close event passed to the endpoint but had the following error.\", error);\n\t\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis._logger?.warn(\"A notification was closed but it didn't have a notification id.\");\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tawait this._notificationClient.addEventListener(\"notification-closed\", closedEventHandler);\n\t\t\tthis._notificationSubscriptions[\"notification-closed\"] = closedEventHandler;\n\t\t}\n\t}\n\n\t/**\n\t * Handles a response from a notification.\n\t * @param notificationId The id of the notification.\n\t * @param action The action to take.\n\t * @param customData The custom data to use.\n\t * @returns Nothing.\n\t */\n\tprivate async handleNotificationResponse(\n\t\tnotificationId: string,\n\t\taction: \"raise-intent\" | \"broadcast\" | \"launch-app\" | \"endpoint\" | \"launch-content\",\n\t\tcustomData: NotificationCustomData\n\t): Promise<void> {\n\t\tswitch (action) {\n\t\t\tcase \"raise-intent\": {\n\t\t\t\tconst intent = {\n\t\t\t\t\tname: customData.id,\n\t\t\t\t\tcontext: customData.context ?? { type: \"fdc3.nothing\" },\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\ttarget: customData?.target\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\ttry {\n\t\t\t\t\tawait this._interopClient?.fireIntent(intent);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._logger?.error(\"Error firing intent in response to a notification click.\", error);\n\t\t\t\t\tif ((error as { message: string })?.message === \"TargetInstanceUnavailable\") {\n\t\t\t\t\t\tthis._logger?.error(\n\t\t\t\t\t\t\t`Error firing intent in response to a notification click as the target instance ${customData?.target?.instanceId} is unavailable. Launch the app without a specific instance as it may have been closed.`\n\t\t\t\t\t\t);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (intent.metadata.target) {\n\t\t\t\t\t\t\t\tintent.metadata.target.instanceId = undefined;\n\t\t\t\t\t\t\t\tif (this._definition?.data?.intentLauncher?.instanceIdFallback !== \"new\") {\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line max-len\n\t\t\t\t\t\t\t\t\tconst result = await this._interopClient?.getInfoForIntent<{ apps: AppIdentifier[] }>(\n\t\t\t\t\t\t\t\t\t\tintent\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (result?.apps) {\n\t\t\t\t\t\t\t\t\t\tconst targetInstance = result.apps.find(\n\t\t\t\t\t\t\t\t\t\t\t// eslint-disable-next-line max-len\n\t\t\t\t\t\t\t\t\t\t\t(entry) => entry.appId === intent.metadata.target?.appId && !isEmpty(entry.instanceId)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (targetInstance) {\n\t\t\t\t\t\t\t\t\t\t\tintent.metadata.target.instanceId = targetInstance.instanceId;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tawait this._interopClient?.fireIntent(intent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (secondError) {\n\t\t\t\t\t\t\tthis._logger?.error(\n\t\t\t\t\t\t\t\t\"Error firing intent in response to a notification click after removing the instance id and just targeting the app.\",\n\t\t\t\t\t\t\t\tsecondError\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"launch-app\": {\n\t\t\t\ttry {\n\t\t\t\t\tif (this._fdc3Client && customData.id) {\n\t\t\t\t\t\tconst target = customData.target ?? { appId: customData.id };\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this._fdc3Client.open(target, customData.context);\n\t\t\t\t\t\t} catch (openError) {\n\t\t\t\t\t\t\tconst message = (openError as Error)?.message;\n\t\t\t\t\t\t\tif (!isEmpty(target.instanceId) && message === OPEN_ERROR.AppTimeout) {\n\t\t\t\t\t\t\t\t// the instance id was provided, try again without it\n\t\t\t\t\t\t\t\tawait this._fdc3Client.open({ appId: customData.id }, customData.context);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._logger?.error(\n\t\t\t\t\t\t\t\t\t`Error showing app ${customData?.id} in response to a notification click using fdc3.open.`,\n\t\t\t\t\t\t\t\t\topenError\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._logger?.error(\n\t\t\t\t\t\t\t`Error showing app ${customData?.id} in response to a notification click as the fdc3 api (through getInteropClient) is not available or the appId is not provided.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._logger?.error(\n\t\t\t\t\t\t`Error showing app ${customData?.id} in response to a notification click.`,\n\t\t\t\t\t\terror\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"launch-content\": {\n\t\t\t\ttry {\n\t\t\t\t\tif (this._helpers?.launchPage && customData.id) {\n\t\t\t\t\t\tawait this._helpers?.launchPage(customData.id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._logger?.error(\n\t\t\t\t\t\t\t`Error launching content ${customData?.id} in response to a notification click as the launchPage function is not available or the pageId is not provided.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._logger?.error(\n\t\t\t\t\t\t`Error launching page ${customData?.id} in response to a notification click.`,\n\t\t\t\t\t\terror\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"broadcast\": {\n\t\t\t\ttry {\n\t\t\t\t\tif (this._helpers?.getInteropClient && customData?.context && customData?.id) {\n\t\t\t\t\t\tconst broadcastClient = await this._helpers.getInteropClient();\n\t\t\t\t\t\tif (broadcastClient && customData.broadcastOptions?.isUserChannel) {\n\t\t\t\t\t\t\tawait broadcastClient.joinContextGroup(customData.id);\n\t\t\t\t\t\t\tbroadcastClient.setContext(customData.context);\n\t\t\t\t\t\t} else if (broadcastClient) {\n\t\t\t\t\t\t\tconst sessionContextGroup = await broadcastClient.joinSessionContextGroup(customData.id);\n\t\t\t\t\t\t\tawait sessionContextGroup.setContext(customData.context);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._logger?.error(\n\t\t\t\t\t\t\t\"Error broadcasting context from a notification is not available as either an interop client is not available or no userChannel or appChannel was specified or context was not passed.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._logger?.error(\"Error broadcasting context.\", error);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"endpoint\": {\n\t\t\t\ttry {\n\t\t\t\t\tif (this._endpointClient && customData?.id) {\n\t\t\t\t\t\tif (this._endpointClient.hasEndpoint(customData.id)) {\n\t\t\t\t\t\t\tthis._logger?.info(\n\t\t\t\t\t\t\t\t`Sending request to endpoint ${customData.id} as a result of an interaction with notification: ${notificationId}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst request = customData.endpointOptions?.request ?? customData.context;\n\t\t\t\t\t\t\tawait this._endpointClient.action(customData.id, request);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\t\t`Not sending request to endpoint ${customData.id} as a result of an interaction with notification: ${notificationId} because either the endpoint id doesn't exist or this module does not have permission to access it.`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._logger?.error(\n\t\t\t\t\t\t\t\"Error performing endpoint action on this notification as either an endpoint id was not specified or we do not have access to an endpoint client.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis._logger?.error(`Error calling an action on endpoint with id ${customData.id}.`, error);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up notification subscriptions.\n\t */\n\tprivate async removeNotificationEventListeners(): Promise<void> {\n\t\tif (!isEmpty(this._notificationClient) && !isEmpty(this._notificationSubscriptions)) {\n\t\t\tfor (const [key, value] of Object.entries(this._notificationSubscriptions)) {\n\t\t\t\tawait this._notificationClient.removeEventListener(\n\t\t\t\t\tkey as keyof NotificationsEventMap,\n\t\t\t\t\tvalue as never\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n","/** Constants representing the errors that can be encountered when calling the `open` method on the DesktopAgent object (`fdc3`). */\nexport const OPEN_ERROR = {\n\t/** Returned if the specified application is not found.*/\n\tAppNotFound: \"AppNotFound\",\n\t/** Returned if the specified application fails to launch correctly.*/\n\tErrorOnLaunch: \"ErrorOnLaunch\",\n\t/** Returned if the specified application launches but fails to add a context listener in order to receive the context passed to the `fdc3.open` call.*/\n\tAppTimeout: \"AppTimeout\",\n\t/** Returned if the FDC3 desktop agent implementation is not currently able to handle the request.*/\n\tResolverUnavailable: \"ResolverUnavailable\",\n\t/** Returned if a call to the `open` function is made with an invalid context argument. Contexts should be Objects with at least a `type` field that has a `string` value.*/\n\tMalformedContext: \"MalformedContext\"\n};\n/** Constants representing the errors that can be encountered when calling the `findIntent`, `findIntentsByContext`, `raiseIntent` or `raiseIntentForContext` methods on the DesktopAgent (`fdc3`). */\nexport const RESOLVE_ERROR = {\n\t/** SHOULD be returned if no apps are available that can resolve the intent and context combination.*/\n\tNoAppsFound: \"NoAppsFound\",\n\t/** Returned if the FDC3 desktop agent implementation is not currently able to handle the request.*/\n\tResolverUnavailable: \"ResolverUnavailable\",\n\t/** Returned if the user cancelled the resolution request, for example by closing or cancelling a resolver UI.*/\n\tUserCancelled: \"UserCancelledResolution\",\n\t/** SHOULD be returned if a timeout cancels an intent resolution that required user interaction. Please use `ResolverUnavailable` instead for situations where a resolver UI or similar fails.*/\n\tResolverTimeout: \"ResolverTimeout\",\n\t/** Returned if a specified target application is not available or a new instance of it cannot be opened. */\n\tTargetAppUnavailable: \"TargetAppUnavailable\",\n\t/** Returned if a specified target application instance is not available, for example because it has been closed. */\n\tTargetInstanceUnavailable: \"TargetInstanceUnavailable\",\n\t/** Returned if the intent and context could not be delivered to the selected application or instance, for example because it has not added an intent handler within a timeout.*/\n\tIntentDeliveryFailed: \"IntentDeliveryFailed\",\n\t/** Returned if a call to one of the `raiseIntent` functions is made with an invalid context argument. Contexts should be Objects with at least a `type` field that has a `string` value.*/\n\tMalformedContext: \"MalformedContext\"\n};\n"],"names":["isEmpty","value","entryPoints","lifecycle","initialize","definition","loggerCreator","helpers","this","_definition","_logger","_helpers","info","closedown","stopNotificationService","get","lifecycleMap","async","platform","customData","startNotificationService","notificationSourceRootEndpointId","data","createEndpointId","updateEndpointId","clearEndpointId","closeEndpointId","streamEndpointId","createNotificationContextType","updateNotificationContextType","clearNotificationContextType","getEndpointClient","endpointClient","hasEndpoint","_endpointClient","getInteropClient","interopClient","_fdc3Client","getFDC3","intentHandler","enabled","_interopClient","registerIntentHandler","intentRequest","context","type","notification","sent","action","eventId","payload","warn","name","create","update","notificationId","id","clear","channelHandler","notificationChannelName","fin","me","identity","uuid","notificationChannel","InterApplicationBus","Channel","onConnection","getConnectionClient","connectionClient","isConnectionValid","Error","register","request","getNotificationClient","_notificationSubscriptions","_notificationClient","setupNotificationEventListeners","stream","requestStream","reader","getReader","logger","notificationClient","read","then","pump","done","catch","error","removeNotificationEventListeners","actionEventHandler","event","result","task","handleNotificationResponse","addEventListener","formSubmittedEventHandler","form","button","onClick","notificationCustomData","closedEventHandler","intent","metadata","target","fireIntent","message","instanceId","undefined","intentLauncher","instanceIdFallback","getInfoForIntent","apps","targetInstance","find","entry","appId","secondError","open","openError","launchPage","broadcastClient","broadcastOptions","isUserChannel","joinContextGroup","setContext","sessionContextGroup","joinSessionContextGroup","endpointOptions","key","Object","entries","removeEventListener"],"sourceRoot":""}