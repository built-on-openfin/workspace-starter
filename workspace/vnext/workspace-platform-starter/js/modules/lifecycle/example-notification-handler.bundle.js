var t={d:(i,n)=>{for(var e in n)t.o(n,e)&&!t.o(i,e)&&Object.defineProperty(i,e,{enumerable:!0,get:n[e]})},o:(t,i)=>Object.prototype.hasOwnProperty.call(t,i)},i={};function n(t){return null==t}t.d(i,{k:()=>e});const e={lifecycle:new class{async initialize(t,i,n){this._definition=t,this._logger=i("ExampleNotificationHandlerProvider"),this._helpers=n,this._logger.info("Initializing")}async closedown(){this._logger?.info("Closedown"),await this.stopNotificationService()}async get(){const t={};return t["after-bootstrap"]=async(t,i)=>{await this.startNotificationService()},t}async startNotificationService(){const t=this._definition?.data?.notificationSourceEndpointId??"notification-source";if(!n(this._helpers?.getEndpointClient)){const i=await this._helpers.getEndpointClient();n(i)||(this._endpointClient=i.hasEndpoint(t)?i:void 0)}if(!n(this._helpers?.getInteropClient)){const i=await this._helpers.getInteropClient();i&&!n(this._endpointClient)&&!1!==this._definition?.data?.intentHandler?.enabled&&(this._interopClient=i,this._logger?.info("Registering intent handler."),await(this._interopClient?.registerIntentHandler((async i=>{if("openfin.notification"===i.context.type){const n=i.context.notification,e=await(this._endpointClient?.action(t,n));this._logger?.info(`Intent handler called and notification sent: ${e}.`,i)}else this._logger?.warn(`A create notification intent was raised but it wasn't passed and openfin.notification context. Type: ${i.context.type}.`)}),this._definition?.data?.intentHandler?.name??"CreateNotification")))}if(!n(!1!==this._definition?.data?.channelHandler?.enabled)){const i=`${fin.me.identity.uuid}/${this._definition?.data?.channelHandler?.name??"notification-handler"}`,n=await fin.InterApplicationBus.Channel.create(i);n.onConnection((async(t,n)=>{if(this._logger?.info(`Channel connection request from: ${t.uuid}`,n),this._helpers?.isConnectionValid){if(!await this._helpers.isConnectionValid(t,n))throw this._logger?.warn(`Channel connection request from: ${t.uuid} to ${i} is not valid.`),new Error(`Connection to ${i} is not valid.`);this._logger?.info(`Channel connection request from: ${t.uuid} is valid.`)}})),n.register("create",(async n=>{const e=n;if("openfin.notification"===e.type){const o=e.notification,a=await(this._endpointClient?.action(t,o));this._logger?.info(`${i} channel create function called and notification sent: ${a}.`,n)}else this._logger?.warn(`${i} channel create function called but it wasn't passed an openfin.notification context. Type: ${e.type}.`)}))}if(this._helpers?.getNotificationClient&&(this._notificationSubscriptions||(this._notificationSubscriptions={}),this._notificationClient=await this._helpers.getNotificationClient(),this._notificationClient&&(await this.setupNotificationEventListeners(),this._endpointClient))){const i=await this._endpointClient.requestStream(t);if(!n(i)){const t=i.getReader();this._logger?.info("Reading from stream");const n=this._logger,e=this._notificationClient;t.read().then((function i({done:o,value:a}){if(!o)return e?.create(a),t.read().then(i);n?.info("Stream ended")})).catch((t=>{this._logger?.error(`Error reading stream: ${t}`)}))}}}async stopNotificationService(){this._logger?.info("Stopping notification service (This is an example.)"),await this.removeNotificationEventListeners()}async setupNotificationEventListeners(){if(!n(this._notificationClient)&&!n(this._notificationSubscriptions)){const t=async t=>{this._logger?.info("Event for notification action received.",t);const i=t.result.task;await this.handleNotificationResponse(i,t.result.customData)};await this._notificationClient.addEventListener("notification-action",t),this._notificationSubscriptions["notification-action"]=t;const i=async t=>{this._logger?.info("Event for notification form submitted received.",t);const{task:i,...n}=t.notification.customData,e={...n};e.context.form=t.form,await this.handleNotificationResponse(i,e)};await this._notificationClient.addEventListener("notification-form-submitted",i),this._notificationSubscriptions["notification-form-submitted"]=i}}async handleNotificationResponse(t,i){switch(t){case"raise-intent":{const t={name:i.name,context:i.context,metadata:{target:i?.target}};try{await(this._interopClient?.fireIntent(t))}catch(e){if(this._logger?.error("Error firing intent in response to a notification click.",e),"TargetInstanceUnavailable"===e?.message){this._logger?.error(`Error firing intent in response to a notification click as the target instance ${i?.target?.instanceId} is unavailable. Launch the app without a specific instance as it may have been closed.`);try{if(t.metadata.target){if(t.metadata.target.instanceId=void 0,"new"!==this._definition?.data?.intentLauncher?.instanceIdFallback){const i=await(this._interopClient?.getInfoForIntent(t));if(i?.apps){const e=i.apps.find((i=>i.appId===t.metadata.target?.appId&&!n(i.instanceId)));e&&(t.metadata.target.instanceId=e.instanceId)}}await(this._interopClient?.fireIntent(t))}}catch(t){this._logger?.error("Error firing intent in response to a notification click after removing the instance id and just targeting the app.",t)}}}break}case"launch-app":try{this._helpers?.launchApp&&i.target?.appId?await(this._helpers?.launchApp(i.target.appId)):this._logger?.error(`Error launching app ${i?.target?.appId} in response to a notification click as the launchApp function is not available or the appId is not provided.`)}catch(t){this._logger?.error(`Error launching app ${i?.target?.appId} in response to a notification click.`,t)}break;case"broadcast":try{if(this._helpers?.getInteropClient&&i?.context&&i?.name){const t=await this._helpers.getInteropClient();if(t&&i.broadcastOptions?.isUserChannel)await t.joinContextGroup(i.name),t.setContext(i.context);else if(t){const n=await t.joinSessionContextGroup(i.name);await n.setContext(i.context)}}else this._logger?.error("Error broadcasting context from a notification is not available as either an interop client is not available or no userChannel or appChannel was specified or context was not passed.")}catch(t){this._logger?.error("Error broadcasting context.",t)}}}async removeNotificationEventListeners(){if(!n(this._notificationClient)&&!n(this._notificationSubscriptions))for(const[t,i]of Object.entries(this._notificationSubscriptions))await this._notificationClient.removeEventListener(t,i)}}};var o=i.k;export{o as entryPoints};
//# sourceMappingURL=example-notification-handler.bundle.js.map