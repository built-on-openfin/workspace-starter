var t={d:(i,n)=>{for(var e in n)t.o(n,e)&&!t.o(i,e)&&Object.defineProperty(i,e,{enumerable:!0,get:n[e]})},o:(t,i)=>Object.prototype.hasOwnProperty.call(t,i)},i={};function n(t){return null==t}t.d(i,{k:()=>e});const e={lifecycle:new class{async initialize(t,i,n){this._definition=t,this._logger=i("ExampleNotificationHandlerProvider"),this._helpers=n,this._logger.info("Initializing")}async closedown(){this._logger?.info("Closedown"),await this.stopNotificationService()}async get(){const t={};return t["after-bootstrap"]=async(t,i)=>{await this.startNotificationService()},t}async startNotificationService(){const t=this._definition?.data?.notificationSourceRootEndpointId??"notification-source",i=`${t}-create`,e=`${t}-update`,a=`${t}-clear`,o=`${t}-close`,s=`${t}-stream`,r="openfin.notificationoptions",c="openfin.updatablenotificationoptions",l="openfin.notification";if(!n(this._helpers?.getEndpointClient)){const t=await this._helpers.getEndpointClient();!n(t)&&t.hasEndpoint(i)&&t.hasEndpoint(e)&&t.hasEndpoint(a)&&t.hasEndpoint(o)&&t.hasEndpoint(s)&&(this._endpointClient=t)}if(!n(this._helpers?.getInteropClient)){const t=await this._helpers.getInteropClient();t&&!n(this._endpointClient)&&!1!==this._definition?.data?.intentHandler?.enabled&&(this._interopClient=t,this._logger?.info("Registering intent handler."),await(this._interopClient?.registerIntentHandler((async t=>{if(t.context.type===r){const n=t.context.notification,e=await(this._endpointClient?.action(i,{eventId:"create",notification:n}));this._logger?.info(`Intent handler called and notification sent: ${e}.`,t)}else this._logger?.warn(`A create notification intent was raised but it wasn't passed and ${r} context. Type: ${t.context.type}.`)}),this._definition?.data?.intentHandler?.name?.create??"CreateNotification")),await(this._interopClient?.registerIntentHandler((async t=>{if(t.context.type===c){const i=t.context.notification,n=await(this._endpointClient?.action(e,{eventId:"update",notification:i}));this._logger?.info(`Intent handler called and notification sent: ${n}.`,t)}else this._logger?.warn(`A update notification intent was raised but it wasn't passed an ${c} context. Type: ${t.context.type}.`)}),this._definition?.data?.intentHandler?.name?.update??"UpdateNotification")),await(this._interopClient?.registerIntentHandler((async t=>{if(t.context.type===l){const i=t.context.notification,e=i?.id;if(n(e))this._logger?.warn("A clear notification intent was raised but it wasn't passed a notification id.");else{const i=await(this._endpointClient?.action(a,{eventId:"clear",notificationId:e}));this._logger?.info(`Intent handler called and notification clear request sent: ${i}.`,t)}}else this._logger?.warn(`A clear notification intent was raised but it wasn't passed and ${l} context. Type: ${t.context.type}.`)}),this._definition?.data?.intentHandler?.name?.clear??"ClearNotification")))}if(!n(!1!==this._definition?.data?.channelHandler?.enabled)){const t=`${fin.me.identity.uuid}/${this._definition?.data?.channelHandler?.name??"notification-handler"}`,o=await fin.InterApplicationBus.Channel.create(t);o.onConnection((async(i,n)=>{if(this._logger?.info(`Channel connection request from: ${i.uuid}`,n),this._helpers?.isConnectionValid){if(!await this._helpers.isConnectionValid(i,n))throw this._logger?.warn(`Channel connection request from: ${i.uuid} to ${t} is not valid.`),new Error(`Connection to ${t} is not valid.`);this._logger?.info(`Channel connection request from: ${i.uuid} is valid.`)}})),o.register("create",(async n=>{const e=n;if(e.type===r){const a=e.notification,o=await(this._endpointClient?.action(i,{eventId:"create",notification:a}));this._logger?.info(`${t} channel create function called and notification sent: ${o}.`,n)}else this._logger?.warn(`${t} channel create function called but it wasn't passed an ${r} context. Type: ${e.type}.`)})),o.register("update",(async i=>{const n=i;if(n.type===c){const a=n.notification,o=await(this._endpointClient?.action(e,{eventId:"update",notification:a}));this._logger?.info(`${t} channel update function called and event sent: ${o}.`,i)}else this._logger?.warn(`${t} channel update function called but it wasn't passed an ${c} context. Type: ${n.type}.`)})),o.register("clear",(async i=>{const e=i;if(e.type===l){const o=e.notification.id;if(n(o))this._logger?.warn(`${t} channel clear function called but it wasn't passed a notification id.`);else{const n=await(this._endpointClient?.action(a,{eventId:"clear",notificationId:o}));this._logger?.info(`${t} channel clear function called and event sent: ${n}.`,i)}}else this._logger?.warn(`${t} channel clear function called but it wasn't passed an ${l} context. Type: ${e.type}.`)}))}if(this._helpers?.getNotificationClient&&(this._notificationSubscriptions||(this._notificationSubscriptions={}),this._notificationClient=await this._helpers.getNotificationClient(),this._notificationClient&&(await this.setupNotificationEventListeners(o),this._endpointClient))){const t=await this._endpointClient.requestStream(s);if(!n(t)){const i=t.getReader();this._logger?.info("Reading from stream");const n=this._logger,e=this._notificationClient;i.read().then((function t({done:a,value:o}){if(!a)return"create"===o.eventId?e?.create(o.notification):"update"===o.eventId?e?.update(o.notification):"clear"===o.eventId||"close"===o.eventId?e?.clear(o.notificationId):n?.warn("Unknown event type: received",o),i.read().then(t);n?.info("Stream ended")})).catch((t=>{this._logger?.error(`Error reading stream: ${t}`)}))}}}async stopNotificationService(){this._logger?.info("Stopping notification service (This is an example.)"),await this.removeNotificationEventListeners()}async setupNotificationEventListeners(t){if(!n(this._notificationClient)&&!n(this._notificationSubscriptions)){const i=async t=>{if(n(t?.result))return void this._logger?.warn("Event for notification action received but it was empty or didn't have a result.");this._logger?.info("Event for notification action received.",t);const i=t.result.task;await this.handleNotificationResponse(i,t.result.customData)};await this._notificationClient.addEventListener("notification-action",i),this._notificationSubscriptions["notification-action"]=i;const e=async t=>{if(n(t?.form))return void this._logger?.warn("Event for notification form received but it was empty or didn't have a form result.");this._logger?.info("Event for notification form submitted received.",t);const{task:i,...e}=t.notification.customData,a={...e};a.context.form=t.form,await this.handleNotificationResponse(i,a)};await this._notificationClient.addEventListener("notification-form-submitted",e),this._notificationSubscriptions["notification-form-submitted"]=e;const a=i=>{this._logger?.info("Event for notification closed received.",i);const e=i.notification.id;n(e)?this._logger?.warn("A notification was closed but it didn't have a notification id."):this._endpointClient?.action(t,{eventId:"close",notificationId:e}).then((t=>(this._logger?.info(`Notification was closed, sending clear request for other machines. Notification Id: ${e}. Sent: ${t}`),!0))).catch((t=>{this._logger?.error("A close event passed to the endpoint but had the following error.",t)}))};await this._notificationClient.addEventListener("notification-closed",a),this._notificationSubscriptions["notification-closed"]=a}}async handleNotificationResponse(t,i){switch(t){case"raise-intent":{const t={name:i.name,context:i.context,metadata:{target:i?.target}};try{await(this._interopClient?.fireIntent(t))}catch(e){if(this._logger?.error("Error firing intent in response to a notification click.",e),"TargetInstanceUnavailable"===e?.message){this._logger?.error(`Error firing intent in response to a notification click as the target instance ${i?.target?.instanceId} is unavailable. Launch the app without a specific instance as it may have been closed.`);try{if(t.metadata.target){if(t.metadata.target.instanceId=void 0,"new"!==this._definition?.data?.intentLauncher?.instanceIdFallback){const i=await(this._interopClient?.getInfoForIntent(t));if(i?.apps){const e=i.apps.find((i=>i.appId===t.metadata.target?.appId&&!n(i.instanceId)));e&&(t.metadata.target.instanceId=e.instanceId)}}await(this._interopClient?.fireIntent(t))}}catch(t){this._logger?.error("Error firing intent in response to a notification click after removing the instance id and just targeting the app.",t)}}}break}case"launch-app":try{this._helpers?.launchApp&&i.target?.appId?await(this._helpers?.launchApp(i.target.appId)):this._logger?.error(`Error launching app ${i?.target?.appId} in response to a notification click as the launchApp function is not available or the appId is not provided.`)}catch(t){this._logger?.error(`Error launching app ${i?.target?.appId} in response to a notification click.`,t)}break;case"broadcast":try{if(this._helpers?.getInteropClient&&i?.context&&i?.name){const t=await this._helpers.getInteropClient();if(t&&i.broadcastOptions?.isUserChannel)await t.joinContextGroup(i.name),t.setContext(i.context);else if(t){const n=await t.joinSessionContextGroup(i.name);await n.setContext(i.context)}}else this._logger?.error("Error broadcasting context from a notification is not available as either an interop client is not available or no userChannel or appChannel was specified or context was not passed.")}catch(t){this._logger?.error("Error broadcasting context.",t)}}}async removeNotificationEventListeners(){if(!n(this._notificationClient)&&!n(this._notificationSubscriptions))for(const[t,i]of Object.entries(this._notificationSubscriptions))await this._notificationClient.removeEventListener(t,i)}}};var a=i.k;export{a as entryPoints};
//# sourceMappingURL=example-notification-handler.bundle.js.map