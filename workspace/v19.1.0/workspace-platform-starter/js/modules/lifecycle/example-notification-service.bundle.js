var t={d:(i,n)=>{for(var e in n)t.o(n,e)&&!t.o(i,e)&&Object.defineProperty(i,e,{enumerable:!0,get:n[e]})},o:(t,i)=>Object.prototype.hasOwnProperty.call(t,i)},i={};function n(t){return null==t}t.d(i,{k:()=>e});const e={lifecycle:new class{async initialize(t,i,n){this._definition=t,this._logger=i("ExampleNotificationServiceProvider"),this._helpers=n,this._logger.info("Initializing")}async closedown(){this._logger?.info("Closedown"),await this.stopNotificationService()}async get(){const t={};return t["after-bootstrap"]=async(t,i)=>{await this.startNotificationService()},t}async startNotificationService(){const t=this._definition?.data?.notificationSourceRootEndpointId??"notification-source",i=`${t}-create`,e=`${t}-update`,o=`${t}-clear`,a=`${t}-close`,s=`${t}-stream`,r="openfin.notificationoptions",c="openfin.updatablenotificationoptions",l="openfin.notification";if(!n(this._helpers?.getEndpointClient)){const t=await this._helpers.getEndpointClient();!n(t)&&t.hasEndpoint(i)&&t.hasEndpoint(e)&&t.hasEndpoint(o)&&t.hasEndpoint(a)&&t.hasEndpoint(s)&&(this._endpointClient=t)}if(!n(this._helpers?.getInteropClient)){const t=await this._helpers.getInteropClient();t&&!n(this._endpointClient)&&!1!==this._definition?.data?.intentHandler?.enabled&&(this._interopClient=t,this._logger?.info("Registering intent service."),await(this._interopClient?.registerIntentHandler((async t=>{if(t.context.type===r){const n=t.context.notification,e=await(this._endpointClient?.action(i,{eventId:"create",payload:n}));this._logger?.info(`Intent handler called and notification sent: ${e}.`,t)}else this._logger?.warn(`A create notification intent was raised but it wasn't passed and ${r} context. Type: ${t.context.type}.`)}),this._definition?.data?.intentHandler?.name?.create??"CreateNotification")),await(this._interopClient?.registerIntentHandler((async t=>{if(t.context.type===c){const i=t.context.notification,n=await(this._endpointClient?.action(e,{eventId:"update",payload:i}));this._logger?.info(`Intent handler called and notification sent: ${n}.`,t)}else this._logger?.warn(`A update notification intent was raised but it wasn't passed an ${c} context. Type: ${t.context.type}.`)}),this._definition?.data?.intentHandler?.name?.update??"UpdateNotification")),await(this._interopClient?.registerIntentHandler((async t=>{if(t.context.type===l){const i=t.context.notification,e=i?.id;if(n(e))this._logger?.warn("A clear notification intent was raised but it wasn't passed a notification id.");else{const i=await(this._endpointClient?.action(o,{eventId:"clear",payload:{id:e}}));this._logger?.info(`Intent handler called and notification clear request sent: ${i}.`,t)}}else this._logger?.warn(`A clear notification intent was raised but it wasn't passed and ${l} context. Type: ${t.context.type}.`)}),this._definition?.data?.intentHandler?.name?.clear??"ClearNotification")))}if(!n(!1!==this._definition?.data?.channelHandler?.enabled)){const t=`${fin.me.identity.uuid}/${this._definition?.data?.channelHandler?.name??"notification-service"}`,a=await fin.InterApplicationBus.Channel.create(t);a.onConnection((async(i,n)=>{if(this._logger?.info(`Channel connection request from: ${i.uuid}`,n),this._helpers?.getConnectionClient){const e=await this._helpers.getConnectionClient();if(!await e.isConnectionValid(i,n))throw this._logger?.warn(`Channel connection request from: ${i.uuid} to ${t} is not valid.`),new Error(`Connection to ${t} is not valid.`);this._logger?.info(`Channel connection request from: ${i.uuid} is valid.`)}})),a.register("create",(async n=>{const e=n;if(e.type===r){const o=e.notification,a=await(this._endpointClient?.action(i,{eventId:"create",payload:o}));this._logger?.info(`${t} channel create function called and notification sent: ${a}.`,n)}else this._logger?.warn(`${t} channel create function called but it wasn't passed an ${r} context. Type: ${e.type}.`)})),a.register("update",(async i=>{const n=i;if(n.type===c){const o=n.notification,a=await(this._endpointClient?.action(e,{eventId:"update",payload:o}));this._logger?.info(`${t} channel update function called and event sent: ${a}.`,i)}else this._logger?.warn(`${t} channel update function called but it wasn't passed an ${c} context. Type: ${n.type}.`)})),a.register("clear",(async i=>{const e=i;if(e.type===l){const a=e.notification.id;if(n(a))this._logger?.warn(`${t} channel clear function called but it wasn't passed a notification id.`);else{const n=await(this._endpointClient?.action(o,{eventId:"clear",payload:{id:a}}));this._logger?.info(`${t} channel clear function called and event sent: ${n}.`,i)}}else this._logger?.warn(`${t} channel clear function called but it wasn't passed an ${l} context. Type: ${e.type}.`)}))}if(this._helpers?.getNotificationClient&&(this._notificationSubscriptions||(this._notificationSubscriptions={}),this._notificationClient=await this._helpers.getNotificationClient(),this._notificationClient&&(await this.setupNotificationEventListeners(a),this._endpointClient))){const t=await this._endpointClient.requestStream(s);if(!n(t)){const i=t.getReader();this._logger?.info("Reading from stream");const n=this._logger,e=this._notificationClient;i.read().then((function t({done:o,value:a}){if(!o)return"create"===a.eventId?e?.create(a.payload):"update"===a.eventId?e?.update(a.payload):"clear"===a.eventId||"close"===a.eventId?e?.clear(a.payload.id):n?.warn("Unknown event type: received",a),i.read().then(t);n?.info("Stream ended")})).catch((t=>{this._logger?.error(`Error reading stream: ${t}`)}))}}}async stopNotificationService(){this._logger?.info("Stopping notification service (This is an example.)"),await this.removeNotificationEventListeners()}async setupNotificationEventListeners(t){if(!n(this._notificationClient)&&!n(this._notificationSubscriptions)){const i=async t=>{if(n(t?.result))return void this._logger?.warn("Event for notification action received but it was empty or didn't have a result.");this._logger?.info("Event for notification action received.",t);const i=t.result.task,e=t.result.customData;await this.handleNotificationResponse(t.notification.id,i,e)};await this._notificationClient.addEventListener("notification-action",i),this._notificationSubscriptions["notification-action"]=i;const e=async t=>{if(n(t?.form))return void this._logger?.warn("Event for notification form received but it was empty or didn't have a form result.");if(n(t?.button?.onClick?.task)||n(t?.button?.onClick?.customData))return void this._logger?.warn("Event for notification form received but it was empty or didn't have a onclick customData result or task.");this._logger?.info("Event for notification form submitted received.",t);const i=t.button.onClick.customData,e=t.button?.onClick?.task;i.context||(i.context={type:"openfin.notification.form"}),i.context.form=t.form,await this.handleNotificationResponse(t.notification.id,e,i)};await this._notificationClient.addEventListener("notification-form-submitted",e),this._notificationSubscriptions["notification-form-submitted"]=e;const o=i=>{this._logger?.info("Event for notification closed received.",i);const e=i.notification.id;n(e)?this._logger?.warn("A notification was closed but it didn't have a notification id."):this._endpointClient?.action(t,{eventId:"close",payload:{id:e}}).then((t=>(this._logger?.info(`Notification was closed, sending clear request for other machines. Notification Id: ${e}. Sent: ${t}`),!0))).catch((t=>{this._logger?.error("A close event passed to the endpoint but had the following error.",t)}))};await this._notificationClient.addEventListener("notification-closed",o),this._notificationSubscriptions["notification-closed"]=o}}async handleNotificationResponse(t,i,e){switch(i){case"raise-intent":{const t={name:e.id,context:e.context??{type:"fdc3.nothing"},metadata:{target:e?.target}};try{await(this._interopClient?.fireIntent(t))}catch(i){if(this._logger?.error("Error firing intent in response to a notification click.",i),"TargetInstanceUnavailable"===i?.message){this._logger?.error(`Error firing intent in response to a notification click as the target instance ${e?.target?.instanceId} is unavailable. Launch the app without a specific instance as it may have been closed.`);try{if(t.metadata.target){if(t.metadata.target.instanceId=void 0,"new"!==this._definition?.data?.intentLauncher?.instanceIdFallback){const i=await(this._interopClient?.getInfoForIntent(t));if(i?.apps){const e=i.apps.find((i=>i.appId===t.metadata.target?.appId&&!n(i.instanceId)));e&&(t.metadata.target.instanceId=e.instanceId)}}await(this._interopClient?.fireIntent(t))}}catch(t){this._logger?.error("Error firing intent in response to a notification click after removing the instance id and just targeting the app.",t)}}}break}case"launch-app":try{this._helpers?.launchApp&&e.id?await(this._helpers?.launchApp(e.id)):this._logger?.error(`Error launching app ${e?.id} in response to a notification click as the launchApp function is not available or the appId is not provided.`)}catch(t){this._logger?.error(`Error launching app ${e?.id} in response to a notification click.`,t)}break;case"launch-content":try{this._helpers?.launchPage&&e.id?await(this._helpers?.launchPage(e.id)):this._logger?.error(`Error launching content ${e?.id} in response to a notification click as the launchPage function is not available or the pageId is not provided.`)}catch(t){this._logger?.error(`Error launching page ${e?.id} in response to a notification click.`,t)}break;case"broadcast":try{if(this._helpers?.getInteropClient&&e?.context&&e?.id){const t=await this._helpers.getInteropClient();if(t&&e.broadcastOptions?.isUserChannel)await t.joinContextGroup(e.id),t.setContext(e.context);else if(t){const i=await t.joinSessionContextGroup(e.id);await i.setContext(e.context)}}else this._logger?.error("Error broadcasting context from a notification is not available as either an interop client is not available or no userChannel or appChannel was specified or context was not passed.")}catch(t){this._logger?.error("Error broadcasting context.",t)}break;case"endpoint":try{if(this._endpointClient&&e?.id)if(this._endpointClient.hasEndpoint(e.id)){this._logger?.info(`Sending request to endpoint ${e.id} as a result of an interaction with notification: ${t}`);const i=e.endpointOptions?.request??e.context;await this._endpointClient.action(e.id,i)}else this._logger?.warn(`Not sending request to endpoint ${e.id} as a result of an interaction with notification: ${t} because either the endpoint id doesn't exist or this module does not have permission to access it.`);else this._logger?.error("Error performing endpoint action on this notification as either an endpoint id was not specified or we do not have access to an endpoint client.")}catch(t){this._logger?.error(`Error calling an action on endpoint with id ${e.id}.`,t)}}}async removeNotificationEventListeners(){if(!n(this._notificationClient)&&!n(this._notificationSubscriptions))for(const[t,i]of Object.entries(this._notificationSubscriptions))await this._notificationClient.removeEventListener(t,i)}}};var o=i.k;export{o as entryPoints};
//# sourceMappingURL=example-notification-service.bundle.js.map