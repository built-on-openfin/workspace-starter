var e={d:(n,s)=>{for(var t in s)e.o(s,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:s[t]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n)},n={};e.d(n,{k:()=>s});const s={platformOverride:new class{async initialize(e,n,s){this._definition=e,this._logger=n("ApplicationUrlAndAccessValidatorPlatformOverride"),this._helpers=s,this._logger.info("Initializing")}async closedown(){this._logger?.info("Closedown")}async getConstructorOverride(e){return n=>{if(void 0===this._helpers)throw new Error("Helpers are required for the the application validator platform override. Please ensure that the platform has been initialized correctly.");const s=this._definition?.data??{},t=this._logger,r=this._helpers,i=r.getUtilClient(),a=i.general.isStringValue,o=i.general.isEmpty,l=i.general.randomUUID;return class extends n{constructor(){super(),t?.info(`Options passed: ${JSON.stringify(e)} and module data: ${JSON.stringify(s)} with session id: ${r.sessionId}`)}async getSavedPage(e){t?.info(`Requesting saved page with id: ${e}`);const n=await super.getSavedPage(e);if(n){t?.info(`Processing page layout for page with id: ${e}`);const s=await this.validateAppUrlAndAccess(n.layout);n.layout=JSON.parse(s)}return n}async applySnapshot(e,n){t?.info("Processing snapshot windows for app url changes or access updates");const s=await this.validateAppUrlAndAccess(e.snapshot.windows);return e.snapshot.windows=JSON.parse(s),t?.info("Passing processed snapshot to base applySnapshot."),super.applySnapshot(e,n)}async validateAppUrlAndAccess(e){const n={},t={};let i;const p=[];r.getApps&&p.push(...await r.getApps());let c=JSON.stringify(e,((e,r)=>{if(Array.isArray(r))return r;if(a(r?.name)&&!r.name.startsWith("internal-generated-")&&!o(r.url)){const e=r.name.split("/")[0];let a;if(i={exists:!1},n[e])i=n[e];else{if(a=p.find((n=>n.appId===e)),a)if(i={exists:!0},"window"===a.launchPreference?.options?.type)Array.isArray(a.launchPreference.options?.updatable)&&a.launchPreference.options?.updatable.findIndex((e=>"url"===e.name))>-1?i={exists:!0}:a.launchPreference.options.window?.url&&(i={url:a.launchPreference.options.window.url,exists:!0});else if("view"===a.launchPreference?.options?.type)Array.isArray(a.launchPreference.options?.updatable)&&a.launchPreference.options?.updatable.findIndex((e=>"url"===e.name))>-1?i={exists:!0}:a.launchPreference.options.view?.url&&(i={url:a.launchPreference.options.view.url,exists:!0});else if("inline-view"!==a?.manifestType&&"inline-window"!==a?.manifestType||!a.manifest.url){if("view"===a?.manifestType||"window"===a?.manifestType){const e=`[[${a.appId}]]`;if(o(t[e])){const n={manifest:a.manifest,originalUrl:r.url};t[e]=n}i={url:`[[${a.appId}]]`,exists:!0}}}else i={url:a.manifest.url,exists:!0};else i={exists:!1};n[e]=i}i.exists?r.url=i.url??r.url:s.deniedAccessUrl&&(r.url=s.deniedAccessUrl,r.customData={appId:e},r.name=`internal-generated-${l()}`)}return r}));const f=Object.keys(t);if(f.length>0)for(const e of f){const n=await this.getUrlFromManifest(t[e].manifest,t[e].originalUrl);c=c.replaceAll(e,n)}return c}async getUrlFromManifest(e,n){try{const s=await fin.System.fetchManifest(e);return s.url?s.url:(t?.warn(`No url found in manifest for ${n}`),n)}catch(e){return t?.error(`Error fetching manifest for ${n}`,e),n}}}}}}};var t=n.k;export{t as entryPoints};
//# sourceMappingURL=application-url-and-access-validator.bundle.js.map