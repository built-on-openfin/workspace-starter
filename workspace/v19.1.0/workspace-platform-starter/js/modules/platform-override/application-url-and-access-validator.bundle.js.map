{"version":3,"file":"application-url-and-access-validator.bundle.js","mappings":"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","sources":["webpack://openfin-workspace--workspace-platform-starter/webpack/bootstrap","webpack://openfin-workspace--workspace-platform-starter/webpack/runtime/define property getters","webpack://openfin-workspace--workspace-platform-starter/webpack/runtime/hasOwnProperty shorthand","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/platform-override/application-url-and-access-validator/index.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/platform-override/application-url-and-access-validator/platform-override.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import type { ModuleImplementation, ModuleTypes } from \"workspace-platform-starter/shapes/module-shapes\";\nimport { ApplicationUrlAndAccessValidator } from \"./platform-override\";\n\n/**\n * Define the entry points for the module.\n */\nexport const entryPoints: { [type in ModuleTypes]?: ModuleImplementation } = {\n\tplatformOverride: new ApplicationUrlAndAccessValidator()\n};\n","// eslint-disable-next-line max-classes-per-file\nimport type OpenFin from \"@openfin/core\";\nimport type { Page, WorkspacePlatformProvider } from \"@openfin/workspace-platform\";\nimport type { PlatformApp } from \"workspace-platform-starter/shapes\";\nimport type { Logger, LoggerCreator } from \"workspace-platform-starter/shapes/logger-shapes\";\nimport type { ModuleDefinition } from \"workspace-platform-starter/shapes/module-shapes\";\nimport type {\n\tPlatformOverride,\n\tPlatformOverrideHelpers,\n\tPlatformOverrideOptions\n} from \"workspace-platform-starter/shapes/platform-shapes\";\nimport type { ApplicationUrlAndAccessValidatorOptions } from \"./shapes\";\n\n/**\n * Implementation for the application validator platform override.\n */\nexport class ApplicationUrlAndAccessValidator\n\timplements PlatformOverride<ApplicationUrlAndAccessValidatorOptions>\n{\n\t/**\n\t * The module definition including settings.\n\t * @internal\n\t */\n\tprivate _definition: ModuleDefinition<ApplicationUrlAndAccessValidatorOptions> | undefined;\n\n\t/**\n\t * The logger for displaying information from the module.\n\t * @internal\n\t */\n\tprivate _logger?: Logger;\n\n\t/**\n\t * Helper methods for the module.\n\t * @internal\n\t */\n\tprivate _helpers: PlatformOverrideHelpers | undefined;\n\n\t/**\n\t * Initialize the module.\n\t * @param definition The definition of the module from configuration include custom options.\n\t * @param loggerCreator For logging entries.\n\t * @param helpers Helper methods for the module to interact with the application core.\n\t * @returns Nothing.\n\t */\n\tpublic async initialize(\n\t\tdefinition: ModuleDefinition<ApplicationUrlAndAccessValidatorOptions>,\n\t\tloggerCreator: LoggerCreator,\n\t\thelpers: PlatformOverrideHelpers\n\t): Promise<void> {\n\t\tthis._definition = definition;\n\t\tthis._logger = loggerCreator(\"ApplicationUrlAndAccessValidatorPlatformOverride\");\n\t\tthis._helpers = helpers;\n\n\t\tthis._logger.info(\"Initializing\");\n\n\t\t// TODO: Add code here to allocate any module resources\n\t\t// You can access the configured options e.g. definition.data?.exampleProp\n\t}\n\n\t/**\n\t * Close down any resources being used by the module.\n\t * @returns Nothing.\n\t */\n\tpublic async closedown(): Promise<void> {\n\t\tthis._logger?.info(\"Closedown\");\n\n\t\t// TODO: Add code here to free up any module resources\n\t}\n\n\t/**\n\t * Get the override constructor for the platform override (useful if you wish this implementation to be layered with other implementations and passed to the platform's initialization object as part of an array).\n\t * @param options The options for the platform override defined as part of the platform.\n\t * @returns The override constructor to be used in an array.\n\t */\n\tpublic async getConstructorOverride(\n\t\toptions: PlatformOverrideOptions\n\t): Promise<OpenFin.ConstructorOverride<WorkspacePlatformProvider>> {\n\t\treturn (Base: OpenFin.Constructor<WorkspacePlatformProvider>) => {\n\t\t\t// use settings passed through the module definition in your override or the default options passed with the function call\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars, no-restricted-syntax\n\t\t\tif (this._helpers === undefined) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Helpers are required for the the application validator platform override. Please ensure that the platform has been initialized correctly.\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst moduleData = this._definition?.data ?? {};\n\t\t\tconst logger = this._logger;\n\t\t\tconst helpers = this._helpers;\n\t\t\tconst utilClient = helpers.getUtilClient();\n\t\t\tconst cachedManifestTokens: { [key: string]: { manifest: string; url: string } } = {};\n\t\t\t// caching the functions as it is called multiple times in the applySnapshot override.\n\t\t\tconst isStringValue = utilClient.general.isStringValue;\n\t\t\tconst isEmpty = utilClient.general.isEmpty;\n\t\t\tconst randomUUID = utilClient.general.randomUUID;\n\n\t\t\t/**\n\t\t\t * Extend the Platform Override.\n\t\t\t */\n\t\t\treturn class CustomPlatformOverride extends Base {\n\t\t\t\t/**\n\t\t\t\t * Constructor for the interop override.\n\t\t\t\t */\n\t\t\t\tconstructor() {\n\t\t\t\t\tsuper();\n\t\t\t\t\t// this is just an example to show a reference to the options, module data and local reference to the passed helpers.\n\t\t\t\t\tlogger?.info(\n\t\t\t\t\t\t`Options passed: ${JSON.stringify(options)} and module data: ${JSON.stringify(moduleData)} with session id: ${helpers.sessionId}`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Implementation for getting a single page in persistent storage.\n\t\t\t\t * @param id The id of the page.\n\t\t\t\t * @returns a page object or undefined if page doesn't exist.\n\t\t\t\t */\n\t\t\t\tpublic async getSavedPage(id: string): Promise<Page | undefined> {\n\t\t\t\t\t// get the page from the default platform implementation or an override that stores it in an alternative location.\n\t\t\t\t\tlogger?.info(`Requesting saved page with id: ${id}`);\n\t\t\t\t\tconst page = await super.getSavedPage(id);\n\t\t\t\t\t// process page layout to ensure that any apps are using the correct urls and access should still be allowed.\n\t\t\t\t\tif (page) {\n\t\t\t\t\t\tlogger?.info(`Processing page layout for page with id: ${id}`);\n\t\t\t\t\t\tconst processedLayout: string = await this.validateAppUrlAndAccess(page.layout);\n\t\t\t\t\t\tpage.layout = JSON.parse(processedLayout);\n\t\t\t\t\t}\n\t\t\t\t\treturn page;\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * An apply snapshot override to check for updated urls and apps that are no longer permissible. If possible you would want this type of logic on the server so it is\n\t\t\t\t * only applied to saved workspaces or snapshots (pages are managed by getPage). This is just an example to show the concept.\n\t\t\t\t * @param payload the payload for the snapshot\n\t\t\t\t * @param identity\tthe identity of the entity that called applySnapshot\n\t\t\t\t * @returns nothing\n\t\t\t\t */\n\t\t\t\tpublic async applySnapshot(\n\t\t\t\t\tpayload: OpenFin.ApplySnapshotPayload,\n\t\t\t\t\tidentity?: OpenFin.Identity\n\t\t\t\t): Promise<void> {\n\t\t\t\t\t// this is an example of how to override the applySnapshot method to check for updated urls and apps that are no longer permissible.\n\t\t\t\t\tlogger?.info(\"Processing snapshot windows for app url changes or access updates\");\n\t\t\t\t\tconst processedWindows: string = await this.validateAppUrlAndAccess(payload.snapshot.windows);\n\n\t\t\t\t\tpayload.snapshot.windows = JSON.parse(processedWindows);\n\t\t\t\t\tlogger?.info(\"Passing processed snapshot to base applySnapshot.\");\n\t\t\t\t\treturn super.applySnapshot(payload, identity);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * This function goes through the payload and checks for app entries and if found checks to see that they\n\t\t\t\t * have the latest url for the app if needed and also checks to see if they still have permission for the app.\n\t\t\t\t * @param payload The payload to validate.\n\t\t\t\t * @returns The validated payload to be parsed as an object.\n\t\t\t\t */\n\t\t\t\tprivate async validateAppUrlAndAccess(payload: unknown): Promise<string> {\n\t\t\t\t\tconst appCache: { [key: string]: { exists: boolean; url?: string } } = {};\n\t\t\t\t\tconst manifestTokens: { [key: string]: { manifest: string; originalUrl: string } } = {};\n\t\t\t\t\tlet appEntry: { exists: boolean; url?: string } | undefined;\n\t\t\t\t\tconst apps: PlatformApp[] = [];\n\t\t\t\t\tif (helpers.getApps) {\n\t\t\t\t\t\t// rather than caching the apps once for the lifetime of the platform you are letting the app service manage the caching of the apps\n\t\t\t\t\t\t// so that this request would be coming from a cache.\n\t\t\t\t\t\tapps.push(...(await helpers.getApps()));\n\t\t\t\t\t}\n\t\t\t\t\tlet processedPayload: string = JSON.stringify(payload, (_, nestedValue) => {\n\t\t\t\t\t\tif (Array.isArray(nestedValue)) {\n\t\t\t\t\t\t\treturn nestedValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check to ensure that we have a name field and that we also have a url field in this object (in case name was added to a random part of the layout)\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tisStringValue(nestedValue?.name) &&\n\t\t\t\t\t\t\t!nestedValue.name.startsWith(\"internal-generated-\") &&\n\t\t\t\t\t\t\t!isEmpty(nestedValue.url)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst appId = nestedValue.name.split(\"/\")[0];\n\t\t\t\t\t\t\tappEntry = { exists: false };\n\t\t\t\t\t\t\tlet app: PlatformApp | undefined;\n\t\t\t\t\t\t\tif (!appCache[appId]) {\n\t\t\t\t\t\t\t\tapp = apps.find((a) => a.appId === appId);\n\t\t\t\t\t\t\t\tif (app) {\n\t\t\t\t\t\t\t\t\tappEntry = { exists: true };\n\t\t\t\t\t\t\t\t\tif (app.launchPreference?.options?.type === \"window\") {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tArray.isArray(app.launchPreference.options?.updatable) &&\n\t\t\t\t\t\t\t\t\t\t\tapp.launchPreference.options?.updatable.findIndex((update) => update.name === \"url\") >\n\t\t\t\t\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t// if an app is marked as having an updatable url (e.g. a crm system entry with an initial app url that can be changed)\n\t\t\t\t\t\t\t\t\t\t\t// then we keep the original url but mark that access to the app still exists.\n\t\t\t\t\t\t\t\t\t\t\tappEntry = { exists: true };\n\t\t\t\t\t\t\t\t\t\t} else if (app.launchPreference.options.window?.url) {\n\t\t\t\t\t\t\t\t\t\t\t// there is an override for the url provided in the manifest use this instead of the source entry.\n\t\t\t\t\t\t\t\t\t\t\tappEntry = { url: app.launchPreference.options.window.url, exists: true };\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (app.launchPreference?.options?.type === \"view\") {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tArray.isArray(app.launchPreference.options?.updatable) &&\n\t\t\t\t\t\t\t\t\t\t\tapp.launchPreference.options?.updatable.findIndex((update) => update.name === \"url\") >\n\t\t\t\t\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t// if an app is marked as having an updatable url (e.g. a crm system entry with an initial app url that can be changed)\n\t\t\t\t\t\t\t\t\t\t\t// then we keep the original url but mark that access to the app still exists.\n\t\t\t\t\t\t\t\t\t\t\tappEntry = { exists: true };\n\t\t\t\t\t\t\t\t\t\t} else if (app.launchPreference.options.view?.url) {\n\t\t\t\t\t\t\t\t\t\t\t// there is an override for the url provided in the manifest use this instead of the source entry.\n\t\t\t\t\t\t\t\t\t\t\tappEntry = { url: app.launchPreference.options.view.url, exists: true };\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\t\t(app?.manifestType === \"inline-view\" || app?.manifestType === \"inline-window\") &&\n\t\t\t\t\t\t\t\t\t\t(app.manifest as { url: string }).url\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tappEntry = { url: (app.manifest as { url: string }).url, exists: true };\n\t\t\t\t\t\t\t\t\t} else if (app?.manifestType === \"view\" || app?.manifestType === \"window\") {\n\t\t\t\t\t\t\t\t\t\tconst token = `[[${app.appId}]]`;\n\t\t\t\t\t\t\t\t\t\tif (!isEmpty(manifestTokens[token])) {\n\t\t\t\t\t\t\t\t\t\t\tconst t = { manifest: app.manifest, originalUrl: nestedValue.url };\n\t\t\t\t\t\t\t\t\t\t\tmanifestTokens[token] = t;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tappEntry = { url: `[[${app.appId}]]`, exists: true };\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tappEntry = { exists: false };\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tappCache[appId] = appEntry;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tappEntry = appCache[appId];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (appEntry.exists) {\n\t\t\t\t\t\t\t\tnestedValue.url = appEntry.url ?? nestedValue.url;\n\t\t\t\t\t\t\t} else if (moduleData.deniedAccessUrl) {\n\t\t\t\t\t\t\t\tnestedValue.url = moduleData.deniedAccessUrl;\n\t\t\t\t\t\t\t\tnestedValue.customData = { appId };\n\t\t\t\t\t\t\t\tnestedValue.name = `internal-generated-${randomUUID()}`;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nestedValue as unknown;\n\t\t\t\t\t});\n\n\t\t\t\t\tconst tokens = Object.keys(manifestTokens);\n\t\t\t\t\tif (tokens.length > 0) {\n\t\t\t\t\t\t// we only want to fetch the url for the manifest once regardless of how many app entries there are in the snapshot.\n\t\t\t\t\t\t// we are caching in this example assuming that manifest urls are also versioned like app urls will be. In a real implementation\n\t\t\t\t\t\t// this would be done on the server to remove the load from the client or inline views/windows would be used or a caching mechanism\n\t\t\t\t\t\t// that could be cleared when the app data changes.\n\t\t\t\t\t\tfor (const token of tokens) {\n\t\t\t\t\t\t\tconst cachedManifestToken = cachedManifestTokens[token];\n\t\t\t\t\t\t\tlet url = manifestTokens[token].originalUrl;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!isEmpty(cachedManifestToken) &&\n\t\t\t\t\t\t\t\tcachedManifestToken.manifest === manifestTokens[token].manifest\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\turl = cachedManifestToken.url;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turl = await this.getUrlFromManifest(\n\t\t\t\t\t\t\t\t\tmanifestTokens[token].manifest,\n\t\t\t\t\t\t\t\t\tmanifestTokens[token].originalUrl\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcachedManifestTokens[token] = { manifest: manifestTokens[token].manifest, url };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprocessedPayload = processedPayload.replaceAll(token, url);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn processedPayload;\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Fetch the url from the manifest or returns the original url.\n\t\t\t\t * @param manifest The manifest to fetch the url from.\n\t\t\t\t * @param originalUrl The original url to return if the manifest does not have a url.\n\t\t\t\t * @returns The url from the manifest or the original url.\n\t\t\t\t */\n\t\t\t\tprivate async getUrlFromManifest(manifest: string, originalUrl: string): Promise<string> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst fetchedManifest = await fin.System.fetchManifest(manifest);\n\t\t\t\t\t\tif (fetchedManifest.url) {\n\t\t\t\t\t\t\treturn fetchedManifest.url;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlogger?.warn(`No url found in manifest for ${originalUrl}`);\n\t\t\t\t\t\treturn originalUrl;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tlogger?.error(`Error fetching manifest for ${originalUrl}`, error);\n\t\t\t\t\t\treturn originalUrl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","entryPoints","platformOverride","initialize","loggerCreator","helpers","this","_definition","_logger","_helpers","info","closedown","getConstructorOverride","options","Base","undefined","Error","moduleData","data","logger","utilClient","getUtilClient","cachedManifestTokens","isStringValue","general","isEmpty","randomUUID","constructor","super","JSON","stringify","sessionId","getSavedPage","id","page","processedLayout","validateAppUrlAndAccess","layout","parse","applySnapshot","payload","identity","processedWindows","snapshot","windows","appCache","manifestTokens","appEntry","apps","getApps","push","processedPayload","_","nestedValue","Array","isArray","name","startsWith","url","appId","split","app","exists","find","a","launchPreference","type","updatable","findIndex","update","window","view","manifestType","manifest","token","t","originalUrl","deniedAccessUrl","customData","tokens","keys","length","cachedManifestToken","getUrlFromManifest","replaceAll","fetchedManifest","fin","System","fetchManifest","warn","error"],"sourceRoot":""}