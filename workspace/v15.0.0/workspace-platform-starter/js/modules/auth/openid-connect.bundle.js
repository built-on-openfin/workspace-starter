/******/ var __webpack_modules__ = ({

/***/ "./client/src/framework/utils.ts":
/*!***************************************!*\
  !*** ./client/src/framework/utils.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatError: () => (/* binding */ formatError),
/* harmony export */   imageUrlToDataUrl: () => (/* binding */ imageUrlToDataUrl),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isInteger: () => (/* binding */ isInteger),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isStringValue: () => (/* binding */ isStringValue),
/* harmony export */   objectClone: () => (/* binding */ objectClone),
/* harmony export */   randomUUID: () => (/* binding */ randomUUID)
/* harmony export */ });
/**
 * Test if a value is a undefined or null.
 * @param value The value to test.
 * @returns True if the value is null or undefined.
 */
function isEmpty(value) {
    // eslint-disable-next-line no-restricted-syntax
    return value === undefined || value === null;
}
/**
 * Test if a value is an object.
 * @param value The value to test.
 * @returns True if the value is an object.
 */
function isObject(value) {
    // eslint-disable-next-line no-restricted-syntax
    return value !== undefined && value !== null && typeof value === "object";
}
/**
 * Test if a value is a string.
 * @param value The value to test.
 * @returns True if the value is a string.
 */
function isString(value) {
    // eslint-disable-next-line no-restricted-syntax
    return value !== undefined && value !== null && typeof value === "string";
}
/**
 * Test if a value is a string that is not empty.
 * @param value The value to test.
 * @returns True if the value is a string that is not empty.
 */
function isStringValue(value) {
    return isString(value) && value.trim().length > 0;
}
/**
 * Test if a value is a number.
 * @param value The value to test.
 * @returns True if the value is a number.
 */
function isNumber(value) {
    // eslint-disable-next-line no-restricted-syntax
    return value !== undefined && value !== null && typeof value === "number";
}
/**
 * Test if a value is a boolean.
 * @param value The value to test.
 * @returns True if the value is a boolean.
 */
function isBoolean(value) {
    // eslint-disable-next-line no-restricted-syntax
    return value !== undefined && value !== null && typeof value === "boolean";
}
/**
 * Test if a value is an integer.
 * @param value The value to test.
 * @returns True if the value is an integer.
 */
function isInteger(value) {
    return isNumber(value) && Number.isInteger(value);
}
/**
 * Deep clone an object.
 * @param obj The object to clone.
 * @returns The clone of the object.
 */
function objectClone(obj) {
    // eslint-disable-next-line no-restricted-syntax
    return obj === undefined ? undefined : JSON.parse(JSON.stringify(obj));
}
/**
 * Polyfills randomUUID if running in a non-secure context.
 * @returns The random UUID.
 */
function randomUUID() {
    if ("randomUUID" in window.crypto) {
        // eslint-disable-next-line no-restricted-syntax
        return window.crypto.randomUUID();
    }
    // Polyfill the window.crypto.randomUUID if we are running in a non secure context that doesn't have it
    // we are still using window.crypto.getRandomValues which is always available
    // https://stackoverflow.com/a/2117523/2800218
    /**
     * Get random hex value.
     * @param c The number to base the random value on.
     * @returns The random value.
     */
    function getRandomHex(c) {
        // eslint-disable-next-line no-bitwise
        const rnd = window.crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (Number(c) / 4));
        return (
        // eslint-disable-next-line no-bitwise
        (Number(c) ^ rnd).toString(16));
    }
    return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, getRandomHex);
}
/**
 * Format an error to a readable string.
 * @param err The error to format.
 * @returns The formatted error.
 */
function formatError(err) {
    if (err instanceof Error) {
        return err.message;
    }
    else if (typeof err === "string") {
        return err;
    }
    return JSON.stringify(err);
}
/**
 * Load an image to a data url containing base64 image data.
 * @param url The url of the image to load.
 * @param dimensions The dimensions to resize the image to.
 * @returns The data url containing base64 data for the image.
 */
async function imageUrlToDataUrl(url, dimensions) {
    return new Promise((resolve) => {
        try {
            const img = document.createElement("img");
            img.addEventListener("load", () => {
                const canvas = document.createElement("canvas");
                canvas.width = dimensions;
                canvas.height = dimensions;
                const ctx = canvas.getContext("2d");
                if (ctx) {
                    ctx.drawImage(img, 0, 0, dimensions, dimensions);
                    resolve(canvas.toDataURL("image/png", 1));
                }
                else {
                    // eslint-disable-next-line unicorn/no-useless-undefined
                    resolve(undefined);
                }
            });
            img.src = url;
        }
        catch { }
    });
}


/***/ }),

/***/ "./client/src/modules/auth/openid-connect/auth.ts":
/*!********************************************************!*\
  !*** ./client/src/modules/auth/openid-connect/auth.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OpenIdConnectProvider: () => (/* binding */ OpenIdConnectProvider)
/* harmony export */ });
/* harmony import */ var _openfin_openid_connect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @openfin/openid-connect */ "../../node_modules/@openfin/openid-connect/openfin.openid-connect.mjs");
/* harmony import */ var workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workspace-platform-starter/utils */ "./client/src/framework/utils.ts");


/**
 * Implementation for the openid connect auth provider.
 */
class OpenIdConnectProvider {
    /**
     * Create a new instance of OpenIdConnectProvider.
     */
    constructor() {
        this._subscribeIdMap = {};
        this._eventSubscribers = {};
    }
    /**
     * Initialize the module.
     * @param definition The definition of the module from configuration include custom options.
     * @param loggerCreator For logging entries.
     * @param helpers Helper methods for the module to interact with the application core.
     * @returns Nothing.
     */
    async initialize(definition, loggerCreator, helpers) {
        this._definition = definition;
        this._logger = loggerCreator("OpenIdConnectProvider");
        this._logger.info("Initializing");
        if (this._definition.data?.enableLogging) {
            (0,_openfin_openid_connect__WEBPACK_IMPORTED_MODULE_0__.enableLogging)();
        }
        const providerUrl = this._definition.data?.providerUrl;
        const clientId = this._definition.data?.clientId;
        const loginRedirectUrl = this._definition.data?.loginRedirectUrl;
        const logoutRedirectUrl = this._definition.data?.logoutRedirectUrl;
        if (!(0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(providerUrl)) {
            this._logger.error("providerUrl is not configured");
        }
        if (!(0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(clientId)) {
            this._logger.error("ClientId is not configured");
        }
        if (!(0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(loginRedirectUrl)) {
            this._logger.error("loginRedirectUrl is not configured");
        }
        if (!(0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(logoutRedirectUrl)) {
            this._logger.error("logoutRedirectUrl is not configured");
        }
    }
    /**
     * Close down any resources being used by the module.
     * @returns Nothing.
     */
    async closedown() {
        this._logger?.info("Closedown");
        if (this._sessionExpiryTimerId) {
            window.clearTimeout(this._sessionExpiryTimerId);
            this._sessionExpiryTimerId = undefined;
        }
    }
    /**
     * Subscribe to one of the auth events.
     * @param to The event to subscribe to.
     * @param callback The callback to fire when the event occurs.
     * @returns Subscription id for unsubscribing or undefined if event type is not available.
     */
    subscribe(to, callback) {
        const subscriptionId = (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.randomUUID)();
        const toMap = this._eventSubscribers[to] ?? {};
        toMap[subscriptionId] = callback;
        this._eventSubscribers[to] = toMap;
        this._subscribeIdMap[subscriptionId] = to;
        this._logger?.info(`Subscription to ${to} events registered. Subscription Id: ${subscriptionId}`);
        return subscriptionId;
    }
    /**
     * Unsubscribe from an already subscribed event.
     * @param subscriptionId The id of the subscription returned from subscribe.
     * @returns True if the unsubscribe was successful.
     */
    unsubscribe(subscriptionId) {
        const eventType = this._subscribeIdMap[subscriptionId];
        if ((0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(eventType)) {
            this._logger?.warn(`You have tried to unsubscribe with a key ${subscriptionId} that is invalid`);
            return false;
        }
        const eventSubscribers = this._eventSubscribers[eventType];
        if (!(0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(eventSubscribers)) {
            delete eventSubscribers[subscriptionId];
        }
        if (this._subscribeIdMap[subscriptionId]) {
            delete this._subscribeIdMap[subscriptionId];
            this._logger?.info(`Subscription to ${eventType} events with subscription Id: ${subscriptionId} has been cleared`);
            return true;
        }
        this._logger?.warn(`Subscription to ${eventType} events with subscription Id: ${subscriptionId} could not be cleared as we do not have a register of that event type.`);
        return false;
    }
    /**
     * Does the auth provider require authentication.
     * @returns True if authentication is required.
     */
    async isAuthenticationRequired() {
        return (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this._authResult);
    }
    /**
     * Perform the login operation on the auth provider.
     * @returns True if the login was successful.
     */
    async login() {
        const providerUrl = this._definition?.data?.providerUrl;
        const clientId = this._definition?.data?.clientId;
        const loginRedirectUrl = this._definition?.data?.loginRedirectUrl;
        const scopes = this._definition?.data?.scopes;
        if ((0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(providerUrl) && (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(clientId) && (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(loginRedirectUrl)) {
            try {
                this._authResult = await (0,_openfin_openid_connect__WEBPACK_IMPORTED_MODULE_0__.authenticate)(providerUrl, clientId, loginRedirectUrl, scopes);
                await this.notifySubscribers("logged-in");
                this.checkForSessionExpiry();
                return true;
            }
            catch (err) {
                this._logger?.error("Authentication failed", (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.formatError)(err));
            }
        }
        return false;
    }
    /**
     * Perform the logout operation on the auth provider.
     * @returns True if the logout was successful.
     */
    async logout() {
        if (this._authResult) {
            if (this._sessionExpiryTimerId) {
                window.clearTimeout(this._sessionExpiryTimerId);
                this._sessionExpiryTimerId = undefined;
            }
            const logoutRedirectUrl = this._definition?.data?.logoutRedirectUrl;
            if ((0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(logoutRedirectUrl)) {
                try {
                    await this.notifySubscribers("before-logged-out");
                    await this._authResult.logout(logoutRedirectUrl);
                }
                catch (err) {
                    this._logger?.error("Logout failed", (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.formatError)(err));
                }
                finally {
                    await this.notifySubscribers("logged-out");
                }
            }
            this._authResult = undefined;
        }
        return true;
    }
    /**
     * Get user information from the auth provider.
     * @returns The user information, the type is unknown as it is dependent on the auth provider.
     */
    async getUserInfo() {
        if (this._authResult) {
            return this._authResult.userInfo;
        }
    }
    /**
     * Notify subscribers of an event change.
     * @param authEventType The type of authentication event to send to.
     */
    async notifySubscribers(authEventType) {
        const subscribers = this._eventSubscribers[authEventType];
        if (subscribers) {
            const subscriberIds = Object.keys(subscribers);
            subscriberIds.reverse();
            for (const subscriberId of subscriberIds) {
                this._logger?.info(`Notifying subscriber with subscription Id: ${subscriberId} of event type: ${authEventType}`);
                await subscribers[subscriberId]();
            }
        }
    }
    /**
     * Check to see if a session has expired.
     */
    checkForSessionExpiry() {
        const validity = this._definition?.data?.checkSessionValidityInSeconds;
        if ((0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(validity) && validity > 0 && (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this._sessionExpiryTimerId)) {
            this._sessionExpiryTimerId = window.setTimeout(async () => {
                this._sessionExpiryTimerId = undefined;
                const idToken = this._authResult?.idToken;
                const providerUrl = this._definition?.data?.providerUrl;
                const clientId = this._definition?.data?.clientId;
                let isValid = false;
                if ((0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(idToken) && (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(providerUrl) && (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(clientId)) {
                    try {
                        const result = await (0,_openfin_openid_connect__WEBPACK_IMPORTED_MODULE_0__.validateIdToken)(idToken, clientId, providerUrl);
                        isValid = result.valid;
                    }
                    catch (err) {
                        this._logger?.error("Failed validating token", (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.formatError)(err));
                    }
                }
                if (isValid) {
                    this._logger?.info("Session Still Active");
                    this.checkForSessionExpiry();
                }
                else {
                    this._logger?.info("Session not valid");
                    this._authResult = undefined;
                    await this.notifySubscribers("session-expired");
                }
            }, validity * 1000);
        }
    }
}


/***/ }),

/***/ "../../node_modules/@openfin/openid-connect/openfin.openid-connect.mjs":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@openfin/openid-connect/openfin.openid-connect.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApiError: () => (/* binding */ Ve),
/* harmony export */   AuthenticationError: () => (/* binding */ Be),
/* harmony export */   InitializationError: () => (/* binding */ Xe),
/* harmony export */   LogoutError: () => (/* binding */ Ye),
/* harmony export */   ParameterError: () => (/* binding */ Qe),
/* harmony export */   ValidationError: () => (/* binding */ Ze),
/* harmony export */   authenticate: () => (/* binding */ et),
/* harmony export */   disableLogging: () => (/* binding */ tt),
/* harmony export */   enableLogging: () => (/* binding */ rt),
/* harmony export */   validateIdToken: () => (/* binding */ ot)
/* harmony export */ });
var e={d:(t,r)=>{for(var o in r)e.o(r,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:r[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{MS:()=>R,_7:()=>AuthenticationError,cX:()=>P,zL:()=>LogoutError,_W:()=>x,p8:()=>j,YR:()=>ze,U$:()=>Je,U7:()=>Ue,OF:()=>He});var r={d:(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},o={};r.d(o,{MS:()=>ApiError,cF:()=>ApiRequestError,AK:()=>AuthTokenExpiredError,M_:()=>AuthorizationError,cX:()=>InitializationError,Yd:()=>w,O4:()=>T,_W:()=>ParameterError,p8:()=>ValidationError,m$:()=>s,U$:()=>u,U7:()=>h,OV:()=>d,N7:()=>A,HP:()=>n,Rp:()=>O});class ApiError extends Error{constructor(e,t){var r,o;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"An unexpected error has occurred"),this.name=this.constructor.name,this.stack=(e?this.stack:null!==(o=null==t?void 0:t.stack)&&void 0!==o?o:this.stack).replace(/^(\w*Error)/,`${this.constructor.name}`)}}class ApiRequestError extends ApiError{constructor(e,t,r){var o;super(e=null!==(o=null!=e?e:null==r?void 0:r.message)&&void 0!==o?o:"An error occurred when executing the API request",r),this.status=t}}class AuthorizationError extends ApiError{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"An authorization error occurred",t)}}class AuthTokenExpiredError extends ApiError{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"The API request failed as the authorization tokens have expired",t)}}class InitializationError extends ApiError{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"An initialization error occurred",t)}}class ParameterError extends ApiError{constructor(e){super(e=null!=e?e:"Invalid parameter detected")}}class ValidationError extends ApiError{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"A token validation error occurred",t)}}const n=()=>void 0!==crypto.randomUUID?crypto.randomUUID():"10000000-1000-4000-8000-100000000000".replace(/[018]/g,(e=>{const t=window.crypto.getRandomValues(new Uint8Array(1))[0]&15>>Number(e)/4;return(Number(e)^t).toString(16)})),a="oauth-api-auth-flow",i=(e,t,r,o,n,a,i,s)=>async c=>{const d=new URL(c);if(0!==d.href.toLowerCase().indexOf(n.toLowerCase()))return!1;if(window.clearInterval(s),window.clearTimeout(t),window.clearTimeout(r),e.removeAllListeners(),e.close(!0),d.searchParams.get("error")){const e=new AuthorizationError("Authorization error");return e.data=d.toString(),i(e),!0}if(d.searchParams.get("state")!==o){const e=new AuthorizationError("State mismatch");return e.data=d.toString(),i(e),!0}const l=d.searchParams.get("code");if(!l){const e=new AuthorizationError("Authorization code missing");return e.data=d.toString(),i(e),!0}return a(l),!0},s=async(e,t,r={})=>{const{defaultHeight:o,defaultWidth:n}=r;return t(await fin.Window.create(Object.assign({alwaysOnTop:!0,maximizable:!1,minimizable:!1,autoShow:!1,defaultCentered:!0,defaultHeight:null!=o?o:750,defaultWidth:null!=n?n:600,includeInSnapshots:!1,name:a,resizable:!1,saveWindowState:!1,showTaskbarIcon:!1,url:e},r)))},c=(e,t,r)=>o=>new Promise(((n,a)=>{let s;const c=window.setTimeout((()=>{window.clearInterval(s),window.clearTimeout(c),o.removeAllListeners(),o.close(!0),a(new AuthorizationError("Authorization timed out"))}),3e5);o.addListener("closing",(async()=>{r.logInfo("User closed auth window"),window.clearInterval(s),window.clearTimeout(c),o.removeAllListeners(),a(new AuthorizationError("Failed to complete authorization code flow"))}));const d=window.setTimeout((async()=>{try{await o.isShowing()||(r.logInfo("Showing auth window"),await o.show(!0),await o.focus())}catch(e){r.logWarning("Unable to show auth window")}}),2e3);(async()=>{const{version:l}=await fin.System.getRuntimeInfo();parseInt(l.split(".")[0],10)>=30?await i(o,c,d,e,t,n,a)((await o.getInfo()).url)||await o.addListener("url-changed",(s=>{r.logInfo("Auth window navigated to",s.url),i(o,c,d,e,t,n,a)(s.url)})):s=window.setInterval((()=>(async(e,t,r,o,n,a,s,c)=>{let d;try{d=await e.getInfo()}catch(e){return window.clearInterval(t),window.clearTimeout(r),window.clearTimeout(o),c(new AuthorizationError("Could not locate auth window")),!1}return i(e,r,o,n,a,s,c,t)(d.url)})(o,s,c,d,e,t,n,a)),500)})()})),d=async(e,t)=>{let r;null==t||t.logInfo("Retrieving authorization server metadata",e);try{r=new URL(e)}catch(e){throw new ParameterError("Unexpected invalid discovery URL")}const o=await fetch(r,{headers:{Accept:"application/json"}});if(!o.ok)throw new Error("Failed to retrieve authorization server metadata");const n=await o.json();if(!n)throw new Error("Unexpected empty authorization server metadata response");return null==t||t.logInfo("Retrieved authorization server metadata",n),n},l=e=>{let t=fin.Integrations;t||(fin.Integrations={},t=fin.Integrations);let r=t[e];return r||(t[e]={},r=t[e]),r},u=e=>{l(e).loggingEnabled=!1},h=(e,t="0.0.0")=>{l(e).loggingEnabled=!0,console.log(p(e),`v${t}`)},p=e=>`[@openfin/${e.toLowerCase()}]`;class w{constructor(e){this.name=e,this.prefix=p(e),this.isLoggingEnabled=this.isLoggingEnabled.bind(this),this.logError=this.logError.bind(this),this.logInfo=this.logInfo.bind(this),this.logWarning=this.logWarning.bind(this)}isLoggingEnabled(){return l(this.name).loggingEnabled}logError(e){this.isLoggingEnabled()&&(e.innerError?console.error(this.prefix,e,"\n\n(inner)",e.innerError):console.error(this.prefix,e))}logInfo(...e){this.isLoggingEnabled()&&console.log(this.prefix,...e)}logWarning(...e){this.isLoggingEnabled()&&console.warn(this.prefix,...e)}}const g=()=>{let e,t,r,o,n;const a=async(t,r=!1)=>{const{command:o,data:n,id:s}=t,c={command:o,id:s};try{if(!e)throw new Error("Access token not found");const{apiRequestUrl:o,data:s,headers:d,httpMethod:l,includeAuthorization:u}=n,h=await(async(t,r,o,n,a)=>{var i,s;const c=Object.assign({Accept:"application/json"},n);"PATCH"!==r&&"POST"!==r&&"PUT"!==r||/content-type/i.test(Object.keys(c).join(","))||(c["Content-Type"]="application/json"),a&&(c.Authorization=`Bearer ${e}`);const d=await fetch(t,{body:"object"==typeof o?JSON.stringify(o):o,headers:c,method:r});if(!d.ok){const e={message:"Failed to execute API request"};return(null===(i=d.headers.get("Content-Type"))||void 0===i?void 0:i.includes("application/json"))&&(e.data=await d.json()),[d.status,void 0,void 0,e]}let l;const u=null!==(s=d.headers.get("Content-Type"))&&void 0!==s?s:"";switch(!0){case!u:break;case/^application\/(\w+\+)?json/i.test(u):l=await d.json();break;case/^multipart\/form-?data|^application\/x-?www-?form-?urlencoded/i.test(u):l=await d.formData();break;case/^application\/(([^/]+)?xml|vnd\.openxmlformats)|^text\/|^image\/svg/i.test(u):l=await d.text();break;default:l=await d.arrayBuffer()}return[d.status,l,u,void 0]})(o,l,s,d,u),[p,w,g,f]=h;if(c.status=p,f){if(!r&&401===p){const[e,r]=await i();return r?(c.status=e,c.error=r,c):await a(t,!0)}c.error=f}else w&&(c.data=w,c.type=g)}catch(e){e instanceof Error?c.error={message:e.message}:c.error={message:"Failed to execute API request"}}return Promise.resolve(c)},i=async()=>{var r;if(!o)throw new Error("Authorization server metadata not set");if(!t)throw new Error("Client ID not set");const a=`grant_type=refresh_token&client_id=${t}&refresh_token=${n}`,i=await fetch(o.token_endpoint,{body:a,headers:{Accept:"application/json","Content-Type":"application/x-www-form-urlencoded"},method:"POST"});if(!i.ok){const e={message:"Failed to refresh access token"};return(null===(r=i.headers.get("Content-Type"))||void 0===r?void 0:r.includes("application/json"))&&(e.data=await i.json()),[i.status,e]}const s=await i.json();return e=s.access_token,[i.status]};self.onmessage=async i=>{const{command:s,id:c}=i.data;let d={command:s,id:c};switch(s){case"API_REQUEST":d=await a(i.data);break;case"CODE_EXCHANGE":d=await(async a=>{var i;const{command:s,data:c,id:d}=a,l={command:s,id:d};try{if(!o)throw new Error("Authorization server metadata not set");if(!t)throw new Error("Client ID not set");const{code:a,codeVerifier:s,redirectUri:d}=c,u=`grant_type=authorization_code&client_id=${t}&code=${a}&code_verifier=${s}&redirect_uri=${d}`,h=await fetch(o.token_endpoint,{body:u,headers:{Accept:"application/json","Content-Type":"application/x-www-form-urlencoded"},method:"POST"});if(h.ok){const t=await h.json();e=t.access_token,r=t.id_token,n=t.refresh_token}else{const e={message:"Failed to retrieve tokens"};(null===(i=h.headers.get("Content-Type"))||void 0===i?void 0:i.includes("application/json"))&&(e.data=await h.json()),l.error=e}}catch(e){e instanceof Error?l.error={message:e.message}:l.error={message:"Failed to retrieve tokens"}}return Promise.resolve(l)})(i.data);break;case"EXPIRE_TOKENS":d=await(async r=>{var a;const{command:i,expireAccessTokenOnly:s,id:c}=r,d={command:i,id:c};try{if(!o)throw new Error("Authorization server metadata not set");if(!o.revocation_endpoint)throw new Error("Revocation endpoint missing in authorization server metadata");if(!s&&!n)throw new Error("Refresh token not found");const r=o.revocation_endpoint;let i,c=!1;const l={body:`client_id=${t}`,headers:{Accept:"application/json","Content-Type":"application/x-www-form-urlencoded"},method:"POST"};if(s){const t=await fetch(r,Object.assign(Object.assign({},l),{body:`${l.body}&token=${e}&token_type_hint=access_token`}));t.ok||(c=!0,(null===(a=t.headers.get("Content-Type"))||void 0===a?void 0:a.includes("application/json"))&&(i=await t.json()))}else{const t=(await Promise.all([await fetch(r,Object.assign(Object.assign({},l),{body:`${l.body}&token=${e}&token_type_hint=access_token`})),await fetch(r,Object.assign(Object.assign({},l),{body:`${l.body}&token=${n}&token_type_hint=refresh_token`}))])).filter((e=>!e.ok));t.length&&(c=!0,i=await t[0].json())}if(c){const e={data:i,message:"Failed to expire tokens"};d.error=e}}catch(e){e instanceof Error?d.error={message:e.message}:d.error={message:"Failed to expire tokens"}}return Promise.resolve(d)})(i.data);break;case"GET_ID_TOKEN":l=i.data,d=Object.assign(Object.assign({},l),{idToken:r});break;case"INIT":d=await(async e=>{const{command:r,data:n,id:a}=e,i={command:r,id:a};return t=n.clientId,o=n.metadata,Promise.resolve(i)})(i.data);break;default:d.error=new Error(`Unexpected oauth worker command: ${s}`)}var l;self.postMessage(d)}};var f;!function(e){e.ApiRequest="API_REQUEST",e.CodeExchange="CODE_EXCHANGE",e.ExpireTokens="EXPIRE_TOKENS",e.GetIdToken="GET_ID_TOKEN",e.Init="INIT"}(f||(f={}));const m=[],y=e=>{m.push(e)},E=(e,t)=>(r,o,a)=>new Promise(((i,s)=>{const c={command:f.CodeExchange,data:{code:r,codeVerifier:o,redirectUri:a},id:n()},{command:d,id:l}=c;y({command:d,id:l,reject:s,resolve:i}),e.postMessage(c),t.logInfo("Worker request sent",c)})),v=(e,t,r)=>(o,a,i,s,c)=>new Promise(((d,l)=>{const u={command:f.ApiRequest,data:{apiRequestUrl:o,clientId:e,data:i,headers:s,httpMethod:a,includeAuthorization:c},id:n()},{command:h,id:p}=u;y({command:h,id:p,reject:l,resolve:d}),t.postMessage(u),r.logInfo("Worker request sent",u)})),S=(e,t)=>r=>new Promise(((o,a)=>{const i={command:f.ExpireTokens,expireAccessTokenOnly:r,id:n()},{command:s,id:c}=i;y({command:s,id:c,reject:a,resolve:o}),e.postMessage(i),t.logInfo("Worker request sent",i)})),b=(e,t)=>async()=>(await new Promise(((r,o)=>{const a={command:f.GetIdToken,id:n()},{command:i,id:s}=a;y({command:i,id:s,reject:o,resolve:r}),e.postMessage(a),t.logInfo("Worker request sent",a)}))).idToken,A=async(e,t,r)=>{const o=new Blob([`(${g})()`],{type:"text/javascript"}),a=URL.createObjectURL(o),i=new Worker(a);return i.onmessage=_(r),await((e,t,r,o)=>new Promise(((a,i)=>{const s={command:f.Init,data:{clientId:t,metadata:e},id:n()},{command:c,id:d}=s;y({command:c,id:d,reject:i,resolve:a}),r.postMessage(s),o.logInfo("Worker request sent",s)})))(e,t,i,r),{exchangeCodeForTokens:E(i,r),executeApiRequest:v(t,i,r),expireTokens:S(i,r),getIdToken:b(i,r),terminate:I(i,r)}},_=e=>t=>{e.logInfo("Worker response received",t.data);const r=t.data,{command:o,error:n,id:a}=r,i=function(e,t){var r={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(r[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(o=Object.getOwnPropertySymbols(e);n<o.length;n++)t.indexOf(o[n])<0&&Object.prototype.propertyIsEnumerable.call(e,o[n])&&(r[o[n]]=e[o[n]])}return r}(r,["command","error","id"]),s=((e,t)=>m.find((r=>r.command===t&&r.id===e)))(a,o);s?(n?("status"in i&&void 0!==i.status&&(n.status=i.status),s.reject(n)):s.resolve(i),k(a,o)):e.logError(new Error("Unable to locate awaited request"))},k=(e,t)=>{const r=m.findIndex((r=>r.command===t&&r.id===e));r>=0&&m.splice(r,1)},I=(e,t)=>async()=>{try{await S(e,t)(!1)}catch(e){t.logWarning(e.message)}e.terminate(),t.logInfo("Worker terminated")};class T{get apiOrigin(){return this._apiOrigin}get clientId(){return this._clientId}get logger(){return this._logger}get metadata(){return this._metadata}get worker(){return this._worker}constructor(e,t,r,o,n){if(this.executeApiRequest=async(e,t="GET",r,o,n=!0,a=!1)=>{this._logger.logInfo("ExecuteApiRequest started",e,t,r,o);try{const a=await((e,t)=>async(r,o,n,a,i)=>{try{return await t.executeApiRequest(`${e}${r}`,o,n,a,i)}catch(e){let t;const{data:r,message:o,status:n}=e;throw t=e instanceof Error?new ApiRequestError(o,n):"Failed to refresh access token"===o?new AuthTokenExpiredError(o):new ApiRequestError(o,n),t.data=r,t}})(this._apiOrigin,this._worker)(e,t,r,o,n);return this._logger.logInfo("ExecuteApiRequest completed",a),a}catch(e){if(e instanceof ApiRequestError){const{data:t,message:r,name:o,stack:n}=e,a=this.getErrorMessageFromServerResponse(t);a&&(e.message=a,e.stack=null==n?void 0:n.replace(`${o}: ${r}`,`${o}: ${a}`))}throw a&&this.logger.logError(e),e}},!(t&&r&&o&&n))throw new InitializationError("Provider has not been properly initialized (call init to create new instances)");this._apiOrigin=null!=e?e:"",this._clientId=t,this._metadata=r,this._worker=o,this._logger=n,this.authorize=this.authorize.bind(this),this.close=this.close.bind(this),this.executeApiRequest=this.executeApiRequest.bind(this),this.expireTokens=this.expireTokens.bind(this),this.getErrorMessageFromServerResponse=this.getErrorMessageFromServerResponse.bind(this),this.getIdToken=this.getIdToken.bind(this)}async authorize(e,t,r){this._logger.logInfo("Authorize started",e,t,r);try{await(o=this._metadata,i=this._clientId,d=this._worker,l=this._logger,async(e,t={},r={})=>{const{authorization_endpoint:u}=o,h=fin.Application.getCurrentSync(),p=(await h.getChildWindows()).find((e=>e.identity.name===a));p&&await p.close(!0);const w=n(),g=(()=>{const e=new Uint32Array(64);return window.crypto.getRandomValues(e),Array.from(e,(e=>`0${e.toString(16)}`.slice(-2))).join("")})(),f=(await(async e=>{const t=(new TextEncoder).encode(e),r=await window.crypto.subtle.digest("SHA-256",t),o=await(e=>new Promise(((t,r)=>{try{const o=new Blob([e]),n=new FileReader;n.onload=e=>{var o,n;const a=null===(o=e.target)||void 0===o?void 0:o.result;if(a){const[,e]=Array.from(null!==(n=a.match(/base64,(.*)$/i))&&void 0!==n?n:[]);t(null!=e?e:"")}r(new Error("Unexpected empty result"))},n.readAsDataURL(o)}catch(e){r(e)}})))(r);return o.replace(/\+/g,"-").replace(/\//g,"_")})(g)).replace(/=+$/,""),m=new URL(u);m.searchParams.set("client_id",i),m.searchParams.set("redirect_uri",e),m.searchParams.set("response_type","code"),m.searchParams.set("state",w),m.searchParams.set("code_challenge",f),m.searchParams.set("code_challenge_method","S256"),Object.entries(t).forEach((e=>m.searchParams.set(e[0],e[1]))),l.logInfo("Starting OAuth flow",m,r);const y=await s(m.toString(),c(w,e,l),r);l.logInfo("Received authorization code"),await d.exchangeCodeForTokens(y,g,e),l.logInfo("Received tokens")})(e,t,r),this._logger.logInfo("Authorize completed")}catch(e){let t;if(e instanceof ApiError){const{data:r}=e,o=this.getErrorMessageFromServerResponse(r);t=new AuthorizationError(o,e),t.data=r}else t=new AuthorizationError(void 0,e);throw this.logger.logError(t),t}var o,i,d,l}async close(){var e;this._logger.logInfo("Close started");try{await(null===(e=this._worker)||void 0===e?void 0:e.terminate()),this._worker=void 0,this._apiOrigin=void 0,this._clientId=void 0,this._metadata=void 0,this._logger.logInfo("Close completed")}catch(e){const t=new ApiError(void 0,e);throw this._logger.logError(t),t}}async expireTokens(e=!1){var t;this._logger.logInfo("ExpireTokens started");try{await(null===(t=this._worker)||void 0===t?void 0:t.expireTokens(e)),this._logger.logInfo("ExpireTokens completed")}catch(e){const t=new ApiError(void 0,e);throw this._logger.logError(t),t}}getErrorMessageFromServerResponse(e){e&&this._logger.logWarning(e)}async getIdToken(){var e;this._logger.logInfo("GetIdToken started");try{const t=await(null===(e=this._worker)||void 0===e?void 0:e.getIdToken());return this._logger.logInfo("GetIdToken completed",t),t}catch(e){const t=new ApiError(void 0,e);throw this._logger.logError(t),t}}static async init(e,t,r,o,...n){const a=new w(o);a.logInfo("Init started",e,t,r);try{let o;if("discoveryEndpoint"in e){const{additionalMetadata:t,discoveryEndpoint:r}=e;o=Object.assign(Object.assign({},await d(r)),null!=t?t:{})}else o=e;if(!o.response_types_supported.find((e=>"code"===e.toLowerCase())))throw new InitializationError("Authorization server does not support the authorization code response type");const n=await A(o,r,a),i=new T(t,r,o,n,a);return a.logInfo("Init completed",i),i}catch(e){let t;throw t=e instanceof ApiError?e:new InitializationError(void 0,e),a.logError(t),t}}}const O=e=>async(t,r,o)=>{let n;null==e||e.logInfo("Validating token against introspection endpoint",t,r,o);try{n=await fetch(o,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:`token=${t}&client_id=${r}`})}catch(e){throw new ValidationError(void 0,e)}if(n.ok){const t=await n.json(),{active:r}=t,o=function(e,t){var r={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(r[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(o=Object.getOwnPropertySymbols(e);n<o.length;n++)t.indexOf(o[n])<0&&Object.prototype.propertyIsEnumerable.call(e,o[n])&&(r[o[n]]=e[o[n]])}return r}(t,["active"]),a=Object.assign({valid:r},o);return null==e||e.logInfo("Token validation result",a),a}const a=await n.json();throw null==e||e.logWarning("Token Validation failed",a),new ValidationError};var R=o.MS,P=o.cX,C=o.Yd,W=o.O4,x=o._W,j=o.p8,$=o.m$,J=o.U$,U=o.U7,K=o.OV,D=o.N7,L=o.Rp;const H=new TextEncoder,M=new TextDecoder;function z(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let o=0;return e.forEach((e=>{r.set(e,o),o+=e.length})),r}const N=e=>{let t=e;t instanceof Uint8Array&&(t=M.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r})(t)}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};class JOSEError extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null===(t=Error.captureStackTrace)||void 0===t||t.call(Error,this,this.constructor)}}class F extends JOSEError{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=t,this.reason=r}}class q extends JOSEError{static get code(){return"ERR_JWT_EXPIRED"}constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_EXPIRED",this.claim=t,this.reason=r}}class G extends JOSEError{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class V extends JOSEError{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class B extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class X extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class Y extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}static get code(){return"ERR_JWKS_INVALID"}}class Q extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWKS_NO_MATCHING_KEY",this.message="no applicable key found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_NO_MATCHING_KEY"}}class Z extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS",this.message="multiple matching keys found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}Symbol.asyncIterator;class ee extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWKS_TIMEOUT",this.message="request timed out"}static get code(){return"ERR_JWKS_TIMEOUT"}}class te extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}const re=crypto,oe=e=>e instanceof CryptoKey;re.getRandomValues.bind(re);const ne=async e=>{var t,r;if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:o,keyUsages:n}=function(e){let t,r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.slice(-3)}`},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new V(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new V('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new V('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new V('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new V('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new V('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),a=[o,null!==(t=e.ext)&&void 0!==t&&t,null!==(r=e.key_ops)&&void 0!==r?r:n];if("PBKDF2"===o.name)return re.subtle.importKey("raw",N(e.k),...a);const i={...e};return delete i.alg,delete i.use,re.subtle.importKey("jwk",i,...a)};function ae(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const ie=function(e,t,r,o,n){if(void 0!==n.crit&&void 0===o.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!o||void 0===o.crit)return new Set;if(!Array.isArray(o.crit)||0===o.crit.length||o.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let a;a=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of o.crit){if(!a.has(t))throw new V(`Extension Header Parameter "${t}" is not recognized`);if(void 0===n[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(a.get(t)&&void 0===o[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(o.crit)};Symbol();function se(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function ce(e,t){return e.name===t}function de(e){return parseInt(e.name.slice(4),10)}function le(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function ue(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!ce(e.algorithm,"HMAC"))throw se("HMAC");const r=parseInt(t.slice(2),10);if(de(e.algorithm.hash)!==r)throw se(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!ce(e.algorithm,"RSASSA-PKCS1-v1_5"))throw se("RSASSA-PKCS1-v1_5");const r=parseInt(t.slice(2),10);if(de(e.algorithm.hash)!==r)throw se(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!ce(e.algorithm,"RSA-PSS"))throw se("RSA-PSS");const r=parseInt(t.slice(2),10);if(de(e.algorithm.hash)!==r)throw se(`SHA-${r}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw se("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!ce(e.algorithm,"ECDSA"))throw se("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw se(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}le(e,r)}function he(e,t,...r){if(r.length>2){const t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else 2===r.length?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor&&t.constructor.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const pe=(e,...t)=>he("Key must be ",e,...t);function we(e,t,...r){return he(`Key for the ${e} algorithm must be `,t,...r)}const ge=e=>oe(e),fe=["CryptoKey"];const me=async(e,t,r,o)=>{const n=await function(e,t,r){if(oe(t))return ue(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(pe(t,...fe));return re.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(pe(t,...fe,"Uint8Array"))}(e,t,"verify");((e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}})(e,n);const a=function(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new V(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}(e,n.algorithm);try{return await re.subtle.verify(a,n,r,o)}catch(e){return!1}},ye=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0},Ee=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!ge(t))throw new TypeError(we(e,t,...fe,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${fe.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,r)=>{if(!ge(t))throw new TypeError(we(e,t,...fe));if("secret"===t.type)throw new TypeError(`${fe.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===r&&"public"===t.type)throw new TypeError(`${fe.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===r&&"public"===t.type)throw new TypeError(`${fe.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===r&&"private"===t.type)throw new TypeError(`${fe.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===r&&"private"===t.type)throw new TypeError(`${fe.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(e,t,r)},ve=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function Se(e,t,r){if(e instanceof Uint8Array&&(e=M.decode(e)),"string"!=typeof e)throw new B("Compact JWS must be a string or Uint8Array");const{0:o,1:n,2:a,length:i}=e.split(".");if(3!==i)throw new B("Invalid Compact JWS");const s=await async function(e,t,r){var o;if(!ae(e))throw new B("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new B('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new B("JWS Protected Header incorrect type");if(void 0===e.payload)throw new B("JWS Payload missing");if("string"!=typeof e.signature)throw new B("JWS Signature missing or incorrect type");if(void 0!==e.header&&!ae(e.header))throw new B("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const t=N(e.protected);n=JSON.parse(M.decode(t))}catch(e){throw new B("JWS Protected Header is invalid")}if(!ye(n,e.header))throw new B("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...n,...e.header};let i=!0;if(ie(B,new Map([["b64",!0]]),null==r?void 0:r.crit,n,a).has("b64")&&(i=n.b64,"boolean"!=typeof i))throw new B('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=a;if("string"!=typeof s||!s)throw new B('JWS "alg" (Algorithm) Header Parameter missing or invalid');const c=r&&ve("algorithms",r.algorithms);if(c&&!c.has(s))throw new G('"alg" (Algorithm) Header Parameter not allowed');if(i){if("string"!=typeof e.payload)throw new B("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new B("JWS Payload must be a string or an Uint8Array instance");let d=!1;"function"==typeof t&&(t=await t(n,e),d=!0),Ee(s,t,"verify");const l=z(H.encode(null!==(o=e.protected)&&void 0!==o?o:""),H.encode("."),"string"==typeof e.payload?H.encode(e.payload):e.payload),u=N(e.signature);if(!await me(s,t,u,l))throw new te;let h;h=i?N(e.payload):"string"==typeof e.payload?H.encode(e.payload):e.payload;const p={payload:h};return void 0!==e.protected&&(p.protectedHeader=n),void 0!==e.header&&(p.unprotectedHeader=e.header),d?{...p,key:t}:p}({payload:n,protected:o,signature:a},t,r),c={payload:s.payload,protectedHeader:s.protectedHeader};return"function"==typeof t?{...c,key:s.key}:c}const be=86400,Ae=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i,_e=e=>{const t=Ae.exec(e);if(!t)throw new TypeError("Invalid time period format");const r=parseFloat(t[1]);switch(t[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(60*r);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(3600*r);case"day":case"days":case"d":return Math.round(r*be);case"week":case"weeks":case"w":return Math.round(604800*r);default:return Math.round(31557600*r)}},ke=e=>e.toLowerCase().replace(/^application\//,""),Ie=(e,t,r={})=>{const{typ:o}=r;if(o&&("string"!=typeof e.typ||ke(e.typ)!==ke(o)))throw new F('unexpected "typ" JWT header value',"typ","check_failed");let n;try{n=JSON.parse(M.decode(t))}catch(e){}if(!ae(n))throw new X("JWT Claims Set must be a top-level JSON object");const{requiredClaims:a=[],issuer:i,subject:s,audience:c,maxTokenAge:d}=r;void 0!==d&&a.push("iat"),void 0!==c&&a.push("aud"),void 0!==s&&a.push("sub"),void 0!==i&&a.push("iss");for(const e of new Set(a.reverse()))if(!(e in n))throw new F(`missing required "${e}" claim`,e,"missing");if(i&&!(Array.isArray(i)?i:[i]).includes(n.iss))throw new F('unexpected "iss" claim value',"iss","check_failed");if(s&&n.sub!==s)throw new F('unexpected "sub" claim value',"sub","check_failed");if(c&&(l=n.aud,u="string"==typeof c?[c]:c,!("string"==typeof l?u.includes(l):Array.isArray(l)&&u.some(Set.prototype.has.bind(new Set(l))))))throw new F('unexpected "aud" claim value',"aud","check_failed");var l,u;let h;switch(typeof r.clockTolerance){case"string":h=_e(r.clockTolerance);break;case"number":h=r.clockTolerance;break;case"undefined":h=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:p}=r,w=(g=p||new Date,Math.floor(g.getTime()/1e3));var g;if((void 0!==n.iat||d)&&"number"!=typeof n.iat)throw new F('"iat" claim must be a number',"iat","invalid");if(void 0!==n.nbf){if("number"!=typeof n.nbf)throw new F('"nbf" claim must be a number',"nbf","invalid");if(n.nbf>w+h)throw new F('"nbf" claim timestamp check failed',"nbf","check_failed")}if(void 0!==n.exp){if("number"!=typeof n.exp)throw new F('"exp" claim must be a number',"exp","invalid");if(n.exp<=w-h)throw new q('"exp" claim timestamp check failed',"exp","check_failed")}if(d){const e=w-n.iat;if(e-h>("number"==typeof d?d:_e(d)))throw new q('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(e<0-h)throw new F('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return n};function Te(e){return e&&"object"==typeof e&&Array.isArray(e.keys)&&e.keys.every(Oe)}function Oe(e){return ae(e)}class Re{constructor(e){if(this._cached=new WeakMap,!Te(e))throw new Y("JSON Web Key Set malformed");var t;this._jwks=(t=e,"function"==typeof structuredClone?structuredClone(t):JSON.parse(JSON.stringify(t)))}async getKey(e,t){const{alg:r,kid:o}={...e,...null==t?void 0:t.header},n=function(e){switch("string"==typeof e&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new V('Unsupported "alg" value for a JSON Web Key Set')}}(r),a=this._jwks.keys.filter((e=>{let t=n===e.kty;if(t&&"string"==typeof o&&(t=o===e.kid),t&&"string"==typeof e.alg&&(t=r===e.alg),t&&"string"==typeof e.use&&(t="sig"===e.use),t&&Array.isArray(e.key_ops)&&(t=e.key_ops.includes("verify")),t&&"EdDSA"===r&&(t="Ed25519"===e.crv||"Ed448"===e.crv),t)switch(r){case"ES256":t="P-256"===e.crv;break;case"ES256K":t="secp256k1"===e.crv;break;case"ES384":t="P-384"===e.crv;break;case"ES512":t="P-521"===e.crv}return t})),{0:i,length:s}=a;if(0===s)throw new Q;if(1!==s){const e=new Z,{_cached:t}=this;throw e[Symbol.asyncIterator]=async function*(){for(const e of a)try{yield await Pe(t,e,r)}catch(e){continue}},e}return Pe(this._cached,i,r)}}async function Pe(e,t,r){const o=e.get(t)||e.set(t,{}).get(t);if(void 0===o[r]){const e=await async function(e,t,r){var o;if(!ae(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=r||(r=!0!==e.ext),r?ne({...e,alg:t,ext:null!==(o=e.ext)&&void 0!==o&&o}):N(e.k);case"RSA":if(void 0!==e.oth)throw new V('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return ne({...e,alg:t});default:throw new V('Unsupported "kty" (Key Type) Parameter value')}}({...t,ext:!0},r);if(e instanceof Uint8Array||"public"!==e.type)throw new Y("JSON Web Key Set members must be public keys");o[r]=e}return o[r]}const Ce=async(e,t,r)=>{let o,n,a=!1;"function"==typeof AbortController&&(o=new AbortController,n=setTimeout((()=>{a=!0,o.abort()}),t));const i=await fetch(e.href,{signal:o?o.signal:void 0,redirect:"manual",headers:r.headers}).catch((e=>{if(a)throw new ee;throw e}));if(void 0!==n&&clearTimeout(n),200!==i.status)throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await i.json()}catch(e){throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON")}};class We extends Re{constructor(e,t){if(super({keys:[]}),this._jwks=void 0,!(e instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(e.href),this._options={agent:null==t?void 0:t.agent,headers:null==t?void 0:t.headers},this._timeoutDuration="number"==typeof(null==t?void 0:t.timeoutDuration)?null==t?void 0:t.timeoutDuration:5e3,this._cooldownDuration="number"==typeof(null==t?void 0:t.cooldownDuration)?null==t?void 0:t.cooldownDuration:3e4,this._cacheMaxAge="number"==typeof(null==t?void 0:t.cacheMaxAge)?null==t?void 0:t.cacheMaxAge:6e5}coolingDown(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cooldownDuration}fresh(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cacheMaxAge}async getKey(e,t){this._jwks&&this.fresh()||await this.reload();try{return await super.getKey(e,t)}catch(r){if(r instanceof Q&&!1===this.coolingDown())return await this.reload(),super.getKey(e,t);throw r}}async reload(){this._pendingFetch&&("undefined"!=typeof WebSocketPair||"undefined"!=typeof navigator&&"Cloudflare-Workers"===navigator.userAgent||"undefined"!=typeof EdgeRuntime&&"vercel"===EdgeRuntime)&&(this._pendingFetch=void 0),this._pendingFetch||(this._pendingFetch=Ce(this._url,this._timeoutDuration,this._options).then((e=>{if(!Te(e))throw new Y("JSON Web Key Set malformed");this._jwks={keys:e.keys},this._jwksTimestamp=Date.now(),this._pendingFetch=void 0})).catch((e=>{throw this._pendingFetch=void 0,e}))),await this._pendingFetch}}const xe=N;class AuthenticationError extends R{constructor(e,t){super(e=e??t?.message??"An error occurred during authentication",t)}}class LogoutError extends R{constructor(e,t){super(e=e??t?.message??"An error occurred during logout",t)}}const je="1.0.0",$e="OIDC",Je=()=>{J($e)},Ue=()=>{U($e,je)};"undefined"!=typeof window&&("undefined"==typeof fin&&Object.assign(window,{fin:{}}),Object.assign(fin,{Integrations:{OIDC:{enableLogging:Ue,disableLogging:Je}}}));const Ke=e=>`${e.replace(/\/$/,"")}/.well-known/openid-configuration`;var De;!function(e){e.OpenIdConnect="OpenID-Connect"}(De||(De={}));class Le extends W{get idToken(){return this._idToken}get openIdProviderUrl(){return this._openIdProviderUrl}get redirectUri(){return this._redirectUri}get scope(){return this._scope}get userInfo(){return this._userInfo}async authorize(e,t,r){await super.authorize(e,t,r),this._idToken=await this.getIdToken(),this._userInfo=await(async e=>{const t=e.metadata?.userinfo_endpoint;if(!t)return;const{data:r}=await e.executeApiRequest(t);return r})(this)}async close(){await super.close(),this._idToken=void 0,this._openIdProviderUrl=void 0,this._redirectUri=void 0,this._scope=void 0,this._userInfo=void 0}getErrorMessageFromServerResponse(e){return e}static async init(e,t,r,o,n,a,i){const s=new C(o);s.logInfo("Init started",e,t,r,o,n,a,i);try{const{additionalMetadata:t,discoveryEndpoint:o}=e,c={...await K(o),...t??{}};if(!c.response_types_supported.find((e=>"code"===e.toLowerCase())))throw new P("OpenID Provider does not support the authorization code response type");const d=await D(c,r,s),l=new Le(void 0,r,c,d,s);return l._openIdProviderUrl=n,l._redirectUri=a,l._scope=i,s.logInfo("Init completed",l),(async(e,t)=>{try{await fin.System.registerUsage({type:"integration-feature",data:{apiVersion:je,componentName:e}})}catch(r){t.logWarning(`Unable to register usage for feature ${e}: ${r?.message}`)}})(De.OpenIdConnect,s),l}catch(e){let t;throw t=e instanceof R?e:new P(void 0,e),s.logError(t),t}}}const He=async(e,t,r)=>{const o=new C($e),n=Ke(r);let a;try{a=await K(n)}catch(e){const t=new j(`Failed to retrieve OpenID Connect metadata from ${n}`);throw o.logError(t),t}const{introspection_endpoint:i,jwks_uri:s}=a;if(i)try{return await L(o)(e,t,i)}catch(e){}else o?.logWarning("No introspection endpoint found in OpenID Connect metadata");if(!s){const e=new j(`Failed to retrieve JSON Web Key Set (JWKS) from ${s}`);throw o.logError(e),e}o?.logInfo("Validating id token against JWKS endpoint",s);try{const{payload:n}=await async function(e,t,r){var o;const n=await Se(e,t,r);if((null===(o=n.protectedHeader.crit)||void 0===o?void 0:o.includes("b64"))&&!1===n.protectedHeader.b64)throw new X("JWTs MUST NOT use unencoded payload");const a={payload:Ie(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return"function"==typeof t?{...a,key:n.key}:a}(e,function(e,t){const r=new We(e,t);return async function(e,t){return r.getKey(e,t)}}(new URL(s)),{audience:t,issuer:r});return o?.logInfo("ID token validation successful",n),{valid:!0,...n}}catch(e){if(!(e instanceof F||e instanceof q||e instanceof X||e instanceof te)){const t=new j(void 0,e);throw o.logError(t),t}return o.logWarning(`ID token validation failed: ${e.message}`),{valid:!1}}},Me=["openid","profile","email"],ze=async(e,t,r,o=[],n,a,i)=>{if(e=e?.trim().replace(/\/$/,""),!e)throw new x("OpenID Provider URL must be a non-empty string");if(!t)throw new x("Client Identifier must be a non-empty string");if(!r)throw new x("Redirection URI must be a non-empty string");const s=await Fe(e,t,r,o,n);if(!s)throw new P("Provider not initialized");const c=s.metadata?.scopes_supported;if(!c){const e=new AuthenticationError("OpenID Provider metadata does not define supported scopes");throw s.logger.logError(e),e}const d=Me.filter((e=>!c.includes(e)));if(d.length>0){const e=new AuthenticationError(`OpenID Provider does not support required scopes: ${d.join(", ")}`);throw s.logger.logError(e),e}const l=new Set([...Me,...o]);await s.authorize(r,{display:"popup",scope:[...l].join(" "),...a},i);const{idToken:u}=s;if(!u){const e=new AuthenticationError("No ID token returned");throw s.logger.logError(e),e}const h=function(e){if("string"!=typeof e)throw new X("JWTs must use Compact JWS serialization, JWT must be a string");const{1:t,length:r}=e.split(".");if(5===r)throw new X("Only JWTs using Compact JWS serialization can be decoded");if(3!==r)throw new X("Invalid JWT");if(!t)throw new X("JWTs must contain a payload");let o,n;try{o=xe(t)}catch(e){throw new X("Failed to parse the base64url encoded payload")}try{n=JSON.parse(M.decode(o))}catch(e){throw new X("Failed to parse the decoded payload as JSON")}if(!ae(n))throw new X("Invalid JWT Claims Set");return n}(u);if(!h){const e=new AuthenticationError("Failed to decode ID token");throw s.logger.logError(e),e}const{aud:p,iss:w}=h;return await He(u,Array.isArray(p)?p[0]:p,w),{claims:h,clientId:t,idToken:u,logout:qe(t,u,s),openIdProviderUrl:e,userInfo:s.userInfo}},Ne=(e,t,r,o,n,a)=>async n=>{if(0!==new URL(n).href.toLowerCase().indexOf(r.toLowerCase()))return!1;window.clearInterval(a),window.clearTimeout(t);try{e.removeAllListeners(),e.close(!0)}catch(e){}return o(),!0},Fe=async(e,t,r,o,n)=>{const a={additionalMetadata:n,discoveryEndpoint:Ke(e)};return Le.init(a,void 0,t,$e,e,r,o)},qe=(e,t,r)=>async(o,n)=>{if(!o)throw new x("Logout Redirection URI must be a non-empty string");const{logger:a,metadata:i}=r;a.logInfo("Logout started",e,t,o,n);const{end_session_endpoint:s}=i??{};if(!s){const e=new LogoutError("OpenID Provider metadata does not define end session endpoint");throw a.logError(e),e}const c=`${s}?id_token_hint=${t}&client_id=${e}&post_logout_redirect_uri=${encodeURIComponent(o)}${n?`&logout_hint=${encodeURIComponent(n)}`:""}`;await $(c,Ge(o,a)),await(r?.close()),a.logInfo("Logout completed")},Ge=(e,t)=>r=>new Promise(((o,n)=>{let a;r.addListener("closing",(async()=>{t.logInfo("User closed auth window"),window.clearInterval(a),r.removeAllListeners(),n(new LogoutError("Failed to complete logout process"))}));const i=window.setTimeout((async()=>{try{await r.isShowing()||(t.logInfo("Showing auth window"),await r.show(!0),await r.focus())}catch{t.logWarning("Unable to show auth window")}}),2e3);(async()=>{const{version:s}=await fin.System.getRuntimeInfo();if(parseInt(s.split(".")[0],10)>=30){await Ne(r,i,e,o,n)((await r.getInfo()).url)||await r.addListener("url-changed",(a=>{t.logInfo("Auth window navigated to",a.url),Ne(r,i,e,o,n)(a.url)}))}else a=window.setInterval((()=>(async(e,t,r,o,n,a)=>{let i;try{i=await e.getInfo()}catch(e){return window.clearInterval(t),window.clearTimeout(r),a(new LogoutError("Could not locate auth window")),!1}return Ne(e,r,o,n,a,t)(i.url)})(r,a,i,e,o,n)),500)})()}));var Ve=t.MS,Be=t._7,Xe=t.cX,Ye=t.zL,Qe=t._W,Ze=t.p8,et=t.YR,tt=t.U$,rt=t.U7,ot=t.OF;

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*********************************************************!*\
  !*** ./client/src/modules/auth/openid-connect/index.ts ***!
  \*********************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   entryPoints: () => (/* binding */ entryPoints)
/* harmony export */ });
/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auth */ "./client/src/modules/auth/openid-connect/auth.ts");

/**
 * Define the entry points for the module.
 */
const entryPoints = {
    auth: new _auth__WEBPACK_IMPORTED_MODULE_0__.OpenIdConnectProvider()
};

})();

var __webpack_exports__entryPoints = __webpack_exports__.entryPoints;
export { __webpack_exports__entryPoints as entryPoints };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUkseUZBQXlGLE1BQU0sNENBQTRDLE9BQU8sV0FBVyxNQUFNLFVBQVUsbUNBQW1DLHFDQUFxQyxxRkFBcUYsaUVBQWlFLEdBQUcscURBQXFELE1BQU0sSUFBSSxvQkFBb0IsU0FBUyw0R0FBNEcsOEJBQThCLHFCQUFxQixJQUFJLEdBQUc7Ozs7OztTQ0E1bTVDO1NBQ0E7O1NBRUE7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7O1NBRUE7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7Ozs7O1VDdEJBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EseUNBQXlDLHdDQUF3QztVQUNqRjtVQUNBO1VBQ0E7Ozs7O1VDUEE7Ozs7O1VDQUE7VUFDQTtVQUNBO1VBQ0EsdURBQXVELGlCQUFpQjtVQUN4RTtVQUNBLGdEQUFnRCxhQUFhO1VBQzdEOzs7Ozs7Ozs7Ozs7Ozs7QUNMK0M7QUFFL0M7O0dBRUc7QUFDSSxNQUFNLFdBQVcsR0FBcUQ7SUFDNUUsSUFBSSxFQUFFLElBQUksd0RBQXFCLEVBQUU7Q0FDakMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS13b3Jrc3BhY2UtcGxhdGZvcm0tc3RhcnRlci8uL2NsaWVudC9zcmMvZnJhbWV3b3JrL3V0aWxzLnRzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS13b3Jrc3BhY2UtcGxhdGZvcm0tc3RhcnRlci8uL2NsaWVudC9zcmMvbW9kdWxlcy9hdXRoL29wZW5pZC1jb25uZWN0L2F1dGgudHMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLXdvcmtzcGFjZS1wbGF0Zm9ybS1zdGFydGVyLy4uLy4uL25vZGVfbW9kdWxlcy9Ab3BlbmZpbi9vcGVuaWQtY29ubmVjdC9vcGVuZmluLm9wZW5pZC1jb25uZWN0Lm1qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0td29ya3NwYWNlLXBsYXRmb3JtLXN0YXJ0ZXIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLXdvcmtzcGFjZS1wbGF0Zm9ybS1zdGFydGVyL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0td29ya3NwYWNlLXBsYXRmb3JtLXN0YXJ0ZXIvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0td29ya3NwYWNlLXBsYXRmb3JtLXN0YXJ0ZXIvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0td29ya3NwYWNlLXBsYXRmb3JtLXN0YXJ0ZXIvLi9jbGllbnQvc3JjL21vZHVsZXMvYXV0aC9vcGVuaWQtY29ubmVjdC9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIHVuZGVmaW5lZCBvciBudWxsLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgbnVsbCB8IHVuZGVmaW5lZCB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuXHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbDtcbn1cblxuLyoqXG4gKiBUZXN0IGlmIGEgdmFsdWUgaXMgYW4gb2JqZWN0LlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBvYmplY3Qge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuXG4vKipcbiAqIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBzdHJpbmcge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuXG4vKipcbiAqIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyB0aGF0IGlzIG5vdCBlbXB0eS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nIHRoYXQgaXMgbm90IGVtcHR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmdWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIHN0cmluZyB7XG5cdHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUudHJpbSgpLmxlbmd0aCA+IDA7XG59XG5cbi8qKlxuICogVGVzdCBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bWJlciB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuXHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59XG5cbi8qKlxuICogVGVzdCBpZiBhIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIGJvb2xlYW4ge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcbn1cblxuLyoqXG4gKiBUZXN0IGlmIGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudW1iZXIge1xuXHRyZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufVxuXG4vKipcbiAqIERlZXAgY2xvbmUgYW4gb2JqZWN0LlxuICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMgVGhlIGNsb25lIG9mIHRoZSBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RDbG9uZTxUPihvYmo6IFQpOiBUIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cdHJldHVybiBvYmogPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG5cbi8qKlxuICogUG9seWZpbGxzIHJhbmRvbVVVSUQgaWYgcnVubmluZyBpbiBhIG5vbi1zZWN1cmUgY29udGV4dC5cbiAqIEByZXR1cm5zIFRoZSByYW5kb20gVVVJRC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVVVSUQoKTogc3RyaW5nIHtcblx0aWYgKFwicmFuZG9tVVVJRFwiIGluIHdpbmRvdy5jcnlwdG8pIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0XHRyZXR1cm4gd2luZG93LmNyeXB0by5yYW5kb21VVUlEKCk7XG5cdH1cblx0Ly8gUG9seWZpbGwgdGhlIHdpbmRvdy5jcnlwdG8ucmFuZG9tVVVJRCBpZiB3ZSBhcmUgcnVubmluZyBpbiBhIG5vbiBzZWN1cmUgY29udGV4dCB0aGF0IGRvZXNuJ3QgaGF2ZSBpdFxuXHQvLyB3ZSBhcmUgc3RpbGwgdXNpbmcgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgd2hpY2ggaXMgYWx3YXlzIGF2YWlsYWJsZVxuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyMy8yODAwMjE4XG5cdC8qKlxuXHQgKiBHZXQgcmFuZG9tIGhleCB2YWx1ZS5cblx0ICogQHBhcmFtIGMgVGhlIG51bWJlciB0byBiYXNlIHRoZSByYW5kb20gdmFsdWUgb24uXG5cdCAqIEByZXR1cm5zIFRoZSByYW5kb20gdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRSYW5kb21IZXgoYzogc3RyaW5nKTogc3RyaW5nIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuXHRcdGNvbnN0IHJuZCA9IHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEpKVswXSAmICgxNSA+PiAoTnVtYmVyKGMpIC8gNCkpO1xuXHRcdHJldHVybiAoXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuXHRcdFx0KE51bWJlcihjKSBeIHJuZCkudG9TdHJpbmcoMTYpXG5cdFx0KTtcblx0fVxuXHRyZXR1cm4gXCIxMDAwMDAwMC0xMDAwLTQwMDAtODAwMC0xMDAwMDAwMDAwMDBcIi5yZXBsYWNlKC9bMDE4XS9nLCBnZXRSYW5kb21IZXgpO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhbiBlcnJvciB0byBhIHJlYWRhYmxlIHN0cmluZy5cbiAqIEBwYXJhbSBlcnIgVGhlIGVycm9yIHRvIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRFcnJvcihlcnI6IHVua25vd24pOiBzdHJpbmcge1xuXHRpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRyZXR1cm4gZXJyLm1lc3NhZ2U7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGVyciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiBlcnI7XG5cdH1cblx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycik7XG59XG5cbi8qKlxuICogTG9hZCBhbiBpbWFnZSB0byBhIGRhdGEgdXJsIGNvbnRhaW5pbmcgYmFzZTY0IGltYWdlIGRhdGEuXG4gKiBAcGFyYW0gdXJsIFRoZSB1cmwgb2YgdGhlIGltYWdlIHRvIGxvYWQuXG4gKiBAcGFyYW0gZGltZW5zaW9ucyBUaGUgZGltZW5zaW9ucyB0byByZXNpemUgdGhlIGltYWdlIHRvLlxuICogQHJldHVybnMgVGhlIGRhdGEgdXJsIGNvbnRhaW5pbmcgYmFzZTY0IGRhdGEgZm9yIHRoZSBpbWFnZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltYWdlVXJsVG9EYXRhVXJsKHVybDogc3RyaW5nLCBkaW1lbnNpb25zOiBudW1iZXIpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuXHRyZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPigocmVzb2x2ZSkgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXG5cdFx0XHRpbWcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdFx0XHRjYW52YXMud2lkdGggPSBkaW1lbnNpb25zO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gZGltZW5zaW9ucztcblxuXHRcdFx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG5cdFx0XHRcdGlmIChjdHgpIHtcblx0XHRcdFx0XHRjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgZGltZW5zaW9ucywgZGltZW5zaW9ucyk7XG5cdFx0XHRcdFx0cmVzb2x2ZShjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIsIDEpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby11c2VsZXNzLXVuZGVmaW5lZFxuXHRcdFx0XHRcdHJlc29sdmUodW5kZWZpbmVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRpbWcuc3JjID0gdXJsO1xuXHRcdH0gY2F0Y2gge31cblx0fSk7XG59XG4iLCJpbXBvcnQge1xuXHRhdXRoZW50aWNhdGUsXG5cdGVuYWJsZUxvZ2dpbmcsXG5cdHZhbGlkYXRlSWRUb2tlbixcblx0dHlwZSBPaWRjQXV0aGVudGljYXRpb25SZXN1bHQsXG5cdHR5cGUgVXNlckluZm9DbGFpbXNcbn0gZnJvbSBcIkBvcGVuZmluL29wZW5pZC1jb25uZWN0XCI7XG5pbXBvcnQgdHlwZSB7IEF1dGhFdmVudFR5cGVzLCBBdXRoUHJvdmlkZXIgfSBmcm9tIFwid29ya3NwYWNlLXBsYXRmb3JtLXN0YXJ0ZXIvc2hhcGVzL2F1dGgtc2hhcGVzXCI7XG5pbXBvcnQgdHlwZSB7IExvZ2dlciwgTG9nZ2VyQ3JlYXRvciB9IGZyb20gXCJ3b3Jrc3BhY2UtcGxhdGZvcm0tc3RhcnRlci9zaGFwZXMvbG9nZ2VyLXNoYXBlc1wiO1xuaW1wb3J0IHR5cGUgeyBNb2R1bGVEZWZpbml0aW9uLCBNb2R1bGVIZWxwZXJzIH0gZnJvbSBcIndvcmtzcGFjZS1wbGF0Zm9ybS1zdGFydGVyL3NoYXBlcy9tb2R1bGUtc2hhcGVzXCI7XG5pbXBvcnQgeyBmb3JtYXRFcnJvciwgaXNFbXB0eSwgaXNOdW1iZXIsIGlzU3RyaW5nVmFsdWUsIHJhbmRvbVVVSUQgfSBmcm9tIFwid29ya3NwYWNlLXBsYXRmb3JtLXN0YXJ0ZXIvdXRpbHNcIjtcbmltcG9ydCB0eXBlIHsgT3BlbklkQ29ubmVjdFByb3ZpZGVyT3B0aW9ucyB9IGZyb20gXCIuL3NoYXBlc1wiO1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIGZvciB0aGUgb3BlbmlkIGNvbm5lY3QgYXV0aCBwcm92aWRlci5cbiAqL1xuZXhwb3J0IGNsYXNzIE9wZW5JZENvbm5lY3RQcm92aWRlciBpbXBsZW1lbnRzIEF1dGhQcm92aWRlcjxPcGVuSWRDb25uZWN0UHJvdmlkZXJPcHRpb25zPiB7XG5cdC8qKlxuXHQgKiBUaGUgbW9kdWxlIGRlZmluaXRpb24gaW5jbHVkaW5nIHNldHRpbmdzLlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdHByaXZhdGUgX2RlZmluaXRpb246IE1vZHVsZURlZmluaXRpb248T3BlbklkQ29ubmVjdFByb3ZpZGVyT3B0aW9ucz4gfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFRoZSBsb2dnZXIgZm9yIGRpc3BsYXlpbmcgaW5mb3JtYXRpb24gZnJvbSB0aGUgbW9kdWxlLlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdHByaXZhdGUgX2xvZ2dlcj86IExvZ2dlcjtcblxuXHQvKipcblx0ICogTWFwIGEgc3Vic2NyaXB0aW9uIGlkIHRvIGFuIGV2ZW50LlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdHByaXZhdGUgcmVhZG9ubHkgX3N1YnNjcmliZUlkTWFwOiB7IFtrZXk6IHN0cmluZ106IEF1dGhFdmVudFR5cGVzIH07XG5cblx0LyoqXG5cdCAqIENhbGxiYWNrcyBmb3IgZXZlbnQgc3Vic2NyaWJlcnMuXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0cHJpdmF0ZSByZWFkb25seSBfZXZlbnRTdWJzY3JpYmVyczogeyBbZXZlbnQgaW4gQXV0aEV2ZW50VHlwZXNdPzogeyBbaWQ6IHN0cmluZ106ICgpID0+IFByb21pc2U8dm9pZD4gfSB9O1xuXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IG9mIHRoZSBhdXRoZW50aWNhdGlvbiByZXF1ZXN0LlxuXHQgKi9cblx0cHJpdmF0ZSBfYXV0aFJlc3VsdDogT2lkY0F1dGhlbnRpY2F0aW9uUmVzdWx0IHwgdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBTZXNzaW9uIGV4cGlyeSB0aW1lci5cblx0ICovXG5cdHByaXZhdGUgX3Nlc3Npb25FeHBpcnlUaW1lcklkOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBPcGVuSWRDb25uZWN0UHJvdmlkZXIuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9zdWJzY3JpYmVJZE1hcCA9IHt9O1xuXHRcdHRoaXMuX2V2ZW50U3Vic2NyaWJlcnMgPSB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIHRoZSBtb2R1bGUuXG5cdCAqIEBwYXJhbSBkZWZpbml0aW9uIFRoZSBkZWZpbml0aW9uIG9mIHRoZSBtb2R1bGUgZnJvbSBjb25maWd1cmF0aW9uIGluY2x1ZGUgY3VzdG9tIG9wdGlvbnMuXG5cdCAqIEBwYXJhbSBsb2dnZXJDcmVhdG9yIEZvciBsb2dnaW5nIGVudHJpZXMuXG5cdCAqIEBwYXJhbSBoZWxwZXJzIEhlbHBlciBtZXRob2RzIGZvciB0aGUgbW9kdWxlIHRvIGludGVyYWN0IHdpdGggdGhlIGFwcGxpY2F0aW9uIGNvcmUuXG5cdCAqIEByZXR1cm5zIE5vdGhpbmcuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZShcblx0XHRkZWZpbml0aW9uOiBNb2R1bGVEZWZpbml0aW9uPE9wZW5JZENvbm5lY3RQcm92aWRlck9wdGlvbnM+LFxuXHRcdGxvZ2dlckNyZWF0b3I6IExvZ2dlckNyZWF0b3IsXG5cdFx0aGVscGVyczogTW9kdWxlSGVscGVyc1xuXHQpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0aGlzLl9kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcblx0XHR0aGlzLl9sb2dnZXIgPSBsb2dnZXJDcmVhdG9yKFwiT3BlbklkQ29ubmVjdFByb3ZpZGVyXCIpO1xuXG5cdFx0dGhpcy5fbG9nZ2VyLmluZm8oXCJJbml0aWFsaXppbmdcIik7XG5cblx0XHRpZiAodGhpcy5fZGVmaW5pdGlvbi5kYXRhPy5lbmFibGVMb2dnaW5nKSB7XG5cdFx0XHRlbmFibGVMb2dnaW5nKCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcHJvdmlkZXJVcmwgPSB0aGlzLl9kZWZpbml0aW9uLmRhdGE/LnByb3ZpZGVyVXJsO1xuXHRcdGNvbnN0IGNsaWVudElkID0gdGhpcy5fZGVmaW5pdGlvbi5kYXRhPy5jbGllbnRJZDtcblx0XHRjb25zdCBsb2dpblJlZGlyZWN0VXJsID0gdGhpcy5fZGVmaW5pdGlvbi5kYXRhPy5sb2dpblJlZGlyZWN0VXJsO1xuXHRcdGNvbnN0IGxvZ291dFJlZGlyZWN0VXJsID0gdGhpcy5fZGVmaW5pdGlvbi5kYXRhPy5sb2dvdXRSZWRpcmVjdFVybDtcblxuXHRcdGlmICghaXNTdHJpbmdWYWx1ZShwcm92aWRlclVybCkpIHtcblx0XHRcdHRoaXMuX2xvZ2dlci5lcnJvcihcInByb3ZpZGVyVXJsIGlzIG5vdCBjb25maWd1cmVkXCIpO1xuXHRcdH1cblxuXHRcdGlmICghaXNTdHJpbmdWYWx1ZShjbGllbnRJZCkpIHtcblx0XHRcdHRoaXMuX2xvZ2dlci5lcnJvcihcIkNsaWVudElkIGlzIG5vdCBjb25maWd1cmVkXCIpO1xuXHRcdH1cblxuXHRcdGlmICghaXNTdHJpbmdWYWx1ZShsb2dpblJlZGlyZWN0VXJsKSkge1xuXHRcdFx0dGhpcy5fbG9nZ2VyLmVycm9yKFwibG9naW5SZWRpcmVjdFVybCBpcyBub3QgY29uZmlndXJlZFwiKTtcblx0XHR9XG5cblx0XHRpZiAoIWlzU3RyaW5nVmFsdWUobG9nb3V0UmVkaXJlY3RVcmwpKSB7XG5cdFx0XHR0aGlzLl9sb2dnZXIuZXJyb3IoXCJsb2dvdXRSZWRpcmVjdFVybCBpcyBub3QgY29uZmlndXJlZFwiKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2xvc2UgZG93biBhbnkgcmVzb3VyY2VzIGJlaW5nIHVzZWQgYnkgdGhlIG1vZHVsZS5cblx0ICogQHJldHVybnMgTm90aGluZy5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBjbG9zZWRvd24oKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0dGhpcy5fbG9nZ2VyPy5pbmZvKFwiQ2xvc2Vkb3duXCIpO1xuXG5cdFx0aWYgKHRoaXMuX3Nlc3Npb25FeHBpcnlUaW1lcklkKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3Nlc3Npb25FeHBpcnlUaW1lcklkKTtcblx0XHRcdHRoaXMuX3Nlc3Npb25FeHBpcnlUaW1lcklkID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJzY3JpYmUgdG8gb25lIG9mIHRoZSBhdXRoIGV2ZW50cy5cblx0ICogQHBhcmFtIHRvIFRoZSBldmVudCB0byBzdWJzY3JpYmUgdG8uXG5cdCAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG5cdCAqIEByZXR1cm5zIFN1YnNjcmlwdGlvbiBpZCBmb3IgdW5zdWJzY3JpYmluZyBvciB1bmRlZmluZWQgaWYgZXZlbnQgdHlwZSBpcyBub3QgYXZhaWxhYmxlLlxuXHQgKi9cblx0cHVibGljIHN1YnNjcmliZSh0bzogQXV0aEV2ZW50VHlwZXMsIGNhbGxiYWNrOiAoKSA9PiBQcm9taXNlPHZvaWQ+KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcblx0XHRjb25zdCBzdWJzY3JpcHRpb25JZCA9IHJhbmRvbVVVSUQoKTtcblxuXHRcdGNvbnN0IHRvTWFwID0gdGhpcy5fZXZlbnRTdWJzY3JpYmVyc1t0b10gPz8ge307XG5cdFx0dG9NYXBbc3Vic2NyaXB0aW9uSWRdID0gY2FsbGJhY2s7XG5cdFx0dGhpcy5fZXZlbnRTdWJzY3JpYmVyc1t0b10gPSB0b01hcDtcblxuXHRcdHRoaXMuX3N1YnNjcmliZUlkTWFwW3N1YnNjcmlwdGlvbklkXSA9IHRvO1xuXHRcdHRoaXMuX2xvZ2dlcj8uaW5mbyhgU3Vic2NyaXB0aW9uIHRvICR7dG99IGV2ZW50cyByZWdpc3RlcmVkLiBTdWJzY3JpcHRpb24gSWQ6ICR7c3Vic2NyaXB0aW9uSWR9YCk7XG5cblx0XHRyZXR1cm4gc3Vic2NyaXB0aW9uSWQ7XG5cdH1cblxuXHQvKipcblx0ICogVW5zdWJzY3JpYmUgZnJvbSBhbiBhbHJlYWR5IHN1YnNjcmliZWQgZXZlbnQuXG5cdCAqIEBwYXJhbSBzdWJzY3JpcHRpb25JZCBUaGUgaWQgb2YgdGhlIHN1YnNjcmlwdGlvbiByZXR1cm5lZCBmcm9tIHN1YnNjcmliZS5cblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdW5zdWJzY3JpYmUgd2FzIHN1Y2Nlc3NmdWwuXG5cdCAqL1xuXHRwdWJsaWMgdW5zdWJzY3JpYmUoc3Vic2NyaXB0aW9uSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdGNvbnN0IGV2ZW50VHlwZSA9IHRoaXMuX3N1YnNjcmliZUlkTWFwW3N1YnNjcmlwdGlvbklkXTtcblx0XHRpZiAoaXNFbXB0eShldmVudFR5cGUpKSB7XG5cdFx0XHR0aGlzLl9sb2dnZXI/Lndhcm4oYFlvdSBoYXZlIHRyaWVkIHRvIHVuc3Vic2NyaWJlIHdpdGggYSBrZXkgJHtzdWJzY3JpcHRpb25JZH0gdGhhdCBpcyBpbnZhbGlkYCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZXZlbnRTdWJzY3JpYmVycyA9IHRoaXMuX2V2ZW50U3Vic2NyaWJlcnNbZXZlbnRUeXBlXTtcblx0XHRpZiAoIWlzRW1wdHkoZXZlbnRTdWJzY3JpYmVycykpIHtcblx0XHRcdGRlbGV0ZSBldmVudFN1YnNjcmliZXJzW3N1YnNjcmlwdGlvbklkXTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fc3Vic2NyaWJlSWRNYXBbc3Vic2NyaXB0aW9uSWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fc3Vic2NyaWJlSWRNYXBbc3Vic2NyaXB0aW9uSWRdO1xuXHRcdFx0dGhpcy5fbG9nZ2VyPy5pbmZvKFxuXHRcdFx0XHRgU3Vic2NyaXB0aW9uIHRvICR7ZXZlbnRUeXBlfSBldmVudHMgd2l0aCBzdWJzY3JpcHRpb24gSWQ6ICR7c3Vic2NyaXB0aW9uSWR9IGhhcyBiZWVuIGNsZWFyZWRgXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbG9nZ2VyPy53YXJuKFxuXHRcdFx0YFN1YnNjcmlwdGlvbiB0byAke2V2ZW50VHlwZX0gZXZlbnRzIHdpdGggc3Vic2NyaXB0aW9uIElkOiAke3N1YnNjcmlwdGlvbklkfSBjb3VsZCBub3QgYmUgY2xlYXJlZCBhcyB3ZSBkbyBub3QgaGF2ZSBhIHJlZ2lzdGVyIG9mIHRoYXQgZXZlbnQgdHlwZS5gXG5cdFx0KTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogRG9lcyB0aGUgYXV0aCBwcm92aWRlciByZXF1aXJlIGF1dGhlbnRpY2F0aW9uLlxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIGF1dGhlbnRpY2F0aW9uIGlzIHJlcXVpcmVkLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGlzQXV0aGVudGljYXRpb25SZXF1aXJlZCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRyZXR1cm4gaXNFbXB0eSh0aGlzLl9hdXRoUmVzdWx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtIHRoZSBsb2dpbiBvcGVyYXRpb24gb24gdGhlIGF1dGggcHJvdmlkZXIuXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGxvZ2luIHdhcyBzdWNjZXNzZnVsLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGxvZ2luKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdGNvbnN0IHByb3ZpZGVyVXJsID0gdGhpcy5fZGVmaW5pdGlvbj8uZGF0YT8ucHJvdmlkZXJVcmw7XG5cdFx0Y29uc3QgY2xpZW50SWQgPSB0aGlzLl9kZWZpbml0aW9uPy5kYXRhPy5jbGllbnRJZDtcblx0XHRjb25zdCBsb2dpblJlZGlyZWN0VXJsID0gdGhpcy5fZGVmaW5pdGlvbj8uZGF0YT8ubG9naW5SZWRpcmVjdFVybDtcblx0XHRjb25zdCBzY29wZXMgPSB0aGlzLl9kZWZpbml0aW9uPy5kYXRhPy5zY29wZXM7XG5cblx0XHRpZiAoaXNTdHJpbmdWYWx1ZShwcm92aWRlclVybCkgJiYgaXNTdHJpbmdWYWx1ZShjbGllbnRJZCkgJiYgaXNTdHJpbmdWYWx1ZShsb2dpblJlZGlyZWN0VXJsKSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5fYXV0aFJlc3VsdCA9IGF3YWl0IGF1dGhlbnRpY2F0ZShwcm92aWRlclVybCwgY2xpZW50SWQsIGxvZ2luUmVkaXJlY3RVcmwsIHNjb3Blcyk7XG5cdFx0XHRcdGF3YWl0IHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoXCJsb2dnZWQtaW5cIik7XG5cdFx0XHRcdHRoaXMuY2hlY2tGb3JTZXNzaW9uRXhwaXJ5KCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdHRoaXMuX2xvZ2dlcj8uZXJyb3IoXCJBdXRoZW50aWNhdGlvbiBmYWlsZWRcIiwgZm9ybWF0RXJyb3IoZXJyKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm0gdGhlIGxvZ291dCBvcGVyYXRpb24gb24gdGhlIGF1dGggcHJvdmlkZXIuXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGxvZ291dCB3YXMgc3VjY2Vzc2Z1bC5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBsb2dvdXQoKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0aWYgKHRoaXMuX2F1dGhSZXN1bHQpIHtcblx0XHRcdGlmICh0aGlzLl9zZXNzaW9uRXhwaXJ5VGltZXJJZCkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3Nlc3Npb25FeHBpcnlUaW1lcklkKTtcblx0XHRcdFx0dGhpcy5fc2Vzc2lvbkV4cGlyeVRpbWVySWQgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGxvZ291dFJlZGlyZWN0VXJsID0gdGhpcy5fZGVmaW5pdGlvbj8uZGF0YT8ubG9nb3V0UmVkaXJlY3RVcmw7XG5cdFx0XHRpZiAoaXNTdHJpbmdWYWx1ZShsb2dvdXRSZWRpcmVjdFVybCkpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKFwiYmVmb3JlLWxvZ2dlZC1vdXRcIik7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5fYXV0aFJlc3VsdC5sb2dvdXQobG9nb3V0UmVkaXJlY3RVcmwpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHR0aGlzLl9sb2dnZXI/LmVycm9yKFwiTG9nb3V0IGZhaWxlZFwiLCBmb3JtYXRFcnJvcihlcnIpKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKFwibG9nZ2VkLW91dFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYXV0aFJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHVzZXIgaW5mb3JtYXRpb24gZnJvbSB0aGUgYXV0aCBwcm92aWRlci5cblx0ICogQHJldHVybnMgVGhlIHVzZXIgaW5mb3JtYXRpb24sIHRoZSB0eXBlIGlzIHVua25vd24gYXMgaXQgaXMgZGVwZW5kZW50IG9uIHRoZSBhdXRoIHByb3ZpZGVyLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGdldFVzZXJJbmZvKCk6IFByb21pc2U8VXNlckluZm9DbGFpbXMgfCB1bmRlZmluZWQ+IHtcblx0XHRpZiAodGhpcy5fYXV0aFJlc3VsdCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2F1dGhSZXN1bHQudXNlckluZm87XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE5vdGlmeSBzdWJzY3JpYmVycyBvZiBhbiBldmVudCBjaGFuZ2UuXG5cdCAqIEBwYXJhbSBhdXRoRXZlbnRUeXBlIFRoZSB0eXBlIG9mIGF1dGhlbnRpY2F0aW9uIGV2ZW50IHRvIHNlbmQgdG8uXG5cdCAqL1xuXHRwcml2YXRlIGFzeW5jIG5vdGlmeVN1YnNjcmliZXJzKGF1dGhFdmVudFR5cGU6IEF1dGhFdmVudFR5cGVzKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3Qgc3Vic2NyaWJlcnMgPSB0aGlzLl9ldmVudFN1YnNjcmliZXJzW2F1dGhFdmVudFR5cGVdO1xuXG5cdFx0aWYgKHN1YnNjcmliZXJzKSB7XG5cdFx0XHRjb25zdCBzdWJzY3JpYmVySWRzID0gT2JqZWN0LmtleXMoc3Vic2NyaWJlcnMpO1xuXHRcdFx0c3Vic2NyaWJlcklkcy5yZXZlcnNlKCk7XG5cblx0XHRcdGZvciAoY29uc3Qgc3Vic2NyaWJlcklkIG9mIHN1YnNjcmliZXJJZHMpIHtcblx0XHRcdFx0dGhpcy5fbG9nZ2VyPy5pbmZvKFxuXHRcdFx0XHRcdGBOb3RpZnlpbmcgc3Vic2NyaWJlciB3aXRoIHN1YnNjcmlwdGlvbiBJZDogJHtzdWJzY3JpYmVySWR9IG9mIGV2ZW50IHR5cGU6ICR7YXV0aEV2ZW50VHlwZX1gXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGF3YWl0IHN1YnNjcmliZXJzW3N1YnNjcmliZXJJZF0oKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgdG8gc2VlIGlmIGEgc2Vzc2lvbiBoYXMgZXhwaXJlZC5cblx0ICovXG5cdHByaXZhdGUgY2hlY2tGb3JTZXNzaW9uRXhwaXJ5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHZhbGlkaXR5ID0gdGhpcy5fZGVmaW5pdGlvbj8uZGF0YT8uY2hlY2tTZXNzaW9uVmFsaWRpdHlJblNlY29uZHM7XG5cdFx0aWYgKGlzTnVtYmVyKHZhbGlkaXR5KSAmJiB2YWxpZGl0eSA+IDAgJiYgaXNFbXB0eSh0aGlzLl9zZXNzaW9uRXhwaXJ5VGltZXJJZCkpIHtcblx0XHRcdHRoaXMuX3Nlc3Npb25FeHBpcnlUaW1lcklkID0gd2luZG93LnNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHR0aGlzLl9zZXNzaW9uRXhwaXJ5VGltZXJJZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRjb25zdCBpZFRva2VuID0gdGhpcy5fYXV0aFJlc3VsdD8uaWRUb2tlbjtcblx0XHRcdFx0Y29uc3QgcHJvdmlkZXJVcmwgPSB0aGlzLl9kZWZpbml0aW9uPy5kYXRhPy5wcm92aWRlclVybDtcblx0XHRcdFx0Y29uc3QgY2xpZW50SWQgPSB0aGlzLl9kZWZpbml0aW9uPy5kYXRhPy5jbGllbnRJZDtcblxuXHRcdFx0XHRsZXQgaXNWYWxpZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChpc1N0cmluZ1ZhbHVlKGlkVG9rZW4pICYmIGlzU3RyaW5nVmFsdWUocHJvdmlkZXJVcmwpICYmIGlzU3RyaW5nVmFsdWUoY2xpZW50SWQpKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlSWRUb2tlbihpZFRva2VuLCBjbGllbnRJZCwgcHJvdmlkZXJVcmwpO1xuXG5cdFx0XHRcdFx0XHRpc1ZhbGlkID0gcmVzdWx0LnZhbGlkO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0dGhpcy5fbG9nZ2VyPy5lcnJvcihcIkZhaWxlZCB2YWxpZGF0aW5nIHRva2VuXCIsIGZvcm1hdEVycm9yKGVycikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc1ZhbGlkKSB7XG5cdFx0XHRcdFx0dGhpcy5fbG9nZ2VyPy5pbmZvKFwiU2Vzc2lvbiBTdGlsbCBBY3RpdmVcIik7XG5cdFx0XHRcdFx0dGhpcy5jaGVja0ZvclNlc3Npb25FeHBpcnkoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9sb2dnZXI/LmluZm8oXCJTZXNzaW9uIG5vdCB2YWxpZFwiKTtcblx0XHRcdFx0XHR0aGlzLl9hdXRoUmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoXCJzZXNzaW9uLWV4cGlyZWRcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHZhbGlkaXR5ICogMTAwMCk7XG5cdFx0fVxuXHR9XG59XG4iLCJ2YXIgZT17ZDoodCxyKT0+e2Zvcih2YXIgbyBpbiByKWUubyhyLG8pJiYhZS5vKHQsbykmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG8se2VudW1lcmFibGU6ITAsZ2V0OnJbb119KX0sbzooZSx0KT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQ9e307ZS5kKHQse01TOigpPT5SLF83OigpPT5BdXRoZW50aWNhdGlvbkVycm9yLGNYOigpPT5QLHpMOigpPT5Mb2dvdXRFcnJvcixfVzooKT0+eCxwODooKT0+aixZUjooKT0+emUsVSQ6KCk9PkplLFU3OigpPT5VZSxPRjooKT0+SGV9KTt2YXIgcj17ZDooZSx0KT0+e2Zvcih2YXIgbyBpbiB0KXIubyh0LG8pJiYhci5vKGUsbykmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8se2VudW1lcmFibGU6ITAsZ2V0OnRbb119KX0sbzooZSx0KT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LG89e307ci5kKG8se01TOigpPT5BcGlFcnJvcixjRjooKT0+QXBpUmVxdWVzdEVycm9yLEFLOigpPT5BdXRoVG9rZW5FeHBpcmVkRXJyb3IsTV86KCk9PkF1dGhvcml6YXRpb25FcnJvcixjWDooKT0+SW5pdGlhbGl6YXRpb25FcnJvcixZZDooKT0+dyxPNDooKT0+VCxfVzooKT0+UGFyYW1ldGVyRXJyb3IscDg6KCk9PlZhbGlkYXRpb25FcnJvcixtJDooKT0+cyxVJDooKT0+dSxVNzooKT0+aCxPVjooKT0+ZCxONzooKT0+QSxIUDooKT0+bixScDooKT0+T30pO2NsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoZSx0KXt2YXIgcixvO3N1cGVyKGU9bnVsbCE9PShyPW51bGwhPWU/ZTpudWxsPT10P3ZvaWQgMDp0Lm1lc3NhZ2UpJiZ2b2lkIDAhPT1yP3I6XCJBbiB1bmV4cGVjdGVkIGVycm9yIGhhcyBvY2N1cnJlZFwiKSx0aGlzLm5hbWU9dGhpcy5jb25zdHJ1Y3Rvci5uYW1lLHRoaXMuc3RhY2s9KGU/dGhpcy5zdGFjazpudWxsIT09KG89bnVsbD09dD92b2lkIDA6dC5zdGFjaykmJnZvaWQgMCE9PW8/bzp0aGlzLnN0YWNrKS5yZXBsYWNlKC9eKFxcdypFcnJvcikvLGAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKX19Y2xhc3MgQXBpUmVxdWVzdEVycm9yIGV4dGVuZHMgQXBpRXJyb3J7Y29uc3RydWN0b3IoZSx0LHIpe3ZhciBvO3N1cGVyKGU9bnVsbCE9PShvPW51bGwhPWU/ZTpudWxsPT1yP3ZvaWQgMDpyLm1lc3NhZ2UpJiZ2b2lkIDAhPT1vP286XCJBbiBlcnJvciBvY2N1cnJlZCB3aGVuIGV4ZWN1dGluZyB0aGUgQVBJIHJlcXVlc3RcIixyKSx0aGlzLnN0YXR1cz10fX1jbGFzcyBBdXRob3JpemF0aW9uRXJyb3IgZXh0ZW5kcyBBcGlFcnJvcntjb25zdHJ1Y3RvcihlLHQpe3ZhciByO3N1cGVyKGU9bnVsbCE9PShyPW51bGwhPWU/ZTpudWxsPT10P3ZvaWQgMDp0Lm1lc3NhZ2UpJiZ2b2lkIDAhPT1yP3I6XCJBbiBhdXRob3JpemF0aW9uIGVycm9yIG9jY3VycmVkXCIsdCl9fWNsYXNzIEF1dGhUb2tlbkV4cGlyZWRFcnJvciBleHRlbmRzIEFwaUVycm9ye2NvbnN0cnVjdG9yKGUsdCl7dmFyIHI7c3VwZXIoZT1udWxsIT09KHI9bnVsbCE9ZT9lOm51bGw9PXQ/dm9pZCAwOnQubWVzc2FnZSkmJnZvaWQgMCE9PXI/cjpcIlRoZSBBUEkgcmVxdWVzdCBmYWlsZWQgYXMgdGhlIGF1dGhvcml6YXRpb24gdG9rZW5zIGhhdmUgZXhwaXJlZFwiLHQpfX1jbGFzcyBJbml0aWFsaXphdGlvbkVycm9yIGV4dGVuZHMgQXBpRXJyb3J7Y29uc3RydWN0b3IoZSx0KXt2YXIgcjtzdXBlcihlPW51bGwhPT0ocj1udWxsIT1lP2U6bnVsbD09dD92b2lkIDA6dC5tZXNzYWdlKSYmdm9pZCAwIT09cj9yOlwiQW4gaW5pdGlhbGl6YXRpb24gZXJyb3Igb2NjdXJyZWRcIix0KX19Y2xhc3MgUGFyYW1ldGVyRXJyb3IgZXh0ZW5kcyBBcGlFcnJvcntjb25zdHJ1Y3RvcihlKXtzdXBlcihlPW51bGwhPWU/ZTpcIkludmFsaWQgcGFyYW1ldGVyIGRldGVjdGVkXCIpfX1jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBBcGlFcnJvcntjb25zdHJ1Y3RvcihlLHQpe3ZhciByO3N1cGVyKGU9bnVsbCE9PShyPW51bGwhPWU/ZTpudWxsPT10P3ZvaWQgMDp0Lm1lc3NhZ2UpJiZ2b2lkIDAhPT1yP3I6XCJBIHRva2VuIHZhbGlkYXRpb24gZXJyb3Igb2NjdXJyZWRcIix0KX19Y29uc3Qgbj0oKT0+dm9pZCAwIT09Y3J5cHRvLnJhbmRvbVVVSUQ/Y3J5cHRvLnJhbmRvbVVVSUQoKTpcIjEwMDAwMDAwLTEwMDAtNDAwMC04MDAwLTEwMDAwMDAwMDAwMFwiLnJlcGxhY2UoL1swMThdL2csKGU9Pntjb25zdCB0PXdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEpKVswXSYxNT4+TnVtYmVyKGUpLzQ7cmV0dXJuKE51bWJlcihlKV50KS50b1N0cmluZygxNil9KSksYT1cIm9hdXRoLWFwaS1hdXRoLWZsb3dcIixpPShlLHQscixvLG4sYSxpLHMpPT5hc3luYyBjPT57Y29uc3QgZD1uZXcgVVJMKGMpO2lmKDAhPT1kLmhyZWYudG9Mb3dlckNhc2UoKS5pbmRleE9mKG4udG9Mb3dlckNhc2UoKSkpcmV0dXJuITE7aWYod2luZG93LmNsZWFySW50ZXJ2YWwocyksd2luZG93LmNsZWFyVGltZW91dCh0KSx3aW5kb3cuY2xlYXJUaW1lb3V0KHIpLGUucmVtb3ZlQWxsTGlzdGVuZXJzKCksZS5jbG9zZSghMCksZC5zZWFyY2hQYXJhbXMuZ2V0KFwiZXJyb3JcIikpe2NvbnN0IGU9bmV3IEF1dGhvcml6YXRpb25FcnJvcihcIkF1dGhvcml6YXRpb24gZXJyb3JcIik7cmV0dXJuIGUuZGF0YT1kLnRvU3RyaW5nKCksaShlKSwhMH1pZihkLnNlYXJjaFBhcmFtcy5nZXQoXCJzdGF0ZVwiKSE9PW8pe2NvbnN0IGU9bmV3IEF1dGhvcml6YXRpb25FcnJvcihcIlN0YXRlIG1pc21hdGNoXCIpO3JldHVybiBlLmRhdGE9ZC50b1N0cmluZygpLGkoZSksITB9Y29uc3QgbD1kLnNlYXJjaFBhcmFtcy5nZXQoXCJjb2RlXCIpO2lmKCFsKXtjb25zdCBlPW5ldyBBdXRob3JpemF0aW9uRXJyb3IoXCJBdXRob3JpemF0aW9uIGNvZGUgbWlzc2luZ1wiKTtyZXR1cm4gZS5kYXRhPWQudG9TdHJpbmcoKSxpKGUpLCEwfXJldHVybiBhKGwpLCEwfSxzPWFzeW5jKGUsdCxyPXt9KT0+e2NvbnN0e2RlZmF1bHRIZWlnaHQ6byxkZWZhdWx0V2lkdGg6bn09cjtyZXR1cm4gdChhd2FpdCBmaW4uV2luZG93LmNyZWF0ZShPYmplY3QuYXNzaWduKHthbHdheXNPblRvcDohMCxtYXhpbWl6YWJsZTohMSxtaW5pbWl6YWJsZTohMSxhdXRvU2hvdzohMSxkZWZhdWx0Q2VudGVyZWQ6ITAsZGVmYXVsdEhlaWdodDpudWxsIT1vP286NzUwLGRlZmF1bHRXaWR0aDpudWxsIT1uP246NjAwLGluY2x1ZGVJblNuYXBzaG90czohMSxuYW1lOmEscmVzaXphYmxlOiExLHNhdmVXaW5kb3dTdGF0ZTohMSxzaG93VGFza2Jhckljb246ITEsdXJsOmV9LHIpKSl9LGM9KGUsdCxyKT0+bz0+bmV3IFByb21pc2UoKChuLGEpPT57bGV0IHM7Y29uc3QgYz13aW5kb3cuc2V0VGltZW91dCgoKCk9Pnt3aW5kb3cuY2xlYXJJbnRlcnZhbChzKSx3aW5kb3cuY2xlYXJUaW1lb3V0KGMpLG8ucmVtb3ZlQWxsTGlzdGVuZXJzKCksby5jbG9zZSghMCksYShuZXcgQXV0aG9yaXphdGlvbkVycm9yKFwiQXV0aG9yaXphdGlvbiB0aW1lZCBvdXRcIikpfSksM2U1KTtvLmFkZExpc3RlbmVyKFwiY2xvc2luZ1wiLChhc3luYygpPT57ci5sb2dJbmZvKFwiVXNlciBjbG9zZWQgYXV0aCB3aW5kb3dcIiksd2luZG93LmNsZWFySW50ZXJ2YWwocyksd2luZG93LmNsZWFyVGltZW91dChjKSxvLnJlbW92ZUFsbExpc3RlbmVycygpLGEobmV3IEF1dGhvcml6YXRpb25FcnJvcihcIkZhaWxlZCB0byBjb21wbGV0ZSBhdXRob3JpemF0aW9uIGNvZGUgZmxvd1wiKSl9KSk7Y29uc3QgZD13aW5kb3cuc2V0VGltZW91dCgoYXN5bmMoKT0+e3RyeXthd2FpdCBvLmlzU2hvd2luZygpfHwoci5sb2dJbmZvKFwiU2hvd2luZyBhdXRoIHdpbmRvd1wiKSxhd2FpdCBvLnNob3coITApLGF3YWl0IG8uZm9jdXMoKSl9Y2F0Y2goZSl7ci5sb2dXYXJuaW5nKFwiVW5hYmxlIHRvIHNob3cgYXV0aCB3aW5kb3dcIil9fSksMmUzKTsoYXN5bmMoKT0+e2NvbnN0e3ZlcnNpb246bH09YXdhaXQgZmluLlN5c3RlbS5nZXRSdW50aW1lSW5mbygpO3BhcnNlSW50KGwuc3BsaXQoXCIuXCIpWzBdLDEwKT49MzA/YXdhaXQgaShvLGMsZCxlLHQsbixhKSgoYXdhaXQgby5nZXRJbmZvKCkpLnVybCl8fGF3YWl0IG8uYWRkTGlzdGVuZXIoXCJ1cmwtY2hhbmdlZFwiLChzPT57ci5sb2dJbmZvKFwiQXV0aCB3aW5kb3cgbmF2aWdhdGVkIHRvXCIscy51cmwpLGkobyxjLGQsZSx0LG4sYSkocy51cmwpfSkpOnM9d2luZG93LnNldEludGVydmFsKCgoKT0+KGFzeW5jKGUsdCxyLG8sbixhLHMsYyk9PntsZXQgZDt0cnl7ZD1hd2FpdCBlLmdldEluZm8oKX1jYXRjaChlKXtyZXR1cm4gd2luZG93LmNsZWFySW50ZXJ2YWwodCksd2luZG93LmNsZWFyVGltZW91dChyKSx3aW5kb3cuY2xlYXJUaW1lb3V0KG8pLGMobmV3IEF1dGhvcml6YXRpb25FcnJvcihcIkNvdWxkIG5vdCBsb2NhdGUgYXV0aCB3aW5kb3dcIikpLCExfXJldHVybiBpKGUscixvLG4sYSxzLGMsdCkoZC51cmwpfSkobyxzLGMsZCxlLHQsbixhKSksNTAwKX0pKCl9KSksZD1hc3luYyhlLHQpPT57bGV0IHI7bnVsbD09dHx8dC5sb2dJbmZvKFwiUmV0cmlldmluZyBhdXRob3JpemF0aW9uIHNlcnZlciBtZXRhZGF0YVwiLGUpO3RyeXtyPW5ldyBVUkwoZSl9Y2F0Y2goZSl7dGhyb3cgbmV3IFBhcmFtZXRlckVycm9yKFwiVW5leHBlY3RlZCBpbnZhbGlkIGRpc2NvdmVyeSBVUkxcIil9Y29uc3Qgbz1hd2FpdCBmZXRjaChyLHtoZWFkZXJzOntBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uXCJ9fSk7aWYoIW8ub2spdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHJldHJpZXZlIGF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhXCIpO2NvbnN0IG49YXdhaXQgby5qc29uKCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbXB0eSBhdXRob3JpemF0aW9uIHNlcnZlciBtZXRhZGF0YSByZXNwb25zZVwiKTtyZXR1cm4gbnVsbD09dHx8dC5sb2dJbmZvKFwiUmV0cmlldmVkIGF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhXCIsbiksbn0sbD1lPT57bGV0IHQ9ZmluLkludGVncmF0aW9uczt0fHwoZmluLkludGVncmF0aW9ucz17fSx0PWZpbi5JbnRlZ3JhdGlvbnMpO2xldCByPXRbZV07cmV0dXJuIHJ8fCh0W2VdPXt9LHI9dFtlXSkscn0sdT1lPT57bChlKS5sb2dnaW5nRW5hYmxlZD0hMX0saD0oZSx0PVwiMC4wLjBcIik9PntsKGUpLmxvZ2dpbmdFbmFibGVkPSEwLGNvbnNvbGUubG9nKHAoZSksYHYke3R9YCl9LHA9ZT0+YFtAb3BlbmZpbi8ke2UudG9Mb3dlckNhc2UoKX1dYDtjbGFzcyB3e2NvbnN0cnVjdG9yKGUpe3RoaXMubmFtZT1lLHRoaXMucHJlZml4PXAoZSksdGhpcy5pc0xvZ2dpbmdFbmFibGVkPXRoaXMuaXNMb2dnaW5nRW5hYmxlZC5iaW5kKHRoaXMpLHRoaXMubG9nRXJyb3I9dGhpcy5sb2dFcnJvci5iaW5kKHRoaXMpLHRoaXMubG9nSW5mbz10aGlzLmxvZ0luZm8uYmluZCh0aGlzKSx0aGlzLmxvZ1dhcm5pbmc9dGhpcy5sb2dXYXJuaW5nLmJpbmQodGhpcyl9aXNMb2dnaW5nRW5hYmxlZCgpe3JldHVybiBsKHRoaXMubmFtZSkubG9nZ2luZ0VuYWJsZWR9bG9nRXJyb3IoZSl7dGhpcy5pc0xvZ2dpbmdFbmFibGVkKCkmJihlLmlubmVyRXJyb3I/Y29uc29sZS5lcnJvcih0aGlzLnByZWZpeCxlLFwiXFxuXFxuKGlubmVyKVwiLGUuaW5uZXJFcnJvcik6Y29uc29sZS5lcnJvcih0aGlzLnByZWZpeCxlKSl9bG9nSW5mbyguLi5lKXt0aGlzLmlzTG9nZ2luZ0VuYWJsZWQoKSYmY29uc29sZS5sb2codGhpcy5wcmVmaXgsLi4uZSl9bG9nV2FybmluZyguLi5lKXt0aGlzLmlzTG9nZ2luZ0VuYWJsZWQoKSYmY29uc29sZS53YXJuKHRoaXMucHJlZml4LC4uLmUpfX1jb25zdCBnPSgpPT57bGV0IGUsdCxyLG8sbjtjb25zdCBhPWFzeW5jKHQscj0hMSk9Pntjb25zdHtjb21tYW5kOm8sZGF0YTpuLGlkOnN9PXQsYz17Y29tbWFuZDpvLGlkOnN9O3RyeXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJBY2Nlc3MgdG9rZW4gbm90IGZvdW5kXCIpO2NvbnN0e2FwaVJlcXVlc3RVcmw6byxkYXRhOnMsaGVhZGVyczpkLGh0dHBNZXRob2Q6bCxpbmNsdWRlQXV0aG9yaXphdGlvbjp1fT1uLGg9YXdhaXQoYXN5bmModCxyLG8sbixhKT0+e3ZhciBpLHM7Y29uc3QgYz1PYmplY3QuYXNzaWduKHtBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uXCJ9LG4pO1wiUEFUQ0hcIiE9PXImJlwiUE9TVFwiIT09ciYmXCJQVVRcIiE9PXJ8fC9jb250ZW50LXR5cGUvaS50ZXN0KE9iamVjdC5rZXlzKGMpLmpvaW4oXCIsXCIpKXx8KGNbXCJDb250ZW50LVR5cGVcIl09XCJhcHBsaWNhdGlvbi9qc29uXCIpLGEmJihjLkF1dGhvcml6YXRpb249YEJlYXJlciAke2V9YCk7Y29uc3QgZD1hd2FpdCBmZXRjaCh0LHtib2R5Olwib2JqZWN0XCI9PXR5cGVvZiBvP0pTT04uc3RyaW5naWZ5KG8pOm8saGVhZGVyczpjLG1ldGhvZDpyfSk7aWYoIWQub2spe2NvbnN0IGU9e21lc3NhZ2U6XCJGYWlsZWQgdG8gZXhlY3V0ZSBBUEkgcmVxdWVzdFwifTtyZXR1cm4obnVsbD09PShpPWQuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkmJihlLmRhdGE9YXdhaXQgZC5qc29uKCkpLFtkLnN0YXR1cyx2b2lkIDAsdm9pZCAwLGVdfWxldCBsO2NvbnN0IHU9bnVsbCE9PShzPWQuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikpJiZ2b2lkIDAhPT1zP3M6XCJcIjtzd2l0Y2goITApe2Nhc2UhdTpicmVhaztjYXNlL15hcHBsaWNhdGlvblxcLyhcXHcrXFwrKT9qc29uL2kudGVzdCh1KTpsPWF3YWl0IGQuanNvbigpO2JyZWFrO2Nhc2UvXm11bHRpcGFydFxcL2Zvcm0tP2RhdGF8XmFwcGxpY2F0aW9uXFwveC0/d3d3LT9mb3JtLT91cmxlbmNvZGVkL2kudGVzdCh1KTpsPWF3YWl0IGQuZm9ybURhdGEoKTticmVhaztjYXNlL15hcHBsaWNhdGlvblxcLygoW14vXSspP3htbHx2bmRcXC5vcGVueG1sZm9ybWF0cyl8XnRleHRcXC98XmltYWdlXFwvc3ZnL2kudGVzdCh1KTpsPWF3YWl0IGQudGV4dCgpO2JyZWFrO2RlZmF1bHQ6bD1hd2FpdCBkLmFycmF5QnVmZmVyKCl9cmV0dXJuW2Quc3RhdHVzLGwsdSx2b2lkIDBdfSkobyxsLHMsZCx1KSxbcCx3LGcsZl09aDtpZihjLnN0YXR1cz1wLGYpe2lmKCFyJiY0MDE9PT1wKXtjb25zdFtlLHJdPWF3YWl0IGkoKTtyZXR1cm4gcj8oYy5zdGF0dXM9ZSxjLmVycm9yPXIsYyk6YXdhaXQgYSh0LCEwKX1jLmVycm9yPWZ9ZWxzZSB3JiYoYy5kYXRhPXcsYy50eXBlPWcpfWNhdGNoKGUpe2UgaW5zdGFuY2VvZiBFcnJvcj9jLmVycm9yPXttZXNzYWdlOmUubWVzc2FnZX06Yy5lcnJvcj17bWVzc2FnZTpcIkZhaWxlZCB0byBleGVjdXRlIEFQSSByZXF1ZXN0XCJ9fXJldHVybiBQcm9taXNlLnJlc29sdmUoYyl9LGk9YXN5bmMoKT0+e3ZhciByO2lmKCFvKXRocm93IG5ldyBFcnJvcihcIkF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhIG5vdCBzZXRcIik7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiQ2xpZW50IElEIG5vdCBzZXRcIik7Y29uc3QgYT1gZ3JhbnRfdHlwZT1yZWZyZXNoX3Rva2VuJmNsaWVudF9pZD0ke3R9JnJlZnJlc2hfdG9rZW49JHtufWAsaT1hd2FpdCBmZXRjaChvLnRva2VuX2VuZHBvaW50LHtib2R5OmEsaGVhZGVyczp7QWNjZXB0OlwiYXBwbGljYXRpb24vanNvblwiLFwiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIn0sbWV0aG9kOlwiUE9TVFwifSk7aWYoIWkub2spe2NvbnN0IGU9e21lc3NhZ2U6XCJGYWlsZWQgdG8gcmVmcmVzaCBhY2Nlc3MgdG9rZW5cIn07cmV0dXJuKG51bGw9PT0ocj1pLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpKXx8dm9pZCAwPT09cj92b2lkIDA6ci5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpJiYoZS5kYXRhPWF3YWl0IGkuanNvbigpKSxbaS5zdGF0dXMsZV19Y29uc3Qgcz1hd2FpdCBpLmpzb24oKTtyZXR1cm4gZT1zLmFjY2Vzc190b2tlbixbaS5zdGF0dXNdfTtzZWxmLm9ubWVzc2FnZT1hc3luYyBpPT57Y29uc3R7Y29tbWFuZDpzLGlkOmN9PWkuZGF0YTtsZXQgZD17Y29tbWFuZDpzLGlkOmN9O3N3aXRjaChzKXtjYXNlXCJBUElfUkVRVUVTVFwiOmQ9YXdhaXQgYShpLmRhdGEpO2JyZWFrO2Nhc2VcIkNPREVfRVhDSEFOR0VcIjpkPWF3YWl0KGFzeW5jIGE9Pnt2YXIgaTtjb25zdHtjb21tYW5kOnMsZGF0YTpjLGlkOmR9PWEsbD17Y29tbWFuZDpzLGlkOmR9O3RyeXtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJBdXRob3JpemF0aW9uIHNlcnZlciBtZXRhZGF0YSBub3Qgc2V0XCIpO2lmKCF0KXRocm93IG5ldyBFcnJvcihcIkNsaWVudCBJRCBub3Qgc2V0XCIpO2NvbnN0e2NvZGU6YSxjb2RlVmVyaWZpZXI6cyxyZWRpcmVjdFVyaTpkfT1jLHU9YGdyYW50X3R5cGU9YXV0aG9yaXphdGlvbl9jb2RlJmNsaWVudF9pZD0ke3R9JmNvZGU9JHthfSZjb2RlX3ZlcmlmaWVyPSR7c30mcmVkaXJlY3RfdXJpPSR7ZH1gLGg9YXdhaXQgZmV0Y2goby50b2tlbl9lbmRwb2ludCx7Ym9keTp1LGhlYWRlcnM6e0FjY2VwdDpcImFwcGxpY2F0aW9uL2pzb25cIixcIkNvbnRlbnQtVHlwZVwiOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJ9LG1ldGhvZDpcIlBPU1RcIn0pO2lmKGgub2spe2NvbnN0IHQ9YXdhaXQgaC5qc29uKCk7ZT10LmFjY2Vzc190b2tlbixyPXQuaWRfdG9rZW4sbj10LnJlZnJlc2hfdG9rZW59ZWxzZXtjb25zdCBlPXttZXNzYWdlOlwiRmFpbGVkIHRvIHJldHJpZXZlIHRva2Vuc1wifTsobnVsbD09PShpPWguaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkmJihlLmRhdGE9YXdhaXQgaC5qc29uKCkpLGwuZXJyb3I9ZX19Y2F0Y2goZSl7ZSBpbnN0YW5jZW9mIEVycm9yP2wuZXJyb3I9e21lc3NhZ2U6ZS5tZXNzYWdlfTpsLmVycm9yPXttZXNzYWdlOlwiRmFpbGVkIHRvIHJldHJpZXZlIHRva2Vuc1wifX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGwpfSkoaS5kYXRhKTticmVhaztjYXNlXCJFWFBJUkVfVE9LRU5TXCI6ZD1hd2FpdChhc3luYyByPT57dmFyIGE7Y29uc3R7Y29tbWFuZDppLGV4cGlyZUFjY2Vzc1Rva2VuT25seTpzLGlkOmN9PXIsZD17Y29tbWFuZDppLGlkOmN9O3RyeXtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJBdXRob3JpemF0aW9uIHNlcnZlciBtZXRhZGF0YSBub3Qgc2V0XCIpO2lmKCFvLnJldm9jYXRpb25fZW5kcG9pbnQpdGhyb3cgbmV3IEVycm9yKFwiUmV2b2NhdGlvbiBlbmRwb2ludCBtaXNzaW5nIGluIGF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhXCIpO2lmKCFzJiYhbil0aHJvdyBuZXcgRXJyb3IoXCJSZWZyZXNoIHRva2VuIG5vdCBmb3VuZFwiKTtjb25zdCByPW8ucmV2b2NhdGlvbl9lbmRwb2ludDtsZXQgaSxjPSExO2NvbnN0IGw9e2JvZHk6YGNsaWVudF9pZD0ke3R9YCxoZWFkZXJzOntBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uXCIsXCJDb250ZW50LVR5cGVcIjpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwifSxtZXRob2Q6XCJQT1NUXCJ9O2lmKHMpe2NvbnN0IHQ9YXdhaXQgZmV0Y2gocixPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse2JvZHk6YCR7bC5ib2R5fSZ0b2tlbj0ke2V9JnRva2VuX3R5cGVfaGludD1hY2Nlc3NfdG9rZW5gfSkpO3Qub2t8fChjPSEwLChudWxsPT09KGE9dC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSl8fHZvaWQgMD09PWE/dm9pZCAwOmEuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSYmKGk9YXdhaXQgdC5qc29uKCkpKX1lbHNle2NvbnN0IHQ9KGF3YWl0IFByb21pc2UuYWxsKFthd2FpdCBmZXRjaChyLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSx7Ym9keTpgJHtsLmJvZHl9JnRva2VuPSR7ZX0mdG9rZW5fdHlwZV9oaW50PWFjY2Vzc190b2tlbmB9KSksYXdhaXQgZmV0Y2gocixPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse2JvZHk6YCR7bC5ib2R5fSZ0b2tlbj0ke259JnRva2VuX3R5cGVfaGludD1yZWZyZXNoX3Rva2VuYH0pKV0pKS5maWx0ZXIoKGU9PiFlLm9rKSk7dC5sZW5ndGgmJihjPSEwLGk9YXdhaXQgdFswXS5qc29uKCkpfWlmKGMpe2NvbnN0IGU9e2RhdGE6aSxtZXNzYWdlOlwiRmFpbGVkIHRvIGV4cGlyZSB0b2tlbnNcIn07ZC5lcnJvcj1lfX1jYXRjaChlKXtlIGluc3RhbmNlb2YgRXJyb3I/ZC5lcnJvcj17bWVzc2FnZTplLm1lc3NhZ2V9OmQuZXJyb3I9e21lc3NhZ2U6XCJGYWlsZWQgdG8gZXhwaXJlIHRva2Vuc1wifX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGQpfSkoaS5kYXRhKTticmVhaztjYXNlXCJHRVRfSURfVE9LRU5cIjpsPWkuZGF0YSxkPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSx7aWRUb2tlbjpyfSk7YnJlYWs7Y2FzZVwiSU5JVFwiOmQ9YXdhaXQoYXN5bmMgZT0+e2NvbnN0e2NvbW1hbmQ6cixkYXRhOm4saWQ6YX09ZSxpPXtjb21tYW5kOnIsaWQ6YX07cmV0dXJuIHQ9bi5jbGllbnRJZCxvPW4ubWV0YWRhdGEsUHJvbWlzZS5yZXNvbHZlKGkpfSkoaS5kYXRhKTticmVhaztkZWZhdWx0OmQuZXJyb3I9bmV3IEVycm9yKGBVbmV4cGVjdGVkIG9hdXRoIHdvcmtlciBjb21tYW5kOiAke3N9YCl9dmFyIGw7c2VsZi5wb3N0TWVzc2FnZShkKX19O3ZhciBmOyFmdW5jdGlvbihlKXtlLkFwaVJlcXVlc3Q9XCJBUElfUkVRVUVTVFwiLGUuQ29kZUV4Y2hhbmdlPVwiQ09ERV9FWENIQU5HRVwiLGUuRXhwaXJlVG9rZW5zPVwiRVhQSVJFX1RPS0VOU1wiLGUuR2V0SWRUb2tlbj1cIkdFVF9JRF9UT0tFTlwiLGUuSW5pdD1cIklOSVRcIn0oZnx8KGY9e30pKTtjb25zdCBtPVtdLHk9ZT0+e20ucHVzaChlKX0sRT0oZSx0KT0+KHIsbyxhKT0+bmV3IFByb21pc2UoKChpLHMpPT57Y29uc3QgYz17Y29tbWFuZDpmLkNvZGVFeGNoYW5nZSxkYXRhOntjb2RlOnIsY29kZVZlcmlmaWVyOm8scmVkaXJlY3RVcmk6YX0saWQ6bigpfSx7Y29tbWFuZDpkLGlkOmx9PWM7eSh7Y29tbWFuZDpkLGlkOmwscmVqZWN0OnMscmVzb2x2ZTppfSksZS5wb3N0TWVzc2FnZShjKSx0LmxvZ0luZm8oXCJXb3JrZXIgcmVxdWVzdCBzZW50XCIsYyl9KSksdj0oZSx0LHIpPT4obyxhLGkscyxjKT0+bmV3IFByb21pc2UoKChkLGwpPT57Y29uc3QgdT17Y29tbWFuZDpmLkFwaVJlcXVlc3QsZGF0YTp7YXBpUmVxdWVzdFVybDpvLGNsaWVudElkOmUsZGF0YTppLGhlYWRlcnM6cyxodHRwTWV0aG9kOmEsaW5jbHVkZUF1dGhvcml6YXRpb246Y30saWQ6bigpfSx7Y29tbWFuZDpoLGlkOnB9PXU7eSh7Y29tbWFuZDpoLGlkOnAscmVqZWN0OmwscmVzb2x2ZTpkfSksdC5wb3N0TWVzc2FnZSh1KSxyLmxvZ0luZm8oXCJXb3JrZXIgcmVxdWVzdCBzZW50XCIsdSl9KSksUz0oZSx0KT0+cj0+bmV3IFByb21pc2UoKChvLGEpPT57Y29uc3QgaT17Y29tbWFuZDpmLkV4cGlyZVRva2VucyxleHBpcmVBY2Nlc3NUb2tlbk9ubHk6cixpZDpuKCl9LHtjb21tYW5kOnMsaWQ6Y309aTt5KHtjb21tYW5kOnMsaWQ6YyxyZWplY3Q6YSxyZXNvbHZlOm99KSxlLnBvc3RNZXNzYWdlKGkpLHQubG9nSW5mbyhcIldvcmtlciByZXF1ZXN0IHNlbnRcIixpKX0pKSxiPShlLHQpPT5hc3luYygpPT4oYXdhaXQgbmV3IFByb21pc2UoKChyLG8pPT57Y29uc3QgYT17Y29tbWFuZDpmLkdldElkVG9rZW4saWQ6bigpfSx7Y29tbWFuZDppLGlkOnN9PWE7eSh7Y29tbWFuZDppLGlkOnMscmVqZWN0Om8scmVzb2x2ZTpyfSksZS5wb3N0TWVzc2FnZShhKSx0LmxvZ0luZm8oXCJXb3JrZXIgcmVxdWVzdCBzZW50XCIsYSl9KSkpLmlkVG9rZW4sQT1hc3luYyhlLHQscik9Pntjb25zdCBvPW5ldyBCbG9iKFtgKCR7Z30pKClgXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSksYT1VUkwuY3JlYXRlT2JqZWN0VVJMKG8pLGk9bmV3IFdvcmtlcihhKTtyZXR1cm4gaS5vbm1lc3NhZ2U9XyhyKSxhd2FpdCgoZSx0LHIsbyk9Pm5ldyBQcm9taXNlKCgoYSxpKT0+e2NvbnN0IHM9e2NvbW1hbmQ6Zi5Jbml0LGRhdGE6e2NsaWVudElkOnQsbWV0YWRhdGE6ZX0saWQ6bigpfSx7Y29tbWFuZDpjLGlkOmR9PXM7eSh7Y29tbWFuZDpjLGlkOmQscmVqZWN0OmkscmVzb2x2ZTphfSksci5wb3N0TWVzc2FnZShzKSxvLmxvZ0luZm8oXCJXb3JrZXIgcmVxdWVzdCBzZW50XCIscyl9KSkpKGUsdCxpLHIpLHtleGNoYW5nZUNvZGVGb3JUb2tlbnM6RShpLHIpLGV4ZWN1dGVBcGlSZXF1ZXN0OnYodCxpLHIpLGV4cGlyZVRva2VuczpTKGksciksZ2V0SWRUb2tlbjpiKGksciksdGVybWluYXRlOkkoaSxyKX19LF89ZT0+dD0+e2UubG9nSW5mbyhcIldvcmtlciByZXNwb25zZSByZWNlaXZlZFwiLHQuZGF0YSk7Y29uc3Qgcj10LmRhdGEse2NvbW1hbmQ6byxlcnJvcjpuLGlkOmF9PXIsaT1mdW5jdGlvbihlLHQpe3ZhciByPXt9O2Zvcih2YXIgbyBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG8pJiZ0LmluZGV4T2Yobyk8MCYmKHJbb109ZVtvXSk7aWYobnVsbCE9ZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49MDtmb3Iobz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO248by5sZW5ndGg7bisrKXQuaW5kZXhPZihvW25dKTwwJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSxvW25dKSYmKHJbb1tuXV09ZVtvW25dXSl9cmV0dXJuIHJ9KHIsW1wiY29tbWFuZFwiLFwiZXJyb3JcIixcImlkXCJdKSxzPSgoZSx0KT0+bS5maW5kKChyPT5yLmNvbW1hbmQ9PT10JiZyLmlkPT09ZSkpKShhLG8pO3M/KG4/KFwic3RhdHVzXCJpbiBpJiZ2b2lkIDAhPT1pLnN0YXR1cyYmKG4uc3RhdHVzPWkuc3RhdHVzKSxzLnJlamVjdChuKSk6cy5yZXNvbHZlKGkpLGsoYSxvKSk6ZS5sb2dFcnJvcihuZXcgRXJyb3IoXCJVbmFibGUgdG8gbG9jYXRlIGF3YWl0ZWQgcmVxdWVzdFwiKSl9LGs9KGUsdCk9Pntjb25zdCByPW0uZmluZEluZGV4KChyPT5yLmNvbW1hbmQ9PT10JiZyLmlkPT09ZSkpO3I+PTAmJm0uc3BsaWNlKHIsMSl9LEk9KGUsdCk9PmFzeW5jKCk9Pnt0cnl7YXdhaXQgUyhlLHQpKCExKX1jYXRjaChlKXt0LmxvZ1dhcm5pbmcoZS5tZXNzYWdlKX1lLnRlcm1pbmF0ZSgpLHQubG9nSW5mbyhcIldvcmtlciB0ZXJtaW5hdGVkXCIpfTtjbGFzcyBUe2dldCBhcGlPcmlnaW4oKXtyZXR1cm4gdGhpcy5fYXBpT3JpZ2lufWdldCBjbGllbnRJZCgpe3JldHVybiB0aGlzLl9jbGllbnRJZH1nZXQgbG9nZ2VyKCl7cmV0dXJuIHRoaXMuX2xvZ2dlcn1nZXQgbWV0YWRhdGEoKXtyZXR1cm4gdGhpcy5fbWV0YWRhdGF9Z2V0IHdvcmtlcigpe3JldHVybiB0aGlzLl93b3JrZXJ9Y29uc3RydWN0b3IoZSx0LHIsbyxuKXtpZih0aGlzLmV4ZWN1dGVBcGlSZXF1ZXN0PWFzeW5jKGUsdD1cIkdFVFwiLHIsbyxuPSEwLGE9ITEpPT57dGhpcy5fbG9nZ2VyLmxvZ0luZm8oXCJFeGVjdXRlQXBpUmVxdWVzdCBzdGFydGVkXCIsZSx0LHIsbyk7dHJ5e2NvbnN0IGE9YXdhaXQoKGUsdCk9PmFzeW5jKHIsbyxuLGEsaSk9Pnt0cnl7cmV0dXJuIGF3YWl0IHQuZXhlY3V0ZUFwaVJlcXVlc3QoYCR7ZX0ke3J9YCxvLG4sYSxpKX1jYXRjaChlKXtsZXQgdDtjb25zdHtkYXRhOnIsbWVzc2FnZTpvLHN0YXR1czpufT1lO3Rocm93IHQ9ZSBpbnN0YW5jZW9mIEVycm9yP25ldyBBcGlSZXF1ZXN0RXJyb3IobyxuKTpcIkZhaWxlZCB0byByZWZyZXNoIGFjY2VzcyB0b2tlblwiPT09bz9uZXcgQXV0aFRva2VuRXhwaXJlZEVycm9yKG8pOm5ldyBBcGlSZXF1ZXN0RXJyb3IobyxuKSx0LmRhdGE9cix0fX0pKHRoaXMuX2FwaU9yaWdpbix0aGlzLl93b3JrZXIpKGUsdCxyLG8sbik7cmV0dXJuIHRoaXMuX2xvZ2dlci5sb2dJbmZvKFwiRXhlY3V0ZUFwaVJlcXVlc3QgY29tcGxldGVkXCIsYSksYX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgQXBpUmVxdWVzdEVycm9yKXtjb25zdHtkYXRhOnQsbWVzc2FnZTpyLG5hbWU6byxzdGFjazpufT1lLGE9dGhpcy5nZXRFcnJvck1lc3NhZ2VGcm9tU2VydmVyUmVzcG9uc2UodCk7YSYmKGUubWVzc2FnZT1hLGUuc3RhY2s9bnVsbD09bj92b2lkIDA6bi5yZXBsYWNlKGAke299OiAke3J9YCxgJHtvfTogJHthfWApKX10aHJvdyBhJiZ0aGlzLmxvZ2dlci5sb2dFcnJvcihlKSxlfX0sISh0JiZyJiZvJiZuKSl0aHJvdyBuZXcgSW5pdGlhbGl6YXRpb25FcnJvcihcIlByb3ZpZGVyIGhhcyBub3QgYmVlbiBwcm9wZXJseSBpbml0aWFsaXplZCAoY2FsbCBpbml0IHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzKVwiKTt0aGlzLl9hcGlPcmlnaW49bnVsbCE9ZT9lOlwiXCIsdGhpcy5fY2xpZW50SWQ9dCx0aGlzLl9tZXRhZGF0YT1yLHRoaXMuX3dvcmtlcj1vLHRoaXMuX2xvZ2dlcj1uLHRoaXMuYXV0aG9yaXplPXRoaXMuYXV0aG9yaXplLmJpbmQodGhpcyksdGhpcy5jbG9zZT10aGlzLmNsb3NlLmJpbmQodGhpcyksdGhpcy5leGVjdXRlQXBpUmVxdWVzdD10aGlzLmV4ZWN1dGVBcGlSZXF1ZXN0LmJpbmQodGhpcyksdGhpcy5leHBpcmVUb2tlbnM9dGhpcy5leHBpcmVUb2tlbnMuYmluZCh0aGlzKSx0aGlzLmdldEVycm9yTWVzc2FnZUZyb21TZXJ2ZXJSZXNwb25zZT10aGlzLmdldEVycm9yTWVzc2FnZUZyb21TZXJ2ZXJSZXNwb25zZS5iaW5kKHRoaXMpLHRoaXMuZ2V0SWRUb2tlbj10aGlzLmdldElkVG9rZW4uYmluZCh0aGlzKX1hc3luYyBhdXRob3JpemUoZSx0LHIpe3RoaXMuX2xvZ2dlci5sb2dJbmZvKFwiQXV0aG9yaXplIHN0YXJ0ZWRcIixlLHQscik7dHJ5e2F3YWl0KG89dGhpcy5fbWV0YWRhdGEsaT10aGlzLl9jbGllbnRJZCxkPXRoaXMuX3dvcmtlcixsPXRoaXMuX2xvZ2dlcixhc3luYyhlLHQ9e30scj17fSk9Pntjb25zdHthdXRob3JpemF0aW9uX2VuZHBvaW50OnV9PW8saD1maW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudFN5bmMoKSxwPShhd2FpdCBoLmdldENoaWxkV2luZG93cygpKS5maW5kKChlPT5lLmlkZW50aXR5Lm5hbWU9PT1hKSk7cCYmYXdhaXQgcC5jbG9zZSghMCk7Y29uc3Qgdz1uKCksZz0oKCk9Pntjb25zdCBlPW5ldyBVaW50MzJBcnJheSg2NCk7cmV0dXJuIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGUpLEFycmF5LmZyb20oZSwoZT0+YDAke2UudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpKSkuam9pbihcIlwiKX0pKCksZj0oYXdhaXQoYXN5bmMgZT0+e2NvbnN0IHQ9KG5ldyBUZXh0RW5jb2RlcikuZW5jb2RlKGUpLHI9YXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTI1NlwiLHQpLG89YXdhaXQoZT0+bmV3IFByb21pc2UoKCh0LHIpPT57dHJ5e2NvbnN0IG89bmV3IEJsb2IoW2VdKSxuPW5ldyBGaWxlUmVhZGVyO24ub25sb2FkPWU9Pnt2YXIgbyxuO2NvbnN0IGE9bnVsbD09PShvPWUudGFyZ2V0KXx8dm9pZCAwPT09bz92b2lkIDA6by5yZXN1bHQ7aWYoYSl7Y29uc3RbLGVdPUFycmF5LmZyb20obnVsbCE9PShuPWEubWF0Y2goL2Jhc2U2NCwoLiopJC9pKSkmJnZvaWQgMCE9PW4/bjpbXSk7dChudWxsIT1lP2U6XCJcIil9cihuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVtcHR5IHJlc3VsdFwiKSl9LG4ucmVhZEFzRGF0YVVSTChvKX1jYXRjaChlKXtyKGUpfX0pKSkocik7cmV0dXJuIG8ucmVwbGFjZSgvXFwrL2csXCItXCIpLnJlcGxhY2UoL1xcLy9nLFwiX1wiKX0pKGcpKS5yZXBsYWNlKC89KyQvLFwiXCIpLG09bmV3IFVSTCh1KTttLnNlYXJjaFBhcmFtcy5zZXQoXCJjbGllbnRfaWRcIixpKSxtLnNlYXJjaFBhcmFtcy5zZXQoXCJyZWRpcmVjdF91cmlcIixlKSxtLnNlYXJjaFBhcmFtcy5zZXQoXCJyZXNwb25zZV90eXBlXCIsXCJjb2RlXCIpLG0uc2VhcmNoUGFyYW1zLnNldChcInN0YXRlXCIsdyksbS5zZWFyY2hQYXJhbXMuc2V0KFwiY29kZV9jaGFsbGVuZ2VcIixmKSxtLnNlYXJjaFBhcmFtcy5zZXQoXCJjb2RlX2NoYWxsZW5nZV9tZXRob2RcIixcIlMyNTZcIiksT2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCgoZT0+bS5zZWFyY2hQYXJhbXMuc2V0KGVbMF0sZVsxXSkpKSxsLmxvZ0luZm8oXCJTdGFydGluZyBPQXV0aCBmbG93XCIsbSxyKTtjb25zdCB5PWF3YWl0IHMobS50b1N0cmluZygpLGModyxlLGwpLHIpO2wubG9nSW5mbyhcIlJlY2VpdmVkIGF1dGhvcml6YXRpb24gY29kZVwiKSxhd2FpdCBkLmV4Y2hhbmdlQ29kZUZvclRva2Vucyh5LGcsZSksbC5sb2dJbmZvKFwiUmVjZWl2ZWQgdG9rZW5zXCIpfSkoZSx0LHIpLHRoaXMuX2xvZ2dlci5sb2dJbmZvKFwiQXV0aG9yaXplIGNvbXBsZXRlZFwiKX1jYXRjaChlKXtsZXQgdDtpZihlIGluc3RhbmNlb2YgQXBpRXJyb3Ipe2NvbnN0e2RhdGE6cn09ZSxvPXRoaXMuZ2V0RXJyb3JNZXNzYWdlRnJvbVNlcnZlclJlc3BvbnNlKHIpO3Q9bmV3IEF1dGhvcml6YXRpb25FcnJvcihvLGUpLHQuZGF0YT1yfWVsc2UgdD1uZXcgQXV0aG9yaXphdGlvbkVycm9yKHZvaWQgMCxlKTt0aHJvdyB0aGlzLmxvZ2dlci5sb2dFcnJvcih0KSx0fXZhciBvLGksZCxsfWFzeW5jIGNsb3NlKCl7dmFyIGU7dGhpcy5fbG9nZ2VyLmxvZ0luZm8oXCJDbG9zZSBzdGFydGVkXCIpO3RyeXthd2FpdChudWxsPT09KGU9dGhpcy5fd29ya2VyKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS50ZXJtaW5hdGUoKSksdGhpcy5fd29ya2VyPXZvaWQgMCx0aGlzLl9hcGlPcmlnaW49dm9pZCAwLHRoaXMuX2NsaWVudElkPXZvaWQgMCx0aGlzLl9tZXRhZGF0YT12b2lkIDAsdGhpcy5fbG9nZ2VyLmxvZ0luZm8oXCJDbG9zZSBjb21wbGV0ZWRcIil9Y2F0Y2goZSl7Y29uc3QgdD1uZXcgQXBpRXJyb3Iodm9pZCAwLGUpO3Rocm93IHRoaXMuX2xvZ2dlci5sb2dFcnJvcih0KSx0fX1hc3luYyBleHBpcmVUb2tlbnMoZT0hMSl7dmFyIHQ7dGhpcy5fbG9nZ2VyLmxvZ0luZm8oXCJFeHBpcmVUb2tlbnMgc3RhcnRlZFwiKTt0cnl7YXdhaXQobnVsbD09PSh0PXRoaXMuX3dvcmtlcil8fHZvaWQgMD09PXQ/dm9pZCAwOnQuZXhwaXJlVG9rZW5zKGUpKSx0aGlzLl9sb2dnZXIubG9nSW5mbyhcIkV4cGlyZVRva2VucyBjb21wbGV0ZWRcIil9Y2F0Y2goZSl7Y29uc3QgdD1uZXcgQXBpRXJyb3Iodm9pZCAwLGUpO3Rocm93IHRoaXMuX2xvZ2dlci5sb2dFcnJvcih0KSx0fX1nZXRFcnJvck1lc3NhZ2VGcm9tU2VydmVyUmVzcG9uc2UoZSl7ZSYmdGhpcy5fbG9nZ2VyLmxvZ1dhcm5pbmcoZSl9YXN5bmMgZ2V0SWRUb2tlbigpe3ZhciBlO3RoaXMuX2xvZ2dlci5sb2dJbmZvKFwiR2V0SWRUb2tlbiBzdGFydGVkXCIpO3RyeXtjb25zdCB0PWF3YWl0KG51bGw9PT0oZT10aGlzLl93b3JrZXIpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmdldElkVG9rZW4oKSk7cmV0dXJuIHRoaXMuX2xvZ2dlci5sb2dJbmZvKFwiR2V0SWRUb2tlbiBjb21wbGV0ZWRcIix0KSx0fWNhdGNoKGUpe2NvbnN0IHQ9bmV3IEFwaUVycm9yKHZvaWQgMCxlKTt0aHJvdyB0aGlzLl9sb2dnZXIubG9nRXJyb3IodCksdH19c3RhdGljIGFzeW5jIGluaXQoZSx0LHIsbywuLi5uKXtjb25zdCBhPW5ldyB3KG8pO2EubG9nSW5mbyhcIkluaXQgc3RhcnRlZFwiLGUsdCxyKTt0cnl7bGV0IG87aWYoXCJkaXNjb3ZlcnlFbmRwb2ludFwiaW4gZSl7Y29uc3R7YWRkaXRpb25hbE1ldGFkYXRhOnQsZGlzY292ZXJ5RW5kcG9pbnQ6cn09ZTtvPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhd2FpdCBkKHIpKSxudWxsIT10P3Q6e30pfWVsc2Ugbz1lO2lmKCFvLnJlc3BvbnNlX3R5cGVzX3N1cHBvcnRlZC5maW5kKChlPT5cImNvZGVcIj09PWUudG9Mb3dlckNhc2UoKSkpKXRocm93IG5ldyBJbml0aWFsaXphdGlvbkVycm9yKFwiQXV0aG9yaXphdGlvbiBzZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgYXV0aG9yaXphdGlvbiBjb2RlIHJlc3BvbnNlIHR5cGVcIik7Y29uc3Qgbj1hd2FpdCBBKG8scixhKSxpPW5ldyBUKHQscixvLG4sYSk7cmV0dXJuIGEubG9nSW5mbyhcIkluaXQgY29tcGxldGVkXCIsaSksaX1jYXRjaChlKXtsZXQgdDt0aHJvdyB0PWUgaW5zdGFuY2VvZiBBcGlFcnJvcj9lOm5ldyBJbml0aWFsaXphdGlvbkVycm9yKHZvaWQgMCxlKSxhLmxvZ0Vycm9yKHQpLHR9fX1jb25zdCBPPWU9PmFzeW5jKHQscixvKT0+e2xldCBuO251bGw9PWV8fGUubG9nSW5mbyhcIlZhbGlkYXRpbmcgdG9rZW4gYWdhaW5zdCBpbnRyb3NwZWN0aW9uIGVuZHBvaW50XCIsdCxyLG8pO3RyeXtuPWF3YWl0IGZldGNoKG8se21ldGhvZDpcIlBPU1RcIixoZWFkZXJzOntcIkNvbnRlbnQtVHlwZVwiOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJ9LGJvZHk6YHRva2VuPSR7dH0mY2xpZW50X2lkPSR7cn1gfSl9Y2F0Y2goZSl7dGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2b2lkIDAsZSl9aWYobi5vayl7Y29uc3QgdD1hd2FpdCBuLmpzb24oKSx7YWN0aXZlOnJ9PXQsbz1mdW5jdGlvbihlLHQpe3ZhciByPXt9O2Zvcih2YXIgbyBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG8pJiZ0LmluZGV4T2Yobyk8MCYmKHJbb109ZVtvXSk7aWYobnVsbCE9ZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG49MDtmb3Iobz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO248by5sZW5ndGg7bisrKXQuaW5kZXhPZihvW25dKTwwJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSxvW25dKSYmKHJbb1tuXV09ZVtvW25dXSl9cmV0dXJuIHJ9KHQsW1wiYWN0aXZlXCJdKSxhPU9iamVjdC5hc3NpZ24oe3ZhbGlkOnJ9LG8pO3JldHVybiBudWxsPT1lfHxlLmxvZ0luZm8oXCJUb2tlbiB2YWxpZGF0aW9uIHJlc3VsdFwiLGEpLGF9Y29uc3QgYT1hd2FpdCBuLmpzb24oKTt0aHJvdyBudWxsPT1lfHxlLmxvZ1dhcm5pbmcoXCJUb2tlbiBWYWxpZGF0aW9uIGZhaWxlZFwiLGEpLG5ldyBWYWxpZGF0aW9uRXJyb3J9O3ZhciBSPW8uTVMsUD1vLmNYLEM9by5ZZCxXPW8uTzQseD1vLl9XLGo9by5wOCwkPW8ubSQsSj1vLlUkLFU9by5VNyxLPW8uT1YsRD1vLk43LEw9by5ScDtjb25zdCBIPW5ldyBUZXh0RW5jb2RlcixNPW5ldyBUZXh0RGVjb2RlcjtmdW5jdGlvbiB6KC4uLmUpe2NvbnN0IHQ9ZS5yZWR1Y2UoKChlLHtsZW5ndGg6dH0pPT5lK3QpLDApLHI9bmV3IFVpbnQ4QXJyYXkodCk7bGV0IG89MDtyZXR1cm4gZS5mb3JFYWNoKChlPT57ci5zZXQoZSxvKSxvKz1lLmxlbmd0aH0pKSxyfWNvbnN0IE49ZT0+e2xldCB0PWU7dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJih0PU0uZGVjb2RlKHQpKSx0PXQucmVwbGFjZSgvLS9nLFwiK1wiKS5yZXBsYWNlKC9fL2csXCIvXCIpLnJlcGxhY2UoL1xccy9nLFwiXCIpO3RyeXtyZXR1cm4oZT0+e2NvbnN0IHQ9YXRvYihlKSxyPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylyW2VdPXQuY2hhckNvZGVBdChlKTtyZXR1cm4gcn0pKHQpfWNhdGNoKGUpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgaW5wdXQgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuXCIpfX07Y2xhc3MgSk9TRUVycm9yIGV4dGVuZHMgRXJyb3J7c3RhdGljIGdldCBjb2RlKCl7cmV0dXJuXCJFUlJfSk9TRV9HRU5FUklDXCJ9Y29uc3RydWN0b3IoZSl7dmFyIHQ7c3VwZXIoZSksdGhpcy5jb2RlPVwiRVJSX0pPU0VfR0VORVJJQ1wiLHRoaXMubmFtZT10aGlzLmNvbnN0cnVjdG9yLm5hbWUsbnVsbD09PSh0PUVycm9yLmNhcHR1cmVTdGFja1RyYWNlKXx8dm9pZCAwPT09dHx8dC5jYWxsKEVycm9yLHRoaXMsdGhpcy5jb25zdHJ1Y3Rvcil9fWNsYXNzIEYgZXh0ZW5kcyBKT1NFRXJyb3J7c3RhdGljIGdldCBjb2RlKCl7cmV0dXJuXCJFUlJfSldUX0NMQUlNX1ZBTElEQVRJT05fRkFJTEVEXCJ9Y29uc3RydWN0b3IoZSx0PVwidW5zcGVjaWZpZWRcIixyPVwidW5zcGVjaWZpZWRcIil7c3VwZXIoZSksdGhpcy5jb2RlPVwiRVJSX0pXVF9DTEFJTV9WQUxJREFUSU9OX0ZBSUxFRFwiLHRoaXMuY2xhaW09dCx0aGlzLnJlYXNvbj1yfX1jbGFzcyBxIGV4dGVuZHMgSk9TRUVycm9ye3N0YXRpYyBnZXQgY29kZSgpe3JldHVyblwiRVJSX0pXVF9FWFBJUkVEXCJ9Y29uc3RydWN0b3IoZSx0PVwidW5zcGVjaWZpZWRcIixyPVwidW5zcGVjaWZpZWRcIil7c3VwZXIoZSksdGhpcy5jb2RlPVwiRVJSX0pXVF9FWFBJUkVEXCIsdGhpcy5jbGFpbT10LHRoaXMucmVhc29uPXJ9fWNsYXNzIEcgZXh0ZW5kcyBKT1NFRXJyb3J7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuY29kZT1cIkVSUl9KT1NFX0FMR19OT1RfQUxMT1dFRFwifXN0YXRpYyBnZXQgY29kZSgpe3JldHVyblwiRVJSX0pPU0VfQUxHX05PVF9BTExPV0VEXCJ9fWNsYXNzIFYgZXh0ZW5kcyBKT1NFRXJyb3J7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuY29kZT1cIkVSUl9KT1NFX05PVF9TVVBQT1JURURcIn1zdGF0aWMgZ2V0IGNvZGUoKXtyZXR1cm5cIkVSUl9KT1NFX05PVF9TVVBQT1JURURcIn19Y2xhc3MgQiBleHRlbmRzIEpPU0VFcnJvcntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5jb2RlPVwiRVJSX0pXU19JTlZBTElEXCJ9c3RhdGljIGdldCBjb2RlKCl7cmV0dXJuXCJFUlJfSldTX0lOVkFMSURcIn19Y2xhc3MgWCBleHRlbmRzIEpPU0VFcnJvcntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5jb2RlPVwiRVJSX0pXVF9JTlZBTElEXCJ9c3RhdGljIGdldCBjb2RlKCl7cmV0dXJuXCJFUlJfSldUX0lOVkFMSURcIn19Y2xhc3MgWSBleHRlbmRzIEpPU0VFcnJvcntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5jb2RlPVwiRVJSX0pXS1NfSU5WQUxJRFwifXN0YXRpYyBnZXQgY29kZSgpe3JldHVyblwiRVJSX0pXS1NfSU5WQUxJRFwifX1jbGFzcyBRIGV4dGVuZHMgSk9TRUVycm9ye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLmNvZGU9XCJFUlJfSldLU19OT19NQVRDSElOR19LRVlcIix0aGlzLm1lc3NhZ2U9XCJubyBhcHBsaWNhYmxlIGtleSBmb3VuZCBpbiB0aGUgSlNPTiBXZWIgS2V5IFNldFwifXN0YXRpYyBnZXQgY29kZSgpe3JldHVyblwiRVJSX0pXS1NfTk9fTUFUQ0hJTkdfS0VZXCJ9fWNsYXNzIFogZXh0ZW5kcyBKT1NFRXJyb3J7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuY29kZT1cIkVSUl9KV0tTX01VTFRJUExFX01BVENISU5HX0tFWVNcIix0aGlzLm1lc3NhZ2U9XCJtdWx0aXBsZSBtYXRjaGluZyBrZXlzIGZvdW5kIGluIHRoZSBKU09OIFdlYiBLZXkgU2V0XCJ9c3RhdGljIGdldCBjb2RlKCl7cmV0dXJuXCJFUlJfSldLU19NVUxUSVBMRV9NQVRDSElOR19LRVlTXCJ9fVN5bWJvbC5hc3luY0l0ZXJhdG9yO2NsYXNzIGVlIGV4dGVuZHMgSk9TRUVycm9ye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLmNvZGU9XCJFUlJfSldLU19USU1FT1VUXCIsdGhpcy5tZXNzYWdlPVwicmVxdWVzdCB0aW1lZCBvdXRcIn1zdGF0aWMgZ2V0IGNvZGUoKXtyZXR1cm5cIkVSUl9KV0tTX1RJTUVPVVRcIn19Y2xhc3MgdGUgZXh0ZW5kcyBKT1NFRXJyb3J7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuY29kZT1cIkVSUl9KV1NfU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMRURcIix0aGlzLm1lc3NhZ2U9XCJzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZFwifXN0YXRpYyBnZXQgY29kZSgpe3JldHVyblwiRVJSX0pXU19TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxFRFwifX1jb25zdCByZT1jcnlwdG8sb2U9ZT0+ZSBpbnN0YW5jZW9mIENyeXB0b0tleTtyZS5nZXRSYW5kb21WYWx1ZXMuYmluZChyZSk7Y29uc3QgbmU9YXN5bmMgZT0+e3ZhciB0LHI7aWYoIWUuYWxnKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYWxnXCIgYXJndW1lbnQgaXMgcmVxdWlyZWQgd2hlbiBcImp3ay5hbGdcIiBpcyBub3QgcHJlc2VudCcpO2NvbnN0e2FsZ29yaXRobTpvLGtleVVzYWdlczpufT1mdW5jdGlvbihlKXtsZXQgdCxyO3N3aXRjaChlLmt0eSl7Y2FzZVwib2N0XCI6c3dpdGNoKGUuYWxnKXtjYXNlXCJIUzI1NlwiOmNhc2VcIkhTMzg0XCI6Y2FzZVwiSFM1MTJcIjp0PXtuYW1lOlwiSE1BQ1wiLGhhc2g6YFNIQS0ke2UuYWxnLnNsaWNlKC0zKX1gfSxyPVtcInNpZ25cIixcInZlcmlmeVwiXTticmVhaztjYXNlXCJBMTI4Q0JDLUhTMjU2XCI6Y2FzZVwiQTE5MkNCQy1IUzM4NFwiOmNhc2VcIkEyNTZDQkMtSFM1MTJcIjp0aHJvdyBuZXcgVihgJHtlLmFsZ30ga2V5cyBjYW5ub3QgYmUgaW1wb3J0ZWQgYXMgQ3J5cHRvS2V5IGluc3RhbmNlc2ApO2Nhc2VcIkExMjhHQ01cIjpjYXNlXCJBMTkyR0NNXCI6Y2FzZVwiQTI1NkdDTVwiOmNhc2VcIkExMjhHQ01LV1wiOmNhc2VcIkExOTJHQ01LV1wiOmNhc2VcIkEyNTZHQ01LV1wiOnQ9e25hbWU6XCJBRVMtR0NNXCJ9LHI9W1wiZW5jcnlwdFwiLFwiZGVjcnlwdFwiXTticmVhaztjYXNlXCJBMTI4S1dcIjpjYXNlXCJBMTkyS1dcIjpjYXNlXCJBMjU2S1dcIjp0PXtuYW1lOlwiQUVTLUtXXCJ9LHI9W1wid3JhcEtleVwiLFwidW53cmFwS2V5XCJdO2JyZWFrO2Nhc2VcIlBCRVMyLUhTMjU2K0ExMjhLV1wiOmNhc2VcIlBCRVMyLUhTMzg0K0ExOTJLV1wiOmNhc2VcIlBCRVMyLUhTNTEyK0EyNTZLV1wiOnQ9e25hbWU6XCJQQktERjJcIn0scj1bXCJkZXJpdmVCaXRzXCJdO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IFYoJ0ludmFsaWQgb3IgdW5zdXBwb3J0ZWQgSldLIFwiYWxnXCIgKEFsZ29yaXRobSkgUGFyYW1ldGVyIHZhbHVlJyl9YnJlYWs7Y2FzZVwiUlNBXCI6c3dpdGNoKGUuYWxnKXtjYXNlXCJQUzI1NlwiOmNhc2VcIlBTMzg0XCI6Y2FzZVwiUFM1MTJcIjp0PXtuYW1lOlwiUlNBLVBTU1wiLGhhc2g6YFNIQS0ke2UuYWxnLnNsaWNlKC0zKX1gfSxyPWUuZD9bXCJzaWduXCJdOltcInZlcmlmeVwiXTticmVhaztjYXNlXCJSUzI1NlwiOmNhc2VcIlJTMzg0XCI6Y2FzZVwiUlM1MTJcIjp0PXtuYW1lOlwiUlNBU1NBLVBLQ1MxLXYxXzVcIixoYXNoOmBTSEEtJHtlLmFsZy5zbGljZSgtMyl9YH0scj1lLmQ/W1wic2lnblwiXTpbXCJ2ZXJpZnlcIl07YnJlYWs7Y2FzZVwiUlNBLU9BRVBcIjpjYXNlXCJSU0EtT0FFUC0yNTZcIjpjYXNlXCJSU0EtT0FFUC0zODRcIjpjYXNlXCJSU0EtT0FFUC01MTJcIjp0PXtuYW1lOlwiUlNBLU9BRVBcIixoYXNoOmBTSEEtJHtwYXJzZUludChlLmFsZy5zbGljZSgtMyksMTApfHwxfWB9LHI9ZS5kP1tcImRlY3J5cHRcIixcInVud3JhcEtleVwiXTpbXCJlbmNyeXB0XCIsXCJ3cmFwS2V5XCJdO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IFYoJ0ludmFsaWQgb3IgdW5zdXBwb3J0ZWQgSldLIFwiYWxnXCIgKEFsZ29yaXRobSkgUGFyYW1ldGVyIHZhbHVlJyl9YnJlYWs7Y2FzZVwiRUNcIjpzd2l0Y2goZS5hbGcpe2Nhc2VcIkVTMjU2XCI6dD17bmFtZTpcIkVDRFNBXCIsbmFtZWRDdXJ2ZTpcIlAtMjU2XCJ9LHI9ZS5kP1tcInNpZ25cIl06W1widmVyaWZ5XCJdO2JyZWFrO2Nhc2VcIkVTMzg0XCI6dD17bmFtZTpcIkVDRFNBXCIsbmFtZWRDdXJ2ZTpcIlAtMzg0XCJ9LHI9ZS5kP1tcInNpZ25cIl06W1widmVyaWZ5XCJdO2JyZWFrO2Nhc2VcIkVTNTEyXCI6dD17bmFtZTpcIkVDRFNBXCIsbmFtZWRDdXJ2ZTpcIlAtNTIxXCJ9LHI9ZS5kP1tcInNpZ25cIl06W1widmVyaWZ5XCJdO2JyZWFrO2Nhc2VcIkVDREgtRVNcIjpjYXNlXCJFQ0RILUVTK0ExMjhLV1wiOmNhc2VcIkVDREgtRVMrQTE5MktXXCI6Y2FzZVwiRUNESC1FUytBMjU2S1dcIjp0PXtuYW1lOlwiRUNESFwiLG5hbWVkQ3VydmU6ZS5jcnZ9LHI9ZS5kP1tcImRlcml2ZUJpdHNcIl06W107YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgVignSW52YWxpZCBvciB1bnN1cHBvcnRlZCBKV0sgXCJhbGdcIiAoQWxnb3JpdGhtKSBQYXJhbWV0ZXIgdmFsdWUnKX1icmVhaztjYXNlXCJPS1BcIjpzd2l0Y2goZS5hbGcpe2Nhc2VcIkVkRFNBXCI6dD17bmFtZTplLmNydn0scj1lLmQ/W1wic2lnblwiXTpbXCJ2ZXJpZnlcIl07YnJlYWs7Y2FzZVwiRUNESC1FU1wiOmNhc2VcIkVDREgtRVMrQTEyOEtXXCI6Y2FzZVwiRUNESC1FUytBMTkyS1dcIjpjYXNlXCJFQ0RILUVTK0EyNTZLV1wiOnQ9e25hbWU6ZS5jcnZ9LHI9ZS5kP1tcImRlcml2ZUJpdHNcIl06W107YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgVignSW52YWxpZCBvciB1bnN1cHBvcnRlZCBKV0sgXCJhbGdcIiAoQWxnb3JpdGhtKSBQYXJhbWV0ZXIgdmFsdWUnKX1icmVhaztkZWZhdWx0OnRocm93IG5ldyBWKCdJbnZhbGlkIG9yIHVuc3VwcG9ydGVkIEpXSyBcImt0eVwiIChLZXkgVHlwZSkgUGFyYW1ldGVyIHZhbHVlJyl9cmV0dXJue2FsZ29yaXRobTp0LGtleVVzYWdlczpyfX0oZSksYT1bbyxudWxsIT09KHQ9ZS5leHQpJiZ2b2lkIDAhPT10JiZ0LG51bGwhPT0ocj1lLmtleV9vcHMpJiZ2b2lkIDAhPT1yP3I6bl07aWYoXCJQQktERjJcIj09PW8ubmFtZSlyZXR1cm4gcmUuc3VidGxlLmltcG9ydEtleShcInJhd1wiLE4oZS5rKSwuLi5hKTtjb25zdCBpPXsuLi5lfTtyZXR1cm4gZGVsZXRlIGkuYWxnLGRlbGV0ZSBpLnVzZSxyZS5zdWJ0bGUuaW1wb3J0S2V5KFwiandrXCIsaSwuLi5hKX07ZnVuY3Rpb24gYWUoZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mKHQ9ZSl8fG51bGw9PT10fHxcIltvYmplY3QgT2JqZWN0XVwiIT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKXJldHVybiExO3ZhciB0O2lmKG51bGw9PT1PYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkpcmV0dXJuITA7bGV0IHI9ZTtmb3IoO251bGwhPT1PYmplY3QuZ2V0UHJvdG90eXBlT2Yocik7KXI9T2JqZWN0LmdldFByb3RvdHlwZU9mKHIpO3JldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk9PT1yfWNvbnN0IGllPWZ1bmN0aW9uKGUsdCxyLG8sbil7aWYodm9pZCAwIT09bi5jcml0JiZ2b2lkIDA9PT1vLmNyaXQpdGhyb3cgbmV3IGUoJ1wiY3JpdFwiIChDcml0aWNhbCkgSGVhZGVyIFBhcmFtZXRlciBNVVNUIGJlIGludGVncml0eSBwcm90ZWN0ZWQnKTtpZighb3x8dm9pZCAwPT09by5jcml0KXJldHVybiBuZXcgU2V0O2lmKCFBcnJheS5pc0FycmF5KG8uY3JpdCl8fDA9PT1vLmNyaXQubGVuZ3RofHxvLmNyaXQuc29tZSgoZT0+XCJzdHJpbmdcIiE9dHlwZW9mIGV8fDA9PT1lLmxlbmd0aCkpKXRocm93IG5ldyBlKCdcImNyaXRcIiAoQ3JpdGljYWwpIEhlYWRlciBQYXJhbWV0ZXIgTVVTVCBiZSBhbiBhcnJheSBvZiBub24tZW1wdHkgc3RyaW5ncyB3aGVuIHByZXNlbnQnKTtsZXQgYTthPXZvaWQgMCE9PXI/bmV3IE1hcChbLi4uT2JqZWN0LmVudHJpZXMociksLi4udC5lbnRyaWVzKCldKTp0O2Zvcihjb25zdCB0IG9mIG8uY3JpdCl7aWYoIWEuaGFzKHQpKXRocm93IG5ldyBWKGBFeHRlbnNpb24gSGVhZGVyIFBhcmFtZXRlciBcIiR7dH1cIiBpcyBub3QgcmVjb2duaXplZGApO2lmKHZvaWQgMD09PW5bdF0pdGhyb3cgbmV3IGUoYEV4dGVuc2lvbiBIZWFkZXIgUGFyYW1ldGVyIFwiJHt0fVwiIGlzIG1pc3NpbmdgKTtpZihhLmdldCh0KSYmdm9pZCAwPT09b1t0XSl0aHJvdyBuZXcgZShgRXh0ZW5zaW9uIEhlYWRlciBQYXJhbWV0ZXIgXCIke3R9XCIgTVVTVCBiZSBpbnRlZ3JpdHkgcHJvdGVjdGVkYCl9cmV0dXJuIG5ldyBTZXQoby5jcml0KX07U3ltYm9sKCk7ZnVuY3Rpb24gc2UoZSx0PVwiYWxnb3JpdGhtLm5hbWVcIil7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYENyeXB0b0tleSBkb2VzIG5vdCBzdXBwb3J0IHRoaXMgb3BlcmF0aW9uLCBpdHMgJHt0fSBtdXN0IGJlICR7ZX1gKX1mdW5jdGlvbiBjZShlLHQpe3JldHVybiBlLm5hbWU9PT10fWZ1bmN0aW9uIGRlKGUpe3JldHVybiBwYXJzZUludChlLm5hbWUuc2xpY2UoNCksMTApfWZ1bmN0aW9uIGxlKGUsdCl7aWYodC5sZW5ndGgmJiF0LnNvbWUoKHQ9PmUudXNhZ2VzLmluY2x1ZGVzKHQpKSkpe2xldCBlPVwiQ3J5cHRvS2V5IGRvZXMgbm90IHN1cHBvcnQgdGhpcyBvcGVyYXRpb24sIGl0cyB1c2FnZXMgbXVzdCBpbmNsdWRlIFwiO2lmKHQubGVuZ3RoPjIpe2NvbnN0IHI9dC5wb3AoKTtlKz1gb25lIG9mICR7dC5qb2luKFwiLCBcIil9LCBvciAke3J9LmB9ZWxzZSAyPT09dC5sZW5ndGg/ZSs9YG9uZSBvZiAke3RbMF19IG9yICR7dFsxXX0uYDplKz1gJHt0WzBdfS5gO3Rocm93IG5ldyBUeXBlRXJyb3IoZSl9fWZ1bmN0aW9uIHVlKGUsdCwuLi5yKXtzd2l0Y2godCl7Y2FzZVwiSFMyNTZcIjpjYXNlXCJIUzM4NFwiOmNhc2VcIkhTNTEyXCI6e2lmKCFjZShlLmFsZ29yaXRobSxcIkhNQUNcIikpdGhyb3cgc2UoXCJITUFDXCIpO2NvbnN0IHI9cGFyc2VJbnQodC5zbGljZSgyKSwxMCk7aWYoZGUoZS5hbGdvcml0aG0uaGFzaCkhPT1yKXRocm93IHNlKGBTSEEtJHtyfWAsXCJhbGdvcml0aG0uaGFzaFwiKTticmVha31jYXNlXCJSUzI1NlwiOmNhc2VcIlJTMzg0XCI6Y2FzZVwiUlM1MTJcIjp7aWYoIWNlKGUuYWxnb3JpdGhtLFwiUlNBU1NBLVBLQ1MxLXYxXzVcIikpdGhyb3cgc2UoXCJSU0FTU0EtUEtDUzEtdjFfNVwiKTtjb25zdCByPXBhcnNlSW50KHQuc2xpY2UoMiksMTApO2lmKGRlKGUuYWxnb3JpdGhtLmhhc2gpIT09cil0aHJvdyBzZShgU0hBLSR7cn1gLFwiYWxnb3JpdGhtLmhhc2hcIik7YnJlYWt9Y2FzZVwiUFMyNTZcIjpjYXNlXCJQUzM4NFwiOmNhc2VcIlBTNTEyXCI6e2lmKCFjZShlLmFsZ29yaXRobSxcIlJTQS1QU1NcIikpdGhyb3cgc2UoXCJSU0EtUFNTXCIpO2NvbnN0IHI9cGFyc2VJbnQodC5zbGljZSgyKSwxMCk7aWYoZGUoZS5hbGdvcml0aG0uaGFzaCkhPT1yKXRocm93IHNlKGBTSEEtJHtyfWAsXCJhbGdvcml0aG0uaGFzaFwiKTticmVha31jYXNlXCJFZERTQVwiOmlmKFwiRWQyNTUxOVwiIT09ZS5hbGdvcml0aG0ubmFtZSYmXCJFZDQ0OFwiIT09ZS5hbGdvcml0aG0ubmFtZSl0aHJvdyBzZShcIkVkMjU1MTkgb3IgRWQ0NDhcIik7YnJlYWs7Y2FzZVwiRVMyNTZcIjpjYXNlXCJFUzM4NFwiOmNhc2VcIkVTNTEyXCI6e2lmKCFjZShlLmFsZ29yaXRobSxcIkVDRFNBXCIpKXRocm93IHNlKFwiRUNEU0FcIik7Y29uc3Qgcj1mdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZVwiRVMyNTZcIjpyZXR1cm5cIlAtMjU2XCI7Y2FzZVwiRVMzODRcIjpyZXR1cm5cIlAtMzg0XCI7Y2FzZVwiRVM1MTJcIjpyZXR1cm5cIlAtNTIxXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlYWNoYWJsZVwiKX19KHQpO2lmKGUuYWxnb3JpdGhtLm5hbWVkQ3VydmUhPT1yKXRocm93IHNlKHIsXCJhbGdvcml0aG0ubmFtZWRDdXJ2ZVwiKTticmVha31kZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoXCJDcnlwdG9LZXkgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIG9wZXJhdGlvblwiKX1sZShlLHIpfWZ1bmN0aW9uIGhlKGUsdCwuLi5yKXtpZihyLmxlbmd0aD4yKXtjb25zdCB0PXIucG9wKCk7ZSs9YG9uZSBvZiB0eXBlICR7ci5qb2luKFwiLCBcIil9LCBvciAke3R9LmB9ZWxzZSAyPT09ci5sZW5ndGg/ZSs9YG9uZSBvZiB0eXBlICR7clswXX0gb3IgJHtyWzFdfS5gOmUrPWBvZiB0eXBlICR7clswXX0uYDtyZXR1cm4gbnVsbD09dD9lKz1gIFJlY2VpdmVkICR7dH1gOlwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJnQubmFtZT9lKz1gIFJlY2VpdmVkIGZ1bmN0aW9uICR7dC5uYW1lfWA6XCJvYmplY3RcIj09dHlwZW9mIHQmJm51bGwhPXQmJnQuY29uc3RydWN0b3ImJnQuY29uc3RydWN0b3IubmFtZSYmKGUrPWAgUmVjZWl2ZWQgYW4gaW5zdGFuY2Ugb2YgJHt0LmNvbnN0cnVjdG9yLm5hbWV9YCksZX1jb25zdCBwZT0oZSwuLi50KT0+aGUoXCJLZXkgbXVzdCBiZSBcIixlLC4uLnQpO2Z1bmN0aW9uIHdlKGUsdCwuLi5yKXtyZXR1cm4gaGUoYEtleSBmb3IgdGhlICR7ZX0gYWxnb3JpdGhtIG11c3QgYmUgYCx0LC4uLnIpfWNvbnN0IGdlPWU9Pm9lKGUpLGZlPVtcIkNyeXB0b0tleVwiXTtjb25zdCBtZT1hc3luYyhlLHQscixvKT0+e2NvbnN0IG49YXdhaXQgZnVuY3Rpb24oZSx0LHIpe2lmKG9lKHQpKXJldHVybiB1ZSh0LGUsciksdDtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSl7aWYoIWUuc3RhcnRzV2l0aChcIkhTXCIpKXRocm93IG5ldyBUeXBlRXJyb3IocGUodCwuLi5mZSkpO3JldHVybiByZS5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsdCx7aGFzaDpgU0hBLSR7ZS5zbGljZSgtMyl9YCxuYW1lOlwiSE1BQ1wifSwhMSxbcl0pfXRocm93IG5ldyBUeXBlRXJyb3IocGUodCwuLi5mZSxcIlVpbnQ4QXJyYXlcIikpfShlLHQsXCJ2ZXJpZnlcIik7KChlLHQpPT57aWYoZS5zdGFydHNXaXRoKFwiUlNcIil8fGUuc3RhcnRzV2l0aChcIlBTXCIpKXtjb25zdHttb2R1bHVzTGVuZ3RoOnJ9PXQuYWxnb3JpdGhtO2lmKFwibnVtYmVyXCIhPXR5cGVvZiByfHxyPDIwNDgpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtlfSByZXF1aXJlcyBrZXkgbW9kdWx1c0xlbmd0aCB0byBiZSAyMDQ4IGJpdHMgb3IgbGFyZ2VyYCl9fSkoZSxuKTtjb25zdCBhPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1gU0hBLSR7ZS5zbGljZSgtMyl9YDtzd2l0Y2goZSl7Y2FzZVwiSFMyNTZcIjpjYXNlXCJIUzM4NFwiOmNhc2VcIkhTNTEyXCI6cmV0dXJue2hhc2g6cixuYW1lOlwiSE1BQ1wifTtjYXNlXCJQUzI1NlwiOmNhc2VcIlBTMzg0XCI6Y2FzZVwiUFM1MTJcIjpyZXR1cm57aGFzaDpyLG5hbWU6XCJSU0EtUFNTXCIsc2FsdExlbmd0aDplLnNsaWNlKC0zKT4+M307Y2FzZVwiUlMyNTZcIjpjYXNlXCJSUzM4NFwiOmNhc2VcIlJTNTEyXCI6cmV0dXJue2hhc2g6cixuYW1lOlwiUlNBU1NBLVBLQ1MxLXYxXzVcIn07Y2FzZVwiRVMyNTZcIjpjYXNlXCJFUzM4NFwiOmNhc2VcIkVTNTEyXCI6cmV0dXJue2hhc2g6cixuYW1lOlwiRUNEU0FcIixuYW1lZEN1cnZlOnQubmFtZWRDdXJ2ZX07Y2FzZVwiRWREU0FcIjpyZXR1cm57bmFtZTp0Lm5hbWV9O2RlZmF1bHQ6dGhyb3cgbmV3IFYoYGFsZyAke2V9IGlzIG5vdCBzdXBwb3J0ZWQgZWl0aGVyIGJ5IEpPU0Ugb3IgeW91ciBqYXZhc2NyaXB0IHJ1bnRpbWVgKX19KGUsbi5hbGdvcml0aG0pO3RyeXtyZXR1cm4gYXdhaXQgcmUuc3VidGxlLnZlcmlmeShhLG4scixvKX1jYXRjaChlKXtyZXR1cm4hMX19LHllPSguLi5lKT0+e2NvbnN0IHQ9ZS5maWx0ZXIoQm9vbGVhbik7aWYoMD09PXQubGVuZ3RofHwxPT09dC5sZW5ndGgpcmV0dXJuITA7bGV0IHI7Zm9yKGNvbnN0IGUgb2YgdCl7Y29uc3QgdD1PYmplY3Qua2V5cyhlKTtpZihyJiYwIT09ci5zaXplKWZvcihjb25zdCBlIG9mIHQpe2lmKHIuaGFzKGUpKXJldHVybiExO3IuYWRkKGUpfWVsc2Ugcj1uZXcgU2V0KHQpfXJldHVybiEwfSxFZT0oZSx0LHIpPT57ZS5zdGFydHNXaXRoKFwiSFNcIil8fFwiZGlyXCI9PT1lfHxlLnN0YXJ0c1dpdGgoXCJQQkVTMlwiKXx8L15BXFxkezN9KD86R0NNKT9LVyQvLnRlc3QoZSk/KChlLHQpPT57aWYoISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpe2lmKCFnZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKHdlKGUsdCwuLi5mZSxcIlVpbnQ4QXJyYXlcIikpO2lmKFwic2VjcmV0XCIhPT10LnR5cGUpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmZS5qb2luKFwiIG9yIFwiKX0gaW5zdGFuY2VzIGZvciBzeW1tZXRyaWMgYWxnb3JpdGhtcyBtdXN0IGJlIG9mIHR5cGUgXCJzZWNyZXRcImApfX0pKGUsdCk6KChlLHQscik9PntpZighZ2UodCkpdGhyb3cgbmV3IFR5cGVFcnJvcih3ZShlLHQsLi4uZmUpKTtpZihcInNlY3JldFwiPT09dC50eXBlKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZmUuam9pbihcIiBvciBcIil9IGluc3RhbmNlcyBmb3IgYXN5bW1ldHJpYyBhbGdvcml0aG1zIG11c3Qgbm90IGJlIG9mIHR5cGUgXCJzZWNyZXRcImApO2lmKFwic2lnblwiPT09ciYmXCJwdWJsaWNcIj09PXQudHlwZSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke2ZlLmpvaW4oXCIgb3IgXCIpfSBpbnN0YW5jZXMgZm9yIGFzeW1tZXRyaWMgYWxnb3JpdGhtIHNpZ25pbmcgbXVzdCBiZSBvZiB0eXBlIFwicHJpdmF0ZVwiYCk7aWYoXCJkZWNyeXB0XCI9PT1yJiZcInB1YmxpY1wiPT09dC50eXBlKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZmUuam9pbihcIiBvciBcIil9IGluc3RhbmNlcyBmb3IgYXN5bW1ldHJpYyBhbGdvcml0aG0gZGVjcnlwdGlvbiBtdXN0IGJlIG9mIHR5cGUgXCJwcml2YXRlXCJgKTtpZih0LmFsZ29yaXRobSYmXCJ2ZXJpZnlcIj09PXImJlwicHJpdmF0ZVwiPT09dC50eXBlKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZmUuam9pbihcIiBvciBcIil9IGluc3RhbmNlcyBmb3IgYXN5bW1ldHJpYyBhbGdvcml0aG0gdmVyaWZ5aW5nIG11c3QgYmUgb2YgdHlwZSBcInB1YmxpY1wiYCk7aWYodC5hbGdvcml0aG0mJlwiZW5jcnlwdFwiPT09ciYmXCJwcml2YXRlXCI9PT10LnR5cGUpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmZS5qb2luKFwiIG9yIFwiKX0gaW5zdGFuY2VzIGZvciBhc3ltbWV0cmljIGFsZ29yaXRobSBlbmNyeXB0aW9uIG11c3QgYmUgb2YgdHlwZSBcInB1YmxpY1wiYCl9KShlLHQscil9LHZlPShlLHQpPT57aWYodm9pZCAwIT09dCYmKCFBcnJheS5pc0FycmF5KHQpfHx0LnNvbWUoKGU9Plwic3RyaW5nXCIhPXR5cGVvZiBlKSkpKXRocm93IG5ldyBUeXBlRXJyb3IoYFwiJHtlfVwiIG9wdGlvbiBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3NgKTtpZih0KXJldHVybiBuZXcgU2V0KHQpfTthc3luYyBmdW5jdGlvbiBTZShlLHQscil7aWYoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJihlPU0uZGVjb2RlKGUpKSxcInN0cmluZ1wiIT10eXBlb2YgZSl0aHJvdyBuZXcgQihcIkNvbXBhY3QgSldTIG11c3QgYmUgYSBzdHJpbmcgb3IgVWludDhBcnJheVwiKTtjb25zdHswOm8sMTpuLDI6YSxsZW5ndGg6aX09ZS5zcGxpdChcIi5cIik7aWYoMyE9PWkpdGhyb3cgbmV3IEIoXCJJbnZhbGlkIENvbXBhY3QgSldTXCIpO2NvbnN0IHM9YXdhaXQgYXN5bmMgZnVuY3Rpb24oZSx0LHIpe3ZhciBvO2lmKCFhZShlKSl0aHJvdyBuZXcgQihcIkZsYXR0ZW5lZCBKV1MgbXVzdCBiZSBhbiBvYmplY3RcIik7aWYodm9pZCAwPT09ZS5wcm90ZWN0ZWQmJnZvaWQgMD09PWUuaGVhZGVyKXRocm93IG5ldyBCKCdGbGF0dGVuZWQgSldTIG11c3QgaGF2ZSBlaXRoZXIgb2YgdGhlIFwicHJvdGVjdGVkXCIgb3IgXCJoZWFkZXJcIiBtZW1iZXJzJyk7aWYodm9pZCAwIT09ZS5wcm90ZWN0ZWQmJlwic3RyaW5nXCIhPXR5cGVvZiBlLnByb3RlY3RlZCl0aHJvdyBuZXcgQihcIkpXUyBQcm90ZWN0ZWQgSGVhZGVyIGluY29ycmVjdCB0eXBlXCIpO2lmKHZvaWQgMD09PWUucGF5bG9hZCl0aHJvdyBuZXcgQihcIkpXUyBQYXlsb2FkIG1pc3NpbmdcIik7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUuc2lnbmF0dXJlKXRocm93IG5ldyBCKFwiSldTIFNpZ25hdHVyZSBtaXNzaW5nIG9yIGluY29ycmVjdCB0eXBlXCIpO2lmKHZvaWQgMCE9PWUuaGVhZGVyJiYhYWUoZS5oZWFkZXIpKXRocm93IG5ldyBCKFwiSldTIFVucHJvdGVjdGVkIEhlYWRlciBpbmNvcnJlY3QgdHlwZVwiKTtsZXQgbj17fTtpZihlLnByb3RlY3RlZCl0cnl7Y29uc3QgdD1OKGUucHJvdGVjdGVkKTtuPUpTT04ucGFyc2UoTS5kZWNvZGUodCkpfWNhdGNoKGUpe3Rocm93IG5ldyBCKFwiSldTIFByb3RlY3RlZCBIZWFkZXIgaXMgaW52YWxpZFwiKX1pZigheWUobixlLmhlYWRlcikpdGhyb3cgbmV3IEIoXCJKV1MgUHJvdGVjdGVkIGFuZCBKV1MgVW5wcm90ZWN0ZWQgSGVhZGVyIFBhcmFtZXRlciBuYW1lcyBtdXN0IGJlIGRpc2pvaW50XCIpO2NvbnN0IGE9ey4uLm4sLi4uZS5oZWFkZXJ9O2xldCBpPSEwO2lmKGllKEIsbmV3IE1hcChbW1wiYjY0XCIsITBdXSksbnVsbD09cj92b2lkIDA6ci5jcml0LG4sYSkuaGFzKFwiYjY0XCIpJiYoaT1uLmI2NCxcImJvb2xlYW5cIiE9dHlwZW9mIGkpKXRocm93IG5ldyBCKCdUaGUgXCJiNjRcIiAoYmFzZTY0dXJsLWVuY29kZSBwYXlsb2FkKSBIZWFkZXIgUGFyYW1ldGVyIG11c3QgYmUgYSBib29sZWFuJyk7Y29uc3R7YWxnOnN9PWE7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHN8fCFzKXRocm93IG5ldyBCKCdKV1MgXCJhbGdcIiAoQWxnb3JpdGhtKSBIZWFkZXIgUGFyYW1ldGVyIG1pc3Npbmcgb3IgaW52YWxpZCcpO2NvbnN0IGM9ciYmdmUoXCJhbGdvcml0aG1zXCIsci5hbGdvcml0aG1zKTtpZihjJiYhYy5oYXMocykpdGhyb3cgbmV3IEcoJ1wiYWxnXCIgKEFsZ29yaXRobSkgSGVhZGVyIFBhcmFtZXRlciBub3QgYWxsb3dlZCcpO2lmKGkpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlLnBheWxvYWQpdGhyb3cgbmV3IEIoXCJKV1MgUGF5bG9hZCBtdXN0IGJlIGEgc3RyaW5nXCIpfWVsc2UgaWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUucGF5bG9hZCYmIShlLnBheWxvYWQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSl0aHJvdyBuZXcgQihcIkpXUyBQYXlsb2FkIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gVWludDhBcnJheSBpbnN0YW5jZVwiKTtsZXQgZD0hMTtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYodD1hd2FpdCB0KG4sZSksZD0hMCksRWUocyx0LFwidmVyaWZ5XCIpO2NvbnN0IGw9eihILmVuY29kZShudWxsIT09KG89ZS5wcm90ZWN0ZWQpJiZ2b2lkIDAhPT1vP286XCJcIiksSC5lbmNvZGUoXCIuXCIpLFwic3RyaW5nXCI9PXR5cGVvZiBlLnBheWxvYWQ/SC5lbmNvZGUoZS5wYXlsb2FkKTplLnBheWxvYWQpLHU9TihlLnNpZ25hdHVyZSk7aWYoIWF3YWl0IG1lKHMsdCx1LGwpKXRocm93IG5ldyB0ZTtsZXQgaDtoPWk/TihlLnBheWxvYWQpOlwic3RyaW5nXCI9PXR5cGVvZiBlLnBheWxvYWQ/SC5lbmNvZGUoZS5wYXlsb2FkKTplLnBheWxvYWQ7Y29uc3QgcD17cGF5bG9hZDpofTtyZXR1cm4gdm9pZCAwIT09ZS5wcm90ZWN0ZWQmJihwLnByb3RlY3RlZEhlYWRlcj1uKSx2b2lkIDAhPT1lLmhlYWRlciYmKHAudW5wcm90ZWN0ZWRIZWFkZXI9ZS5oZWFkZXIpLGQ/ey4uLnAsa2V5OnR9OnB9KHtwYXlsb2FkOm4scHJvdGVjdGVkOm8sc2lnbmF0dXJlOmF9LHQsciksYz17cGF5bG9hZDpzLnBheWxvYWQscHJvdGVjdGVkSGVhZGVyOnMucHJvdGVjdGVkSGVhZGVyfTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3suLi5jLGtleTpzLmtleX06Y31jb25zdCBiZT04NjQwMCxBZT0vXihcXGQrfFxcZCtcXC5cXGQrKSA/KHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSkkL2ksX2U9ZT0+e2NvbnN0IHQ9QWUuZXhlYyhlKTtpZighdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0aW1lIHBlcmlvZCBmb3JtYXRcIik7Y29uc3Qgcj1wYXJzZUZsb2F0KHRbMV0pO3N3aXRjaCh0WzJdLnRvTG93ZXJDYXNlKCkpe2Nhc2VcInNlY1wiOmNhc2VcInNlY3NcIjpjYXNlXCJzZWNvbmRcIjpjYXNlXCJzZWNvbmRzXCI6Y2FzZVwic1wiOnJldHVybiBNYXRoLnJvdW5kKHIpO2Nhc2VcIm1pbnV0ZVwiOmNhc2VcIm1pbnV0ZXNcIjpjYXNlXCJtaW5cIjpjYXNlXCJtaW5zXCI6Y2FzZVwibVwiOnJldHVybiBNYXRoLnJvdW5kKDYwKnIpO2Nhc2VcImhvdXJcIjpjYXNlXCJob3Vyc1wiOmNhc2VcImhyXCI6Y2FzZVwiaHJzXCI6Y2FzZVwiaFwiOnJldHVybiBNYXRoLnJvdW5kKDM2MDAqcik7Y2FzZVwiZGF5XCI6Y2FzZVwiZGF5c1wiOmNhc2VcImRcIjpyZXR1cm4gTWF0aC5yb3VuZChyKmJlKTtjYXNlXCJ3ZWVrXCI6Y2FzZVwid2Vla3NcIjpjYXNlXCJ3XCI6cmV0dXJuIE1hdGgucm91bmQoNjA0ODAwKnIpO2RlZmF1bHQ6cmV0dXJuIE1hdGgucm91bmQoMzE1NTc2MDAqcil9fSxrZT1lPT5lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXmFwcGxpY2F0aW9uXFwvLyxcIlwiKSxJZT0oZSx0LHI9e30pPT57Y29uc3R7dHlwOm99PXI7aWYobyYmKFwic3RyaW5nXCIhPXR5cGVvZiBlLnR5cHx8a2UoZS50eXApIT09a2UobykpKXRocm93IG5ldyBGKCd1bmV4cGVjdGVkIFwidHlwXCIgSldUIGhlYWRlciB2YWx1ZScsXCJ0eXBcIixcImNoZWNrX2ZhaWxlZFwiKTtsZXQgbjt0cnl7bj1KU09OLnBhcnNlKE0uZGVjb2RlKHQpKX1jYXRjaChlKXt9aWYoIWFlKG4pKXRocm93IG5ldyBYKFwiSldUIENsYWltcyBTZXQgbXVzdCBiZSBhIHRvcC1sZXZlbCBKU09OIG9iamVjdFwiKTtjb25zdHtyZXF1aXJlZENsYWltczphPVtdLGlzc3VlcjppLHN1YmplY3Q6cyxhdWRpZW5jZTpjLG1heFRva2VuQWdlOmR9PXI7dm9pZCAwIT09ZCYmYS5wdXNoKFwiaWF0XCIpLHZvaWQgMCE9PWMmJmEucHVzaChcImF1ZFwiKSx2b2lkIDAhPT1zJiZhLnB1c2goXCJzdWJcIiksdm9pZCAwIT09aSYmYS5wdXNoKFwiaXNzXCIpO2Zvcihjb25zdCBlIG9mIG5ldyBTZXQoYS5yZXZlcnNlKCkpKWlmKCEoZSBpbiBuKSl0aHJvdyBuZXcgRihgbWlzc2luZyByZXF1aXJlZCBcIiR7ZX1cIiBjbGFpbWAsZSxcIm1pc3NpbmdcIik7aWYoaSYmIShBcnJheS5pc0FycmF5KGkpP2k6W2ldKS5pbmNsdWRlcyhuLmlzcykpdGhyb3cgbmV3IEYoJ3VuZXhwZWN0ZWQgXCJpc3NcIiBjbGFpbSB2YWx1ZScsXCJpc3NcIixcImNoZWNrX2ZhaWxlZFwiKTtpZihzJiZuLnN1YiE9PXMpdGhyb3cgbmV3IEYoJ3VuZXhwZWN0ZWQgXCJzdWJcIiBjbGFpbSB2YWx1ZScsXCJzdWJcIixcImNoZWNrX2ZhaWxlZFwiKTtpZihjJiYobD1uLmF1ZCx1PVwic3RyaW5nXCI9PXR5cGVvZiBjP1tjXTpjLCEoXCJzdHJpbmdcIj09dHlwZW9mIGw/dS5pbmNsdWRlcyhsKTpBcnJheS5pc0FycmF5KGwpJiZ1LnNvbWUoU2V0LnByb3RvdHlwZS5oYXMuYmluZChuZXcgU2V0KGwpKSkpKSl0aHJvdyBuZXcgRigndW5leHBlY3RlZCBcImF1ZFwiIGNsYWltIHZhbHVlJyxcImF1ZFwiLFwiY2hlY2tfZmFpbGVkXCIpO3ZhciBsLHU7bGV0IGg7c3dpdGNoKHR5cGVvZiByLmNsb2NrVG9sZXJhbmNlKXtjYXNlXCJzdHJpbmdcIjpoPV9lKHIuY2xvY2tUb2xlcmFuY2UpO2JyZWFrO2Nhc2VcIm51bWJlclwiOmg9ci5jbG9ja1RvbGVyYW5jZTticmVhaztjYXNlXCJ1bmRlZmluZWRcIjpoPTA7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBjbG9ja1RvbGVyYW5jZSBvcHRpb24gdHlwZVwiKX1jb25zdHtjdXJyZW50RGF0ZTpwfT1yLHc9KGc9cHx8bmV3IERhdGUsTWF0aC5mbG9vcihnLmdldFRpbWUoKS8xZTMpKTt2YXIgZztpZigodm9pZCAwIT09bi5pYXR8fGQpJiZcIm51bWJlclwiIT10eXBlb2Ygbi5pYXQpdGhyb3cgbmV3IEYoJ1wiaWF0XCIgY2xhaW0gbXVzdCBiZSBhIG51bWJlcicsXCJpYXRcIixcImludmFsaWRcIik7aWYodm9pZCAwIT09bi5uYmYpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBuLm5iZil0aHJvdyBuZXcgRignXCJuYmZcIiBjbGFpbSBtdXN0IGJlIGEgbnVtYmVyJyxcIm5iZlwiLFwiaW52YWxpZFwiKTtpZihuLm5iZj53K2gpdGhyb3cgbmV3IEYoJ1wibmJmXCIgY2xhaW0gdGltZXN0YW1wIGNoZWNrIGZhaWxlZCcsXCJuYmZcIixcImNoZWNrX2ZhaWxlZFwiKX1pZih2b2lkIDAhPT1uLmV4cCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIG4uZXhwKXRocm93IG5ldyBGKCdcImV4cFwiIGNsYWltIG11c3QgYmUgYSBudW1iZXInLFwiZXhwXCIsXCJpbnZhbGlkXCIpO2lmKG4uZXhwPD13LWgpdGhyb3cgbmV3IHEoJ1wiZXhwXCIgY2xhaW0gdGltZXN0YW1wIGNoZWNrIGZhaWxlZCcsXCJleHBcIixcImNoZWNrX2ZhaWxlZFwiKX1pZihkKXtjb25zdCBlPXctbi5pYXQ7aWYoZS1oPihcIm51bWJlclwiPT10eXBlb2YgZD9kOl9lKGQpKSl0aHJvdyBuZXcgcSgnXCJpYXRcIiBjbGFpbSB0aW1lc3RhbXAgY2hlY2sgZmFpbGVkICh0b28gZmFyIGluIHRoZSBwYXN0KScsXCJpYXRcIixcImNoZWNrX2ZhaWxlZFwiKTtpZihlPDAtaCl0aHJvdyBuZXcgRignXCJpYXRcIiBjbGFpbSB0aW1lc3RhbXAgY2hlY2sgZmFpbGVkIChpdCBzaG91bGQgYmUgaW4gdGhlIHBhc3QpJyxcImlhdFwiLFwiY2hlY2tfZmFpbGVkXCIpfXJldHVybiBufTtmdW5jdGlvbiBUZShlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJkFycmF5LmlzQXJyYXkoZS5rZXlzKSYmZS5rZXlzLmV2ZXJ5KE9lKX1mdW5jdGlvbiBPZShlKXtyZXR1cm4gYWUoZSl9Y2xhc3MgUmV7Y29uc3RydWN0b3IoZSl7aWYodGhpcy5fY2FjaGVkPW5ldyBXZWFrTWFwLCFUZShlKSl0aHJvdyBuZXcgWShcIkpTT04gV2ViIEtleSBTZXQgbWFsZm9ybWVkXCIpO3ZhciB0O3RoaXMuX2p3a3M9KHQ9ZSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBzdHJ1Y3R1cmVkQ2xvbmU/c3RydWN0dXJlZENsb25lKHQpOkpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodCkpKX1hc3luYyBnZXRLZXkoZSx0KXtjb25zdHthbGc6cixraWQ6b309ey4uLmUsLi4ubnVsbD09dD92b2lkIDA6dC5oZWFkZXJ9LG49ZnVuY3Rpb24oZSl7c3dpdGNoKFwic3RyaW5nXCI9PXR5cGVvZiBlJiZlLnNsaWNlKDAsMikpe2Nhc2VcIlJTXCI6Y2FzZVwiUFNcIjpyZXR1cm5cIlJTQVwiO2Nhc2VcIkVTXCI6cmV0dXJuXCJFQ1wiO2Nhc2VcIkVkXCI6cmV0dXJuXCJPS1BcIjtkZWZhdWx0OnRocm93IG5ldyBWKCdVbnN1cHBvcnRlZCBcImFsZ1wiIHZhbHVlIGZvciBhIEpTT04gV2ViIEtleSBTZXQnKX19KHIpLGE9dGhpcy5fandrcy5rZXlzLmZpbHRlcigoZT0+e2xldCB0PW49PT1lLmt0eTtpZih0JiZcInN0cmluZ1wiPT10eXBlb2YgbyYmKHQ9bz09PWUua2lkKSx0JiZcInN0cmluZ1wiPT10eXBlb2YgZS5hbGcmJih0PXI9PT1lLmFsZyksdCYmXCJzdHJpbmdcIj09dHlwZW9mIGUudXNlJiYodD1cInNpZ1wiPT09ZS51c2UpLHQmJkFycmF5LmlzQXJyYXkoZS5rZXlfb3BzKSYmKHQ9ZS5rZXlfb3BzLmluY2x1ZGVzKFwidmVyaWZ5XCIpKSx0JiZcIkVkRFNBXCI9PT1yJiYodD1cIkVkMjU1MTlcIj09PWUuY3J2fHxcIkVkNDQ4XCI9PT1lLmNydiksdClzd2l0Y2gocil7Y2FzZVwiRVMyNTZcIjp0PVwiUC0yNTZcIj09PWUuY3J2O2JyZWFrO2Nhc2VcIkVTMjU2S1wiOnQ9XCJzZWNwMjU2azFcIj09PWUuY3J2O2JyZWFrO2Nhc2VcIkVTMzg0XCI6dD1cIlAtMzg0XCI9PT1lLmNydjticmVhaztjYXNlXCJFUzUxMlwiOnQ9XCJQLTUyMVwiPT09ZS5jcnZ9cmV0dXJuIHR9KSksezA6aSxsZW5ndGg6c309YTtpZigwPT09cyl0aHJvdyBuZXcgUTtpZigxIT09cyl7Y29uc3QgZT1uZXcgWix7X2NhY2hlZDp0fT10aGlzO3Rocm93IGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWFzeW5jIGZ1bmN0aW9uKigpe2Zvcihjb25zdCBlIG9mIGEpdHJ5e3lpZWxkIGF3YWl0IFBlKHQsZSxyKX1jYXRjaChlKXtjb250aW51ZX19LGV9cmV0dXJuIFBlKHRoaXMuX2NhY2hlZCxpLHIpfX1hc3luYyBmdW5jdGlvbiBQZShlLHQscil7Y29uc3Qgbz1lLmdldCh0KXx8ZS5zZXQodCx7fSkuZ2V0KHQpO2lmKHZvaWQgMD09PW9bcl0pe2NvbnN0IGU9YXdhaXQgYXN5bmMgZnVuY3Rpb24oZSx0LHIpe3ZhciBvO2lmKCFhZShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSldLIG11c3QgYmUgYW4gb2JqZWN0XCIpO3N3aXRjaCh0fHwodD1lLmFsZyksZS5rdHkpe2Nhc2VcIm9jdFwiOmlmKFwic3RyaW5nXCIhPXR5cGVvZiBlLmt8fCFlLmspdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBcImtcIiAoS2V5IFZhbHVlKSBQYXJhbWV0ZXIgdmFsdWUnKTtyZXR1cm4gbnVsbCE9cnx8KHI9ITAhPT1lLmV4dCkscj9uZSh7Li4uZSxhbGc6dCxleHQ6bnVsbCE9PShvPWUuZXh0KSYmdm9pZCAwIT09byYmb30pOk4oZS5rKTtjYXNlXCJSU0FcIjppZih2b2lkIDAhPT1lLm90aCl0aHJvdyBuZXcgVignUlNBIEpXSyBcIm90aFwiIChPdGhlciBQcmltZXMgSW5mbykgUGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQnKTtjYXNlXCJFQ1wiOmNhc2VcIk9LUFwiOnJldHVybiBuZSh7Li4uZSxhbGc6dH0pO2RlZmF1bHQ6dGhyb3cgbmV3IFYoJ1Vuc3VwcG9ydGVkIFwia3R5XCIgKEtleSBUeXBlKSBQYXJhbWV0ZXIgdmFsdWUnKX19KHsuLi50LGV4dDohMH0scik7aWYoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fFwicHVibGljXCIhPT1lLnR5cGUpdGhyb3cgbmV3IFkoXCJKU09OIFdlYiBLZXkgU2V0IG1lbWJlcnMgbXVzdCBiZSBwdWJsaWMga2V5c1wiKTtvW3JdPWV9cmV0dXJuIG9bcl19Y29uc3QgQ2U9YXN5bmMoZSx0LHIpPT57bGV0IG8sbixhPSExO1wiZnVuY3Rpb25cIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKG89bmV3IEFib3J0Q29udHJvbGxlcixuPXNldFRpbWVvdXQoKCgpPT57YT0hMCxvLmFib3J0KCl9KSx0KSk7Y29uc3QgaT1hd2FpdCBmZXRjaChlLmhyZWYse3NpZ25hbDpvP28uc2lnbmFsOnZvaWQgMCxyZWRpcmVjdDpcIm1hbnVhbFwiLGhlYWRlcnM6ci5oZWFkZXJzfSkuY2F0Y2goKGU9PntpZihhKXRocm93IG5ldyBlZTt0aHJvdyBlfSkpO2lmKHZvaWQgMCE9PW4mJmNsZWFyVGltZW91dChuKSwyMDAhPT1pLnN0YXR1cyl0aHJvdyBuZXcgSk9TRUVycm9yKFwiRXhwZWN0ZWQgMjAwIE9LIGZyb20gdGhlIEpTT04gV2ViIEtleSBTZXQgSFRUUCByZXNwb25zZVwiKTt0cnl7cmV0dXJuIGF3YWl0IGkuanNvbigpfWNhdGNoKGUpe3Rocm93IG5ldyBKT1NFRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgdGhlIEpTT04gV2ViIEtleSBTZXQgSFRUUCByZXNwb25zZSBhcyBKU09OXCIpfX07Y2xhc3MgV2UgZXh0ZW5kcyBSZXtjb25zdHJ1Y3RvcihlLHQpe2lmKHN1cGVyKHtrZXlzOltdfSksdGhpcy5fandrcz12b2lkIDAsIShlIGluc3RhbmNlb2YgVVJMKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwidXJsIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMXCIpO3RoaXMuX3VybD1uZXcgVVJMKGUuaHJlZiksdGhpcy5fb3B0aW9ucz17YWdlbnQ6bnVsbD09dD92b2lkIDA6dC5hZ2VudCxoZWFkZXJzOm51bGw9PXQ/dm9pZCAwOnQuaGVhZGVyc30sdGhpcy5fdGltZW91dER1cmF0aW9uPVwibnVtYmVyXCI9PXR5cGVvZihudWxsPT10P3ZvaWQgMDp0LnRpbWVvdXREdXJhdGlvbik/bnVsbD09dD92b2lkIDA6dC50aW1lb3V0RHVyYXRpb246NWUzLHRoaXMuX2Nvb2xkb3duRHVyYXRpb249XCJudW1iZXJcIj09dHlwZW9mKG51bGw9PXQ/dm9pZCAwOnQuY29vbGRvd25EdXJhdGlvbik/bnVsbD09dD92b2lkIDA6dC5jb29sZG93bkR1cmF0aW9uOjNlNCx0aGlzLl9jYWNoZU1heEFnZT1cIm51bWJlclwiPT10eXBlb2YobnVsbD09dD92b2lkIDA6dC5jYWNoZU1heEFnZSk/bnVsbD09dD92b2lkIDA6dC5jYWNoZU1heEFnZTo2ZTV9Y29vbGluZ0Rvd24oKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdGhpcy5fandrc1RpbWVzdGFtcCYmRGF0ZS5ub3coKTx0aGlzLl9qd2tzVGltZXN0YW1wK3RoaXMuX2Nvb2xkb3duRHVyYXRpb259ZnJlc2goKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdGhpcy5fandrc1RpbWVzdGFtcCYmRGF0ZS5ub3coKTx0aGlzLl9qd2tzVGltZXN0YW1wK3RoaXMuX2NhY2hlTWF4QWdlfWFzeW5jIGdldEtleShlLHQpe3RoaXMuX2p3a3MmJnRoaXMuZnJlc2goKXx8YXdhaXQgdGhpcy5yZWxvYWQoKTt0cnl7cmV0dXJuIGF3YWl0IHN1cGVyLmdldEtleShlLHQpfWNhdGNoKHIpe2lmKHIgaW5zdGFuY2VvZiBRJiYhMT09PXRoaXMuY29vbGluZ0Rvd24oKSlyZXR1cm4gYXdhaXQgdGhpcy5yZWxvYWQoKSxzdXBlci5nZXRLZXkoZSx0KTt0aHJvdyByfX1hc3luYyByZWxvYWQoKXt0aGlzLl9wZW5kaW5nRmV0Y2gmJihcInVuZGVmaW5lZFwiIT10eXBlb2YgV2ViU29ja2V0UGFpcnx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmXCJDbG91ZGZsYXJlLVdvcmtlcnNcIj09PW5hdmlnYXRvci51c2VyQWdlbnR8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBFZGdlUnVudGltZSYmXCJ2ZXJjZWxcIj09PUVkZ2VSdW50aW1lKSYmKHRoaXMuX3BlbmRpbmdGZXRjaD12b2lkIDApLHRoaXMuX3BlbmRpbmdGZXRjaHx8KHRoaXMuX3BlbmRpbmdGZXRjaD1DZSh0aGlzLl91cmwsdGhpcy5fdGltZW91dER1cmF0aW9uLHRoaXMuX29wdGlvbnMpLnRoZW4oKGU9PntpZighVGUoZSkpdGhyb3cgbmV3IFkoXCJKU09OIFdlYiBLZXkgU2V0IG1hbGZvcm1lZFwiKTt0aGlzLl9qd2tzPXtrZXlzOmUua2V5c30sdGhpcy5fandrc1RpbWVzdGFtcD1EYXRlLm5vdygpLHRoaXMuX3BlbmRpbmdGZXRjaD12b2lkIDB9KSkuY2F0Y2goKGU9Pnt0aHJvdyB0aGlzLl9wZW5kaW5nRmV0Y2g9dm9pZCAwLGV9KSkpLGF3YWl0IHRoaXMuX3BlbmRpbmdGZXRjaH19Y29uc3QgeGU9TjtjbGFzcyBBdXRoZW50aWNhdGlvbkVycm9yIGV4dGVuZHMgUntjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKGU9ZT8/dD8ubWVzc2FnZT8/XCJBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgYXV0aGVudGljYXRpb25cIix0KX19Y2xhc3MgTG9nb3V0RXJyb3IgZXh0ZW5kcyBSe2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZT1lPz90Py5tZXNzYWdlPz9cIkFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBsb2dvdXRcIix0KX19Y29uc3QgamU9XCIxLjAuMFwiLCRlPVwiT0lEQ1wiLEplPSgpPT57SigkZSl9LFVlPSgpPT57VSgkZSxqZSl9O1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJihcInVuZGVmaW5lZFwiPT10eXBlb2YgZmluJiZPYmplY3QuYXNzaWduKHdpbmRvdyx7ZmluOnt9fSksT2JqZWN0LmFzc2lnbihmaW4se0ludGVncmF0aW9uczp7T0lEQzp7ZW5hYmxlTG9nZ2luZzpVZSxkaXNhYmxlTG9nZ2luZzpKZX19fSkpO2NvbnN0IEtlPWU9PmAke2UucmVwbGFjZSgvXFwvJC8sXCJcIil9Ly53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uYDt2YXIgRGU7IWZ1bmN0aW9uKGUpe2UuT3BlbklkQ29ubmVjdD1cIk9wZW5JRC1Db25uZWN0XCJ9KERlfHwoRGU9e30pKTtjbGFzcyBMZSBleHRlbmRzIFd7Z2V0IGlkVG9rZW4oKXtyZXR1cm4gdGhpcy5faWRUb2tlbn1nZXQgb3BlbklkUHJvdmlkZXJVcmwoKXtyZXR1cm4gdGhpcy5fb3BlbklkUHJvdmlkZXJVcmx9Z2V0IHJlZGlyZWN0VXJpKCl7cmV0dXJuIHRoaXMuX3JlZGlyZWN0VXJpfWdldCBzY29wZSgpe3JldHVybiB0aGlzLl9zY29wZX1nZXQgdXNlckluZm8oKXtyZXR1cm4gdGhpcy5fdXNlckluZm99YXN5bmMgYXV0aG9yaXplKGUsdCxyKXthd2FpdCBzdXBlci5hdXRob3JpemUoZSx0LHIpLHRoaXMuX2lkVG9rZW49YXdhaXQgdGhpcy5nZXRJZFRva2VuKCksdGhpcy5fdXNlckluZm89YXdhaXQoYXN5bmMgZT0+e2NvbnN0IHQ9ZS5tZXRhZGF0YT8udXNlcmluZm9fZW5kcG9pbnQ7aWYoIXQpcmV0dXJuO2NvbnN0e2RhdGE6cn09YXdhaXQgZS5leGVjdXRlQXBpUmVxdWVzdCh0KTtyZXR1cm4gcn0pKHRoaXMpfWFzeW5jIGNsb3NlKCl7YXdhaXQgc3VwZXIuY2xvc2UoKSx0aGlzLl9pZFRva2VuPXZvaWQgMCx0aGlzLl9vcGVuSWRQcm92aWRlclVybD12b2lkIDAsdGhpcy5fcmVkaXJlY3RVcmk9dm9pZCAwLHRoaXMuX3Njb3BlPXZvaWQgMCx0aGlzLl91c2VySW5mbz12b2lkIDB9Z2V0RXJyb3JNZXNzYWdlRnJvbVNlcnZlclJlc3BvbnNlKGUpe3JldHVybiBlfXN0YXRpYyBhc3luYyBpbml0KGUsdCxyLG8sbixhLGkpe2NvbnN0IHM9bmV3IEMobyk7cy5sb2dJbmZvKFwiSW5pdCBzdGFydGVkXCIsZSx0LHIsbyxuLGEsaSk7dHJ5e2NvbnN0e2FkZGl0aW9uYWxNZXRhZGF0YTp0LGRpc2NvdmVyeUVuZHBvaW50Om99PWUsYz17Li4uYXdhaXQgSyhvKSwuLi50Pz97fX07aWYoIWMucmVzcG9uc2VfdHlwZXNfc3VwcG9ydGVkLmZpbmQoKGU9PlwiY29kZVwiPT09ZS50b0xvd2VyQ2FzZSgpKSkpdGhyb3cgbmV3IFAoXCJPcGVuSUQgUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgYXV0aG9yaXphdGlvbiBjb2RlIHJlc3BvbnNlIHR5cGVcIik7Y29uc3QgZD1hd2FpdCBEKGMscixzKSxsPW5ldyBMZSh2b2lkIDAscixjLGQscyk7cmV0dXJuIGwuX29wZW5JZFByb3ZpZGVyVXJsPW4sbC5fcmVkaXJlY3RVcmk9YSxsLl9zY29wZT1pLHMubG9nSW5mbyhcIkluaXQgY29tcGxldGVkXCIsbCksKGFzeW5jKGUsdCk9Pnt0cnl7YXdhaXQgZmluLlN5c3RlbS5yZWdpc3RlclVzYWdlKHt0eXBlOlwiaW50ZWdyYXRpb24tZmVhdHVyZVwiLGRhdGE6e2FwaVZlcnNpb246amUsY29tcG9uZW50TmFtZTplfX0pfWNhdGNoKHIpe3QubG9nV2FybmluZyhgVW5hYmxlIHRvIHJlZ2lzdGVyIHVzYWdlIGZvciBmZWF0dXJlICR7ZX06ICR7cj8ubWVzc2FnZX1gKX19KShEZS5PcGVuSWRDb25uZWN0LHMpLGx9Y2F0Y2goZSl7bGV0IHQ7dGhyb3cgdD1lIGluc3RhbmNlb2YgUj9lOm5ldyBQKHZvaWQgMCxlKSxzLmxvZ0Vycm9yKHQpLHR9fX1jb25zdCBIZT1hc3luYyhlLHQscik9Pntjb25zdCBvPW5ldyBDKCRlKSxuPUtlKHIpO2xldCBhO3RyeXthPWF3YWl0IEsobil9Y2F0Y2goZSl7Y29uc3QgdD1uZXcgaihgRmFpbGVkIHRvIHJldHJpZXZlIE9wZW5JRCBDb25uZWN0IG1ldGFkYXRhIGZyb20gJHtufWApO3Rocm93IG8ubG9nRXJyb3IodCksdH1jb25zdHtpbnRyb3NwZWN0aW9uX2VuZHBvaW50Omksandrc191cmk6c309YTtpZihpKXRyeXtyZXR1cm4gYXdhaXQgTChvKShlLHQsaSl9Y2F0Y2goZSl7fWVsc2Ugbz8ubG9nV2FybmluZyhcIk5vIGludHJvc3BlY3Rpb24gZW5kcG9pbnQgZm91bmQgaW4gT3BlbklEIENvbm5lY3QgbWV0YWRhdGFcIik7aWYoIXMpe2NvbnN0IGU9bmV3IGooYEZhaWxlZCB0byByZXRyaWV2ZSBKU09OIFdlYiBLZXkgU2V0IChKV0tTKSBmcm9tICR7c31gKTt0aHJvdyBvLmxvZ0Vycm9yKGUpLGV9bz8ubG9nSW5mbyhcIlZhbGlkYXRpbmcgaWQgdG9rZW4gYWdhaW5zdCBKV0tTIGVuZHBvaW50XCIscyk7dHJ5e2NvbnN0e3BheWxvYWQ6bn09YXdhaXQgYXN5bmMgZnVuY3Rpb24oZSx0LHIpe3ZhciBvO2NvbnN0IG49YXdhaXQgU2UoZSx0LHIpO2lmKChudWxsPT09KG89bi5wcm90ZWN0ZWRIZWFkZXIuY3JpdCl8fHZvaWQgMD09PW8/dm9pZCAwOm8uaW5jbHVkZXMoXCJiNjRcIikpJiYhMT09PW4ucHJvdGVjdGVkSGVhZGVyLmI2NCl0aHJvdyBuZXcgWChcIkpXVHMgTVVTVCBOT1QgdXNlIHVuZW5jb2RlZCBwYXlsb2FkXCIpO2NvbnN0IGE9e3BheWxvYWQ6SWUobi5wcm90ZWN0ZWRIZWFkZXIsbi5wYXlsb2FkLHIpLHByb3RlY3RlZEhlYWRlcjpuLnByb3RlY3RlZEhlYWRlcn07cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD97Li4uYSxrZXk6bi5rZXl9OmF9KGUsZnVuY3Rpb24oZSx0KXtjb25zdCByPW5ldyBXZShlLHQpO3JldHVybiBhc3luYyBmdW5jdGlvbihlLHQpe3JldHVybiByLmdldEtleShlLHQpfX0obmV3IFVSTChzKSkse2F1ZGllbmNlOnQsaXNzdWVyOnJ9KTtyZXR1cm4gbz8ubG9nSW5mbyhcIklEIHRva2VuIHZhbGlkYXRpb24gc3VjY2Vzc2Z1bFwiLG4pLHt2YWxpZDohMCwuLi5ufX1jYXRjaChlKXtpZighKGUgaW5zdGFuY2VvZiBGfHxlIGluc3RhbmNlb2YgcXx8ZSBpbnN0YW5jZW9mIFh8fGUgaW5zdGFuY2VvZiB0ZSkpe2NvbnN0IHQ9bmV3IGoodm9pZCAwLGUpO3Rocm93IG8ubG9nRXJyb3IodCksdH1yZXR1cm4gby5sb2dXYXJuaW5nKGBJRCB0b2tlbiB2YWxpZGF0aW9uIGZhaWxlZDogJHtlLm1lc3NhZ2V9YCkse3ZhbGlkOiExfX19LE1lPVtcIm9wZW5pZFwiLFwicHJvZmlsZVwiLFwiZW1haWxcIl0semU9YXN5bmMoZSx0LHIsbz1bXSxuLGEsaSk9PntpZihlPWU/LnRyaW0oKS5yZXBsYWNlKC9cXC8kLyxcIlwiKSwhZSl0aHJvdyBuZXcgeChcIk9wZW5JRCBQcm92aWRlciBVUkwgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIik7aWYoIXQpdGhyb3cgbmV3IHgoXCJDbGllbnQgSWRlbnRpZmllciBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKTtpZighcil0aHJvdyBuZXcgeChcIlJlZGlyZWN0aW9uIFVSSSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKTtjb25zdCBzPWF3YWl0IEZlKGUsdCxyLG8sbik7aWYoIXMpdGhyb3cgbmV3IFAoXCJQcm92aWRlciBub3QgaW5pdGlhbGl6ZWRcIik7Y29uc3QgYz1zLm1ldGFkYXRhPy5zY29wZXNfc3VwcG9ydGVkO2lmKCFjKXtjb25zdCBlPW5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiT3BlbklEIFByb3ZpZGVyIG1ldGFkYXRhIGRvZXMgbm90IGRlZmluZSBzdXBwb3J0ZWQgc2NvcGVzXCIpO3Rocm93IHMubG9nZ2VyLmxvZ0Vycm9yKGUpLGV9Y29uc3QgZD1NZS5maWx0ZXIoKGU9PiFjLmluY2x1ZGVzKGUpKSk7aWYoZC5sZW5ndGg+MCl7Y29uc3QgZT1uZXcgQXV0aGVudGljYXRpb25FcnJvcihgT3BlbklEIFByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgcmVxdWlyZWQgc2NvcGVzOiAke2Quam9pbihcIiwgXCIpfWApO3Rocm93IHMubG9nZ2VyLmxvZ0Vycm9yKGUpLGV9Y29uc3QgbD1uZXcgU2V0KFsuLi5NZSwuLi5vXSk7YXdhaXQgcy5hdXRob3JpemUocix7ZGlzcGxheTpcInBvcHVwXCIsc2NvcGU6Wy4uLmxdLmpvaW4oXCIgXCIpLC4uLmF9LGkpO2NvbnN0e2lkVG9rZW46dX09cztpZighdSl7Y29uc3QgZT1uZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vIElEIHRva2VuIHJldHVybmVkXCIpO3Rocm93IHMubG9nZ2VyLmxvZ0Vycm9yKGUpLGV9Y29uc3QgaD1mdW5jdGlvbihlKXtpZihcInN0cmluZ1wiIT10eXBlb2YgZSl0aHJvdyBuZXcgWChcIkpXVHMgbXVzdCB1c2UgQ29tcGFjdCBKV1Mgc2VyaWFsaXphdGlvbiwgSldUIG11c3QgYmUgYSBzdHJpbmdcIik7Y29uc3R7MTp0LGxlbmd0aDpyfT1lLnNwbGl0KFwiLlwiKTtpZig1PT09cil0aHJvdyBuZXcgWChcIk9ubHkgSldUcyB1c2luZyBDb21wYWN0IEpXUyBzZXJpYWxpemF0aW9uIGNhbiBiZSBkZWNvZGVkXCIpO2lmKDMhPT1yKXRocm93IG5ldyBYKFwiSW52YWxpZCBKV1RcIik7aWYoIXQpdGhyb3cgbmV3IFgoXCJKV1RzIG11c3QgY29udGFpbiBhIHBheWxvYWRcIik7bGV0IG8sbjt0cnl7bz14ZSh0KX1jYXRjaChlKXt0aHJvdyBuZXcgWChcIkZhaWxlZCB0byBwYXJzZSB0aGUgYmFzZTY0dXJsIGVuY29kZWQgcGF5bG9hZFwiKX10cnl7bj1KU09OLnBhcnNlKE0uZGVjb2RlKG8pKX1jYXRjaChlKXt0aHJvdyBuZXcgWChcIkZhaWxlZCB0byBwYXJzZSB0aGUgZGVjb2RlZCBwYXlsb2FkIGFzIEpTT05cIil9aWYoIWFlKG4pKXRocm93IG5ldyBYKFwiSW52YWxpZCBKV1QgQ2xhaW1zIFNldFwiKTtyZXR1cm4gbn0odSk7aWYoIWgpe2NvbnN0IGU9bmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJGYWlsZWQgdG8gZGVjb2RlIElEIHRva2VuXCIpO3Rocm93IHMubG9nZ2VyLmxvZ0Vycm9yKGUpLGV9Y29uc3R7YXVkOnAsaXNzOnd9PWg7cmV0dXJuIGF3YWl0IEhlKHUsQXJyYXkuaXNBcnJheShwKT9wWzBdOnAsdykse2NsYWltczpoLGNsaWVudElkOnQsaWRUb2tlbjp1LGxvZ291dDpxZSh0LHUscyksb3BlbklkUHJvdmlkZXJVcmw6ZSx1c2VySW5mbzpzLnVzZXJJbmZvfX0sTmU9KGUsdCxyLG8sbixhKT0+YXN5bmMgbj0+e2lmKDAhPT1uZXcgVVJMKG4pLmhyZWYudG9Mb3dlckNhc2UoKS5pbmRleE9mKHIudG9Mb3dlckNhc2UoKSkpcmV0dXJuITE7d2luZG93LmNsZWFySW50ZXJ2YWwoYSksd2luZG93LmNsZWFyVGltZW91dCh0KTt0cnl7ZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKSxlLmNsb3NlKCEwKX1jYXRjaChlKXt9cmV0dXJuIG8oKSwhMH0sRmU9YXN5bmMoZSx0LHIsbyxuKT0+e2NvbnN0IGE9e2FkZGl0aW9uYWxNZXRhZGF0YTpuLGRpc2NvdmVyeUVuZHBvaW50OktlKGUpfTtyZXR1cm4gTGUuaW5pdChhLHZvaWQgMCx0LCRlLGUscixvKX0scWU9KGUsdCxyKT0+YXN5bmMobyxuKT0+e2lmKCFvKXRocm93IG5ldyB4KFwiTG9nb3V0IFJlZGlyZWN0aW9uIFVSSSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKTtjb25zdHtsb2dnZXI6YSxtZXRhZGF0YTppfT1yO2EubG9nSW5mbyhcIkxvZ291dCBzdGFydGVkXCIsZSx0LG8sbik7Y29uc3R7ZW5kX3Nlc3Npb25fZW5kcG9pbnQ6c309aT8/e307aWYoIXMpe2NvbnN0IGU9bmV3IExvZ291dEVycm9yKFwiT3BlbklEIFByb3ZpZGVyIG1ldGFkYXRhIGRvZXMgbm90IGRlZmluZSBlbmQgc2Vzc2lvbiBlbmRwb2ludFwiKTt0aHJvdyBhLmxvZ0Vycm9yKGUpLGV9Y29uc3QgYz1gJHtzfT9pZF90b2tlbl9oaW50PSR7dH0mY2xpZW50X2lkPSR7ZX0mcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG8pfSR7bj9gJmxvZ291dF9oaW50PSR7ZW5jb2RlVVJJQ29tcG9uZW50KG4pfWA6XCJcIn1gO2F3YWl0ICQoYyxHZShvLGEpKSxhd2FpdChyPy5jbG9zZSgpKSxhLmxvZ0luZm8oXCJMb2dvdXQgY29tcGxldGVkXCIpfSxHZT0oZSx0KT0+cj0+bmV3IFByb21pc2UoKChvLG4pPT57bGV0IGE7ci5hZGRMaXN0ZW5lcihcImNsb3NpbmdcIiwoYXN5bmMoKT0+e3QubG9nSW5mbyhcIlVzZXIgY2xvc2VkIGF1dGggd2luZG93XCIpLHdpbmRvdy5jbGVhckludGVydmFsKGEpLHIucmVtb3ZlQWxsTGlzdGVuZXJzKCksbihuZXcgTG9nb3V0RXJyb3IoXCJGYWlsZWQgdG8gY29tcGxldGUgbG9nb3V0IHByb2Nlc3NcIikpfSkpO2NvbnN0IGk9d2luZG93LnNldFRpbWVvdXQoKGFzeW5jKCk9Pnt0cnl7YXdhaXQgci5pc1Nob3dpbmcoKXx8KHQubG9nSW5mbyhcIlNob3dpbmcgYXV0aCB3aW5kb3dcIiksYXdhaXQgci5zaG93KCEwKSxhd2FpdCByLmZvY3VzKCkpfWNhdGNoe3QubG9nV2FybmluZyhcIlVuYWJsZSB0byBzaG93IGF1dGggd2luZG93XCIpfX0pLDJlMyk7KGFzeW5jKCk9Pntjb25zdHt2ZXJzaW9uOnN9PWF3YWl0IGZpbi5TeXN0ZW0uZ2V0UnVudGltZUluZm8oKTtpZihwYXJzZUludChzLnNwbGl0KFwiLlwiKVswXSwxMCk+PTMwKXthd2FpdCBOZShyLGksZSxvLG4pKChhd2FpdCByLmdldEluZm8oKSkudXJsKXx8YXdhaXQgci5hZGRMaXN0ZW5lcihcInVybC1jaGFuZ2VkXCIsKGE9Pnt0LmxvZ0luZm8oXCJBdXRoIHdpbmRvdyBuYXZpZ2F0ZWQgdG9cIixhLnVybCksTmUocixpLGUsbyxuKShhLnVybCl9KSl9ZWxzZSBhPXdpbmRvdy5zZXRJbnRlcnZhbCgoKCk9Pihhc3luYyhlLHQscixvLG4sYSk9PntsZXQgaTt0cnl7aT1hd2FpdCBlLmdldEluZm8oKX1jYXRjaChlKXtyZXR1cm4gd2luZG93LmNsZWFySW50ZXJ2YWwodCksd2luZG93LmNsZWFyVGltZW91dChyKSxhKG5ldyBMb2dvdXRFcnJvcihcIkNvdWxkIG5vdCBsb2NhdGUgYXV0aCB3aW5kb3dcIikpLCExfXJldHVybiBOZShlLHIsbyxuLGEsdCkoaS51cmwpfSkocixhLGksZSxvLG4pKSw1MDApfSkoKX0pKTt2YXIgVmU9dC5NUyxCZT10Ll83LFhlPXQuY1gsWWU9dC56TCxRZT10Ll9XLFplPXQucDgsZXQ9dC5ZUix0dD10LlUkLHJ0PXQuVTcsb3Q9dC5PRjtleHBvcnR7VmUgYXMgQXBpRXJyb3IsQmUgYXMgQXV0aGVudGljYXRpb25FcnJvcixYZSBhcyBJbml0aWFsaXphdGlvbkVycm9yLFllIGFzIExvZ291dEVycm9yLFFlIGFzIFBhcmFtZXRlckVycm9yLFplIGFzIFZhbGlkYXRpb25FcnJvcixldCBhcyBhdXRoZW50aWNhdGUsdHQgYXMgZGlzYWJsZUxvZ2dpbmcscnQgYXMgZW5hYmxlTG9nZ2luZyxvdCBhcyB2YWxpZGF0ZUlkVG9rZW59OyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IHR5cGUgeyBNb2R1bGVJbXBsZW1lbnRhdGlvbiwgTW9kdWxlVHlwZXMgfSBmcm9tIFwid29ya3NwYWNlLXBsYXRmb3JtLXN0YXJ0ZXIvc2hhcGVzL21vZHVsZS1zaGFwZXNcIjtcbmltcG9ydCB7IE9wZW5JZENvbm5lY3RQcm92aWRlciB9IGZyb20gXCIuL2F1dGhcIjtcblxuLyoqXG4gKiBEZWZpbmUgdGhlIGVudHJ5IHBvaW50cyBmb3IgdGhlIG1vZHVsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudHJ5UG9pbnRzOiB7IFt0eXBlIGluIE1vZHVsZVR5cGVzXT86IE1vZHVsZUltcGxlbWVudGF0aW9uIH0gPSB7XG5cdGF1dGg6IG5ldyBPcGVuSWRDb25uZWN0UHJvdmlkZXIoKVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==