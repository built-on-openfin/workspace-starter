/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@openfin/search-api/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@openfin/search-api/index.js ***!
  \***************************************************/
/***/ ((module) => {

(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{TemplateNames:()=>ee,create:()=>Se,defaultTopic:()=>Be,subscribe:()=>Ce});var n={};e.r(n),e.d(n,{subscribe:()=>K});var r={};e.r(r),e.d(r,{create:()=>Re});const o="deregistered or does not exist",s=new Error(`provider ${o}`),i=new Error("provider with name already exists"),c=new Error("bad payload"),u=new Error("subscription rejected"),a=new Error(`channel ${o}`),l=new Map;function d(e){const t=f(e);if(t)return t;throw a}function f(e){const t=l.get(e);if(t)return t}function p(e,t){l.set(e,t)}var g;!function(e){e[e.Initial=0]="Initial",e[e.Open=1]="Open",e[e.Close=2]="Close"}(g||(g={}));const h="all",v="0",y="5",w="6",m=()=>{};function b(e,t){return`${e}-${t}`}function R(e){return`__search-${e}-topic__`}const S=new Map;function C(e,t){S.has(e)||S.set(e,new Map),S.get(e).set(t.name,t)}function B(e,t){const n=S.get(e);n&&n.delete(t)}function k(e){return S.get(e)?[...S.get(e).values()]:[]}function $(e){const t=S.get(e);t&&t.clear()}function P(e,t){const n=S.get(e);return n?n.get(t):null}function I(e,t,n){var r;let o=n;if(!o&&(null===(r=e.actions)||void 0===r?void 0:r.length)){const t=e.actions[0];o="string"!=typeof t?null==t?void 0:t.name:t}return{...e,action:o,dispatcherIdentity:t}}function O(e,t,n="ascending"){const r=e||[];if(!(null==t?void 0:t.length))return r;const o=[],s=new Map;t.forEach((e=>{if(e.key)return s.set(e.key,e);o.push(e)}));let i=r.map((e=>{const{key:t}=e;if(t&&s.has(t)){const e=s.get(t);return s.delete(t),e}return e}));return i.push(...s.values(),...o),i="ascending"===n?i.sort(((e,t)=>(null!==e.score&&void 0!==e.score?e.score:1/0)-(null!==t.score&&void 0!==t.score?t.score:1/0))):i.sort(((e,t)=>(null!==t.score&&void 0!==t.score?t.score:1/0)-(null!==e.score&&void 0!==e.score?e.score:1/0))),i}function M(e){const t={};let n=[],r=[],o=g.Initial;t.getStatus=()=>o,t.getResultBuffer=()=>n,t.setResultBuffer=e=>{n=e,(null==n?void 0:n.length)&&t.onChange()},t.getRevokedBuffer=()=>r,t.setRevokedBuffer=e=>{r=e,(null==r?void 0:r.length)&&t.onChange()},t.onChange=m;const s={};return t.res=s,s.close=()=>{o!==g.Close&&(o=g.Close,t.onChange())},s.open=()=>{o!==g.Open&&(o=g.Open,t.onChange())},s.respond=n=>{const r=O(t.getResultBuffer(),n,e);t.setResultBuffer(r)},s.revoke=(...e)=>{const n=new Set(e),r=t.getResultBuffer().filter((({key:e})=>{const t=n.has(e);return t&&n.delete(e),!t}));t.setResultBuffer(r),n.size&&(t.getRevokedBuffer().forEach((e=>n.add(e))),t.setRevokedBuffer([...n]))},t}function N(e,t){const n=new Set;let r=!1;return{close:()=>{r=!0;for(const e of n)e()},req:{id:e,...t,onClose:e=>{n.add(e),r&&e()},removeListener:e=>{n.delete(e)}}}}function E(){return{name:fin.me.name,uuid:fin.me.uuid}}function x(){let e;try{const t=fin.Platform.getCurrentSync();if(!(null==t?void 0:t.identity))return;e=t.identity.uuid}catch(e){}return e}function T(e){console.error("OpenFin Search API: ",e)}const F=new Map;function q(e){F.has(e)||F.set(e,new Map);const t=F.get(e);return{getRequestsForIdentity:e=>{const n=function(e){return`${e.uuid}:${e.name}`}(e);return t.has(n)||t.set(n,new Map),t.get(n)}}}function D(e,t){return d(e).dispatch(v,t)}function L(e){const t=P.bind(null,e),n=q(e),r=D.bind(null,e);return async(e,o)=>{if(!e||!e.id||!e.providerName){const e=c;return T(e),{error:e.message}}const{id:i,providerName:u}=e,a=t(u);if(!a){const e=s;return T(e),{error:e.message}}const l=n.getRequestsForIdentity(o);let d=l.get(e.id);d||(d=N(i,e),l.set(e.id,d));const f=M(),p=()=>{const e=f.getResultBuffer();f.setResultBuffer([]);const t=f.getRevokedBuffer();f.setRevokedBuffer([]);const n=f.getStatus();r({id:i,providerName:u,results:e,revoked:t,status:n})};let g=!0,h=!1;f.onChange=()=>{if(g)return g=!1,void p();h||(h=!0,setTimeout((()=>{h=!1,p()}),100))};try{const e=await a.onSearch(d.req,f.res),t=f.getStatus();return{id:i,providerName:u,status:t,results:e}}catch(e){return T(e),{id:i,providerName:u,error:e.message}}}}async function _(e,t){const n=d(e),r=E(),o={identity:r,...t,onSearch:void 0,onResultDispatch:void 0};await n.dispatch("2",o),C(e,{identity:r,...t})}async function j(e,t){const n=d(e);return await n.dispatch("3",t),B(e,t)}async function A(e,t,n,r){const o=I(n,E(),r),s=P(e,t);if(s){const{onResultDispatch:e}=s;if(!e)return;return e(o)}const i={providerName:t,result:o};return d(e).dispatch(y,i)}async function z(e,t){const n={...t};let r;return r=async function*(e,t,{setState:n}){const r=d(e);for(;;){const e=await r.dispatch("1",t),o=e.error;if(o)throw new Error(o);const s=e;if(t.id=s.id,n(s.state),s.done)return s.value;yield s.value}}(e,n,{setState:e=>{r.state=e}}),await r.next(),r.id=n.id,r.close=()=>{!function(e,t){d(e).dispatch(w,{id:t})}(e,r.id)},r}async function G(e){return d(e).dispatch("4",null)}async function H(e){const t=d(e);!function(e){l.delete(e)}(e),$(e),await t.disconnect()}async function J(e){const t=R(e),n=await async function(e){let t=!1;for(let n=0;n<10;n++)try{const n=await Promise.race([fin.InterApplicationBus.Channel.connect(e),new Promise(((e,n)=>setTimeout((()=>{t||n(a)}),2e3)))]);return t=!0,n}catch(e){if(9===n)throw e}}(t);var r;return n.register(v,L(e)),n.register(w,function(e){const t=q(e);return(e,n)=>{const r=t.getRequestsForIdentity(n),o=r.get(e.id);o&&(o.close(),r.delete(e.id))}}(e)),n.register(y,(r=e,async(e,t)=>{if(!e||!e.providerName||!e.result)return void T(c);const n=P(r,e.providerName);if(!n)return void T(s);const{onResultDispatch:o}=n;return o?(e.result.dispatcherIdentity=t,o(e.result)):void 0})),n.onDisconnection(function(e){const t=q(e);return async n=>{if(!f(e))return;const r=t.getRequestsForIdentity(n);for(const{req:e,close:t}of r.values())t(),r.delete(e.id);let o,s=!0;for(;s;)try{o=await J(e),s=!1}catch(e){await new Promise((e=>setTimeout(e,2e3)))}p(e,o);for(const t of k(e))try{await _(e,t)}catch(e){}}}(e)),n}async function K(e){const t="string"==typeof e?e:null==e?void 0:e.topic,n=function(e,t){const n=e||x(),r=t||h;return n?b(n,r):r}("string"==typeof e?null:null==e?void 0:e.uuid,t);let r=f(n);return r||(r=await J(n),p(n,r)),{getAllProviders:G.bind(null,n),register:_.bind(null,n),search:z.bind(null,n),deregister:j.bind(null,n),dispatch:A.bind(null,n),disconnect:H.bind(null,n)}}const Q=new Map;function U(e){const t=V(e);if(t)return t;throw a}function V(e){const t=Q.get(e);if(t)return t}const W=new Map;function X(e,t){W.has(e)||W.set(e,[]),W.get(e).push(t)}function Y(e,t){const n=W.get(e);if(!n)return;const r=n.findIndex((e=>e===t));-1!==r&&n.splice(r,1)}var Z,ee;function te(e){return[...k(e)].map((e=>({...e,onSearch:void 0,onResultDispatch:void 0})))}function ne(e,t){if(P(e,t.name))throw new Error("provider with name already exists");C(e,{identity:E(),...t})}function re(e,t){B(e,t)}async function oe(e,t,n,r){const o=P(e,t);if(!o)throw s;const{onResultDispatch:i}=o;if(i)return i(I(n,E(),r))}!function(e){e.Fetching="fetching",e.Fetched="fetched",e.Complete="complete"}(Z||(Z={})),function(e){e.Contact="Contact",e.List="List",e.Plain="Plain",e.SimpleText="SimpleText"}(ee||(ee={}));let se=0;function ie(e,t){se+=1;const n=N(se.toString(),t);let r;return r=async function*(e,t,n){const r=function(e,t){const n=[],r=[],o=[],s=[];for(const i of e){const e=M(i.scoreOrder),c={results:[],provider:{name:i.name,identity:i.identity,title:i.title,scoreOrder:i.scoreOrder}};n.push(c),r.push(e);const u=(async()=>{try{const n=await i.onSearch(t,e.res);c.results=O(c.results,n)}catch(e){c.error=e}u.done=!0})();s.push(u),o.push(o.length)}return{providerResponses:n,listenerResponses:r,openListenerResponses:o,intialResponsePromises:s}}(t.targets?t.targets.map((t=>P(e,t))).filter((e=>!!e)):[...k(e)],t),{providerResponses:o,listenerResponses:s}=r;let{openListenerResponses:i,intialResponsePromises:c}=r,u=Z.Fetching;const a=e=>{u=e,n.setState(u)};let l,d=!1;t.onClose((()=>{d=!0,l&&l()}));do{let e=!1;if(c.length){const t=[];for(const n of c)n.done?e=!0:t.push(n);c=t,c.length||(a(Z.Fetched),e=!0)}let t,n=!1;const r=()=>{n=!0,t&&t()},f=[];for(const t of i){const n=s[t],i=o[t],c=n.getStatus();(c===g.Open||u===Z.Fetching&&c===g.Initial)&&(f.push(t),n.onChange=r);const a=n.getResultBuffer();a.length&&(n.setResultBuffer([]),i.results=O(i.results,a),e=!0);const l=n.getRevokedBuffer();if(l.length){n.setRevokedBuffer([]);const t=new Set(l);i.results=i.results.filter((({key:e})=>!t.has(e))),e=!0}}if(i=f,e&&(yield o),d)break;n||(i.length||c.length)&&await Promise.race([...c,new Promise((e=>{t=e})),new Promise((e=>{l=e}))])}while(i.length||c.length);return a(Z.Complete),o}(e,n.req,{setState:e=>{r.state=e}}),r.id=se.toString(),r.close=n.close,r.state=Z.Fetching,r}const ce=new Map;function ue(e,t){return`${e}:${t}`}function ae(e,t,n){return U(e).dispatch(t,w,{id:n})}async function le(e,t,{id:n,query:r,context:o,targets:s}){const i=U(e),c={id:n,query:r,context:o,targets:s,providerName:t.name},u=await i.dispatch(t.identity,v,c),a=u.error;if(a)throw new Error(a);return u}const de=new Map;function fe(e,t,n){return`${e}:${t.name}:${t.uuid}:${n}`}const pe=new Map;function ge(e,t,n){return`${e}:${t}:${n}`}function he(e,t){const n=fe.bind(null,e,t.identity),r=ae.bind(null,e,t.identity),o=le.bind(null,e,t);return async(s,i)=>{const c=n(s.id);if(!de.has(c)){const e=()=>{r(s.id),de.delete(c)};de.set(c,e),s.onClose(e)}const u=ge(e,t.name,s.id),a=()=>{pe.delete(u),i.close()};s.onClose(a),pe.set(u,(e=>{var t,n;(null===(t=e.results)||void 0===t?void 0:t.length)&&i.respond(e.results),(null===(n=e.revoked)||void 0===n?void 0:n.length)&&i.revoke(...e.revoked),e.status===g.Open&&i.open(),e.status===g.Close&&a()}));const l=await o(s);return l.status===g.Open&&i.open(),l.status!==g.Close&&l.status!==g.Initial||a(),l.results}}function ve(e,t){return async n=>{const r=U(e),o={providerName:t.name,result:n};return r.dispatch(t.identity,y,o)}}const ye=new Map;function we(e,t){return`${e}-${t.name}-${t.uuid}`}async function me(e){const t=R(e),n=await(r=t,fin.InterApplicationBus.Channel.create(r));var r,o;return n.onConnection(function(e){return async t=>{const n=W.get(e);if(n)for(const e of n)if(!await e(t))throw u}}(e)),n.onDisconnection(function(e){return async t=>{!function(e,t){const n=we(e,t),r=ye.get(n);if(r){for(const t of r)B(e,t);ye.delete(n)}}(e,t)}}(e)),n.register(w,function(e){return t=>function(e,t){const n=ue(e,t),r=ce.get(n);r&&r.generator.close()}(e,t.id)}(e)),n.register(v,function(e){return t=>{const n=ge(e,t.providerName,t.id),r=pe.get(n);r&&r(t)}}(e)),n.register("2",function(e){return(t,n)=>{if(t&&t.name){if(P(e,t.name))throw i;t.identity=n,function(e,t){const n=we(e,t.identity);ye.has(n)||ye.set(n,[]),ye.get(n).push(t.name),C(e,{...t,onSearch:he(e,t),onResultDispatch:ve(e,t)})}(e,t)}else T(c)}}(e)),n.register("3",function(e){return t=>{t?function(e,t){const n=P(e,t);if(!n)return;const r=we(e,n.identity),o=ye.get(r);if(o){const n=o.findIndex((e=>e===t));-1!==n&&(o.splice(n,1),B(e,t))}}(e,t):T(c)}}(e)),n.register("4",(o=e,async()=>te(o))),n.register("1",function(e){return async t=>{if(!t)return T(c),{error:c.message};let n;if(t.id)n=ue(e,t.id);else{const r=ie(e,t);n=ue(e,r.id),t.id=r.id,ce.set(n,{generator:r})}const r=ce.get(n);clearTimeout(r.timeout);const o=await r.generator.next();return r.timeout=function(e){return window.setTimeout((()=>{ce.delete(e)}),1e4)}(n),{...o,id:t.id,state:r.generator.state}}}(e)),n.register(y,function(e){return async(t,n)=>{if(!t||!t.providerName||!t.result)return void T(c);const r=P(e,t.providerName);if(!r)throw s;const{onResultDispatch:o}=r;return o?(t.result.dispatcherIdentity=n,o(t.result)):void 0}}(e)),n}async function be(e){const t=U(e);!function(e){Q.delete(e)}(e),await t.destroy(),$(e)}async function Re(e){const t=function(e){const t=x(),n=e||h;return t?b(t,n):n}("string"==typeof e?e:null==e?void 0:e.topic);let n=V(t);return n||(n=await me(t),function(e,t){Q.set(e,t)}(t,n)),{getAllProviders:te.bind(null,t),search:ie.bind(null,t),register:ne.bind(null,t),deregister:re.bind(null,t),onSubscription:X.bind(null,t),removeSubscriptionListener:Y.bind(null,t),dispatch:oe.bind(null,t),disconnect:be.bind(null,t)}}const{create:Se}=r,{subscribe:Ce}=n,Be=h,ke={create:Se,subscribe:Ce,defaultTopic:Be},$e=()=>{const e=window;e.search=ke,e.fin&&(e.fin.Search=ke)},Pe=e=>{const t=()=>{$e(),window.removeEventListener(e,t)};return t};if("undefined"!=typeof window){$e();const e="load",t=Pe(e);window.addEventListener(e,t);const n="DOMContentLoaded",r=Pe(n);window.addEventListener(n,r)}module.exports=t})();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@openfin/workspace/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@openfin/workspace/index.js ***!
  \**************************************************/
/***/ ((module) => {

(()=>{"use strict";var e={d:(o,r)=>{for(var t in r)e.o(r,t)&&!e.o(o,t)&&Object.defineProperty(o,t,{enumerable:!0,get:r[t]})},o:(e,o)=>Object.prototype.hasOwnProperty.call(e,o),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},o={};e.r(o),e.d(o,{Storefront:()=>$,launchApp:()=>T});var r,t,n={};e.r(n),e.d(n,{hide:()=>C,register:()=>b,show:()=>F}),function(e){e.Local="local",e.Dev="dev",e.Staging="staging",e.Prod="prod"}(t||(t={}));const a="undefined"!=typeof window&&"undefined"!=typeof fin,i=("undefined"==typeof process||null===(r=process.env)||void 0===r||r.JEST_WORKER_ID,"undefined"!=typeof window),d=(i?window.origin:t.Local,a&&fin.me.uuid,a&&fin.me.name,"undefined"!=typeof ENV?ENV:t.Local,t.Local,t.Dev,t.Staging,t.Prod,!0),s=("undefined"!=typeof WORKSPACE_API_URL&&WORKSPACE_API_URL,"undefined"!=typeof WORKSPACE_APPS_URL&&WORKSPACE_APPS_URL,"undefined"!=typeof WORKSPACE_STOREFRONT_FOOTER_URL&&WORKSPACE_STOREFRONT_FOOTER_URL,"undefined"!=typeof WORKSPACE_STOREFRONT_LANDING_PAGE_URL&&WORKSPACE_STOREFRONT_LANDING_PAGE_URL,"undefined"!=typeof WORKSPACE_STOREFRONT_NAVIGATION_URL&&WORKSPACE_STOREFRONT_NAVIGATION_URL,"#7795f7"),c={trace:!0,debug:"undefined"!=typeof LOG_DEBUG&&LOG_DEBUG,info:!1,warn:!0,error:!0,fatal:!0};const p=function(e,o){const r=`${e} : `,t=`color:${s}`;return{trace:c.trace?(e,...o)=>{console.trace(`%c${r}${e}`,t,...o)}:(e,...o)=>{},debug:c.debug?(e,...o)=>{console.info(`%c${r}${e}`,"color:#86db94",...o)}:(e,...o)=>{},info:c.info?(e,...o)=>{console.debug(`%c${r}${e}`,"color:#ffffff",...o)}:(e,...o)=>{},warn:c.warn?(e,...o)=>{console.warn(`%c${r}${e}`,"color:#edad68",...o)}:(e,...o)=>{},error:c.error?(e,o,...t)=>{console.error(`%c${r}${e}`,"color:#f55d67",...t,o)}:(e,o,...r)=>{},fatal:c.fatal?(e,o,...t)=>{console.error(`%c${r}${e}`,"color:#f70723",...t,o)}:(e,o,...r)=>{}}}("utils.channels"),g=i&&"complete"!==document.readyState&&new Promise((e=>document.addEventListener("readystatechange",(()=>{"complete"===document.readyState&&e()}))));var f,w,u,l,h;!function(e){e.Workspace="openfin-browser"}(f||(f={})),function(e){e.ViewPageTitleUpdated="view-page-title-updated",e.ViewDestroyed="view-destroyed",e.RunRequested="run-requested",e.WindowOptionsChanged="window-options-changed",e.WindowClosed="window-closed",e.WindowCreated="window-created"}(w||(w={})),function(e){e.FinProtocol="fin-protocol"}(u||(u={})),f.Workspace,f.Workspace,function(e){e.Home="openfin-home",e.Dock="openfin-dock",e.Storefront="openfin-storefront",e.HomeInternal="openfin-home-internal",e.BrowserMenu="openfin-browser-menu",e.BrowserIndicator="openfin-browser-indicator",e.BrowserWindow="internal-generated-window"}(l||(l={})),function(e){e.Shown="shown",e.BoundsChanged="bounds-changed",e.LayoutReady="layout-ready",e.EndUserBoundsChanging="end-user-bounds-changing",e.Blurred="blurred",e.CloseRequested="close-requested",e.Focused="focused",e.ShowRequested="show-requested",e.ViewCrashed="view-crashed",e.ViewAttached="view-attached",e.ViewDetached="view-detached"}(h||(h={})),l.Home,f.Workspace,l.Dock,f.Workspace,l.Storefront,f.Workspace;const v={name:f.Workspace,uuid:f.Workspace},S=e=>function(e){if(!a)throw new Error("getOFWindow can only be used in an OpenFin env. Avoid calling this method during pre-rendering.");return fin.Window.wrapSync(e)}(e).getOptions().then((()=>!0)).catch((()=>!1));var P,R;(R=P||(P={})).LaunchApp="launch-app",R.CreateWorkspace="create-workspace",R.UpdateWorkspace="update-workspace",R.DeleteWorkspace="delete-workspace",R.LaunchWorkspace="launch-workspace",R.ShareWorkspace="share-workspace",R.GetWorkspace="get-workspace",R.GetWorkspaceList="get-workspace-list",R.GetActiveWorkspace="get-active-workspace",R.GetPage="get-page",R.CreatePage="create-page",R.UpdatePage="update-page",R.RenamePage="rename-page",R.DeletePage="delete-page",R.SharePage="share-page",R.LaunchPage="launch-page",R.AttachPagesToWindow="attach-pages-to-window",R.DetachPagesFromWindow="detach-pages-from-window",R.ReorderPagesForWindow="reorder-pages-for-window",R.SetActivePageForWindow="set-active-page-for-window",R.GetSavedPageList="get-saved-page-list",R.GetAttachedPageList="get-running-page-list",R.GetAllPageList="get-all-page-list",R.GetActivePageIdForWindow="get-active-page-id-for-window",R.GetPagesForWindow="get-pages-for-window",R.GetSavedPageMetadata="get-saved-page-metadata",R.RegisterStorefrontProvider="register-storefront-provider",R.GetStorefrontProviders="get-storefront-providers",R.HideStorefront="hide-storefront",R.GetStorefrontProviderApps="get-storefront-provider-apps",R.GetStorefrontProviderLandingPage="get-storefront-provider-landing-page",R.GetStorefrontProviderFooter="get-storefront-provider-footer",R.GetStorefrontProviderNavigation="get-storefront-provider-navigation",R.LaunchStorefrontProviderApp="launch-storefront-provider-app",R.ShowStorefront="show-storefront",R.CreateStorefrontWindow="create-storefront-window",R.CreateBrowserWindow="create-browser-window";const y=function(e){let o;return()=>{if(!a)throw new Error("getChannelClient cannot be used outside an OpenFin env. Avoid using this method during pre-rendering.");return o||(p.debug(`connecting to channel provider ${e}`),o=(async()=>{await g;const r=await fin.InterApplicationBus.Channel.connect(e);return r.onDisconnection((async()=>{p.warn(`disconnected from channel provider ${e}`),o=void 0})),r})().then((o=>(p.debug(`connected to channel provider ${e}`),o))).catch((o=>{p.error(`failed to connect to channel provider ${e}`,o)}))),o}}("__of_workspace_protocol__"),A=async()=>{if(!await S(v))return fin.System.openUrlWithBrowser((()=>{const e=new URL("fins://system-apps/workspace");return e.searchParams.append("isLaunchedViaLib",d.toString()),e.toString()})())},W=async()=>(await A(),y());var O,_,L;let m;!function(e){e.Snapshot="snapshot",e.Manifest="manifest",e.View="view",e.External="external"}(O||(O={})),(L=_||(_={})).LandingPage="landingPage",L.AppGrid="appGrid";const E=new Map;let G=!1;const k=e=>{if(!E.has(e))throw new Error(`Storefront Provider with id ${e} is not registered`);return E.get(e)},b=e=>(m=(async e=>{const o=await W();if(E.has(e.id))throw new Error(`Storefront provider with id ${e.id} already registered`);return E.set(e.id,e),(e=>{G||(G=!0,e.register(P.GetStorefrontProviderApps,(e=>k(e).getApps())),e.register(P.GetStorefrontProviderFooter,(e=>k(e).getFooter())),e.register(P.GetStorefrontProviderLandingPage,(e=>k(e).getLandingPage())),e.register(P.GetStorefrontProviderNavigation,(e=>k(e).getNavigation())),e.register(P.LaunchStorefrontProviderApp,(({id:e,app:o})=>k(e).launchApp(o))))})(o),o.dispatch(P.RegisterStorefrontProvider,e)})(e),m),C=async()=>{await m,await A(),await(async()=>(await y()).dispatch(P.HideStorefront,void 0))()},F=async()=>{await m,await A(),await(async()=>(await y()).dispatch(P.ShowStorefront,null))()},T=async e=>(await W()).dispatch(P.LaunchApp,e),$=n;module.exports=o})();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/application/Factory.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/application/Factory.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const validate_1 = __webpack_require__(/*! ../../util/validate */ "./node_modules/openfin-adapter/src/util/validate.js");
const Instance_1 = __webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/application/Instance.js");
/**
 * @typedef {object} ApplicationOption
 * @summary Application creation options.
 * @desc This is the options object required by {@link Application.start Application.start}.
 *
 * The following options are required:
 * * `uuid` is required in the app manifest as well as by {@link Application.start Application.start}
 * * `name` is optional in the app manifest but required by {@link Application.start Application.start}
 * * `url` is optional in both the app manifest {@link Application.start Application.start} and  but is usually given
 * (defaults to `"about:blank"` when omitted).
 *
 * _This jsdoc typedef mirrors the `ApplicationOption` TypeScript interface in `@types/openfin`._
 *
 * **IMPORTANT NOTE:**
 * This object inherits all the properties of the window creation {@link Window~options options} object,
 * which will take priority over those of the same name that may be provided in `mainWindowOptions`.
 *
 * @property {boolean} [disableIabSecureLogging=false]
 * When set to `true` it will disable IAB secure logging for the app.
 *
 * @property {string} [loadErrorMessage="There was an error loading the application."]
 * An error message to display when the application (launched via manifest) fails to load.
 * A dialog box will be launched with the error message just before the runtime exits.
 * Load fails such as failed DNS resolutions or aborted connections as well as cancellations, _e.g.,_ `window.stop()`,
 * will trigger this dialog.
 * Client response codes such as `404 Not Found` are not treated as fails as they are valid server responses.
 *
 * @property {Window~options} [mainWindowOptions]
 * The options of the main window of the application.
 * For a description of these options, click the link (in the Type column).
 *
 * @property {number} [maxViewPoolSize=1000]
 * Platforms Only.  The maximum number of "detached" or "pooled" Views that can exist in the Platform before being closed.
 * If you do not wish for views to be pooled on your platform, set this property to zero.
 *
 * @property {string} [name]
 * The name of the application (and the application's main window).
 *
 * If provided, _must_ match `uuid`.
 *
 * @property {boolean} [nonPersistent=false]
 * A flag to configure the application as non-persistent.
 * Runtime exits when there are no persistent apps running.
 *
 * @property {boolean} [plugins=false]
 * Enable Flash at the application level.
 *
 * @property {boolean} [spellCheck=false]
 * Enable spell check at the application level.
 *
 * @property {string} [url="about:blank"]
 * The url to the application (specifically the application's main window).
 *
 * @property {string} uuid
 * The _Unique Universal Identifier_ (UUID) of the application, unique within the set of all other applications
 *  running in the OpenFin Runtime.
 *
 * Note that `name` and `uuid` must match.
 *
 * @property {boolean} [webSecurity=true]
 * When set to `false` it will disable the same-origin policy for the app.
 */
/**
 * @lends Application
 */
class ApplicationModule extends base_1.Base {
    /**
     * Asynchronously returns an Application object that represents an existing application.
     * @param { Identity } identity
     * @return {Promise.<Application>}
     * @tutorial Application.wrap
     * @static
     */
    async wrap(identity) {
        this.wire.sendAction('wrap-application').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1.Application(this.wire, identity);
    }
    /**
     * Synchronously returns an Application object that represents an existing application.
     * @param { Identity } identity
     * @return {Application}
     * @tutorial Application.wrapSync
     * @static
     */
    wrapSync(identity) {
        this.wire.sendAction('wrap-application-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1.Application(this.wire, identity);
    }
    async _create(appOptions) {
        // set defaults:
        if (appOptions.waitForPageLoad === undefined) {
            appOptions.waitForPageLoad = false;
        }
        if (appOptions.autoShow === undefined && appOptions.isPlatformController === undefined) {
            appOptions.autoShow = true;
        }
        await this.wire.sendAction('create-application', appOptions);
        return this.wrap({ uuid: appOptions.uuid });
    }
    /**
     * DEPRECATED method to create a new Application. Use {@link Application.start} instead.
     * @param { ApplicationOption } appOptions
     * @return {Promise.<Application>}
     * @tutorial Application.create
     * @ignore
     */
    create(appOptions) {
        console.warn('Deprecation Warning: fin.Application.create is deprecated. Please use fin.Application.start');
        this.wire.sendAction('application-create').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return this._create(appOptions);
    }
    /**
     * Creates and starts a new Application.
     * @param { ApplicationOption } appOptions
     * @return {Promise.<Application>}
     * @tutorial Application.start
     * @static
     */
    async start(appOptions) {
        this.wire.sendAction('start-application').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const app = await this._create(appOptions);
        await this.wire.sendAction('run-application', { uuid: appOptions.uuid });
        return app;
    }
    /**
     * Asynchronously starts a batch of applications given an array of application identifiers and manifestUrls.
     * Returns once the RVM is finished attempting to launch the applications.
     * @param { Array.<ManifestInfo> } applications
     * @return {Promise.<void>}
     * @static
     * @tutorial Application.startManyManifests
     * @experimental
     */
    async startManyManifests(applications) {
        return this.wire.sendAction('run-applications', { applications }).then(() => undefined);
    }
    /**
     * Asynchronously returns an Application object that represents the current application
     * @return {Promise.<Application>}
     * @tutorial Application.getCurrent
     * @static
     */
    getCurrent() {
        this.wire.sendAction('get-current-application').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return this.wrap({ uuid: this.wire.me.uuid });
    }
    /**
     * Synchronously returns an Application object that represents the current application
     * @return {Application}
     * @tutorial Application.getCurrentSync
     * @static
     */
    getCurrentSync() {
        this.wire.sendAction('get-current-application-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return this.wrapSync({ uuid: this.wire.me.uuid });
    }
    /**
     * Retrieves application's manifest and returns a running instance of the application.
     * @param {string} manifestUrl - The URL of app's manifest.
     * @param {RvmLaunchOptions} [opts] - Parameters that the RVM will use.
     * @return {Promise.<Application>}
     * @tutorial Application.startFromManifest
     * @static
     */
    async startFromManifest(manifestUrl, opts) {
        this.wire.sendAction('application-start-from-manifest').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const app = await this._createFromManifest(manifestUrl);
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore using private method without warning.
        await app._run(opts); // eslint-disable-line no-underscore-dangle
        return app;
    }
    createFromManifest(manifestUrl) {
        console.warn('Deprecation Warning: fin.Application.createFromManifest is deprecated. Please use fin.Application.startFromManifest');
        this.wire.sendAction('application-create-from-manifest').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return this._createFromManifest(manifestUrl);
    }
    _createFromManifest(manifestUrl) {
        return this.wire
            .sendAction('get-application-manifest', { manifestUrl })
            .then(({ payload }) => {
            const uuid = payload.data.platform ? payload.data.platform.uuid : payload.data.startup_app.uuid;
            return this.wrap({ uuid });
        })
            .then((app) => {
            app._manifestUrl = manifestUrl; // eslint-disable-line no-underscore-dangle
            return app;
        });
    }
}
exports["default"] = ApplicationModule;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/application/Instance.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/application/Instance.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Application = void 0;
/* eslint-disable import/prefer-default-export */
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const window_1 = __webpack_require__(/*! ../window */ "./node_modules/openfin-adapter/src/api/window/index.js");
const view_1 = __webpack_require__(/*! ../view */ "./node_modules/openfin-adapter/src/api/view/index.js");
/**
 * @classdesc An object representing an application. Allows the developer to create,
 * execute, show/close an application as well as listen to <a href="tutorial-Application.EventEmitter.html">application events</a>.
 * @class
 * @hideconstructor
 */
class Application extends base_1.EmitterBase {
    constructor(wire, identity) {
        super(wire, ['application', identity.uuid]);
        this.identity = identity;
        this.window = new window_1._Window(this.wire, {
            uuid: this.identity.uuid,
            name: this.identity.uuid
        });
    }
    windowListFromIdentityList(identityList) {
        const windowList = [];
        identityList.forEach((identity) => {
            windowList.push(new window_1._Window(this.wire, {
                uuid: identity.uuid,
                name: identity.name
            }));
        });
        return windowList;
    }
    /**
     * Adds a listener to the end of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - Called whenever an event of the specified type occurs.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function addListener
     * @memberof Application
     * @instance
     * @tutorial Application.EventEmitter
     */
    /**
     * Adds a listener to the end of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - Called whenever an event of the specified type occurs.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function on
     * @memberof Application
     * @instance
     * @tutorial Application.EventEmitter
     */
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function once
     * @memberof Application
     * @instance
     * @tutorial Application.EventEmitter
     */
    /**
     * Adds a listener to the beginning of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function prependListener
     * @memberof Application
     * @instance
     * @tutorial Application.EventEmitter
     */
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.
     * The listener is added to the beginning of the listeners array.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function prependOnceListener
     * @memberof Application
     * @instance
     * @tutorial Application.EventEmitter
     */
    /**
     * Remove a listener from the listener array for the specified event.
     * Caution: Calling this method changes the array indices in the listener array behind the listener.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function removeListener
     * @memberof Application
     * @instance
     * @tutorial Application.EventEmitter
     */
    /**
     * Removes all listeners, or those of the specified event.
     * @param { string | symbol } [eventType]  - The type of the event.
     * @return {Promise.<this>}
     * @function removeAllListeners
     * @memberof Application
     * @instance
     * @tutorial Application.EventEmitter
     */
    /**
     * Determines if the application is currently running.
     * @return {Promise.<boolean>}
     * @tutorial Application.isRunning
     */
    /**
     * JumpListCategory interface
     * @typedef { object } JumpListCategory
     * @property { string } name The display title for the category. If omitted, items in this category will be placed into the standard 'Tasks' category. There can be only one such category, and it will always be displayed at the bottom of the JumpList.
     * @property { JumpListItem[] } items Array of JumpListItem objects
     */
    /**
     * JumpListItem interface
     * @typedef { object } JumpListItem
     * @property { string } type One of the following: "task" or "separator". Defaults to task.
     * @property { string } title The text to be displayed for the JumpList Item. Should only be set if type is "task".
     * @property { string } description Description of the task (displayed in a tooltip). Should only be set if type is "task".
     * @property { string } deepLink Deep link to a manifest, i.e: fins://path.to/manifest.json?$$param1=value1. See {@link https://developers.openfin.co/docs/deep-linking deep-linking} for more information.
     * @property { string } iconPath The absolute path to an icon to be displayed for the item, which can be an arbitrary resource file that contains an icon (e.g. .ico, .exe, .dll).
     * @property { number } iconIndex The index of the icon in the resource file. If a resource file contains multiple icons this value can be used to specify the zero-based index of the icon that should be displayed for this task. If a resource file contains only one icon, this property should be set to zero.
     */
    isRunning() {
        return this.wire.sendAction('is-application-running', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Closes the application and any child windows created by the application.
     * Cleans the application from state so it is no longer found in getAllApplications.
     * @param { boolean } [force = false] Close will be prevented from closing when force is false and
     *  ‘close-requested’ has been subscribed to for application’s main window.
     * @return {Promise.<boolean>}
     * @tutorial Application.quit
     */
    async quit(force = false) {
        await this._close(force);
        await this.wire.sendAction('destroy-application', { force, ...this.identity });
    }
    _close(force = false) {
        return this.wire.sendAction('close-application', { force, ...this.identity }).then(() => undefined);
    }
    close(force = false) {
        console.warn('Deprecation Warning: Application.close is deprecated Please use Application.quit');
        this.wire.sendAction('application-close', this.identity).catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return this._close(force);
    }
    /**
     * Retrieves an array of wrapped fin.Windows for each of the application’s child windows.
     * @return {Promise.Array.<_Window>}
     * @tutorial Application.getChildWindows
     */
    getChildWindows() {
        return this.wire.sendAction('get-child-windows', this.identity).then(({ payload }) => {
            const identityList = [];
            payload.data.forEach((winName) => {
                identityList.push({ uuid: this.identity.uuid, name: winName });
            });
            return this.windowListFromIdentityList(identityList);
        });
    }
    /**
     * Retrieves an array of active window groups for all of the application's windows. Each group is
     * represented as an array of wrapped fin.Windows.
     * @return {Promise.Array.Array.<_Window>}
     * @deprecated All Window Group APIs will be removed by major version 22.
     * @tutorial Application.getGroups
     */
    getGroups() {
        console.warn('Deprecation Warning: All Window Group APIs will be removed by major version 22.');
        const winGroups = [];
        return this.wire
            .sendAction('get-application-groups', {
            crossApp: true,
            ...this.identity
        })
            .then(({ payload }) => {
            payload.data.forEach((windowList, index) => {
                const identityList = [];
                windowList.forEach((winInfo) => {
                    identityList.push({ uuid: winInfo.uuid, name: winInfo.windowName });
                });
                winGroups[index] = this.windowListFromIdentityList(identityList);
            });
            return winGroups;
        });
    }
    /**
     * Retrieves the JSON manifest that was used to create the application. Invokes the error callback
     * if the application was not created from a manifest.
     * @return {Promise.<any>}
     * @tutorial Application.getManifest
     */
    getManifest() {
        return this.wire.sendAction('get-application-manifest', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Retrieves UUID of the application that launches this application. Invokes the error callback
     * if the application was created from a manifest.
     * @return {Promise.<string>}
     * @tutorial Application.getParentUuid
     */
    getParentUuid() {
        return this.wire.sendAction('get-parent-application', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Retrieves current application's shortcut configuration.
     * @return {Promise.<ShortCutConfig>}
     * @tutorial Application.getShortcuts
     */
    getShortcuts() {
        return this.wire.sendAction('get-shortcuts', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Retrieves current application's views.
     * @experimental
     * @return {Promise.Array.<View>}
     * @tutorial Application.getViews
     */
    async getViews() {
        const { payload } = await this.wire.sendAction('application-get-views', this.identity);
        return payload.data.map((id) => new view_1.View(this.wire, id));
    }
    /**
     * Returns the current zoom level of the application.
     * @return {Promise.<number>}
     * @tutorial Application.getZoomLevel
     */
    getZoomLevel() {
        return this.wire.sendAction('get-application-zoom-level', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Returns an instance of the main Window of the application
     * @return {Promise.<_Window>}
     * @tutorial Application.getWindow
     */
    getWindow() {
        this.wire.sendAction('application-get-window', this.identity).catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return Promise.resolve(this.window);
    }
    /**
     * Manually registers a user with the licensing service. The only data sent by this call is userName and appName.
     * @param { string } userName - username to be passed to the RVM.
     * @param { string } appName - app name to be passed to the RVM.
     * @return {Promise.<void>}
     * @tutorial Application.registerUser
     */
    registerUser(userName, appName) {
        return this.wire.sendAction('register-user', { userName, appName, ...this.identity }).then(() => undefined);
    }
    /**
     * Removes the application’s icon from the tray.
     * @return {Promise.<void>}
     * @tutorial Application.removeTrayIcon
     */
    removeTrayIcon() {
        return this.wire.sendAction('remove-tray-icon', this.identity).then(() => undefined);
    }
    /**
     * Restarts the application.
     * @return {Promise.<void>}
     * @tutorial Application.restart
     */
    restart() {
        return this.wire.sendAction('restart-application', this.identity).then(() => undefined);
    }
    /**
     * DEPRECATED method to run the application.
     * Needed when starting application via {@link Application.create}, but NOT needed when starting via {@link Application.start}.
     * @return {Promise.<void>}
     * @tutorial Application.run
     * @ignore
     */
    run() {
        console.warn('Deprecation Warning: Application.run is deprecated Please use fin.Application.start');
        this.wire.sendAction('application-run', this.identity).catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return this._run();
    }
    _run(opts = {}) {
        return this.wire
            .sendAction('run-application', {
            manifestUrl: this._manifestUrl,
            opts,
            ...this.identity
        })
            .then(() => undefined);
    }
    /**
     * Instructs the RVM to schedule one restart of the application.
     * @return {Promise.<void>}
     * @tutorial Application.scheduleRestart
     */
    scheduleRestart() {
        return this.wire.sendAction('relaunch-on-close', this.identity).then(() => undefined);
    }
    /**
     * Sends a message to the RVM to upload the application's logs. On success,
     * an object containing logId is returned.
     * @return {Promise.<LogInfo>}
     * @tutorial Application.sendApplicationLog
     */
    async sendApplicationLog() {
        const { payload } = await this.wire.sendAction('send-application-log', this.identity);
        return payload.data;
    }
    /**
     * Sets or removes a custom JumpList for the application. Only applicable in Windows OS.
     * If categories is null the previously set custom JumpList (if any) will be replaced by the standard JumpList for the app (managed by Windows).
     * Note: If the "name" property is omitted it defaults to "tasks".
     * @param { Array.<JumpListCategory> | null } jumpListCategories An array of JumpList Categories to populate. If null, remove any existing JumpList configuration and set to Windows default.
     * @return { Promise.<void> }
     * @tutorial Application.setJumpList
     */
    async setJumpList(jumpListCategories) {
        await this.wire.sendAction('set-jump-list', { config: jumpListCategories, ...this.identity });
    }
    /**
     * Adds a customizable icon in the system tray.  To listen for a click on the icon use the `tray-icon-clicked` event.
     * @param { string } icon Image URL or base64 encoded string to be used as the icon
     * @return {Promise.<void>}
     * @tutorial Application.setTrayIcon
     */
    setTrayIcon(icon) {
        return this.wire
            .sendAction('set-tray-icon', {
            enabledIcon: icon,
            ...this.identity
        })
            .then(() => undefined);
    }
    /**
     * Sets new application's shortcut configuration. Windows only.
     * @param { ShortCutConfig } config New application's shortcut configuration.
     * @param { boolean } [config.desktop] - Enable/disable desktop shortcut.
     * @param { boolean } [config.startMenu] - Enable/disable start menu shortcut.
     * @param { boolean } [config.systemStartup] - Enable/disable system startup shortcut.
     * @return {Promise.<void>}
     * @tutorial Application.setShortcuts
     */
    setShortcuts(config) {
        return this.wire.sendAction('set-shortcuts', { data: config, ...this.identity }).then(() => undefined);
    }
    /**
     * Sets the query string in all shortcuts for this app. Requires RVM 5.5+.
     * @param { string } queryString The new query string for this app's shortcuts.
     * @return {Promise.<void>}
     * @tutorial Application.setShortcutQueryParams
     */
    async setShortcutQueryParams(queryString) {
        await this.wire.sendAction('set-shortcut-query-args', { data: queryString, ...this.identity });
    }
    /**
     * Sets the zoom level of the application. The original size is 0 and each increment above or below represents zooming 20%
     * larger or smaller to default limits of 300% and 50% of original size, respectively.
     * @param { number } level The zoom level
     * @return {Promise.<void>}
     * @tutorial Application.setZoomLevel
     */
    setZoomLevel(level) {
        return this.wire.sendAction('set-application-zoom-level', { level, ...this.identity }).then(() => undefined);
    }
    /**
     * Sets a username to correlate with App Log Management.
     * @param { string } username Username to correlate with App's Log.
     * @return {Promise.<void>}
     * @tutorial Application.setAppLogUsername
     */
    async setAppLogUsername(username) {
        await this.wire.sendAction('set-app-log-username', { data: username, ...this.identity });
    }
    /**
     * @summary Retrieves information about the system tray.
     * @desc The only information currently returned is the position and dimensions.
     * @return {Promise.<TrayInfo>}
     * @tutorial Application.getTrayIconInfo
     */
    getTrayIconInfo() {
        return this.wire.sendAction('get-tray-icon-info', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Closes the application by terminating its process.
     * @return {Promise.<void>}
     * @tutorial Application.terminate
     */
    terminate() {
        return this.wire.sendAction('terminate-application', this.identity).then(() => undefined);
    }
    /**
     * Waits for a hanging application. This method can be called in response to an application
     * "not-responding" to allow the application to continue and to generate another "not-responding"
     * message after a certain period of time.
     * @return {Promise.<void>}
     * @ignore
     */
    wait() {
        return this.wire.sendAction('wait-for-hung-application', this.identity).then(() => undefined);
    }
    /**
     * Retrieves information about the application.
     * @return {Promise.<ApplicationInfo>}
     * @tutorial Application.getInfo
     */
    getInfo() {
        return this.wire.sendAction('get-info', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Retrieves all process information for entities (windows and views) associated with an application.
     * @return {Promise.<AppProcessInfo>}
     * @tutorial Application.getProcessInfo
     * @experimental
     */
    async getProcessInfo() {
        const { payload: { data } } = await this.wire.sendAction('application-get-process-info', this.identity);
        return data;
    }
    /**
     * Sets file auto download location.
     * @param { string } downloadLocation file auto download location
     * @return {Promise.<void>}
     * @tutorial Application.setFileDownloadLocation
     */
    async setFileDownloadLocation(downloadLocation) {
        await this.wire.sendAction('set-file-download-location', { downloadLocation, ...this.identity });
    }
}
exports.Application = Application;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/application/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/application/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Factory_1 = __webpack_require__(/*! ./Factory */ "./node_modules/openfin-adapter/src/api/application/Factory.js");
__exportStar(__webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/application/Instance.js"), exports);
exports["default"] = Factory_1.default;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/base.js":
/*!******************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/base.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Reply = exports.EmitterBase = exports.Base = void 0;
const promises_1 = __webpack_require__(/*! ../util/promises */ "./node_modules/openfin-adapter/src/util/promises.js");
const fin_store_1 = __webpack_require__(/*! ../transport/fin_store */ "./node_modules/openfin-adapter/src/transport/fin_store.js");
class Base {
    constructor(wire) {
        this.isNodeEnvironment = () => {
            return this.wire.environment.constructor.name === 'NodeEnvironment';
        };
        this.isOpenFinEnvironment = () => {
            return this.wire.environment.constructor.name === 'OpenFinEnvironment';
        };
        this.wire = wire;
    }
    get fin() {
        return fin_store_1.getFin(this.wire);
    }
    get topic() {
        return this._topic || this.constructor.name.replace('_', '').toLowerCase();
    }
    set topic(t) {
        this._topic = t;
    }
    get me() {
        return this.wire.me;
    }
}
exports.Base = Base;
class EmitterBase extends Base {
    constructor(wire, emitterAccessor) {
        super(wire);
        this.emitterAccessor = emitterAccessor;
        this.eventNames = () => (this.hasEmitter() ? this.getOrCreateEmitter().eventNames() : []);
        this.emit = (eventName, payload, ...args) => {
            return this.hasEmitter() ? this.getOrCreateEmitter().emit(eventName, payload, ...args) : false;
        };
        this.hasEmitter = () => this.wire.eventAggregator.has(this.emitterAccessor);
        this.getOrCreateEmitter = () => this.wire.eventAggregator.getOrCreate(this.emitterAccessor);
        this.listeners = (type) => this.hasEmitter() ? this.getOrCreateEmitter().listeners(type) : [];
        this.listenerCount = (type) => this.hasEmitter() ? this.getOrCreateEmitter().listenerCount(type) : 0;
        this.registerEventListener = async (eventType, options = {}, applySubscription, undoSubscription) => {
            const runtimeEvent = {
                ...this.identity,
                timestamp: options.timestamp || Date.now(),
                topic: this.topic,
                type: eventType
            };
            const emitter = this.getOrCreateEmitter();
            // We apply the subscription and then undo if the async call fails to avoid
            // indeterminacy in subscription application order, which can break things elsewhere
            applySubscription(emitter);
            try {
                await this.wire.sendAction('subscribe-to-desktop-event', runtimeEvent);
            }
            catch (e) {
                undoSubscription(emitter);
                this.deleteEmitterIfNothingRegistered(emitter);
                throw e;
            }
        };
        this.deregisterEventListener = async (eventType, options = {}) => {
            if (this.hasEmitter()) {
                const runtimeEvent = {
                    ...this.identity,
                    timestamp: options.timestamp || Date.now(),
                    topic: this.topic,
                    type: eventType
                };
                await this.wire.sendAction('unsubscribe-to-desktop-event', runtimeEvent).catch(() => null);
                const emitter = this.getOrCreateEmitter();
                return emitter;
            }
            // This will only be reached if unsubscribe from event that does not exist but do not want to error here
            return Promise.resolve();
        };
        this.on = async (eventType, listener, options) => {
            await this.registerEventListener(eventType, options, (emitter) => {
                emitter.on(eventType, listener);
            }, (emitter) => {
                emitter.removeListener(eventType, listener);
            });
            return this;
        };
        this.addListener = this.on;
        this.once = async (eventType, listener, options) => {
            const deregister = () => this.deregisterEventListener(eventType);
            await this.registerEventListener(eventType, options, (emitter) => {
                emitter.once(eventType, deregister);
                emitter.once(eventType, listener);
            }, (emitter) => {
                emitter.removeListener(eventType, deregister);
                emitter.removeListener(eventType, listener);
            });
            return this;
        };
        this.prependListener = async (eventType, listener, options) => {
            await this.registerEventListener(eventType, options, (emitter) => {
                emitter.prependListener(eventType, listener);
            }, (emitter) => {
                emitter.removeListener(eventType, listener);
            });
            return this;
        };
        this.prependOnceListener = async (eventType, listener, options) => {
            const deregister = () => this.deregisterEventListener(eventType);
            await this.registerEventListener(eventType, options, (emitter) => {
                emitter.prependOnceListener(eventType, listener);
                emitter.once(eventType, deregister);
            }, (emitter) => {
                emitter.removeListener(eventType, listener);
                emitter.removeListener(eventType, deregister);
            });
            return this;
        };
        this.removeListener = async (eventType, listener, options) => {
            const emitter = await this.deregisterEventListener(eventType, options);
            if (emitter) {
                emitter.removeListener(eventType, listener);
                this.deleteEmitterIfNothingRegistered(emitter);
            }
            return this;
        };
        this.deregisterAllListeners = async (eventType) => {
            const runtimeEvent = { ...this.identity, type: eventType, topic: this.topic };
            if (this.hasEmitter()) {
                const emitter = this.getOrCreateEmitter();
                const refCount = emitter.listenerCount(runtimeEvent.type);
                const unsubscribePromises = [];
                for (let i = 0; i < refCount; i++) {
                    unsubscribePromises.push(this.wire.sendAction('unsubscribe-to-desktop-event', runtimeEvent).catch(() => null));
                }
                await Promise.all(unsubscribePromises);
                return emitter;
            }
            return undefined;
        };
        this.removeAllListeners = async (eventType) => {
            const removeByEvent = async (event) => {
                const emitter = await this.deregisterAllListeners(event);
                if (emitter) {
                    emitter.removeAllListeners(event);
                    this.deleteEmitterIfNothingRegistered(emitter);
                }
            };
            if (eventType) {
                await removeByEvent(eventType);
            }
            else if (this.hasEmitter()) {
                const events = this.getOrCreateEmitter().eventNames();
                await promises_1.promiseMap(events, removeByEvent);
            }
            return this;
        };
        this.listeners = (event) => this.hasEmitter() ? this.getOrCreateEmitter().listeners(event) : [];
    }
    deleteEmitterIfNothingRegistered(emitter) {
        if (emitter.eventNames().length === 0) {
            this.wire.eventAggregator.delete(this.emitterAccessor);
        }
    }
}
exports.EmitterBase = EmitterBase;
class Reply {
}
exports.Reply = Reply;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/clipboard/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/clipboard/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
/**
 * WriteRequestType interface
 * @typedef { object } WriteRequestType
 * @property { string } data Data to be written
 * @property { string } [type] Clipboard Type
 */
/**
 * The Clipboard API allows reading and writing to the clipboard in multiple formats.
 * @namespace
 */
class Clipboard extends base_1.Base {
    /**
     * Writes data into the clipboard as plain text
     * @param { WriteRequestType } writeObj This object is described in the WriteRequestType typeof
     * @return {Promise.<void>}
     * @tutorial Clipboard.writeText
     */
    writeText(writeObj) {
        return this.wire.sendAction('clipboard-write-text', writeObj).then(() => undefined);
    }
    /**
     * Read the content of the clipboard as plain text
     * @param { string } type Clipboard Type
     * @return {Promise.<string>}
     * @tutorial Clipboard.readText
     */
    readText(type) {
        return this.wire.sendAction('clipboard-read-text', type).then(({ payload }) => payload.data);
    }
    /**
     * Writes data into the clipboard as Html
     * @param { WriteRequestType } writeObj This object is described in the WriteRequestType typedef
     * @return {Promise.<void>}
     * @tutorial Clipboard.writeHtml
     */
    writeHtml(writeObj) {
        return this.wire.sendAction('clipboard-write-html', writeObj).then(() => undefined);
    }
    /**
     * Read the content of the clipboard as Html
     * @param { string } type Clipboard Type
     * @return {Promise.<string>}
     * @tutorial Clipboard.readHtml
     */
    readHtml(type) {
        return this.wire.sendAction('clipboard-read-html', type).then(({ payload }) => payload.data);
    }
    /**
     * Writes data into the clipboard as Rtf
     * @param { WriteRequestType } writeObj This object is described in the WriteRequestType typedef
     * @return {Promise.<void>}
     * @tutorial Clipboard.writeRtf
     */
    writeRtf(writeObj) {
        return this.wire.sendAction('clipboard-write-rtf', writeObj).then(() => undefined);
    }
    /**
     * Read the content of the clipboard as Rtf
     * @param { string } type Clipboard Type
     * @return {Promise.<string>}
     * @tutorial Clipboard.readRtf
     */
    readRtf(type) {
        return this.wire.sendAction('clipboard-read-rtf', type).then(({ payload }) => payload.data);
    }
    /**
     * Writes data into the clipboard
     * @param { WriteAnyRequestType } writeObj This object is described in the WriteAnyRequestType typedef
     * @return {Promise.<void>}
     * @tutorial Clipboard.write
     */
    write(writeObj) {
        return this.wire.sendAction('clipboard-write', writeObj).then(() => undefined);
    }
    /**
     * Reads available formats for the clipboard type
     * @param { string } type Clipboard Type
     * @return {Promise.Array.<string>}
     * @tutorial Clipboard.getAvailableFormats
     */
    getAvailableFormats(type) {
        return this.wire.sendAction('clipboard-read-formats', type).then(({ payload }) => payload.data);
    }
}
exports["default"] = Clipboard;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/events/emitterMap.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/events/emitterMap.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmitterMap = void 0;
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
class EmitterMap {
    constructor() {
        this.storage = new Map();
    }
    // eslint-disable-next-line class-methods-use-this
    hashKeys(keys) {
        const hashed = keys.map(normalizeString);
        return hashed.join('/');
    }
    getOrCreate(keys) {
        const hash = this.hashKeys(keys);
        if (!this.storage.has(hash)) {
            this.storage.set(hash, new events_1.EventEmitter());
        }
        // We set it above
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.storage.get(hash);
    }
    has(keys) {
        return this.storage.has(this.hashKeys(keys));
    }
    delete(keys) {
        const hash = this.hashKeys(keys);
        return this.storage.delete(hash);
    }
}
exports.EmitterMap = EmitterMap;
function normalizeString(s) {
    const b = Buffer.from(s);
    return b.toString('base64');
}


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/events/eventAggregator.js":
/*!************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/events/eventAggregator.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const emitterMap_1 = __webpack_require__(/*! ./emitterMap */ "./node_modules/openfin-adapter/src/api/events/emitterMap.js");
function isEventMessage(message) {
    return message.action === 'process-desktop-event';
}
function isNotificationMessage(message) {
    return message.action === 'process-notification-event';
}
const buildLocalPayload = (rawPayload) => {
    const { payload: { message }, type } = rawPayload;
    const payload = {};
    switch (type) {
        case 'message':
            payload.message = message;
            break;
        case 'show':
        case 'error':
        case 'click':
        case 'close':
        default:
            break;
    }
    return payload;
};
function mapKeyFromEvent(event) {
    const { topic } = event;
    if (topic === 'frame') {
        const { uuid, name } = event;
        return [topic, uuid, name];
    }
    if (topic === 'window') {
        const { uuid, name } = event;
        return [topic, uuid, name];
    }
    if (topic === 'application') {
        const { uuid } = event;
        return [topic, uuid];
    }
    if (topic === 'external-window') {
        const { uuid } = event;
        return [topic, uuid];
    }
    if (topic === 'view') {
        const { uuid, name } = event;
        return [topic, uuid, name];
    }
    return [topic];
}
class EventAggregator extends emitterMap_1.EmitterMap {
    constructor() {
        super(...arguments);
        this.dispatchEvent = (message) => {
            if (isEventMessage(message)) {
                const { payload } = message;
                const accessor = mapKeyFromEvent(payload);
                if (this.has(accessor)) {
                    this.getOrCreate(accessor).emit(payload.type, payload);
                    return true;
                }
            }
            else if (isNotificationMessage(message)) {
                const { payload: { notificationId }, type } = message.payload;
                const accessor = ['notification', `${notificationId}`];
                if (this.has(accessor)) {
                    this.getOrCreate(accessor).emit(type, buildLocalPayload(message.payload));
                    return true;
                }
            }
            return false;
        };
    }
}
exports["default"] = EventAggregator;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/external-application/Factory.js":
/*!******************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/external-application/Factory.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const Instance_1 = __webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/external-application/Instance.js");
/**
 * @lends ExternalApplication
 */
class ExternalApplicationModule extends base_1.Base {
    /**
     * Asynchronously returns an External Application object that represents an external application.
     * <br>It is possible to wrap a process that does not yet exist, (for example, to listen for startup-related events)
     * provided its uuid is already known.
     * @param {string} uuid The UUID of the external application to be wrapped
     * @return {Promise.<ExternalApplication>}
     * @tutorial ExternalApplication.wrap
     * @static
     */
    wrap(uuid) {
        this.wire.sendAction('external-application-wrap').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return Promise.resolve(new Instance_1.ExternalApplication(this.wire, { uuid }));
    }
    /**
     * Synchronously returns an External Application object that represents an external application.
     * <br>It is possible to wrap a process that does not yet exist, (for example, to listen for startup-related events)
     * provided its uuid is already known.
     * @param {string} uuid The UUID of the external application to be wrapped
     * @return {ExternalApplication}
     * @tutorial ExternalApplication.wrapSync
     * @static
     */
    wrapSync(uuid) {
        this.wire.sendAction('external-application-wrap-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return new Instance_1.ExternalApplication(this.wire, { uuid });
    }
}
exports["default"] = ExternalApplicationModule;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/external-application/Instance.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/external-application/Instance.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExternalApplication = void 0;
/* eslint-disable import/prefer-default-export */
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
/**
 * @classdesc An ExternalApplication object representing native language adapter connections to the runtime. Allows
 * the developer to listen to <a href="tutorial-ExternalApplication.EventEmitter.html">application events.</a>
 * Discovery of connections is provided by <a href="tutorial-System.getAllExternalApplications.html">getAllExternalApplications.</a>
 *
 * Processes that can be wrapped as `ExternalApplication`s include the following:
 * - Processes which have connected to an OpenFin runtime via an adapter
 * - Processes started via `System.launchExternalApplication`
 * - Processes monitored via `System.monitorExternalProcess`
 * @class
 * @hideconstructor
 */
class ExternalApplication extends base_1.EmitterBase {
    constructor(wire, identity) {
        super(wire, ['external-application', identity.uuid]);
        this.identity = identity;
    }
    /**
     * Adds a listener to the end of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - Called whenever an event of the specified type occurs.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function addListener
     * @memberof ExternalApplication
     * @instance
     * @tutorial ExternalApplication.EventEmitter
     */
    /**
     * Adds a listener to the end of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - Called whenever an event of the specified type occurs.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function on
     * @memberof ExternalApplication
     * @instance
     * @tutorial ExternalApplication.EventEmitter
     */
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function once
     * @memberof ExternalApplication
     * @instance
     * @tutorial ExternalApplication.EventEmitter
     */
    /**
     * Adds a listener to the beginning of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function prependListener
     * @memberof ExternalApplication
     * @instance
     * @tutorial ExternalApplication.EventEmitter
     */
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.
     * The listener is added to the beginning of the listeners array.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function prependOnceListener
     * @memberof ExternalApplication
     * @instance
     * @tutorial ExternalApplication.EventEmitter
     */
    /**
     * Remove a listener from the listener array for the specified event.
     * Caution: Calling this method changes the array indices in the listener array behind the listener.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function removeListener
     * @memberof ExternalApplication
     * @instance
     * @tutorial ExternalApplication.EventEmitter
     */
    /**
     * Removes all listeners, or those of the specified event.
     * @param { string | symbol } [eventType]  - The type of the event.
     * @return {Promise.<this>}
     * @function removeAllListeners
     * @memberof ExternalApplication
     * @instance
     * @tutorial ExternalApplication.EventEmitter
     */
    /**
     * Retrieves information about the external application.
     * @return {Promise.<ExternalApplicationInfo>}
     * @tutorial ExternalApplication.getInfo
     */
    getInfo() {
        return this.wire.sendAction('get-external-application-info', this.identity).then(({ payload }) => payload.data);
    }
}
exports.ExternalApplication = ExternalApplication;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/external-application/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/external-application/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Factory_1 = __webpack_require__(/*! ./Factory */ "./node_modules/openfin-adapter/src/api/external-application/Factory.js");
exports["default"] = Factory_1.default;
__exportStar(__webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/external-application/Instance.js"), exports);


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/external-window/Factory.js":
/*!*************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/external-window/Factory.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const Instance_1 = __webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/external-window/Instance.js");
/**
 * @lends ExternalWindow
 */
class ExternalWindowModule extends base_1.Base {
    /**
     * Asynchronously returns an external window object that represents
     * an existing external window.<br>
     * Note: This method is restricted by default and must be enabled via
     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>.
     * @param { ExternalWindowIdentity } identity
     * @return {Promise.<ExternalWindow>}
     * @static
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial ExternalWindow.wrap
     */
    async wrap(identity) {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const response = await this.wire.sendAction('register-native-external-window', identity);
        // Allow core to provide uuid if none is provided by user,
        // or nativeId when wrapping via a uuid obtained from `launchExternalProcess`
        const identityFromCore = response.payload.data;
        return new Instance_1.ExternalWindow(this.wire, identityFromCore);
    }
}
exports["default"] = ExternalWindowModule;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/external-window/Instance.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/external-window/Instance.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExternalWindow = void 0;
/* eslint-disable import/prefer-default-export */
const window_1 = __webpack_require__(/*! ../window */ "./node_modules/openfin-adapter/src/api/window/index.js");
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
/**
 * @classdesc An ExternalWindow is an OpenFin object representing a window that belongs to a non-openfin application.<br>
 * While External Windows don't have the complete functionality of an OpenFin Window object,
 * they can be used to tap into any application that is currently running in the OS.<br>
 * External Windows are useful for grouping, moving and resizing non-openfin applications
 * as well as listening to events that are dispatched by these applications.<br>
 * They are also compatible with OpenFin's Layouts service to facilitate
 * complete positional control over all running applications.<br>
 * External Windows has the ability to listen for <a href="tutorial-ExternalWindow.EventEmitter.html"> external window-specific events</a>.
 * @class
 * @alias ExternalWindow
 * @hideconstructor
 */
class ExternalWindow extends base_1.EmitterBase {
    constructor(wire, identity) {
        super(wire, ['external-window', identity.uuid]);
        this.identity = identity;
        this.topic = 'external-window';
    }
    /**
     * Brings the external window to the front of the window stack.
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.bringToFront
     */
    async bringToFront() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('bring-external-window-to-front', this.identity);
    }
    /**
     * Closes the external window.
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.close
     */
    async close() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('close-external-window', this.identity);
        Object.setPrototypeOf(this, null);
    }
    /**
     * Flashes the external window’s frame and taskbar icon until stopFlashing is called.
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.flash
     */
    async flash() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('flash-external-window', this.identity);
    }
    /**
     * Gives focus to the external window.
     * @return {Promise.<void>}
     * @emits ExternalWindow#focused
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.focus
     */
    async focus() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('focus-external-window', this.identity);
    }
    /**
     * Gets the current bounds (top, left, etc.) of the external window.
     * @return {Promise.<Bounds>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.getBounds
     */
    async getBounds() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const { payload: { data } } = await this.wire.sendAction('get-external-window-bounds', this.identity);
        return data;
    }
    /**
     * Retrieves an array containing wrapped external windows that are grouped
     * with this external window. If a window is not in a group an empty array
     * is returned.
     * @return {Promise.<Array<ExternalWindow|_Window>>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.getGroup
     */
    async getGroup() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const { payload: { data } } = await this.wire.sendAction('get-external-window-group', this.identity);
        if (!data.length) {
            return [];
        }
        return data.map(({ uuid, name, isExternalWindow }) => {
            if (isExternalWindow) {
                return new ExternalWindow(this.wire, { uuid });
            }
            return new window_1._Window(this.wire, { uuid, name });
        });
    }
    /**
     * Gets an information object for the window.
     * @return {Promise.<any>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.getInfo
     */
    async getInfo() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const { payload: { data } } = await this.wire.sendAction('get-external-window-info', this.identity);
        return data;
    }
    /**
     * Gets an external window's options.
     * @return {Promise.<any>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.getOptions
     */
    async getOptions() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const { payload: { data } } = await this.wire.sendAction('get-external-window-options', this.identity);
        return data;
    }
    /**
     * Gets the current state ("minimized", "maximized", or "restored") of
     * the external window.
     * @return {Promise.<string>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.getState
     */
    async getState() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const { payload: { data } } = await this.wire.sendAction('get-external-window-state', this.identity);
        return data;
    }
    /**
     * Hides the external window.
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.hide
     */
    async hide() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('hide-external-window', this.identity);
    }
    /**
     * Determines if the external window is currently showing.
     * @return {Promise.<boolean>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.isShowing
     */
    async isShowing() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const { payload: { data } } = await this.wire.sendAction('is-external-window-showing', this.identity);
        return data;
    }
    /**
     * Joins the same window group as the specified window. Currently unsupported (method will nack).
     * @param { _Window | ExternalWindow } target The window whose group is to be joined
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.joinGroup
     */
    async joinGroup(target) {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const { identity: { uuid, name } } = target;
        const targetIdentity = { groupingUuid: uuid, groupingWindowName: name };
        const payload = { ...this.identity, ...targetIdentity };
        await this.wire.sendAction('join-external-window-group', payload);
    }
    /**
     * Leaves the current window group so that the window can be moved
     * independently of those in the group.
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.leaveGroup
     */
    async leaveGroup() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('leave-external-window-group', this.identity);
    }
    /**
     * Maximizes the external window.
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.maximize
     */
    async maximize() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('maximize-external-window', this.identity);
    }
    /**
     * Merges the instance's window group with the same window group as the specified window
     * @param { _Window | ExternalWindow } target The window whose group is to be merged with
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.mergeGroups
     */
    async mergeGroups(target) {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const { identity: { uuid, name } } = target;
        const targetIdentity = { groupingUuid: uuid, groupingWindowName: name };
        const payload = { ...this.identity, ...targetIdentity };
        await this.wire.sendAction('merge-external-window-groups', payload);
    }
    /**
     * Minimizes the external window.
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.minimize
     */
    async minimize() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('minimize-external-window', this.identity);
    }
    /**
     * Moves the external window by a specified amount.
     * @param { number } deltaLeft The change in the left position of the window
     * @param { number } deltaTop The change in the top position of the window
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.moveBy
     */
    async moveBy(deltaLeft, deltaTop) {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const payload = { ...this.identity, deltaLeft, deltaTop };
        await this.wire.sendAction('move-external-window-by', payload);
    }
    /**
     * Moves the external window to a specified location.
     * @param { number } left The left position of the window
     * @param { number } top The top position of the window
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.moveTo
     */
    async moveTo(left, top) {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const payload = { ...this.identity, left, top };
        await this.wire.sendAction('move-external-window', payload);
    }
    /**
     * Resizes the external window by a specified amount.
     * @param { number } deltaWidth The change in the width of the window
     * @param { number } deltaHeight The change in the height of the window
     * @param { AnchorType } anchor Specifies a corner to remain fixed during the resize.
     * Can take the values: "top-left", "top-right", "bottom-left", or "bottom-right".
     * If undefined, the default is "top-left".
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.resizeBy
     */
    async resizeBy(deltaWidth, deltaHeight, anchor) {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const payload = {
            ...this.identity,
            anchor,
            deltaHeight: Math.floor(deltaHeight),
            deltaWidth: Math.floor(deltaWidth)
        };
        await this.wire.sendAction('resize-external-window-by', payload);
    }
    /**
     * Resizes the external window to the specified dimensions.
     * @param { number } width The change in the width of the window
     * @param { number } height The change in the height of the window
     * @param { AnchorType } anchor Specifies a corner to remain fixed during the resize.
     * Can take the values: "top-left", "top-right", "bottom-left", or "bottom-right".
     * If undefined, the default is "top-left".
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.resizeTo
     */
    async resizeTo(width, height, anchor) {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const payload = {
            ...this.identity,
            anchor,
            height: Math.floor(height),
            width: Math.floor(width)
        };
        await this.wire.sendAction('resize-external-window', payload);
    }
    /**
     * Restores the external window to its normal state (i.e. unminimized, unmaximized).
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.restore
     */
    async restore() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('restore-external-window', this.identity);
    }
    /**
     * Will bring the external window to the front of the entire stack and
     * give it focus.
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.setAsForeground
     */
    async setAsForeground() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('set-external-window-as-foreground', this.identity);
    }
    /**
     * Sets the external window's size and position.
     * @property { Bounds } bounds
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.setBounds
     */
    async setBounds(bounds) {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const payload = { ...this.identity, ...bounds };
        await this.wire.sendAction('set-external-window-bounds', payload);
    }
    /**
     * Shows the external window if it is hidden.
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.show
     */
    async show() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('show-external-window', this.identity);
    }
    /**
     * Shows the external window, if it is hidden, at the specified location.
     * If the toggle parameter is set to true, the external window will
     * alternate between showing and hiding.
     * @param { number } left The left position of the window
     * @param { number } top The top position of the window
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.showAt
     */
    async showAt(left, top) {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const payload = {
            ...this.identity,
            left: Math.floor(left),
            top: Math.floor(top)
        };
        await this.wire.sendAction('show-external-window-at', payload);
    }
    /**
     * Stops the taskbar icon from flashing.
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.stopFlashing
     */
    async stopFlashing() {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        await this.wire.sendAction('stop-external-window-flashing', this.identity);
    }
    /**
     * Updates the external window using the passed options
     * @param {*} options Changes an external window's options
     * @return {Promise.<void>}
     * @experimental
     * @deprecated All External Window APIs will be removed by major version 22.
     * @tutorial Window.updateOptions
     */
    async updateOptions(options) {
        console.warn('Deprecation Warning: All External Window APIs will be removed by major version 22.');
        const payload = { ...this.identity, options };
        await this.wire.sendAction('update-external-window-options', payload);
    }
}
exports.ExternalWindow = ExternalWindow;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/external-window/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/external-window/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Factory_1 = __webpack_require__(/*! ./Factory */ "./node_modules/openfin-adapter/src/api/external-window/Factory.js");
exports["default"] = Factory_1.default;
__exportStar(__webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/external-window/Instance.js"), exports);


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/fin.js":
/*!*****************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/fin.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
// Import from the file rather than the directory in case someone consuming types is using module resolution other than "node"
const index_1 = __webpack_require__(/*! ./system/index */ "./node_modules/openfin-adapter/src/api/system/index.js");
const index_2 = __webpack_require__(/*! ./window/index */ "./node_modules/openfin-adapter/src/api/window/index.js");
const index_3 = __webpack_require__(/*! ./application/index */ "./node_modules/openfin-adapter/src/api/application/index.js");
const index_4 = __webpack_require__(/*! ./interappbus/index */ "./node_modules/openfin-adapter/src/api/interappbus/index.js");
const index_5 = __webpack_require__(/*! ./notification/index */ "./node_modules/openfin-adapter/src/api/notification/index.js");
const index_6 = __webpack_require__(/*! ./clipboard/index */ "./node_modules/openfin-adapter/src/api/clipboard/index.js");
const index_7 = __webpack_require__(/*! ./external-application/index */ "./node_modules/openfin-adapter/src/api/external-application/index.js");
const index_8 = __webpack_require__(/*! ./external-window/index */ "./node_modules/openfin-adapter/src/api/external-window/index.js");
const index_9 = __webpack_require__(/*! ./frame/index */ "./node_modules/openfin-adapter/src/api/frame/index.js");
const index_10 = __webpack_require__(/*! ./global-hotkey/index */ "./node_modules/openfin-adapter/src/api/global-hotkey/index.js");
const index_11 = __webpack_require__(/*! ./view/index */ "./node_modules/openfin-adapter/src/api/view/index.js");
const index_12 = __webpack_require__(/*! ./platform/index */ "./node_modules/openfin-adapter/src/api/platform/index.js");
const me_1 = __webpack_require__(/*! ./me */ "./node_modules/openfin-adapter/src/api/me.js");
const fin_store_1 = __webpack_require__(/*! ../transport/fin_store */ "./node_modules/openfin-adapter/src/transport/fin_store.js");
const interop_1 = __webpack_require__(/*! ./interop */ "./node_modules/openfin-adapter/src/api/interop/index.js");
const snapshot_source_1 = __webpack_require__(/*! ./snapshot-source */ "./node_modules/openfin-adapter/src/api/snapshot-source/index.js");
class Fin extends events_1.EventEmitter {
    constructor(wire) {
        super();
        fin_store_1.registerFin(wire, this);
        this.wire = wire;
        this.System = new index_1.default(wire);
        this.Window = new index_2.default(wire);
        this.Application = new index_3.default(wire);
        this.InterApplicationBus = new index_4.default(wire);
        this.Notification = new index_5.default(wire);
        this.Clipboard = new index_6.default(wire);
        this.ExternalApplication = new index_7.default(wire);
        this.ExternalWindow = new index_8.default(wire);
        this.Frame = new index_9.default(wire);
        this.GlobalHotkey = new index_10.default(wire);
        this.Platform = new index_12.default(wire, this.InterApplicationBus.Channel);
        this.View = new index_11.default(wire);
        this.Interop = new interop_1.default(wire);
        this.SnapshotSource = new snapshot_source_1.default(wire);
        this.me = me_1.getMe(wire);
        // Handle disconnect events
        wire.on('disconnected', () => {
            this.emit('disconnected');
        });
    }
}
exports["default"] = Fin;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/frame/Factory.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/frame/Factory.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const validate_1 = __webpack_require__(/*! ../../util/validate */ "./node_modules/openfin-adapter/src/util/validate.js");
const Instance_1 = __webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/frame/Instance.js");
/**
 * @lends Frame
 */
class _FrameModule extends base_1.Base {
    /**
     * Asynchronously returns a reference to the specified frame. The frame does not have to exist
     * @param {Identity} identity - the identity of the frame you want to wrap
     * @return {Promise.<_Frame>}
     * @tutorial Frame.wrap
     * @static
     */
    async wrap(identity) {
        this.wire.sendAction('frame-wrap').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1._Frame(this.wire, identity);
    }
    /**
     * Synchronously returns a reference to the specified frame. The frame does not have to exist
     * @param {Identity} identity - the identity of the frame you want to wrap
     * @return {_Frame}
     * @tutorial Frame.wrapSync
     * @static
     */
    wrapSync(identity) {
        this.wire.sendAction('frame-wrap-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1._Frame(this.wire, identity);
    }
    /**
     * Asynchronously returns a reference to the current frame
     * @return {Promise.<_Frame>}
     * @tutorial Frame.getCurrent
     * @static
     */
    getCurrent() {
        this.wire.sendAction('frame-get-current').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return Promise.resolve(new Instance_1._Frame(this.wire, this.wire.environment.getCurrentEntityIdentity()));
    }
    /**
     * Synchronously returns a reference to the current frame
     * @return {_Frame}
     * @tutorial Frame.getCurrentSync
     * @static
     */
    getCurrentSync() {
        this.wire.sendAction('frame-get-current-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return new Instance_1._Frame(this.wire, this.wire.environment.getCurrentEntityIdentity());
    }
}
exports["default"] = _FrameModule;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/frame/Instance.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/frame/Instance.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._Frame = void 0;
/* eslint-disable import/prefer-default-export */
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
/**
 * @classdesc
 * An iframe represents an embedded HTML page within a parent HTML page. Because this embedded page
 * has its own DOM and global JS context (which may or may not be linked to that of the parent depending
 * on if it is considered out of the root domain or not), it represents a unique endpoint as an OpenFin
 * connection. Iframes may be generated dynamically, or be present on initial page load and each non-CORS
 * iframe has the OpenFin API injected by default. It is possible to opt into cross-origin iframes having
 * the API by setting api.iframe.crossOriginInjection to true in a window's options. To block all iframes
 * from getting the API injected you can set api.frame.sameOriginInjection
 * to false <a href="Window.html#~options" target="_blank">(see Window~options)</a>.
 *
 * To be able to directly address this context for eventing and messaging purposes, it needs a
 * unique uuid name pairing. For OpenFin applications and windows this is provided via a configuration
 * object in the form of a manifest URL or options object, but there is no configuration object for iframes.
 * Just as a call to window.open outside of our Window API returns a new window with a random GUID assigned
 * for the name, each iframe that has the API injected will be assigned a GUID as its name, the UUID will be
 * the same as the parent window's.
 *
 * The fin.Frame namespace represents a way to interact with `iframes` and facilitates the discovery of current context
 * (iframe or main window) as well as the ability to listen for <a href="tutorial-Frame.EventEmitter.html">frame-specific events</a>.
 * @class
 * @alias Frame
 * @hideconstructor
 */
class _Frame extends base_1.EmitterBase {
    constructor(wire, identity) {
        super(wire, ['frame', identity.uuid, identity.name]);
        this.identity = identity;
    }
    /**
     * Adds the listener function to the end of the listeners array for the specified event type.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - Called whenever an event of the specified type occurs.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function addListener
     * @memberof Frame
     * @instance
     * @tutorial Frame.EventEmitter
     */
    /**
     * Adds a listener to the end of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - Called whenever an event of the specified type occurs.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function on
     * @memberof Frame
     * @instance
     * @tutorial Frame.EventEmitter
     */
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function once
     * @memberof Frame
     * @instance
     * @tutorial Frame.EventEmitter
     */
    /**
     * Adds a listener to the beginning of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function prependListener
     * @memberof Frame
     * @instance
     * @tutorial Frame.EventEmitter
     */
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.
     * The listener is added to the beginning of the listeners array.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function prependOnceListener
     * @memberof Frame
     * @instance
     * @tutorial Frame.EventEmitter
     */
    /**
     * Remove a listener from the listener array for the specified event.
     * Caution: Calling this method changes the array indices in the listener array behind the listener.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function removeListener
     * @memberof Frame
     * @instance
     * @tutorial Frame.EventEmitter
     */
    /**
     * Removes all listeners, or those of the specified event.
     * @param { string | symbol } [eventType]  - The type of the event.
     * @return {Promise.<this>}
     * @function removeAllListeners
     * @memberof Frame
     * @instance
     * @tutorial Frame.EventEmitter
     */
    /**
     * Returns a frame info object for the represented frame
     * @return {Promise.<FrameInfo>}
     * @tutorial Frame.getInfo
     */
    getInfo() {
        return this.wire.sendAction('get-frame-info', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Returns a frame info object representing the window that the referenced iframe is
     * currently embedded in
     * @return {Promise.<FrameInfo>}
     * @tutorial Frame.getParentWindow
     */
    getParentWindow() {
        return this.wire.sendAction('get-parent-window', this.identity).then(({ payload }) => payload.data);
    }
}
exports._Frame = _Frame;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/frame/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/frame/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Factory_1 = __webpack_require__(/*! ./Factory */ "./node_modules/openfin-adapter/src/api/frame/Factory.js");
exports["default"] = Factory_1.default;
__exportStar(__webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/frame/Instance.js"), exports);


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/global-hotkey/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/global-hotkey/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nonHotkeyEvents = void 0;
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
var apiActions;
(function (apiActions) {
    apiActions["REGISTER"] = "global-hotkey-register";
    apiActions["UNREGISTER"] = "global-hotkey-unregister";
    apiActions["UNREGISTER_ALL"] = "global-hotkey-unregister-all";
    apiActions["IS_REGISTERED"] = "global-hotkey-is-registered";
})(apiActions || (apiActions = {}));
var nonHotkeyEvents;
(function (nonHotkeyEvents) {
    nonHotkeyEvents["REGISTERED"] = "registered";
    nonHotkeyEvents["UNREGISTERED"] = "unregistered";
})(nonHotkeyEvents = exports.nonHotkeyEvents || (exports.nonHotkeyEvents = {}));
/**
 * The GlobalHotkey module can register/unregister a global hotkeys.
 * @namespace
 */
class GlobalHotkey extends base_1.EmitterBase {
    constructor(wire) {
        super(wire, ['global-hotkey']);
        this.topic = 'global-hotkey';
    }
    /**
     * Registers a global hotkey with the operating system.
     * @param { string } hotkey a hotkey string
     * @param { Function } listener called when the registered hotkey is pressed by the user.
     * @return {Promise.<void>}
     * @tutorial GlobalHotkey.register
     */
    async register(hotkey, listener) {
        await this.on(hotkey, listener);
        await this.wire.sendAction("global-hotkey-register" /* REGISTER */, { hotkey });
        return undefined;
    }
    /**
     * Unregisters a global hotkey with the operating system.
     * @param { string } hotkey a hotkey string
     * @return {Promise.<void>}
     * @tutorial GlobalHotkey.unregister
     */
    async unregister(hotkey) {
        await this.removeAllListeners(hotkey);
        await this.wire.sendAction("global-hotkey-unregister" /* UNREGISTER */, { hotkey });
        return undefined;
    }
    /**
     * Unregisters all global hotkeys for the current application.
     * @return {Promise.<void>}
     * @tutorial GlobalHotkey.unregisterAll
     */
    async unregisterAll() {
        await Promise.all(this.eventNames()
            .filter((name) => !(name === "registered" /* REGISTERED */ || name === "unregistered" /* UNREGISTERED */))
            .map((name) => this.removeAllListeners(name)));
        await this.wire.sendAction("global-hotkey-unregister-all" /* UNREGISTER_ALL */, {});
        return undefined;
    }
    /**
     * Checks if a given hotkey has been registered
     * @param { string } hotkey a hotkey string
     * @return {Promise.<boolean>}
     * @tutorial GlobalHotkey.isRegistered
     */
    async isRegistered(hotkey) {
        const { payload: { data } } = await this.wire.sendAction("global-hotkey-is-registered" /* IS_REGISTERED */, { hotkey });
        return data;
    }
}
exports["default"] = GlobalHotkey;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/interappbus/channel/channel.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/interappbus/channel/channel.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelBase = exports.ProtectedItems = void 0;
const idOrResult = (func) => (...args) => {
    const res = func(...args);
    return res === undefined ? args[1] : res;
};
class ProtectedItems {
    constructor(providerIdentity, send) {
        this.providerIdentity = providerIdentity;
        this.sendRaw = send;
        this.send = async (to, action, payload) => {
            const raw = await send('send-channel-message', {
                ...to,
                providerIdentity: this.providerIdentity,
                action,
                payload
            }).catch((reason) => {
                throw new Error(reason.message);
            });
            return raw.payload.data.result;
        };
    }
}
exports.ProtectedItems = ProtectedItems;
class ChannelBase {
    constructor(providerIdentity, send, channelProtectedMap) {
        this.defaultSet = false;
        this.subscriptions = new Map();
        this.defaultAction = (action, payload, id) => {
            throw new Error(`No action registered at target for ${action}`);
        };
        // The items in ProtectedItems are only used by subclass, but not exposed to public.
        // Use this way to avoid a malicious site to access them directly.
        channelProtectedMap.set(this, new ProtectedItems(providerIdentity, send));
    }
    async processAction(action, payload, senderIdentity) {
        try {
            const mainAction = this.subscriptions.has(action)
                ? this.subscriptions.get(action)
                : (currentPayload, id) => this.defaultAction(action, currentPayload, id);
            const preActionProcessed = this.preAction ? await this.preAction(action, payload, senderIdentity) : payload;
            const actionProcessed = await mainAction(preActionProcessed, senderIdentity);
            return this.postAction ? await this.postAction(action, actionProcessed, senderIdentity) : actionProcessed;
        }
        catch (e) {
            if (this.errorMiddleware) {
                return this.errorMiddleware(action, e, senderIdentity);
            }
            throw e;
        }
    }
    beforeAction(func) {
        if (this.preAction) {
            throw new Error('Already registered beforeAction middleware');
        }
        this.preAction = idOrResult(func);
    }
    onError(func) {
        if (this.errorMiddleware) {
            throw new Error('Already registered error middleware');
        }
        this.errorMiddleware = func;
    }
    afterAction(func) {
        if (this.postAction) {
            throw new Error('Already registered afterAction middleware');
        }
        this.postAction = idOrResult(func);
    }
    remove(action) {
        this.subscriptions.delete(action);
    }
    setDefaultAction(func) {
        if (this.defaultSet) {
            throw new Error('default action can only be set once');
        }
        else {
            this.defaultAction = func;
            this.defaultSet = true;
        }
    }
    register(topic, listener) {
        if (this.subscriptions.has(topic)) {
            throw new Error(`Subscription already registered for action: ${topic}. Unsubscribe before adding new subscription`);
        }
        else {
            this.subscriptions.set(topic, listener);
            return true;
        }
    }
}
exports.ChannelBase = ChannelBase;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/interappbus/channel/client.js":
/*!****************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/interappbus/channel/client.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const channel_1 = __webpack_require__(/*! ./channel */ "./node_modules/openfin-adapter/src/api/interappbus/channel/channel.js");
const clientProtectedMap = new WeakMap();
class ChannelClient extends channel_1.ChannelBase {
    constructor(routingInfo, send, clientMap) {
        super(routingInfo, send, clientProtectedMap);
        this.disconnectListener = () => undefined;
        this.clientMap = clientMap;
        this.endpointId = routingInfo.endpointId;
    }
    get providerIdentity() {
        const protectedObj = clientProtectedMap.get(this);
        return protectedObj.providerIdentity;
    }
    async dispatch(action, payload) {
        const protectedObj = clientProtectedMap.get(this);
        if (this.clientMap.get(this.endpointId)) {
            return protectedObj.send(protectedObj.providerIdentity, action, payload);
        }
        throw new Error('The client you are trying to dispatch from is disconnected from the target provider.');
    }
    onDisconnection(listener) {
        this.disconnectListener = (payload) => {
            try {
                listener(payload);
            }
            catch (err) {
                throw new Error(`Error while calling the onDisconnection callback: ${err.message}`);
            }
            finally {
                this.disconnectListener = () => undefined;
            }
        };
    }
    async disconnect() {
        const protectedObj = clientProtectedMap.get(this);
        const { channelName, uuid, name, channelId } = protectedObj.providerIdentity;
        await protectedObj.sendRaw('disconnect-from-channel', { channelName, uuid, name, endpointId: this.endpointId });
        this.removeChannel(channelId, this.endpointId);
    }
}
exports["default"] = ChannelClient;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/interappbus/channel/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/interappbus/channel/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Channel = void 0;
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/openfin-adapter/src/api/interappbus/channel/client.js");
const provider_1 = __webpack_require__(/*! ./provider */ "./node_modules/openfin-adapter/src/api/interappbus/channel/provider.js");
const base_1 = __webpack_require__(/*! ../../base */ "./node_modules/openfin-adapter/src/api/base.js");
class Channel extends base_1.EmitterBase {
    constructor(wire) {
        super(wire, ['channel']);
        this.onmessage = (msg) => {
            if (msg.action === 'process-channel-message') {
                this.processChannelMessage(msg);
                return true;
            }
            if (msg.action === 'process-channel-connection') {
                this.processChannelConnection(msg);
                return true;
            }
            return false;
        };
        this.topic = 'channel';
        this.providerMap = new Map();
        this.clientMap = new Map();
        this.endpointIdMap = new Map();
        wire.registerMessageHandler(this.onmessage.bind(this));
    }
    async getAllChannels() {
        return this.wire.sendAction('get-all-channels').then(({ payload }) => payload.data);
    }
    async onChannelConnect(listener) {
        await this.on('connected', listener);
    }
    async onChannelDisconnect(listener) {
        await this.on('disconnected', listener);
    }
    async connect(channelName, options) {
        if (!channelName || typeof channelName !== 'string') {
            throw new Error('Please provide a channelName string to connect to a channel.');
        }
        const opts = options || {};
        let resolver;
        let listener;
        const waitResponse = new Promise((resolve) => {
            resolver = resolve;
            listener = (payload) => {
                if (channelName === payload.channelName) {
                    this.removeListener('connected', listener);
                    this.connect(channelName, opts).then((response) => {
                        resolve(response);
                    });
                }
            };
            this.on('connected', listener);
        });
        try {
            const { payload: { data: routingInfo } } = await this.wire.sendAction('connect-to-channel', { channelName, ...opts });
            // Required for backwards compatibility
            if (!routingInfo.endpointId) {
                routingInfo.endpointId = this.wire.environment.getNextMessageId();
                // For New Clients connecting to Old Providers. To prevent multi-dispatching and publishing, we delete previously-connected
                // clients that are in the same context as the newly-connected client.
                this.checkForPreviousClientConnection(routingInfo.channelId);
            }
            const { channelId, endpointId } = routingInfo;
            // If there isn't a matching channel, the above sendAction call will error out and go to catch, skipping the logic below
            if (resolver) {
                resolver();
            }
            this.removeListener('connected', listener);
            const channel = new client_1.default(routingInfo, this.wire.sendAction.bind(this.wire), this.clientMap);
            this.addChannelToClientMaps(channel, channelId, endpointId);
            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
            // @ts-ignore use of protected property
            channel.removeChannel = this.removeChannelFromClientMaps.bind(this);
            this.on('disconnected', (eventPayload) => {
                if (eventPayload.channelName === channelName) {
                    this.removeChannelFromClientMaps(channelId, endpointId);
                    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
                    // @ts-ignore use of private property
                    channel.disconnectListener(eventPayload);
                }
            });
            return channel;
        }
        catch (e) {
            const shouldWait = { wait: true, ...opts }.wait;
            const internalNackMessage = 'internal-nack';
            if (shouldWait && e.message && e.message.includes(internalNackMessage)) {
                console.warn(`Channel not found for channelName: ${channelName}, waiting for channel creation.`);
                return waitResponse;
            }
            if (e.message === internalNackMessage) {
                throw new Error(`No channel found for channelName: ${channelName}`);
            }
            else {
                throw new Error(e);
            }
        }
    }
    async create(channelName) {
        if (!channelName) {
            throw new Error('Please provide a channelName to create a channel');
        }
        const { payload: { data: providerIdentity } } = await this.wire.sendAction('create-channel', { channelName });
        const channel = new provider_1.ChannelProvider(providerIdentity, this.wire.sendAction.bind(this.wire));
        const key = providerIdentity.channelId;
        this.providerMap.set(key, channel);
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore use of protected property
        channel.removeChannel = this.removeChannelFromProviderMap.bind(this);
        this.on('client-disconnected', (eventPayload) => {
            if (eventPayload.channelName === channelName) {
                let remainingConnections = channel.connections.filter((identity) => {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
                    // @ts-ignore use of non-existed property
                    return identity.endpointId === undefined || identity.endpointId !== eventPayload.endpointId;
                });
                if (remainingConnections.length === channel.connections.length) {
                    remainingConnections = channel.connections.filter((identity) => {
                        return identity.uuid !== eventPayload.uuid || identity.name !== eventPayload.name;
                    });
                }
                channel.connections = remainingConnections;
                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
                // @ts-ignore use of private property
                channel.disconnectListener(eventPayload);
            }
        });
        return channel;
    }
    addChannelToClientMaps(channel, channelId, endpointId) {
        this.clientMap.set(endpointId, channel);
        this.endpointIdMap.set(`${channelId}/${this.wire.me.uuid}/${this.wire.me.name}`, endpointId);
    }
    removeChannelFromClientMaps(channelId, endpointId) {
        this.clientMap.delete(endpointId);
        this.endpointIdMap.delete(`${channelId}/${this.wire.me.uuid}/${this.wire.me.name}`);
    }
    removeChannelFromProviderMap(channelId) {
        this.providerMap.delete(channelId);
    }
    checkForPreviousClientConnection(channelId) {
        const endpointIdFromPreviousConnection = this.endpointIdMap.get(`${channelId}/${this.wire.me.uuid}/${this.wire.me.name}`);
        if (endpointIdFromPreviousConnection) {
            this.removeChannelFromClientMaps(channelId, endpointIdFromPreviousConnection);
            console.warn('You have created a second connection to an older provider. First connection has been removed from the clientMap');
            console.warn('If the provider calls publish(), you may receive multiple messages.');
        }
    }
    async processChannelMessage(msg) {
        const { senderIdentity, providerIdentity, action, ackToSender, payload, intendedTargetIdentity } = msg.payload;
        let key;
        let bus;
        // If the sender is the client
        if (intendedTargetIdentity.channelId) {
            key = intendedTargetIdentity.channelId;
            bus = this.providerMap.get(key);
        }
        else if (intendedTargetIdentity.endpointId) {
            // If the sender is the provider
            key = intendedTargetIdentity.endpointId;
            bus = this.clientMap.get(key);
        }
        else {
            key = this.endpointIdMap.get(`${providerIdentity.channelId}/${this.wire.me.uuid}/${this.wire.me.name}`);
            bus = this.clientMap.get(key);
        }
        if (!bus) {
            ackToSender.payload.success = false;
            ackToSender.payload.reason = `Client connection with identity uuid: ${this.wire.me.uuid} / name: ${this.wire.me.name} no longer connected.`;
            return this.wire.sendRaw(ackToSender);
        }
        try {
            const res = await bus.processAction(action, payload, senderIdentity);
            ackToSender.payload.payload = ackToSender.payload.payload || {};
            ackToSender.payload.payload.result = res;
            return this.wire.sendRaw(ackToSender);
        }
        catch (e) {
            ackToSender.payload.success = false;
            ackToSender.payload.reason = e.message;
            return this.wire.sendRaw(ackToSender);
        }
    }
    async processChannelConnection(msg) {
        const { clientIdentity, providerIdentity, ackToSender, payload } = msg.payload;
        const key = providerIdentity.channelId;
        const bus = this.providerMap.get(key);
        if (!bus) {
            ackToSender.payload.success = false;
            ackToSender.payload.reason = `Channel "${providerIdentity.channelName}" has been destroyed.`;
            return this.wire.sendRaw(ackToSender);
        }
        try {
            if (!(bus instanceof provider_1.ChannelProvider)) {
                throw Error('Cannot connect to a channel client');
            }
            const res = await bus.processConnection(clientIdentity, payload);
            ackToSender.payload.payload = ackToSender.payload.payload || {};
            ackToSender.payload.payload.result = res;
            return this.wire.sendRaw(ackToSender);
        }
        catch (e) {
            ackToSender.payload.success = false;
            ackToSender.payload.reason = e.message;
            return this.wire.sendRaw(ackToSender);
        }
    }
}
exports.Channel = Channel;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/interappbus/channel/provider.js":
/*!******************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/interappbus/channel/provider.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelProvider = void 0;
const channel_1 = __webpack_require__(/*! ./channel */ "./node_modules/openfin-adapter/src/api/interappbus/channel/channel.js");
const runtimeVersioning_1 = __webpack_require__(/*! ../../../util/runtimeVersioning */ "./node_modules/openfin-adapter/src/util/runtimeVersioning.js");
const providerProtectedMap = new WeakMap();
class ChannelProvider extends channel_1.ChannelBase {
    constructor(providerIdentity, send) {
        super(providerIdentity, send, providerProtectedMap);
        this.connectListener = () => undefined;
        this.disconnectListener = () => undefined;
        this.connections = [];
    }
    dispatch(to, action, payload) {
        if (!ChannelProvider.clientIdentityIncludesEndpointId(to)) {
            this.checkForMultipleClients(to, action);
        }
        if (this.isClientConnected(to)) {
            return providerProtectedMap.get(this).send(to, action, payload);
        }
        return Promise.reject(new Error(`The client you are trying to dispatch to is disconnected from this provider.
                {uuid: ${to.uuid}, name: ${to.name}}`));
    }
    async processAction(action, payload, senderIdentity) {
        if (ChannelProvider.clientIsMultiRuntime(senderIdentity) &&
            !runtimeVersioning_1.runtimeUuidMeetsMinimumRuntimeVersion(senderIdentity.runtimeUuid, '18.87.56.0')) {
            this.handleMultiRuntimeLegacyClient(senderIdentity);
        }
        else {
            this.checkForClientConnection(senderIdentity);
        }
        return super.processAction(action, payload, senderIdentity);
    }
    async processConnection(senderId, payload) {
        this.connections.push(senderId);
        return this.connectListener(senderId, payload);
    }
    publish(action, payload) {
        return this.connections.map((to) => providerProtectedMap.get(this).send(to, action, payload));
    }
    onConnection(listener) {
        this.connectListener = listener;
    }
    onDisconnection(listener) {
        this.disconnectListener = listener;
    }
    async destroy() {
        const protectedObj = providerProtectedMap.get(this);
        const { channelName, channelId } = protectedObj.providerIdentity;
        this.connections = [];
        await protectedObj.sendRaw('destroy-channel', { channelName });
        this.removeChannel(channelId);
    }
    checkForClientConnection(clientIdentity) {
        if (!this.isClientConnected(clientIdentity)) {
            throw new Error(`This action was sent from a client that is not connected to the provider.
                    Client Identity: {uuid: ${clientIdentity.uuid}, name: ${clientIdentity.name}, endpointId: ${clientIdentity.endpointId}}`);
        }
    }
    isClientConnected(clientIdentity) {
        if (ChannelProvider.clientIdentityIncludesEndpointId(clientIdentity)) {
            return this.connections.some((identity) => {
                return (
                // Might be redundant to check for uuid and name here after we get an endpointId match, but just in case
                identity.endpointId === clientIdentity.endpointId &&
                    identity.uuid === clientIdentity.uuid &&
                    identity.name === clientIdentity.name);
            });
        }
        return this.isLegacyClientConnected(clientIdentity);
    }
    isLegacyClientConnected(clientIdentity) {
        return this.connections.some((identity) => {
            return identity.uuid === clientIdentity.uuid && identity.name === clientIdentity.name;
        });
    }
    handleMultiRuntimeLegacyClient(senderIdentity) {
        if (!this.isLegacyClientConnected(senderIdentity)) {
            throw new Error(`This action was sent from a client that is not connected to the provider. Client Identity:
                    {uuid: ${senderIdentity.uuid}, name: ${senderIdentity.name}, endpointId: ${senderIdentity.endpointId}}`);
        }
    }
    checkForMultipleClients(clientIdentity, action) {
        let count = 0;
        this.connections.forEach((c) => {
            if (c.name === clientIdentity.name && c.uuid === clientIdentity.uuid) {
                count += 1;
            }
        });
        if (count >= 2) {
            const protectedObj = providerProtectedMap.get(this);
            const { uuid, name } = clientIdentity;
            const providerUuid = protectedObj === null || protectedObj === void 0 ? void 0 : protectedObj.providerIdentity.uuid;
            const providerName = protectedObj === null || protectedObj === void 0 ? void 0 : protectedObj.providerIdentity.name;
            // eslint-disable-next-line no-console
            console.warn(`WARNING: Dispatch call may have unintended results. The "to" argument of your dispatch call is missing the
                "endpointId" parameter. The identity you are dispatching to ({uuid: ${uuid}, name: ${name}})
                has multiple channelClients for this channel. Your dispatched action: (${action}) from the provider:
                ({uuid: ${providerUuid}, name: ${providerName}}) will only be processed by the most recently-created client.`);
        }
    }
    // eslint-disable-next-line class-methods-use-this
    static clientIdentityIncludesEndpointId(subscriptionIdentity) {
        return subscriptionIdentity.endpointId !== undefined;
    }
    // eslint-disable-next-line class-methods-use-this
    static clientIsMultiRuntime(subscriptionIdentity) {
        return subscriptionIdentity.runtimeUuid !== undefined;
    }
}
exports.ChannelProvider = ChannelProvider;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/interappbus/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/interappbus/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InterAppPayload = void 0;
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const ref_counter_1 = __webpack_require__(/*! ../../util/ref-counter */ "./node_modules/openfin-adapter/src/util/ref-counter.js");
const index_1 = __webpack_require__(/*! ./channel/index */ "./node_modules/openfin-adapter/src/api/interappbus/channel/index.js");
const validate_1 = __webpack_require__(/*! ../../util/validate */ "./node_modules/openfin-adapter/src/util/validate.js");
/**
 * A messaging bus that allows for pub/sub messaging between different applications.
 * @namespace
 */
class InterApplicationBus extends base_1.Base {
    constructor(wire) {
        super(wire);
        this.events = {
            subscriberAdded: 'subscriber-added',
            subscriberRemoved: 'subscriber-removed'
        };
        this.refCounter = new ref_counter_1.default();
        this.Channel = new index_1.Channel(wire);
        this.emitter = new events_1.EventEmitter();
        wire.registerMessageHandler(this.onmessage.bind(this));
        this.on = this.emitter.on.bind(this.emitter);
        this.removeAllListeners = this.emitter.removeAllListeners.bind(this.emitter);
    }
    /**
     * Publishes a message to all applications running on OpenFin Runtime that
     * are subscribed to the specified topic.
     * @param { string } topic The topic on which the message is sent
     * @param { any } message The message to be published. Can be either a primitive
     * data type (string, number, or boolean) or composite data type (object, array)
     * that is composed of other primitive or composite data types
     * @return {Promise.<void>}
     * @tutorial InterApplicationBus.publish
     */
    publish(topic, message) {
        return this.wire
            .sendAction('publish-message', {
            topic,
            message,
            sourceWindowName: this.me.name
        })
            .then(() => undefined);
    }
    /**
     * Sends a message to a specific application on a specific topic.
     * @param { Identity } destination The identity of the application to which the message is sent
     * @param { string } topic The topic on which the message is sent
     * @param { any } message The message to be sent. Can be either a primitive data
     * type (string, number, or boolean) or composite data type (object, array) that
     * is composed of other primitive or composite data types
     * @return {Promise.<void>}
     * @tutorial InterApplicationBus.send
     */
    async send(destination, topic, message) {
        const errorMsg = validate_1.validateIdentity(destination);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        await this.wire.sendAction('send-message', {
            destinationUuid: destination.uuid,
            destinationWindowName: destination.name,
            topic,
            message,
            sourceWindowName: this.me.name
        });
    }
    /**
     * Subscribes to messages from the specified application on the specified topic.
     * @param { Identity } source This object is described in the Identity in the typedef
     * @param { string } topic The topic on which the message is sent
     * @param { function } listener A function that is called when a message has
     * been received. It is passed the message, uuid and name of the sending application.
     * The message can be either a primitive data type (string, number, or boolean) or
     * composite data type (object, array) that is composed of other primitive or composite
     * data types
     * @return {Promise.<void>}
     * @tutorial InterApplicationBus.subscribe
     */
    subscribe(source, topic, listener) {
        const subKey = this.createSubscriptionKey(source.uuid, source.name || '*', topic);
        const sendSubscription = () => {
            return this.wire.sendAction('subscribe', {
                sourceUuid: source.uuid,
                sourceWindowName: source.name || '*',
                topic,
                destinationWindowName: this.me.name
            });
        };
        const alreadySubscribed = () => {
            return Promise.resolve();
        };
        this.emitter.on(subKey, listener);
        return this.refCounter.actOnFirst(subKey, sendSubscription, alreadySubscribed);
    }
    /**
     * Unsubscribes to messages from the specified application on the specified topic.
     * @param { Identity } source This object is described in the Identity in the typedef
     * @param { string } topic The topic on which the message is sent
     * @param { function } listener A callback previously registered with subscribe()
     * @return {Promise.<void>}
     * @tutorial InterApplicationBus.unsubscribe
     */
    unsubscribe(source, topic, listener) {
        const subKey = this.createSubscriptionKey(source.uuid, source.name || '*', topic);
        const sendUnsubscription = () => {
            return this.wire.sendAction('unsubscribe', {
                sourceUuid: source.uuid,
                sourceWindowName: source.name || '*',
                topic,
                destinationWindowName: this.me.name
            });
        };
        const dontSendUnsubscription = () => {
            return new Promise((r) => r).then(() => undefined);
        };
        this.emitter.removeListener(subKey, listener);
        return this.refCounter.actOnLast(subKey, sendUnsubscription, dontSendUnsubscription);
    }
    processMessage(message) {
        const { payload: { message: payloadMessage, sourceWindowName, sourceUuid, topic } } = message;
        const keys = [
            this.createSubscriptionKey(sourceUuid, sourceWindowName, topic),
            this.createSubscriptionKey(sourceUuid, '*', topic),
            this.createSubscriptionKey('*', '*', topic)
        ];
        const idOfSender = { uuid: sourceUuid, name: sourceWindowName };
        keys.forEach((key) => {
            this.emitter.emit(key, payloadMessage, idOfSender);
        });
    }
    emitSubscriverEvent(type, message) {
        const { payload: { targetName: name, uuid, topic } } = message;
        const payload = { name, uuid, topic };
        this.emitter.emit(type, payload);
    }
    // eslint-disable-next-line class-methods-use-this
    createSubscriptionKey(uuid, name, topic) {
        const n = name || '*';
        if (!(uuid && n && topic)) {
            throw new Error('Missing uuid, name, or topic string');
        }
        return createKey(uuid, n, topic);
    }
    onmessage(message) {
        const { action } = message;
        switch (action) {
            case 'process-message':
                this.processMessage(message);
                break;
            case this.events.subscriberAdded:
                this.emitSubscriverEvent(this.events.subscriberAdded, message);
                break;
            case this.events.subscriberRemoved:
                this.emitSubscriverEvent(this.events.subscriberRemoved, message);
                break;
            default:
                break;
        }
        return true;
    }
}
exports["default"] = InterApplicationBus;
class InterAppPayload {
}
exports.InterAppPayload = InterAppPayload;
function createKey(...toHash) {
    return toHash
        .map((item) => {
        return Buffer.from(`${item}`).toString('base64');
    })
        .join('/');
}


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/interop/Factory.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/interop/Factory.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const InteropBroker_1 = __webpack_require__(/*! ./InteropBroker */ "./node_modules/openfin-adapter/src/api/interop/InteropBroker.js");
const InteropClient_1 = __webpack_require__(/*! ./InteropClient */ "./node_modules/openfin-adapter/src/api/interop/InteropClient.js");
const defaultOverride = (Class, ...args) => new Class(...args);
/**
 * @typedef { object } InteropConfig
 * @summary Information relevant to the Interop Broker.
 * @property {string} [currentContextGroup] Context Group for the client. (green, yellow, red, etc.)
 * @property {string} [providerId] When provided, automatically connects the client to the specified provider uuid
 */
/**
 * Manages creation of Interop Brokers and Interop Clients. These APIs are called under-the-hood in Platforms.
 * @namespace
 * @alias Interop
 */
class InteropModule extends base_1.Base {
    /**
     * Initializes an Interop Broker. This is called under-the-hood for Platforms.
     * @param { string } name - Name of the Interop Broker.
     * @param { OverrideCallback<InteropBroker> } [override] - A callback function that can be used to extend or replace default Interop Broker behavior.
     * @return {Promise.<InteropBroker>}
     * @tutorial Interop.init
     * @experimental
     * @static
     */
    async init(name, override = defaultOverride) {
        this.wire.sendAction('interop-init').catch((e) => {
            // don't expose, analytics-only call
        });
        const provider = await this.fin.InterApplicationBus.Channel.create(`interop-broker-${name}`);
        // Allows for manifest-level configuration, without having to override. (e.g. specifying custom context groups)
        const options = await this.fin.Application.getCurrentSync().getInfo();
        return override(InteropBroker_1.InteropBroker, this.wire, provider, options.initialOptions.interopBrokerConfiguration || {});
    }
    /**
     * Connects a client to an Interop broker. This is called under-the-hood for Views in a Platform.
     * @param { string } name - The name of the Interop Broker to connect to. For Platforms, this will default to the uuid of the Platform.
     * @param { InteropConfig } [interopConfig] - Information relevant to the Interop Broker. Typically a declaration of
     * what context(s) the entity wants to subscribe to, and the current Context Group of the entity.
     * @return {InteropClient}
     * @tutorial Interop.connectSync
     * @experimental
     * @static
     */
    connectSync(name, interopConfig) {
        this.wire.sendAction('interop-connect-sync').catch((e) => {
            // don't expose, analytics-only call
        });
        return new InteropClient_1.InteropClient(this.wire, name, interopConfig);
    }
}
exports["default"] = InteropModule;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/interop/InteropBroker.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/interop/InteropBroker.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InteropBroker = void 0;
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
let contextGroups = [
    {
        id: 'green',
        displayMetadata: {
            color: '#00CC88',
            name: 'green'
        }
    },
    {
        id: 'purple',
        displayMetadata: {
            color: '#8C61FF',
            name: 'purple'
        }
    },
    {
        id: 'orange',
        displayMetadata: {
            color: '#FF8C4C',
            name: 'orange'
        }
    },
    {
        id: 'red',
        displayMetadata: {
            color: '#FF5E60',
            name: 'red'
        }
    },
    {
        id: 'pink',
        displayMetadata: {
            color: '#FF8FB8',
            name: 'pink'
        }
    },
    {
        id: 'yellow',
        displayMetadata: {
            color: '#E9FF8F',
            name: 'yellow'
        }
    }
];
/**
 * {@link https://developers.openfin.co/of-docs/docs/enable-color-linking **THE INTEROP API IS EXPERIMENTAL. IF YOU WOULD LIKE TO USE IT, PLEASE USE OUR DEFAULT IMPLEMENTATION IN BROWSER**}
 *
 * The Interop Broker is responsible for keeping track of the Interop state of the Platform, and for directing messages to the proper locations.
 *
 * ---
 *
 * There are 2 ways to inject custom functionality into the Interop Broker:
 *
 * **1. Configuration**
 *
 * At the moment, you can configure the default context groups for the Interop Broker without having to override it. To do so, include the `interopBrokerConfiguration` `contextGroups` option in your `platform` options in your manifest. This is the preferred method.
 * ```js
 * {
 *      "runtime": {
 *          "arguments": "--v=1 --inspect",
 *          "version": "alpha-v19"
 *      },
 *      "platform": {
 *          "uuid": "platform_customization_local",
 *          "applicationIcon": "https://openfin.github.io/golden-prototype/favicon.ico",
 *          "autoShow": false,
 *          "providerUrl": "http://localhost:5555/provider.html",
 *          "interopBrokerConfiguration": {
 *              "contextGroups": [
 *                  {
 *                      "id": "green",
 *                      "displayMetadata": {
 *                          "color": "#00CC88",
 *                          "name": "green"
 *                      }
 *                  },
 *                  {
 *                      "id": "purple",
 *                      "displayMetadata": {
 *                          "color": "#8C61FF",
 *                          "name": "purple"
 *                      }
 *                  },
 *              ]
 *          }
 *      }
 * }
 * ```
 *
 * ---
 * **2. Overriding**
 *
 * Similarly to how [Platform Overriding]{@link https://developers.openfin.co/docs/platform-customization#section-customizing-platform-behavior} works, you can override functions in the Interop Broker in `fin.Platform.init`. An example of that is shown below. Overriding `isConnectionAuthorized` and `isActionAuthorized` will allow you to control allowed connections and allowed actions.
 *
 * However, if there is custom functionality you wish to include in the Interop Broker, please let us know. We would like to provide better configuration options so that you don't have to continually maintain your own override code.
 *
 * ```js
 * fin.Platform.init({
 *     overrideCallback: async (Provider) => {
 *         class Override extends Provider {
 *             async getSnapshot() {
 *                 console.log('before getSnapshot')
 *                 const snapshot = await super.getSnapshot();
 *                 console.log('after getSnapshot')
 *                 return snapshot;
 *             }
 *
 *             async applySnapshot({ snapshot, options }) {
 *                 console.log('before applySnapshot')
 *                 const originalPromise = super.applySnapshot({ snapshot, options });
 *                 console.log('after applySnapshot')
 *
 *                 return originalPromise;
 *             }
 *         };
 *         return new Override();
 *     },
 *     interopOverride: async (InteropBroker, provider, options, ...args) => {
 *         class Override extends InteropBroker {
 *             async joinContextGroup(channelName = 'default', target) {
 *                 console.log('before super joinContextGroup')
 *                 super.joinContextGroup(channelName, target);
 *                 console.log('after super joinContextGroup')
 *             }
 *         }
 *
 *         options.systemChannels = [
 *             {
 *                 id: 'green',
 *                 displayMetadata: {
 *                     color: '#00CC88',
 *                     name: 'green'
 *                 }
 *             },
 *             {
 *                 id: 'purple',
 *                 displayMetadata: {
 *                     color: '#8C61FF',
 *                     name: 'purple'
 *                 }
 *             },
 *             {
 *                 id: 'orange',
 *                 displayMetadata: {
 *                     color: '#FF8C4C',
 *                     name: 'orange'
 *                 }
 *             },
 *             {
 *                 id: 'red',
 *                 displayMetadata: {
 *                     color: '#FF5E60',
 *                     name: 'red'
 *                 }
 *             }
 *         ];
 *       return new Override(provider, options, ...args);
 *   }
 * });
 * ```
 *
 * ---
 *
 * @hideconstructor
 * @class
 */
class InteropBroker extends base_1.Base {
    constructor(wire, channel, options) {
        super(wire);
        this.channel = channel;
        this.interopClients = new Map();
        this.contextGroupsById = new Map();
        if (options.contextGroups) {
            contextGroups = options.contextGroups;
        }
        this.intentClientMap = new Map();
        this.setContextGroupMap();
        this.wireChannel(channel);
    }
    /*
    Client API
    */
    /**
     * SetContextOptions interface
     * @typedef { object } SetContextOptions
     * @property { Context } {context} - New context to set.
     */
    /**
     * Sets a context for the context group of the incoming current entity.
     * @param { SetContextOptions } setContextOptions - New context to set.
     * @param { ClientIdentity } clientIdentity - Identity of the client sender.
     * @return { void }
     * @experimental
     */
    setContext({ context }, clientIdentity) {
        this.wire.sendAction('interop-broker-set-context').catch((e) => {
            // don't expose, analytics-only call
        });
        const clientState = this.getClientState(clientIdentity);
        if (clientState && clientState.contextGroupId) {
            const { contextGroupId } = clientState;
            if (!this.contextGroupsById.has(contextGroupId)) {
                // Theoretically not possible.
                throw new Error(`Client has a context group that isn't in the context group mapping: ${contextGroupId}.`);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const contextGroupState = this.contextGroupsById.get(contextGroupId);
            const broadcastedContextType = context.type;
            contextGroupState.set(broadcastedContextType, context);
            const clientsInSameContextGroup = Array.from(this.interopClients.values()).filter((connectedClient) => connectedClient.contextGroupId === contextGroupId);
            clientsInSameContextGroup.forEach((client) => {
                for (const [, handlerInfo] of client.contextHandlers) {
                    if (InteropBroker.isContextTypeCompatible(broadcastedContextType, handlerInfo.contextType)) {
                        this.invokeContextHandler(client.clientIdentity, handlerInfo.handlerId, context);
                    }
                }
            });
        }
        else if (clientState) {
            // Client has not joined any context group behavior.
            throw new Error('You must join a context group before you can set context.');
        }
        else {
            // This shouldn't get hit.
            throw new Error(`Client with Identity: ${clientIdentity.uuid} ${clientIdentity.name} not in Client State Map`);
        }
    }
    /*
    Platform Window APIs
    */
    // joinContextGroup and addClientToContextGroup are separate functions here, for easier overrides and separation of concerns.
    // joinContextGroup checks all connections for matching identities, in case we have multiple connection from an entity.
    /**
     * JoinContextGroupOptions interface
     * @typedef { object } JoinContextGroupOptions
     * @property { string } contextGroupId - Id of the context group.
     * @property { Identity | ClientIdentity } [target] - Identity of the entity you wish to join to a context group.
     */
    /**
     * Join all connections at the given identity (or just one if endpointId provided) to context group `contextGroupId`.
     * If no target is specified, it adds the sender to the context group.
     * joinContextGroup is responsible for checking connections at the incoming identity. It calls {@link InteropBroker#addClientToContextGroup InteropBroker.addClientToContextGroup} to actually group the client.
     * Used by Platform Windows.
     * @return { Promise<void> }
     * @param { JoinContextGroupOptions } joinContextGroupOptions - Id of the Context Group and identity of the entity to join to the group.
     * @param { ClientIdentity } senderIdentity - Identity of the client sender.
     * @experimental
     */
    async joinContextGroup({ contextGroupId, target }, senderIdentity) {
        this.wire.sendAction('interop-broker-join-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        if (target) {
            // If an endpointId is provided, use that. This will likely be used by external adapters.
            if (InteropBroker.hasEndpointId(target)) {
                await this.addClientToContextGroup({ contextGroupId }, target);
            }
            // Sanity check here in case a single app has multiple connections
            const allConnections = this.channel.connections.filter((x) => x.uuid === target.uuid && x.name === target.name);
            if (!allConnections.length) {
                throw new Error(`Given Identity ${target.uuid} ${target.name} is not connected to the Interop Broker.`);
            }
            if (allConnections.length > 1) {
                // Should figure out how we want to handle this situation. In the meantime, just change context group for all connections.
                console.warn(`More than one connection found for identity ${target.uuid} ${target.name}`);
            }
            const promises = [];
            for (const connection of allConnections) {
                promises.push(this.addClientToContextGroup({ contextGroupId }, connection));
            }
            await Promise.all(promises);
        }
        else {
            // No target provided, add the sender to the context group.
            await this.addClientToContextGroup({ contextGroupId }, senderIdentity);
        }
    }
    /**
     * AddClientToContextGroupOptions interface
     * @typedef { object } AddClientToContextGroupOptions
     * @property { string } contextGroupId - Name of the context group.
     */
    // addClientToContextGroup does the actual addition of the client to the Context Group
    /**
     * Helper function for {@link InteropBroker#joinContextGroup InteropBroker.joinContextGroup}. Does the work of actually adding the client to the Context Group.
     * Used by Platform Windows.
     * @return { Promise<void> }
     * @param { AddClientToContextGroupOptions } addClientToContextGroupOptions - Contains the contextGroupId
     * @param { ClientIdentity } clientIdentity - Identity of the client sender.
     * @experimental
     */
    async addClientToContextGroup({ contextGroupId }, clientIdentity) {
        this.wire.sendAction('interop-broker-add-client-to-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        const clientSubscriptionState = this.getClientState(clientIdentity);
        if (!clientSubscriptionState) {
            throw new Error(`Client with Identity: ${clientIdentity.uuid} ${clientIdentity.name} not in Client State Map`);
        }
        if (!this.getContextGroups().find((contextGroupInfo) => contextGroupInfo.id === contextGroupId)) {
            throw new Error(`Attempting to join a context group that does not exist: ${contextGroupId}. You may only join existing context groups.`);
        }
        const oldContextGroupId = clientSubscriptionState.contextGroupId;
        if (oldContextGroupId !== contextGroupId) {
            clientSubscriptionState.contextGroupId = contextGroupId;
            await InteropBroker.setCurrentContextGroupInClientOptions(clientIdentity, contextGroupId);
            const contextGroupMap = this.contextGroupsById.get(contextGroupId);
            for (const [, handlerInfo] of clientSubscriptionState.contextHandlers) {
                const { contextType, handlerId } = handlerInfo;
                if (contextType === undefined) {
                    // Send this single handler all of the context, because it accepts all.
                    contextGroupMap.forEach((context, _) => {
                        this.invokeContextHandler(clientIdentity, handlerId, context);
                    });
                }
                else if (contextGroupMap.has(contextType)) {
                    const contextForType = contextGroupMap.get(contextType);
                    if (contextForType) {
                        this.invokeContextHandler(clientIdentity, handlerId, contextForType);
                    }
                }
            }
        }
    }
    /**
     * RemoveFromContextGroupOptions interface
     * @typedef { object } RemoveFromContextGroupOptions
     * @property { Identity | ClientIdentity } target - Identity of the entity you wish to join to a context group.
     */
    // Removes the target from its context group. Similar structure to joinContextGroup.
    /**
     * Removes the specified target from a context group.
     * If no target is specified, it removes the sender from their context group.
     * removeFromContextGroup is responsible for checking connections at the incoming identity. It calls {@link InteropBroker#removeClientFromContextGroup InteropBroker.removeClientFromContextGroup} to actually ungroup the client.
     * Used by Platform Windows.
     * @return { Promise<void> }
     * @param { RemoveFromContextGroupOptions } removeFromContextGroupOptions - Contains the target identity to remove.
     * @param { ClientIdentity } senderIdentity - Identity of the client sender.
     * @experimental
     */
    async removeFromContextGroup({ target }, senderIdentity) {
        this.wire.sendAction('interop-broker-remove-from-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        if (target) {
            // If an endpointId is provided, use that. This will likely be used by external adapters.
            if (InteropBroker.hasEndpointId(target)) {
                await this.removeClientFromContextGroup(target);
            }
            // Sanity check here in case a single app has multiple connections
            const allConnections = this.channel.connections.filter((x) => x.uuid === target.uuid && x.name === target.name);
            if (!allConnections.length) {
                throw new Error(`No connection found for given Identity ${target.uuid} ${target.name}`);
            }
            if (allConnections.length > 1) {
                console.warn(`More than one connection found for identity ${target.uuid} ${target.name}`);
            }
            const promises = [];
            for (const connection of allConnections) {
                promises.push(this.removeClientFromContextGroup(connection));
            }
            await Promise.all(promises);
        }
        else {
            // No target provided, remove the sender from the context group.
            await this.removeClientFromContextGroup(senderIdentity);
        }
    }
    // removeClientFromContextGroup does the actual remove of the client from the Context Group
    /**
     * Helper function for {@link InteropBroker#removeFromContextGroup InteropBroker.removeFromContextGroup}. Does the work of actually removing the client from the Context Group.
     * Used by Platform Windows.
     * @return { Promise<void> }
     * @property { ClientIdentity } clientIdentity - Identity of the client sender.
     * @experimental
     */
    async removeClientFromContextGroup(clientIdentity) {
        this.wire.sendAction('interop-broker-remove-client-from-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        const clientState = this.getClientState(clientIdentity);
        if (clientState) {
            clientState.contextGroupId = undefined;
        }
        await InteropBroker.setCurrentContextGroupInClientOptions(clientIdentity, null);
    }
    // Used by platform windows to know what client groups the provider has declared. Also used internally to access context groups. Overrideable so that the platform developer can modify it.
    /**
     * Returns the Interop-Broker-defined context groups available for an entity to join. Because this function is used in the rest of the Interop Broker to fetch the Context Groups, overriding this allows you to customize the Context Groups for the Interop Broker. However, we recommend customizing the context groups through configuration instead.
     * Used by Platform Windows.
     * @return { Promise<ContextGroupInfo[]>}
     * @experimental
     */
    // eslint-disable-next-line class-methods-use-this
    getContextGroups() {
        this.wire.sendAction('interop-broker-get-context-groups').catch((e) => {
            // don't expose, analytics-only call
        });
        // Create copy for immutability
        return contextGroups.map((contextGroup) => {
            return { ...contextGroup };
        });
    }
    /**
     * GetInfoForContextGroupOptions interface
     * @typedef { object } GetInfoForContextGroupOptions
     * @property { string } contextGroupId - Name of the context group to get info for.
     */
    // Used to by platform windows to get display metadata for a context group.
    /**
     * Gets display info for a context group
     * Used by Platform Windows.
     * @param { GetInfoForContextGroupOptions } getInfoForContextGroupOptions - Contains contextGroupId, the context group you wish to get display info for.
     * @return { Promise<ContextGroupInfo>}
     * @experimental
     */
    getInfoForContextGroup({ contextGroupId }) {
        this.wire.sendAction('interop-broker-get-info-for-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        return this.getContextGroups().find((contextGroup) => contextGroup.id === contextGroupId);
    }
    /**
     * GetAllClientsInContextGroupOptions interface
     * @typedef { object } GetAllClientsInContextGroupOptions
     * @property { string } contextGroupId - Name of the context group to get info for.
     */
    // Used by platform windows to get all clients for a context group.
    /**
     * Gets all clients for a context group.
     * Used by Platform Windows.
     * @param { GetAllClientsInContextGroupOptions } getAllClientsInContextGroupOptions - Contains contextGroupId, the context group you wish to get clients for.
     * @return { Promise<ClientIdentity[]>}
     * @experimental
     */
    getAllClientsInContextGroup({ contextGroupId }) {
        this.wire.sendAction('interop-broker-get-all-clients-in-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        const clientsInContextGroup = Array.from(this.interopClients.values())
            .filter((connectedClient) => connectedClient.contextGroupId === contextGroupId)
            .map((subscriptionState) => {
            return subscriptionState.clientIdentity;
        });
        return clientsInContextGroup;
    }
    /**
     * Responsible for launching of applications that can handle a given intent, and delegation of intents to those applications.
     * Must be overridden.
     * @param { Intent } intent The combination of an action and a context that is passed to an application for resolution.
     * @return { Promise<void> }
     * @tutorial interop.handleFiredIntent
     * @experimental
     */
    // eslint-disable-next-line class-methods-use-this
    async handleFiredIntent(intent) {
        // don't do anything, this is meant to be overidden by the platform provider
        this.wire.sendAction('interop-broker-handle-fired-intent').catch((e) => {
            // don't expose, this is only for api analytics purposes
        });
        // TODO: Update this warning with a link to our docs once they are written.
        throw new Error('An intent has been fired and handleFiredIntent has not been overridden. Please override this function to handle the intent. Refer to our documentation for more info.');
    }
    /**
     * Should be called in {@link InteropBroker#handleFiredIntent InteropBroker.handleFiredIntent}.
     * While handleFiredIntent is responsible for launching applications, setIntentTarget is used to tell the InteropBroker which application should receive the intent when it is ready.
     * @param { Intent } intent The combination of an action and a context that is passed to an application for resolution.
     * @param { Identity } target - Identity of the target that will handle the intent.
     * @return { Promise<void> }
     * @experimental
     */
    async setIntentTarget(intent, target) {
        this.wire.sendAction('interop-broker-set-intent-target').catch((e) => {
            // don't expose, this is only for api analytics purposes
        });
        const targetInfo = this.intentClientMap.get(target.name);
        const handlerId = `intent-handler-${intent.name}`;
        if (!targetInfo) {
            this.intentClientMap.set(target.name, new Map());
            const newHandlerInfoMap = this.intentClientMap.get(target.name);
            if (newHandlerInfoMap) {
                newHandlerInfoMap.set(handlerId, { isReady: false, pendingIntents: [intent] });
            }
        }
        else {
            const handlerInfo = targetInfo.get(handlerId);
            if (!handlerInfo) {
                targetInfo.set(handlerId, { isReady: false, pendingIntents: [intent] });
            }
            else {
                handlerInfo.pendingIntents.push(intent);
                if (handlerInfo.clientIdentity && handlerInfo.isReady) {
                    const { clientIdentity, pendingIntents } = handlerInfo;
                    try {
                        const intentToSend = pendingIntents[pendingIntents.length - 1];
                        await this.channel.dispatch(clientIdentity, handlerId, intentToSend);
                        handlerInfo.pendingIntents = [];
                    }
                    catch (error) {
                        console.error(`Error invoking intent handler for client ${clientIdentity.uuid}/${clientIdentity.name}/${clientIdentity.endpointId}`);
                        handlerInfo.isReady = false;
                    }
                }
            }
        }
    }
    /*
    Snapshot APIs
    */
    // Used to save interop broker state in snapshots
    decorateSnapshot(snapshot) {
        return { ...snapshot, interopSnapshotDetails: { contextGroupStates: this.getContextGroupStates() } };
    }
    // Used to restore interop broker state in snapshots.
    applySnapshot(snapshot, options) {
        var _a;
        const contextGroupStates = (_a = snapshot === null || snapshot === void 0 ? void 0 : snapshot.interopSnapshotDetails) === null || _a === void 0 ? void 0 : _a.contextGroupStates;
        if (contextGroupStates) {
            if (!(options === null || options === void 0 ? void 0 : options.closeExistingWindows)) {
                this.updateExistingClients(contextGroupStates);
            }
            this.rehydrateContextGroupStates(contextGroupStates);
        }
    }
    updateExistingClients(contextGroupStates) {
        const clients = this.interopClients;
        clients.forEach((subState) => {
            const { clientIdentity, contextGroupId, contextHandlers } = subState;
            if (contextGroupId) {
                const groupContexts = contextGroupStates[contextGroupId];
                for (const [, context] of Object.entries(groupContexts)) {
                    contextHandlers.forEach((contextHandler) => {
                        const { handlerId, contextType } = contextHandler;
                        if (InteropBroker.isContextTypeCompatible(context.type, contextType)) {
                            this.invokeContextHandler(clientIdentity, handlerId, context);
                        }
                    });
                }
            }
        });
    }
    // Used to store context group state in snapshots
    getContextGroupStates() {
        return InteropBroker.toObject(this.contextGroupsById);
    }
    // Used to rehydrate the context state from a snapshot
    rehydrateContextGroupStates(incomingContextGroupStates) {
        const contextGroupStates = Object.entries(incomingContextGroupStates);
        for (const [contextGroupId, contexts] of contextGroupStates) {
            const contextObjects = Object.entries(contexts);
            for (const [contextType, context] of contextObjects) {
                if (this.contextGroupsById.has(contextGroupId)) {
                    const currentContextGroupState = this.contextGroupsById.get(contextGroupId);
                    currentContextGroupState.set(contextType, context);
                }
                else {
                    // This logic will change when dynamic context group creation comes in.
                    console.warn(`Attempting to set a context group that isn't in the context group mapping. Skipping context group rehydration for: ${contextGroupId}`);
                }
            }
        }
    }
    /*
    Internal Context Handler APIs
    */
    // Used to give context to a client that has registered their context handler
    contextHandlerRegistered({ contextType, handlerId }, clientIdentity) {
        const handlerInfo = { contextType, handlerId };
        const clientState = this.getClientState(clientIdentity);
        clientState === null || clientState === void 0 ? void 0 : clientState.contextHandlers.set(handlerId, handlerInfo);
        if (clientState && clientState.contextGroupId) {
            const { contextGroupId } = clientState;
            const contextGroupMap = this.contextGroupsById.get(contextGroupId);
            if (contextType === undefined) {
                // Send this single handler all of the context, because it accepts all.
                contextGroupMap.forEach((context, _) => {
                    this.invokeContextHandler(clientIdentity, handlerId, context);
                });
            }
            else if (contextGroupMap.has(contextType)) {
                const contextForType = contextGroupMap.get(contextType);
                if (contextForType) {
                    this.invokeContextHandler(clientIdentity, handlerId, contextForType);
                }
            }
        }
    }
    // eslint-disable-next-line class-methods-use-this
    async intentHandlerRegistered(payload, clientIdentity) {
        const { handlerId } = payload;
        const clientIntentInfo = this.intentClientMap.get(clientIdentity.name);
        const handlerInfo = clientIntentInfo === null || clientIntentInfo === void 0 ? void 0 : clientIntentInfo.get(handlerId);
        if (!clientIntentInfo) {
            this.intentClientMap.set(clientIdentity.name, new Map());
            const newHandlerInfoMap = this.intentClientMap.get(clientIdentity.name);
            if (newHandlerInfoMap) {
                newHandlerInfoMap.set(handlerId, { isReady: true, pendingIntents: [], clientIdentity });
            }
        }
        else if (!handlerInfo) {
            clientIntentInfo.set(handlerId, { isReady: true, pendingIntents: [], clientIdentity });
        }
        else {
            const { pendingIntents } = handlerInfo;
            handlerInfo.clientIdentity = clientIdentity;
            handlerInfo.isReady = true;
            try {
                if (pendingIntents.length > 0) {
                    const intentToSend = pendingIntents[pendingIntents.length - 1];
                    await this.channel.dispatch(clientIdentity, handlerId, intentToSend);
                    handlerInfo.pendingIntents = [];
                }
            }
            catch (error) {
                console.error(`Error invoking intent handler: ${handlerId} for client ${clientIdentity.uuid}/${clientIdentity.name}/${clientIdentity.endpointId}`);
            }
        }
    }
    // Used to invoke a client's context handler
    invokeContextHandler(clientIdentity, handlerId, context) {
        this.channel.dispatch(clientIdentity, handlerId, context).catch((e) => {
            console.error(`Error invoking context handler ${handlerId} for context type ${context.type} in client ${clientIdentity.uuid}/${clientIdentity.name}/${clientIdentity.endpointId}`, e);
        });
    }
    // Used to remove a context handler for a client
    removeContextHandler({ handlerId }, clientIdentity) {
        const clientState = this.getClientState(clientIdentity);
        if (clientState) {
            clientState.contextHandlers.delete(handlerId);
        }
    }
    /*
    Internal Utilties
    */
    // Getter for interop info for a client.
    getClientState(id) {
        return this.interopClients.get(id.endpointId);
    }
    // Util for getContextGroupStates. Serializes the contextGroupStates object so we can store it.
    static toObject(map) {
        const objectFromMap = Object.fromEntries(map);
        const newObject = {};
        Object.entries(objectFromMap).forEach(([contextGroupId, contextMap]) => {
            const newContextObject = Object.fromEntries(contextMap);
            newObject[contextGroupId] = newContextObject;
        });
        return newObject;
    }
    // Util to check a client identity.
    static hasEndpointId(target) {
        return target.endpointId !== undefined;
    }
    // Util to check if we should send a context to a handler.
    static isContextTypeCompatible(contextType, registeredContextType) {
        return typeof registeredContextType === 'undefined' || contextType === registeredContextType;
    }
    // Setup function for state mapping
    setContextGroupMap() {
        // This way, if a user overrides this.getContextGroups, it's reflected in the contextGroupMapping.
        for (const contextGroupInfo of this.getContextGroups()) {
            this.contextGroupsById.set(contextGroupInfo.id, new Map());
        }
    }
    static async setCurrentContextGroupInClientOptions(clientIdentity, contextGroupId) {
        const entityInfo = await fin.System.getEntityInfo(clientIdentity.uuid, clientIdentity.name);
        let entity;
        if (entityInfo.entityType === 'view') {
            entity = await fin.View.wrap(clientIdentity);
        }
        else if (entityInfo.entityType === 'window') {
            entity = await fin.Window.wrap(clientIdentity);
        }
        if (entity) {
            await entity.updateOptions({
                interop: {
                    currentContextGroup: contextGroupId
                }
            });
        }
        else {
            console.warn(`Setting Current Context Group: Entity with identity ${clientIdentity.uuid}, ${clientIdentity.name} is not a window or view. It is a ${entityInfo.entityType} instead.`);
        }
    }
    // Setup Channel Connection Logic
    wireChannel(channel) {
        channel.onConnection((clientIdentity, payload) => {
            if (!this.isConnectionAuthorized(clientIdentity, payload)) {
                throw new Error(`Connection not authorized for ${clientIdentity.uuid}, ${clientIdentity.name}`);
            }
            if (!clientIdentity.endpointId) {
                throw new Error('Version too old to be compatible with Interop. Please upgrade your runtime to a more recent version.');
            }
            const clientSubscriptionState = {
                contextGroupId: undefined,
                contextHandlers: new Map(),
                clientIdentity
            };
            // Only allow the client to join a contextGroup that actually exists.
            if ((payload === null || payload === void 0 ? void 0 : payload.currentContextGroup) && this.contextGroupsById.has(payload.currentContextGroup)) {
                clientSubscriptionState.contextGroupId = payload === null || payload === void 0 ? void 0 : payload.currentContextGroup;
            }
            this.interopClients.set(clientIdentity.endpointId, clientSubscriptionState);
        });
        channel.onDisconnection((clientIdentity) => {
            this.interopClients.delete(clientIdentity.endpointId);
            const targetInfo = this.intentClientMap.get(clientIdentity.name);
            if (targetInfo && clientIdentity.uuid === fin.me.identity.uuid) {
                targetInfo.forEach((handler) => {
                    handler.isReady = false;
                });
            }
        });
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore
        channel.beforeAction((action, payload, clientIdentity) => {
            if (!this.isActionAuthorized(action, payload, clientIdentity)) {
                throw new Error(`Action (${action}) not authorized for ${clientIdentity.uuid}, ${clientIdentity.name}`);
            }
            console.log(action, payload, clientIdentity);
        });
        channel.afterAction(console.log);
        // Client functions
        channel.register('setContext', this.setContext.bind(this));
        channel.register('fireIntent', this.handleFiredIntent.bind(this));
        // Platform window functions
        channel.register('getContextGroups', this.getContextGroups.bind(this));
        channel.register('joinContextGroup', this.joinContextGroup.bind(this));
        channel.register('removeFromContextGroup', this.removeFromContextGroup.bind(this));
        channel.register('getAllClientsInContextGroup', this.getAllClientsInContextGroup.bind(this));
        channel.register('getInfoForContextGroup', this.getInfoForContextGroup.bind(this));
        // Internal methods
        channel.register('contextHandlerRegistered', this.contextHandlerRegistered.bind(this));
        channel.register('intentHandlerRegistered', this.intentHandlerRegistered.bind(this));
        channel.register('removeContextHandler', this.removeContextHandler.bind(this));
    }
    /**
     * Can be used to completely prevent a connection. Return false to prevent connections. Allows all connections by default.
     * @param _id the identity tryinc to connect
     * @param _connectionPayload optional payload to use in custom implementations, will be undefined by default
     */
    async isConnectionAuthorized(_id, _connectionPayload) {
        this.wire.sendAction('interop-broker-is-connection-authorized').catch((e) => {
            // don't expose, analytics-only call
        });
        return true;
    }
    /**
     * Called before every action to check if this entity should be allowed to take the action.
     * Return false to prevent the action
     * @param _action the string action to authorize in camel case
     * @param _payload the data being sent for this action
     * @param _identity the connection attempting to dispatch this action
     */
    async isActionAuthorized(_action, _payload, _identity) {
        this.wire.sendAction('interop-broker-is-action-authorized').catch((e) => {
            // don't expose, analytics-only call
        });
        return true;
    }
}
exports.InteropBroker = InteropBroker;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/interop/InteropClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/interop/InteropClient.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _clientPromise;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InteropClient = void 0;
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/openfin-adapter/src/api/interop/utils.js");
/**
 * @typedef { object } Intent
 * @summary The combination of an action and a context that is passed to an application for resolution.
 * @property { string } name Name of the intent.
 * @property { Context } context Data associated with the intent
 */
/**
 * @typedef { object } Subscription
 * @summary Object returned when subscribing a handler.
 * @property { function } unsubscribe Function to unsubscribe the handler.
 */
/**
 * @typedef { function } ContextHandler
 * @summary Subscription function for addContextHandler.
 */
/**
 * @typedef { function } IntentHandler
 * @summary Subscription function for registerIntentHandler
 */
/**
 * @typedef { object } ClientIdentity
 * @summary The Identity for a Channel Client. Includes endpointId to differentiate between different connections for an entity.
 * @property {string} uuid GUID of an application.
 * @property {string} name Name of an entity in an application.
 * @property {string} endpointId Unique differentiator for different Channel connections for an entity.
 */
/**
 * @typedef { object } ContextGroupInfo
 * @summary Information for a Context Group. Contains metadata for displaying the group properly.
 * @property {string} id Name of the context group
 * @property {DisplayMetadata} displayMetadata Metadata for the Context Group. Contains the group's human-readable name, color, and an image, as defined by the Interop Broker.
 */
/**
 * @typedef { object } DisplayMetadata
 * @summary The display data for a Context Group.
 * @property {string} name A user-readable name for this context group, e.g: `"Red"`
 * @property {string} [color] The color that should be associated within this context group when displaying this context group in a UI, e.g: `0xFF0000`.
 * @property {string} [glyph] A URL of an image that can be used to display this context group
 */
/**
 * @typedef { object } Context
 * @summary Data passed between entities in a context group.
 * @property {object} [id] An object containing key-value pairs for the bulk of the data for the context. Differs between context types.
 * @property {string} [name] User-readable name for the incoming context.
 * @property {string} type Conserved type for the context (e.g. `instrument` or `country`)
 */
/**
 * {@link https://developers.openfin.co/of-docs/docs/enable-color-linking **THE INTEROP API IS EXPERIMENTAL. IF YOU WOULD LIKE TO USE IT, PLEASE USE OUR DEFAULT IMPLEMENTATION IN BROWSER**}
 *
 * The Interop Client API is broken up into two groups:
 *
 * **Content Facing APIs** - For Application Developers putting Views into a Platform Window, who care about Context. These are APIs that send out and receive the Context data that flows between applications. Think of this as the Water in the Interop Pipes.
 *
 * **Context Grouping APIs** - For Platform Developers, to add and remove Views to and from Context Groups. These APIs are utilized under-the-hood in Platforms, so they don't need to be used to participate in Interop. These are the APIs that decide which entities the context data flows between. Think of these as the valves or pipes that control the flow of Context Data for Interop.
 *
 * ---
 *
 * All APIs are available at the `fin.me.interop` namespace.
 *
 * ---
 *
 * **You only need 2 things to participate in Interop Context Grouping:**
 * * A Context Handler for incoming context: {@link InteropClient#addContextHandler addContextHandler(handler, contextType?)}
 * * Call setContext on your context group when you want to share context with other group members: {@link InteropClient#setContext setContext(context)}
 *
 * ---
 *
 * ##### Constructor
 * Returned by {@link Interop.connectSync Interop.connectSync}.
 *
 * ##### Content Facing APIs
 *  * {@link InteropClient#addContextHandler addContextHandler(handler, contextType?)}
 *  * {@link InteropClient#setContext setContext(context)}
 *

 * ##### Context Grouping APIs - For Platform Window Use
 *  * {@link InteropClient#getContextGroups getContextGroups()}
 *  * {@link InteropClient#joinContextGroup joinContextGroup(contextGroupId, target?)}
 *  * {@link InteropClient#removeFromContextGroup removeFromContextGroup(target?)}
 *  * {@link InteropClient#getInfoForContextGroup getInfoForContextGroup(contextGroupId)}
 *  * {@link InteropClient#getAllClientsInContextGroup getAllClientsInContextGroup(contextGroupId)}
 *
 * @hideconstructor
 * @class
 */
class InteropClient extends base_1.Base {
    constructor(wire, name, interopConfig) {
        super(wire);
        _clientPromise.set(this, void 0);
        __classPrivateFieldSet(this, _clientPromise, this.fin.InterApplicationBus.Channel.connect(`interop-broker-${name}`, {
            payload: interopConfig
        }));
    }
    /*
    Client APIs
    */
    /**
     * Sets a context for the context group of the current entity.
     * @param { Context } context - New context to set.
     * @return { Promise<void> }
     * @tutorial interop.setContext
     */
    async setContext(context) {
        this.wire.sendAction('interop-client-set-context').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet(this, _clientPromise);
        return client.dispatch('setContext', { context });
    }
    /**
     * Add a context handler for incoming context. If an entity is part of a context group, and then sets its context handler, it will receive all of its declared contexts.
     * @param { ContextHandler } handler - Handler for incoming context.
     * @param { string } [contextType] - The type of context you wish to handle.
     * @return { Promise<Subscription> }
     * @tutorial interop.addContextHandler
     */
    async addContextHandler(handler, contextType) {
        this.wire.sendAction('interop-client-add-context-handler').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet(this, _clientPromise);
        let handlerId;
        if (contextType) {
            handlerId = `invokeContextHandler-${contextType}-${utils_1.generateId()}`;
            console.warn(`Warning: By providing a contextType (${contextType}), you are using the experimental addContextHandler. To avoid issues, make sure you are adding your context handlers at the top level in your application.`);
        }
        else {
            handlerId = 'invokeContextHandler';
        }
        const wrappedHandler = this.wrapContextHandler(handler, handlerId);
        client.register(handlerId, wrappedHandler);
        await client.dispatch('contextHandlerRegistered', { handlerId, contextType });
        return {
            unsubscribe: async () => {
                client.remove(handlerId);
                await client.dispatch('removeContextHandler', { handlerId });
            }
        };
    }
    /*
    Platform Window APIs
    */
    /**
     * Returns the Interop-Broker-defined context groups available for an entity to join.
     * Used by Platform Windows.
     * @return { Promise<ContextGroupInfo[]>}
     * @tutorial interop.getContextGroups
     */
    async getContextGroups() {
        this.wire.sendAction('interop-client-get-context-groups').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet(this, _clientPromise);
        return client.dispatch('getContextGroups');
    }
    /**
     * Join all Interop Clients at the given identity to context group `contextGroupId`.
     * If no target is specified, it adds the sender to the context group.
     * Because multiple Channel connections/Interop Clients can potentially exist at a `uuid`/`name` combo, we currently join all Channel connections/Interop Clients at the given identity to the context group.
     * If an `endpointId` is provided (which is unlikely, unless the call is coming from an external adapter), then we only join that single connection to the context group.
     * For all intents and purposes, there will only be 1 connection present in Platform and Browser implmentations, so this point is more-or-less moot.
     * Used by Platform Windows.
     * @param { string } contextGroupId - Id of the context group.
     * @param { Identity } [target] - Identity of the entity you wish to join to a context group.
     * @return { Promise<void>}
     * @tutorial interop.joinContextGroup
     */
    async joinContextGroup(contextGroupId, target) {
        this.wire.sendAction('interop-client-join-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet(this, _clientPromise);
        if (!contextGroupId) {
            throw new Error('No contextGroupId specified for joinContextGroup.');
        }
        return client.dispatch('joinContextGroup', { contextGroupId, target });
    }
    /**
     * Removes the specified target from a context group.
     * If no target is specified, it removes the sender from their context group.
     * Used by Platform Windows.
     * @param { Identity } [target] - Identity of the entity you wish to join to a context group.
     * @return { Promise<void>}
     * @tutorial interop.removeFromContextGroup
     */
    async removeFromContextGroup(target) {
        this.wire.sendAction('interop-client-remove-from-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet(this, _clientPromise);
        return client.dispatch('removeFromContextGroup', { target });
    }
    /**
     * Gets all clients for a context group.
     * Used by Platform Windows.
     * @param { string } contextGroupId - The id of context group you wish to get clients for.
     * @return { Promise<ClientIdentity[]>}
     * @tutorial interop.getAllClientsInContextGroup
     */
    async getAllClientsInContextGroup(contextGroupId) {
        this.wire.sendAction('interop-client-get-all-clients-in-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet(this, _clientPromise);
        if (!contextGroupId) {
            throw new Error('No contextGroupId specified for getAllClientsInContextGroup.');
        }
        return client.dispatch('getAllClientsInContextGroup', { contextGroupId });
    }
    /**
     * Gets display info for a context group
     * Used by Platform Windows.
     * @param { string } contextGroupId - The id of context group you wish to get display info for.
     * @return { Promise<ContextGroupInfo>}
     * @tutorial interop.getInfoForContextGroup
     */
    async getInfoForContextGroup(contextGroupId) {
        this.wire.sendAction('interop-client-get-info-for-context-group').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet(this, _clientPromise);
        if (!contextGroupId) {
            throw new Error('No contextGroupId specified for getInfoForContextGroup.');
        }
        return client.dispatch('getInfoForContextGroup', { contextGroupId });
    }
    /**
     * Sends an intent to the Interop Broker to resolve.
     * @param { Intent } intent - The combination of an action and a context that is passed to an application for resolution.
     * @return { Promise<void>}
     * @tutorial interop.fireIntent
     * @experimental
     */
    async fireIntent(intent) {
        this.wire.sendAction('interop-client-fire-intent').catch((e) => {
            // don't expose, this is only for api analytics purposes
        });
        const client = await __classPrivateFieldGet(this, _clientPromise);
        return client.dispatch('fireIntent', intent);
    }
    /**
     * Adds an intent handler for incoming intents. The last intent sent of the name subscribed to will be received.
     * @param { IntentHandler } handler - Registered function meant to handle a specific intent type.
     * @param { string } intentName - The name of an intent.
     * @return { Promise<Subscription> }
     * @tutorial interop.registerIntentHandler
     * @experimental
     */
    async registerIntentHandler(handler, intentName) {
        this.wire.sendAction('interop-client-register-intent-handler').catch((e) => {
            // don't expose, this is only for api analytics purposes
        });
        const client = await __classPrivateFieldGet(this, _clientPromise);
        const handlerId = `intent-handler-${intentName}`;
        const wrappedHandler = this.wrapIntentHandler(handler, handlerId);
        try {
            await client.register(handlerId, wrappedHandler);
            await client.dispatch('intentHandlerRegistered', { handlerId });
        }
        catch (error) {
            throw new Error('Unable to register intent handler');
        }
        return {
            unsubscribe: async () => {
                client.remove(handlerId);
            }
        };
    }
    /*
    Internal Utilties
    */
    // Util for more useful error handling
    // eslint-disable-next-line class-methods-use-this
    wrapContextHandler(handler, handlerId) {
        return async (context) => {
            try {
                await handler(context);
            }
            catch (error) {
                console.error(`Error thrown by handler ${handlerId} for context type ${context.type}: ${error}`);
                throw error;
            }
        };
    }
    // eslint-disable-next-line class-methods-use-this
    wrapIntentHandler(handler, handlerId) {
        return async (intent) => {
            try {
                await handler(intent);
            }
            catch (error) {
                console.error(`Error thrown by handler ${handlerId}: ${error}`);
                throw error;
            }
        };
    }
}
exports.InteropClient = InteropClient;
_clientPromise = new WeakMap();


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/interop/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/interop/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Factory_1 = __webpack_require__(/*! ./Factory */ "./node_modules/openfin-adapter/src/api/interop/Factory.js");
exports["default"] = Factory_1.default;
__exportStar(__webpack_require__(/*! ./InteropClient */ "./node_modules/openfin-adapter/src/api/interop/InteropClient.js"), exports);
__exportStar(__webpack_require__(/*! ./InteropBroker */ "./node_modules/openfin-adapter/src/api/interop/InteropBroker.js"), exports);


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/interop/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/interop/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateId = void 0;
exports.generateId = () => `${Math.random()}${Date.now()}`;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/me.js":
/*!****************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/me.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMe = exports.getBaseMe = void 0;
const EntityType_1 = __webpack_require__(/*! ../shapes/EntityType */ "./node_modules/openfin-adapter/src/shapes/EntityType.js");
const view_1 = __webpack_require__(/*! ./view */ "./node_modules/openfin-adapter/src/api/view/index.js");
const frame_1 = __webpack_require__(/*! ./frame */ "./node_modules/openfin-adapter/src/api/frame/index.js");
const window_1 = __webpack_require__(/*! ./window */ "./node_modules/openfin-adapter/src/api/window/index.js");
function getBaseMe(entityType, uuid, name) {
    const entityTypeHelpers = {
        isView: entityType === 'view',
        isWindow: entityType === 'window',
        isFrame: entityType === 'iframe',
        isExternal: entityType === 'external connection'
    };
    return { ...entityTypeHelpers, uuid, name, entityType };
}
exports.getBaseMe = getBaseMe;
// We need to do a lot of casting as unknown here because the compiler get's confused about matching types. What matters is that it works on the outside
function getMe(wire) {
    const { uuid, name, entityType } = wire.me;
    const interopObject = {
        setContext() {
            throw new Error('Interop API has not been instantiated. Either connection has failed or you have not declared interop in your config.');
        },
        addContextHandler() {
            throw new Error('Interop API has not been instantiated. Either connection has failed or you have not declared interop in your config.');
        },
        getContextGroups() {
            throw new Error('Interop API has not been instantiated. Either connection has failed or you have not declared interop in your config.');
        },
        joinContextGroup() {
            throw new Error('Interop API has not been instantiated. Either connection has failed or you have not declared interop in your config.');
        },
        removeFromContextGroup() {
            throw new Error('Interop API has not been instantiated. Either connection has failed or you have not declared interop in your config.');
        },
        getAllClientsInContextGroup() {
            throw new Error('Interop API has not been instantiated. Either connection has failed or you have not declared interop in your config.');
        },
        getInfoForContextGroup() {
            throw new Error('Interop API has not been instantiated. Either connection has failed or you have not declared interop in your config.');
        }
    };
    switch (entityType) {
        case EntityType_1.default.VIEW:
            return Object.assign(new view_1.View(wire, { uuid, name }), getBaseMe(entityType, uuid, name), {
                interop: interopObject
            });
        case EntityType_1.default.WINDOW:
            return Object.assign(new window_1._Window(wire, { uuid, name }), getBaseMe(entityType, uuid, name), {
                interop: interopObject
            });
        case EntityType_1.default.IFRAME:
            return Object.assign(new frame_1._Frame(wire, { uuid, name }), getBaseMe(entityType, uuid, name), {
                interop: interopObject
            });
        default:
            return { ...getBaseMe(entityType, uuid, name) };
    }
}
exports.getMe = getMe;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/notification/Factory.js":
/*!**********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/notification/Factory.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const shapes_1 = __webpack_require__(/*! ./shapes */ "./node_modules/openfin-adapter/src/api/notification/shapes.js");
const Instance_1 = __webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/notification/Instance.js");
/**
 * @lends Notification
 */
class _NotificationModule extends base_1.Base {
    constructor() {
        super(...arguments);
        this.nextNoteId = 0;
        this.events = shapes_1.events;
    }
    genNoteId() {
        this.nextNoteId += 1;
        return this.nextNoteId;
    }
    /**
     * Creates a new Notification.
     * @deprecated fin.Notification has been deprecated and will be removed by major version 22.
     * Please migrate to the [Notification Center API]{@link https://developers.openfin.co/docs/notifications-api}.
     * @param { object } options
     * @return {_Notification}
     * @tutorial Notification.create
     * @static
     */
    create(options) {
        // eslint-disable-next-line no-console
        console.warn('fin.Notification has been deprecated and will be removed by major version 22. Please migrate to the Notification Center API: https://developers.openfin.co/docs/notifications-api.');
        const noteOptions = new shapes_1.NotificationOptions(options, this.me, this.genNoteId());
        return new Instance_1._Notification(this.wire, noteOptions);
    }
}
exports["default"] = _NotificationModule;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/notification/Instance.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/notification/Instance.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._Notification = void 0;
/* eslint-disable import/prefer-default-export */
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
/**
 * @deprecated fin.Notification has been deprecated and will be removed by major version 22.
 * Please migrate to the [Notification Center API]{@link https://developers.openfin.co/docs/notifications-api}.
 * @classdesc A Notification object represents a window on OpenFin Runtime which
 * is shown briefly to the user on the bottom-right corner of the primary monitor.
 * A notification is typically used to alert the user of some important event which
 * requires his or her attention. Notifications are a child or your application that
 * are controlled by the runtime.
 * @class
 * @alias Notification
 * @hideconstructor
 */
class _Notification extends base_1.EmitterBase {
    constructor(wire, options) {
        super(wire, ['notification', `${options.notificationId}`]);
        this.listenerList = ['newListener'];
        this.unhookAllListeners = () => {
            this.listenerList.forEach((event) => {
                this.removeAllListeners(event);
            });
            this.listenerList.length = 0;
        };
        this.options = options;
        this.url = options.url;
        this.timeout = options.timeout;
        this.message = options.message;
        this.notificationId = options.notificationId;
        this.on('newListener', (event) => {
            this.listenerList.push(event);
        });
        // give any user added listeners a chance to run then unhook
        this.on('close', () => {
            setTimeout(this.unhookAllListeners, 1);
        });
    }
    /**
     * Invoked when the notification is shown
     * @deprecated fin.Notification has been deprecated and will be removed by major version 22.
     * Please migrate to the [Notification Center API]{@link https://developers.openfin.co/docs/notifications-api}.
     * @return {Promise.<void>}
     * @tutorial Notification.show
     */
    async show() {
        // eslint-disable-next-line no-console
        console.warn('fin.Notification has been deprecated and will be removed by major version 22. Please migrate to the Notification Center API: https://developers.openfin.co/docs/notifications-api.');
        if (!this.url) {
            throw new Error('Notifications require a url');
        }
        await this.wire.sendAction('send-action-to-notifications-center', {
            action: 'create-notification',
            payload: {
                url: this.url,
                notificationId: this.options.notificationId,
                message: {
                    message: this.message
                },
                timeout: this.timeout
            }
        });
    }
    /**
     * Sends a message to the notification.
     * @deprecated fin.Notification has been deprecated and will be removed by major version 22.
     * Please migrate to the [Notification Center API]{@link https://developers.openfin.co/docs/notifications-api}.
     * @param { any } message The message to be sent to the notification.
     * Can be either a primitive data type (string, number, or boolean)
     * or composite data type (object, array) that is composed of other
     * primitive or composite data types
     * @return {Promise.<void>}
     * @tutorial Notification.sendMessage
     */
    async sendMessage(message) {
        // eslint-disable-next-line no-console
        console.warn('fin.Notification has been deprecated and will be removed by major version 22. Please migrate to the Notification Center API: https://developers.openfin.co/docs/notifications-api.');
        await this.wire.sendAction('send-action-to-notifications-center', {
            action: 'send-notification-message',
            payload: {
                notificationId: this.options.notificationId,
                message: {
                    message
                }
            }
        });
    }
    /**
     * Closes the notification
     * @deprecated fin.Notification has been deprecated and will be removed by major version 22.
     * Please migrate to the [Notification Center API]{@link https://developers.openfin.co/docs/notifications-api}.
     * @return {Promise.<void>}
     * @tutorial Notification.close
     */
    async close() {
        // eslint-disable-next-line no-console
        console.warn('fin.Notification has been deprecated and will be removed by major version 22. Please migrate to the Notification Center API: https://developers.openfin.co/docs/notifications-api.');
        await this.wire.sendAction('send-action-to-notifications-center', {
            action: 'close-notification',
            payload: {
                notificationId: this.options.notificationId
            }
        });
    }
}
exports._Notification = _Notification;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/notification/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/notification/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Factory_1 = __webpack_require__(/*! ./Factory */ "./node_modules/openfin-adapter/src/api/notification/Factory.js");
__exportStar(__webpack_require__(/*! ./shapes */ "./node_modules/openfin-adapter/src/api/notification/shapes.js"), exports);
__exportStar(__webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/notification/Instance.js"), exports);
exports["default"] = Factory_1.default;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/notification/shapes.js":
/*!*********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/notification/shapes.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationOptions = exports.events = void 0;
exports.events = {
    show: 'show',
    close: 'close',
    error: 'error',
    click: 'click',
    message: 'message'
};
class NotificationOptions {
    constructor(options = {}, identity, notificationId) {
        const { url, message, timeout, ignoreMouseOver } = options;
        this.url = url;
        this.message = message || null;
        this.timeout = timeout;
        this.notificationId = notificationId;
        this.uuidOfProxiedApp = identity.uuid;
        this.ignoreMouseOver = ignoreMouseOver;
    }
}
exports.NotificationOptions = NotificationOptions;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/platform/Factory.js":
/*!******************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/platform/Factory.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* eslint-disable no-undef, no-underscore-dangle */
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const index_1 = __webpack_require__(/*! ./layout/index */ "./node_modules/openfin-adapter/src/api/platform/layout/index.js");
const Instance_1 = __webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/platform/Instance.js");
/**
 * InitPlatformOptions interface
 * @typedef { object } InitPlatformOptions
 * @property { OverrideCallback } [overrideCallback] a callback function that can be used to extend or replace default Provider behavior.
 */
/**
 * @typedef { same | different } ProcessAffinityStrategy
 * @summary Strategy to place views that share a domain into different process affinities or the same process affinity.
 * @property { string } same views in the same domain will have the same process affinity.
 * @property { string } different views in the same domain will have different process affinities.
 */
/**
 * @typedef { object } PlatformOptions
 * @summary The options object required by {@link Platform#start Platform.start}
 * Any {@link ApplicationOption Application option} is also a valid platform option
 * @property {Array.<Object>} [commands] Configuration for keyboard commands.
 * For details and usage, see [Using Keyboard Commands]{@link https://developers.openfin.co/docs/platform-api#section-5-3-using-keyboard-commands}.
 * @property {DefaultWindowOptions} [defaultWindowOptions] Default window options apply to all platform windows.
 * @property {View~options} [defaultViewOptions] Default view options apply to all platform views.
 * @property {ProcessAffinityStrategy} [viewProcessAffinityStrategy] 'same' | 'different'.
 */
/**
 * @typedef { object } DefaultWindowOptions
 * @summary Default window options apply to all platform windows.
 * Any {@link Window~options Window option} is also a valid Default Window option
 * used by default in any window that is created in the current platform's scope.
 * Individual window options will override these defaults.
 * @property {string} [stylesheetUrl]
 * Specify a path of a custom CSS file to be injected to all of the platform's windows.
 * _note_: this option is only applied to windows that use the Default OpenFin Window.
 * Windows with a specified url (Custom Windows) will not be affected by this option.
 */
/**
 * Snapshot interface
 * @typedef { object } Snapshot
 * @property { WindowOption[] } windows The array of window options objects
 */
/**
 * @lends Platform
 */
class PlatformModule extends base_1.Base {
    constructor(wire, channel) {
        super(wire);
        this._channel = channel;
        this._initializer = (...args) => this.wire.environment
            .getProviderInitializer()
            .then((initConstructor) => initConstructor(this.wire.environment)(...args));
        /**
         * @namespace
         * @desc Layouts give app providers the ability to embed multiple views in a single window.  The Layout namespace
         * enables the initialization and manipulation of a window's Layout.  A Layout will
         * <a href="tutorial-Layout.DOMEvents.html">emit events locally</a> on the DOM element representing the layout-container.
         */
        this.Layout = new index_1.LayoutModule(this.wire);
    }
    /**
     * Initializes a Platform. Must be called from the Provider when using a custom provider.
     * @param { InitPlatformOptions } [options] - platform options including a callback function that can be used to extend or replace
     * default Provider behavior.
     * @return {Promise.<void>}
     * @tutorial Platform.init
     * @experimental
     * @static
     */
    async init(options) {
        const overrideCallback = options === null || options === void 0 ? void 0 : options.overrideCallback;
        const interopBroker = await this.fin.Interop.init(this.fin.me.uuid, options === null || options === void 0 ? void 0 : options.interopOverride);
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore debugging purposes
        window.interopBroker = interopBroker;
        return this._initializer(overrideCallback, interopBroker);
    }
    /**
     * Asynchronously returns a Platform object that represents an existing platform.
     * @param { Identity } identity
     * @return {Promise.<Platform>}
     * @tutorial Platform.wrap
     * @static
     */
    async wrap(identity) {
        this.wire.sendAction('platform-wrap').catch((e) => {
            // don't expose
        });
        return new Instance_1.Platform({ uuid: identity.uuid }, this._channel);
    }
    /**
     * Synchronously returns a Platform object that represents an existing platform.
     * @param { Identity } identity
     * @return {Platform}
     * @tutorial Platform.wrapSync
     * @static
     */
    wrapSync(identity) {
        this.wire.sendAction('platform-wrap-sync').catch((e) => {
            // don't expose
        });
        return new Instance_1.Platform({ uuid: identity.uuid }, this._channel);
    }
    /**
     * Asynchronously returns a Platform object that represents the current platform.
     * @return {Promise.<Platform>}
     * @tutorial Platform.getCurrent
     * @static
     */
    async getCurrent() {
        this.wire.sendAction('platform-get-current').catch((e) => {
            // don't expose
        });
        return this.wrap({ uuid: this.wire.me.uuid });
    }
    /**
     * Synchronously returns a Platform object that represents the current platform.
     * @return {Platform}
     * @tutorial Platform.getCurrentSync
     * @static
     */
    getCurrentSync() {
        this.wire.sendAction('platform-get-current-sync').catch((e) => {
            // don't expose
        });
        return this.wrapSync({ uuid: this.wire.me.uuid });
    }
    /**
     * Creates and starts a Platform and returns a wrapped and running Platform instance. The wrapped Platform methods can
     * be used to launch content into the platform.  Promise will reject if the platform is already running.
     * @param { PlatformOptions } platformOptions
     * @return {Promise.<Platform>}
     * @tutorial Platform.start
     * @static
     */
    start(platformOptions) {
        this.wire.sendAction('platform-start').catch((e) => {
            // don't expose
        });
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(async (resolve, reject) => {
            try {
                const { uuid } = platformOptions;
                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
                // @ts-ignore using private variable.
                const app = await this.fin.Application._create({ ...platformOptions, isPlatformController: true });
                app.once('platform-api-ready', () => resolve(this.wrapSync({ uuid })));
                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
                // @ts-ignore using private variable.
                app._run({ uuid });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * Retrieves platforms's manifest and returns a wrapped and running Platform.  If there is a snapshot in the manifest,
     * it will be launched into the platform.
     * @param {string} manifestUrl - The URL of platform's manifest.
     * @param {RvmLaunchOptions} [opts] - Parameters that the RVM will use.
     * @return {Promise.<Platform>}
     * @tutorial Platform.startFromManifest
     * @static
     */
    startFromManifest(manifestUrl, opts) {
        this.wire.sendAction('platform-start-from-manifest').catch((e) => {
            // don't expose
        });
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(async (resolve, reject) => {
            try {
                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
                // @ts-ignore using private variable.
                const app = await this.fin.Application._createFromManifest(manifestUrl);
                app.once('platform-api-ready', () => resolve(this.wrapSync({ uuid: app.identity.uuid })));
                // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
                // @ts-ignore using private method without warning.
                app._run(opts);
            }
            catch (e) {
                reject(e);
            }
        });
    }
}
exports["default"] = PlatformModule;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/platform/Instance.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/platform/Instance.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _connectToProvider;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Platform = void 0;
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const validate_1 = __webpack_require__(/*! ../../util/validate */ "./node_modules/openfin-adapter/src/util/validate.js");
const Platform_1 = __webpack_require__(/*! ../../shapes/Platform */ "./node_modules/openfin-adapter/src/shapes/Platform.js");
// Reuse clients to avoid overwriting already-registered client in provider
const clientMap = new Map();
/** Manages the life cycle of windows and views in the application.
 *
 * Enables taking snapshots of itself and applying them to restore a previous configuration
 * as well as listen to <a href="tutorial-Platform.EventEmitter.html">platform events</a>.
 * @namespace
 */
class Platform extends base_1.EmitterBase {
    // eslint-disable-next-line no-shadow
    constructor(identity, channel) {
        // we piggyback off of application event emitter because from the core's perspective platform is just an app.
        super(channel.wire, ['application', identity.uuid]);
        this.getClient = (identity) => {
            this.wire.sendAction('platform-get-client', this.identity).catch((e) => {
                // don't expose
            });
            const target = identity || this.identity;
            const { uuid } = target;
            if (!clientMap.has(uuid)) {
                const clientPromise = __classPrivateFieldGet(this, _connectToProvider).call(this, uuid);
                clientMap.set(uuid, clientPromise);
            }
            // we set it above
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return clientMap.get(uuid);
        };
        _connectToProvider.set(this, async (uuid) => {
            try {
                const channelName = `custom-frame-${uuid}`;
                const client = await this._channel.connect(channelName, { wait: false });
                client.onDisconnection(() => {
                    clientMap.delete(uuid);
                });
                return client;
            }
            catch (e) {
                clientMap.delete(uuid);
                throw new Error('The targeted Platform is not currently running. Listen for application-started event for the given Uuid.');
            }
        });
        // Deprecated (renamed)
        this.launchLegacyManifest = this.launchContentManifest;
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        this._channel = channel;
        this.identity = { uuid: identity.uuid };
        this.topic = 'application';
        this.Layout = this.fin.Platform.Layout;
        this.Application = this.fin.Application.wrapSync(this.identity);
    }
    /**
     * Creates a new view and attaches it to a specified target window.
     * @param { View~options } viewOptions View creation options
     * @param { Identity } [target] The window to which the new view is to be attached. If no target, create a view in a new window.
     * @param { Identity } [targetView] If provided, the new view will be added to the same tabstrip as targetView.
     * @return { Promise<View> }
     * @tutorial Platform.createView
     */
    async createView(viewOptions, target, targetView) {
        this.wire.sendAction('platform-create-view', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        const response = await client.dispatch('create-view', {
            target,
            opts: viewOptions,
            targetView
        });
        if (!response || validate_1.validateIdentity(response.identity)) {
            throw new Error(`When overwriting the createView call, please return an object that has a valid 'identity' property: ${JSON.stringify(response)}`);
        }
        return this.fin.View.wrapSync(response.identity);
    }
    /**
     * Creates a new Window.
     * @param { Window~options } options Window creation options
     * @return { Promise<_Window> }
     * @tutorial Platform.createWindow
     */
    async createWindow(options) {
        this.wire.sendAction('platform-create-window', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        if (!options.reason) {
            options.reason = Platform_1.WindowCreationReason.APICall;
        }
        const response = await client.dispatch('create-view-container', options);
        if (!response || validate_1.validateIdentity(response.identity)) {
            throw new Error(`When overwriting the createWindow call, please return an object that has a valid 'identity' property: ${JSON.stringify(response)}`);
        }
        const { identity } = response;
        const res = this.fin.Window.wrapSync(identity);
        // we add the identity at the top level for backwards compatibility.
        res.name = identity.name;
        res.uuid = identity.uuid;
        return res;
    }
    /**
     * Closes current platform, all its windows, and their views.
     * @return { Promise<void> }
     * @tutorial Platform.quit
     */
    async quit() {
        this.wire.sendAction('platform-quit', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        return client.dispatch('quit');
    }
    /**
     * Closes a specified view in a target window.
     * @param { Identity } viewIdentity View identity
     * @return { Promise<void> }
     * @tutorial Platform.closeView
     */
    async closeView(viewIdentity) {
        this.wire.sendAction('platform-close-view', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        await client.dispatch('close-view', {
            view: viewIdentity
        });
    }
    /**
     * ***DEPRECATED - please use Platform.createView.***
     * Reparents a specified view in a new target window.
     * @param { Identity } viewIdentity View identity
     * @param { Identity } target new owner window identity
     * @return { Promise<View> }
     * @tutorial Platform.createView
     */
    async reparentView(viewIdentity, target) {
        var _a;
        // eslint-disable-next-line no-console
        console.warn('Platform.reparentView has been deprecated, please use Platform.createView');
        this.wire.sendAction('platform-reparent-view', this.identity).catch((e) => {
            // don't expose
        });
        const normalizedViewIdentity = {
            ...viewIdentity,
            uuid: (_a = viewIdentity.uuid) !== null && _a !== void 0 ? _a : this.identity.uuid
        };
        const view = await this.fin.View.wrap(normalizedViewIdentity);
        const viewOptions = await view.getOptions();
        return this.createView(viewOptions, target);
    }
    /**
     * Returns a snapshot of the platform in its current state.
     *
     * Can be used to restore an application to a previous state.
     * @return { Promise<Snapshot> }
     * @tutorial Platform.getSnapshot
     */
    async getSnapshot() {
        this.wire.sendAction('platform-get-snapshot', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        return client.dispatch('get-snapshot');
    }
    /**
     * Adds a snapshot to a running Platform.
     * Requested snapshot must be a valid Snapshot object, or a url or filepath to such an object.
     *
     * Can optionally close existing windows and overwrite current platform state with that of a snapshot.
     *
     * The function accepts either a snapshot taken using {@link Platform#getSnapshot getSnapshot},
     * or a url or filepath to a snapshot JSON object.
     * @param { Snapshot | string } requestedSnapshot Snapshot to apply, or a url or filepath.
     * @param { ApplySnapshotOptions } [options] Optional parameters to specify whether existing windows should be closed.
     * @return { Promise<Platform> }
     * @tutorial Platform.applySnapshot
     */
    async applySnapshot(requestedSnapshot, options) {
        this.wire.sendAction('platform-apply-snapshot', this.identity).catch((e) => {
            // don't expose
        });
        const errMsg = 'Requested snapshot must be a valid Snapshot object, or a url or filepath to such an object.';
        let snapshot;
        if (typeof requestedSnapshot === 'string') {
            // Fetch and parse snapshot
            try {
                const response = await this._channel.wire.sendAction('get-application-manifest', {
                    manifestUrl: requestedSnapshot
                });
                snapshot = response.payload.data;
            }
            catch (err) {
                throw new Error(`${errMsg}: ${err}`);
            }
        }
        else {
            snapshot = requestedSnapshot;
        }
        if (!snapshot.windows) {
            throw new Error(errMsg);
        }
        const client = await this.getClient();
        await client.dispatch('apply-snapshot', {
            snapshot,
            options
        });
        return this;
    }
    /**
     * Fetches a JSON manifest using the browser process and returns a Javascript object.
     * Can be overwritten using {@link Platform#init Platform.init}.
     * @param { string } manifestUrl The URL of the manifest to fetch.
     * @return { Promise<any> }
     * @tutorial Platform.fetchManifest
     */
    async fetchManifest(manifestUrl) {
        const client = await this.getClient();
        return client.dispatch('platform-fetch-manifest', { manifestUrl });
    }
    /**
     * Retrieves a manifest by url and launches a legacy application manifest or snapshot into the platform.  Returns a promise that
     * resolves to the wrapped Platform.
     * @param {string} manifestUrl - The URL of the manifest that will be launched into the platform.  If this app manifest
     * contains a snapshot, that will be launched into the platform.  If not, the application described in startup_app options
     * will be launched into the platform. The applicable startup_app options will become {@link View~options View Options}.
     * @return {Promise<Platform>}
     * @tutorial Platform.launchContentManifest
     * @experimental
     */
    async launchContentManifest(manifestUrl) {
        this.wire.sendAction('platform-launch-content-manifest', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        const manifest = await this.fetchManifest(manifestUrl);
        client.dispatch('launch-into-platform', { manifest });
        return this;
    }
    /**
     * Set the context of a host window. The context will be available to the window itself, and to its child Views. It will be saved in any platform snapshots.
     * It can be retrieved using {@link Platform#getWindowContext getWindowContext}.
     * @param {any} context - A field where serializable context data can be stored to be saved in platform snapshots.
     * @param {Identity} [target] - A target window or view may optionally be provided. If no target is provided, the update will be applied
     * to the current window (if called from a Window) or the current host window (if called from a View).
     * @return {Promise<void>}
     * @tutorial Platform.setWindowContext
     * @experimental
     */
    async setWindowContext(context = {}, target) {
        this.wire.sendAction('platform-set-window-context', this.identity).catch((e) => {
            // don't expose
        });
        if (!context) {
            throw new Error('Please provide a serializable object or string to set the context.');
        }
        const client = await this.getClient();
        const { entityType } = target ? await this.fin.System.getEntityInfo(target.uuid, target.name) : this.fin.me;
        await client.dispatch('set-window-context', {
            context,
            entityType,
            target: target || { uuid: this.fin.me.uuid, name: this.fin.me.name }
        });
    }
    /**
     * Get the context context of a host window that was previously set using {@link Platform#setWindowContext setWindowContext}.
     * The context will be saved in any platform snapshots.  Returns a promise that resolves to the context.
     * @param {Identity} [target] - A target window or view may optionally be provided. If no target is provided, target will be
     * the current window (if called from a Window) or the current host window (if called from a View).
     * @return {Promise<any>}
     * @tutorial Platform.getWindowContext
     * @experimental
     */
    async getWindowContext(target) {
        this.wire.sendAction('platform-get-window-context', this.identity).catch((e) => {
            // don't expose
        });
        const client = await this.getClient();
        const { entityType } = target ? await this.fin.System.getEntityInfo(target.uuid, target.name) : this.fin.me;
        return client.dispatch('get-window-context', {
            target: target || { uuid: this.fin.me.uuid, name: this.fin.me.name },
            entityType
        });
    }
}
exports.Platform = Platform;
_connectToProvider = new WeakMap();


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/platform/common-utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/platform/common-utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidPresetType = void 0;
function isValidPresetType(type) {
    switch (type) {
        case "columns" /* columns */:
        case "grid" /* grid */:
        case "rows" /* rows */:
        case "tabs" /* tabs */:
            return true;
        default:
            return false;
    }
}
exports.isValidPresetType = isValidPresetType;
exports["default"] = { isValidPresetType };


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/platform/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/platform/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Factory_1 = __webpack_require__(/*! ./Factory */ "./node_modules/openfin-adapter/src/api/platform/Factory.js");
exports["default"] = Factory_1.default;
__exportStar(__webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/platform/Instance.js"), exports);


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/platform/layout/Factory.js":
/*!*************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/platform/layout/Factory.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var _layoutManager;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LayoutModule = void 0;
const Instance_1 = __webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/platform/layout/Instance.js");
const base_1 = __webpack_require__(/*! ../../base */ "./node_modules/openfin-adapter/src/api/base.js");
/**
 * InitLayoutOptions interface
 * @typedef { object } InitLayoutOptions
 * @property { string } [containerId] The id attribute of the container where the window's Layout should be initialized.  If not provided
 * then an element with id `layout-container` is used. We recommend using a div element.
 */
/**
 * PresetLayoutOptions interface
 * @typedef { object } PresetLayoutOptions
 * @property { LayoutPresetTypes } presetType Which preset layout arrangement to use.
 * The preset options are `columns`, `grid`, `rows`, and `tabs`.
 */
/**
 * LayoutConfig interface
 * @typedef { object } LayoutConfig
 * @property { Array<LayoutItem> } content Content of the layout.  There can only be one top-level LayoutItem in the content array.
 * We do not recommend trying to build Layouts or LayoutItems by hand and instead use calls such as {@link Platform#getSnapshot getSnapshot}
 * or our {@link https://openfin.github.io/golden-prototype/config-gen Layout Config Generation Tool }.
 * @property { LayoutSettings } settings Configuration for certain Layout behaviors. See the LayoutSettings interface.
 */
/**
 * LayoutItem Interface
 * @typedef { object } LayoutItem Represents the arrangement of Views within a Platform window's Layout.  We do not recommend trying
 * to build Layouts or LayoutItems by hand and instead use calls such as {@link Platform#getSnapshot getSnapshot} or our
 * {@link https://openfin.github.io/golden-prototype/config-gen Layout Config Generation Tool }.
 * @property { string } type The type of the item. Possible values are 'row', 'column', 'stack', and 'component'.
 * @property { Array<LayoutItem> } [content] An array of configurations for items that will be created as children of this item.
 * @property { string } [componentName] Only a `component` type will have this property and it should be set to `view`.
 * @property { View~options } [componentState] Only a `component` type will have this property and it represents the view
 * options of a given component.
 */
/**
 * LayoutSettings Interface
 * @typedef { object } LayoutSettings Represents a potential ways to customize behavior of your Layout
 * @property { boolean } [constrainDragToHeaders=false] Limits the area to which tabs can be dragged.
 * If true, stack headers are the only areas where tabs can be dropped.
 * @property { boolean } [hasHeaders=true] Turns tab headers on or off.
 * If false, the layout will be displayed with splitters only.
 * @property {object} [newTabButton]
 * Configuration of the Plus button that appears on each tabstrip. Upon pressing, a new tab
 * will be added to the tabstrip with the specified url.
 * @property {string} [newTabButton.url] Specifies the url that opens in the tab created upon pressing the button.
 * @property { boolean } [popoutWholeStack=false] Whether the popout button will only act on the entire stack,
 * as opposed to only the active tab.
 * @property { boolean } [preventDragIn=false] If true, tabs can't be dragged into the window.
 * @property { boolean } [preventDragOut=false] If true, tabs can't be dragged out of the window.
 * @property { boolean } [reorderEnabled=true] If true, the user can re-arrange the layout by
 * dragging items by their tabs to the desired location.
 * @property { boolean } [showCloseIcon=false] Whether to show the close button on stack header
 * (not to be confused with close button on every tab).
 * @property { boolean } [showMaximiseIcon=false] Whether to show the maximize button on stack header.
 * The button will maximize the current tab to fill the entire window.
 * @property { boolean } [showPopoutIcon=false] Whether to show the popout button on stack header.
 * The button will create a new window with current tab as its content.
 * In case `popoutWholeStack` is set to true, all tabs in the stack will be in the new window.
 */
/**
 * @lends Platform#Layout
 */
class LayoutModule extends base_1.Base {
    constructor() {
        super(...arguments);
        _layoutManager.set(this, void 0);
        /**
         * Initialize the window's Layout.  Must be called from a custom window that has a 'layout' option set upon creation of that window.
         * If a containerId is not provided, this method attempts to find an element with the id `layout-container`.
         * A Layout will <a href="tutorial-Layout.DOMEvents.html">emit events locally</a> on the DOM element representing the layout-container.
         * In order to capture the relevant events during Layout initiation, set up the listeners on the DOM element prior to calling `init`.
         * @param { InitLayoutOptions } [options] - Layout init options.
         * @return { Promise<Layout> }
         * @static
         * @experimental
         * @tutorial Layout.init
         */
        this.init = async (options = {}) => {
            this.wire.sendAction('layout-init').catch((e) => {
                // don't expose
            });
            if (!this.fin.me.isWindow) {
                throw new Error('Layout.init can only be called from a Window context.');
            }
            else if (__classPrivateFieldGet(this, _layoutManager)) {
                throw new Error('Layout for this window already initialized, please use Layout.replace call to replace the layout.');
            }
            // We need to go through environment to make sure it is only imported/bundled in OpenFin.
            const ManagerConstructor = await this.wire.environment.getManagerConstructor();
            __classPrivateFieldSet(this, _layoutManager, new ManagerConstructor());
            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
            // @ts-ignore - layout warning here for backwards compatibility, can remove layout check in .52
            let { layout, containerId } = options;
            if (layout) {
                console.warn(`We recommend using a layout in window options.
                This layout has not been sanitized and unexpected behavior can occur.`);
            }
            layout = layout || (await this.fin.Window.getCurrentSync().getOptions()).layout;
            containerId = containerId || 'layout-container';
            const container = document.getElementById(containerId);
            // Should we error here if there is no container? Getting a typescript complaint on createLayout
            // override here
            // pull createChannelConnection out of LayoutManager and setup channel connections here using layoutmanager instance methods?
            await __classPrivateFieldGet(this, _layoutManager).initManager();
            await __classPrivateFieldGet(this, _layoutManager).createLayout(layout, container);
            // Adding this to the returned instance undocumented/typed for Browser.
            return Object.assign(this.getCurrentSync(), { layoutManager: __classPrivateFieldGet(this, _layoutManager) });
        };
    }
    /**
     * Asynchronously returns a Layout object that represents a Window's layout.
     * @param { Identity } identity
     * @return {Promise.<Layout>}
     * @tutorial Layout.wrap
     * @static
     */
    // eslint-disable-next-line class-methods-use-this
    async wrap(identity) {
        this.wire.sendAction('layout-wrap').catch((e) => {
            // don't expose
        });
        return new Instance_1.Layout(identity, this.wire);
    }
    /**
     * Synchronously returns a Layout object that represents a Window's layout.
     * @param { Identity } identity
     * @return {Layout}
     * @tutorial Layout.wrapSync
     * @static
     */
    // eslint-disable-next-line class-methods-use-this
    wrapSync(identity) {
        this.wire.sendAction('layout-wrap-sync').catch((e) => {
            // don't expose
        });
        return new Instance_1.Layout(identity, this.wire);
    }
    /**
     * Asynchronously returns a Layout object that represents a Window's layout.
     * @return {Promise.<Layout>}
     * @tutorial Layout.getCurrent
     * @static
     */
    async getCurrent() {
        this.wire.sendAction('layout-get-current').catch((e) => {
            // don't expose
        });
        if (!this.fin.me.isWindow) {
            throw new Error('You are not in a Window context.  Only Windows can have a Layout.');
        }
        const { uuid, name } = this.fin.me;
        return this.wrap({ uuid, name });
    }
    /**
     * Synchronously returns a Layout object that represents a Window's layout.
     * @return {Layout}
     * @tutorial Layout.getCurrentSync
     * @static
     */
    getCurrentSync() {
        this.wire.sendAction('layout-get-current-sync').catch((e) => {
            // don't expose
        });
        if (!this.fin.me.isWindow) {
            throw new Error('You are not in a Window context.  Only Windows can have a Layout.');
        }
        const { uuid, name } = this.fin.me;
        return this.wrapSync({ uuid, name });
    }
}
exports.LayoutModule = LayoutModule;
_layoutManager = new WeakMap();


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/platform/layout/Instance.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/platform/layout/Instance.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-undef, import/prefer-default-export */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Layout = void 0;
const validate_1 = __webpack_require__(/*! ../../../util/validate */ "./node_modules/openfin-adapter/src/util/validate.js");
const common_utils_1 = __webpack_require__(/*! ../common-utils */ "./node_modules/openfin-adapter/src/api/platform/common-utils.js");
const base_1 = __webpack_require__(/*! ../../base */ "./node_modules/openfin-adapter/src/api/base.js");
/**
 * @lends Platform#Layout
 */
class Layout extends base_1.Base {
    // eslint-disable-next-line no-shadow
    constructor(identity, wire) {
        super(wire);
        /**
         * Replaces a Platform window's layout with a new layout.  Any views that were in the old layout but not the new layout
         * will be destroyed.
         * @param { LayoutConfig } layout New layout to implement in the target window.
         * Please see explanation of a layout {@link https://developers.openfin.co/docs/platform-api#section-layout here}.
         * @return { Promise<void> }
         * @tutorial Layout.replace
         */
        this.replace = async (layout) => {
            this.wire.sendAction('layout-replace').catch((e) => {
                // don't expose
            });
            const client = await this.platform.getClient();
            await client.dispatch('replace-layout', {
                target: this.identity,
                opts: { layout }
            });
        };
        /**
         * Replaces the specified view with a view with the provided configuration.
         * The old view is stripped of its listeners and either closed or attached to the provider window
         * depending on `detachOnClose` view option.
         * @param { Identity } viewToReplace Identity of the view to be replaced
         * @param { View~options } newView Creation options of the new view.
         * @return { Promise<void> }
         * @tutorial Layout.replaceView
         */
        this.replaceView = async (viewToReplace, newView) => {
            this.wire.sendAction('layout-replace-view').catch((e) => {
                // don't expose
            });
            const client = await this.platform.getClient();
            await client.dispatch('replace-view', {
                target: this.identity,
                opts: { viewToReplace, newView }
            });
        };
        /**
         * Replaces a Platform window's layout with a preset layout arrangement using the existing Views attached to the window.
         * The preset options are `columns`, `grid`, `rows`, and `tabs`.
         * @param { PresetLayoutOptions } options Mandatory object with `presetType` property that sets which preset layout arrangement to use.
         * The preset options are `columns`, `grid`, `rows`, and `tabs`.
         * @return { Promise<void> }
         * @tutorial Layout.applyPreset
         */
        this.applyPreset = async (options) => {
            this.wire.sendAction('layout-apply-preset').catch((e) => {
                // don't expose
            });
            const client = await this.platform.getClient();
            const { presetType } = options;
            if (!presetType || !common_utils_1.isValidPresetType(presetType)) {
                throw new Error('Cannot apply preset layout, please include an applicable presetType property in the PresetLayoutOptions.');
            }
            await client.dispatch('apply-preset-layout', {
                target: this.identity,
                opts: { presetType }
            });
        };
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        this.identity = identity;
        this.platform = this.fin.Platform.wrapSync({ uuid: identity.uuid });
        if (identity.uuid === this.fin.me.uuid && identity.name === this.fin.me.name) {
            this.init = this.fin.Platform.Layout.init;
        }
    }
    /**
     * Returns the configuration of the window's layout.  Returns the same information that is returned for all windows in getSnapshot.
     * @return { Promise<LayoutConfig> }
     * @tutorial Layout.getConfig
     */
    async getConfig() {
        this.wire.sendAction('layout-get-config').catch((e) => {
            // don't expose
        });
        const client = await this.platform.getClient();
        return client.dispatch('get-frame-snapshot', {
            target: this.identity
        });
    }
}
exports.Layout = Layout;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/platform/layout/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/platform/layout/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./Factory */ "./node_modules/openfin-adapter/src/api/platform/layout/Factory.js"), exports);
__exportStar(__webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/platform/layout/Instance.js"), exports);
__exportStar(__webpack_require__(/*! ./shapes */ "./node_modules/openfin-adapter/src/api/platform/layout/shapes.js"), exports);


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/platform/layout/shapes.js":
/*!************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/platform/layout/shapes.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/snapshot-source/Factory.js":
/*!*************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/snapshot-source/Factory.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const Instance_1 = __webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/snapshot-source/Instance.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/openfin-adapter/src/api/snapshot-source/utils.js");
/**
 * @typedef { object } SnapshotProvider
 * @property {getSnapshot} [getSnapshot]
 * @property {applySnapshot} [applySnapshot]
 */
/**
 * @lends SnapshotSource
 */
class SnapshotSourceModule extends base_1.Base {
    /**
     * Initializes a SnapshotSource with the getSnapshot and applySnapshot methods defined.
     * @param { SnapshotProvider } provider
     * @return { Promise<void> }
     * @tutorial SnapshotSource.init
     * @static
     */
    async init(provider) {
        this.wire.sendAction('snapshot-source-init').catch((e) => {
            // don't expose, analytics-only call
        });
        if (typeof provider !== 'object' ||
            typeof provider.getSnapshot !== 'function' ||
            typeof provider.applySnapshot !== 'function') {
            throw new Error('you must pass in a valid SnapshotProvider');
        }
        const channel = await this.fin.InterApplicationBus.Channel.create(utils_1.getSnapshotSourceChannelName(fin.me.identity));
        channel.register("get-snapshot" /* GET_SNAPSHOT */, async () => {
            const snapshot = await provider.getSnapshot();
            return { snapshot };
        });
        channel.register("apply-snapshot" /* APPLY_SNAPSHOT */, ({ snapshot }) => provider.applySnapshot(snapshot));
    }
    /**
     * Synchronously returns a SnapshotSource object that represents the current SnapshotSource.
     * @param { Identity } identity
     * @return { SnapshotSource }
     * @tutorial SnapshotSource.wrapSync
     * @static
     */
    wrapSync(identity) {
        this.wire.sendAction('snapshot-source-wrap-sync').catch((e) => {
            // don't expose, analytics-only call
        });
        return new Instance_1.SnapshotSource(this.wire, identity);
    }
    /**
     * Asynchronously returns a SnapshotSource object that represents the current SnapshotSource.
     * @param { Identity } identity
     * @return { Promise.<SnapshotSource> }
     * @tutorial SnapshotSource.wrap
     * @static
     */
    async wrap(identity) {
        this.wire.sendAction('snapshot-source-wrap').catch((e) => {
            // don't expose, analytics-only call
        });
        return this.wrapSync(identity);
    }
}
exports["default"] = SnapshotSourceModule;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/snapshot-source/Instance.js":
/*!**************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/snapshot-source/Instance.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _identity, _getConnection, _getClient, _startConnection, _setUpConnectionListener;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SnapshotSource = void 0;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/openfin-adapter/src/api/snapshot-source/utils.js");
const connectionMap = new Map();
/**
 * Enables configuring a SnapshotSource with custom getSnapshot and applySnapshot methods.
 * @namespace
 */
class SnapshotSource extends base_1.Base {
    constructor(wire, id) {
        super(wire);
        _identity.set(this, void 0);
        _getConnection.set(this, () => {
            if (!connectionMap.has(this.identity.uuid)) {
                connectionMap.set(this.identity.uuid, { eventFired: null, clientPromise: null });
            }
            return connectionMap.get(this.identity.uuid);
        });
        _getClient.set(this, () => {
            if (!__classPrivateFieldGet(this, _getConnection).call(this).clientPromise) {
                __classPrivateFieldGet(this, _getConnection).call(this).clientPromise = __classPrivateFieldGet(this, _startConnection).call(this);
            }
            return __classPrivateFieldGet(this, _getConnection).call(this).clientPromise;
        });
        _startConnection.set(this, async () => {
            const channelName = utils_1.getSnapshotSourceChannelName(this.identity);
            try {
                if (!__classPrivateFieldGet(this, _getConnection).call(this).eventFired) {
                    await __classPrivateFieldGet(this, _setUpConnectionListener).call(this);
                }
                const client = await this.fin.InterApplicationBus.Channel.connect(channelName, { wait: false });
                client.onDisconnection(() => {
                    __classPrivateFieldGet(this, _getConnection).call(this).clientPromise = null;
                    __classPrivateFieldGet(this, _getConnection).call(this).eventFired = null;
                });
                return client;
            }
            catch (e) {
                __classPrivateFieldGet(this, _getConnection).call(this).clientPromise = null;
                throw new Error("The targeted SnapshotSource is not currently initialized. Await this object's ready() method.");
            }
        });
        _setUpConnectionListener.set(this, async () => {
            const channelName = utils_1.getSnapshotSourceChannelName(this.identity);
            let resolve;
            let reject;
            const eventFired = new Promise((y, n) => {
                resolve = y;
                reject = n;
            });
            __classPrivateFieldGet(this, _getConnection).call(this).eventFired = eventFired;
            const listener = async (e) => {
                try {
                    if (e.channelName === channelName) {
                        resolve();
                        await this.fin.InterApplicationBus.Channel.removeListener('connected', listener);
                    }
                }
                catch (err) {
                    reject(err);
                }
            };
            await this.fin.InterApplicationBus.Channel.on('connected', listener);
        });
        __classPrivateFieldSet(this, _identity, id);
    }
    get identity() {
        return __classPrivateFieldGet(this, _identity);
    }
    /**
     * Method to determine if the SnapshotSource has been initialized.
     *
     * Use when the parent application is starting up to ensure the SnapshotSource is able to accept and
     * apply a snapshot using the {@link SnapshotSource#applySnapshot applySnapshot} method.
     * @return { Promise<void> }
     * @tutorial SnapshotSource.ready
     */
    async ready() {
        this.wire.sendAction('snapshot-source-ready').catch((e) => {
            // don't expose, analytics-only call
        });
        // eslint-disable-next-line no-async-promise-executor
        try {
            // If getClient was already called before this, do we have a timing issue where the channel might have been created but we missed the event but this still fails?
            await __classPrivateFieldGet(this, _getClient).call(this);
        }
        catch (e) {
            // it was not running.
            await __classPrivateFieldGet(this, _getConnection).call(this).eventFired;
        }
    }
    /**
     * Call the SnapshotSource's getSnapshot method defined by {@link SnapshotSource#init init}.
     * @return { Promise<any> }
     */
    async getSnapshot() {
        this.wire.sendAction('snapshot-source-get-snapshot').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet(this, _getClient).call(this);
        const response = (await client.dispatch("get-snapshot" /* GET_SNAPSHOT */));
        return (await response).snapshot;
    }
    /**
     * Call the SnapshotSource's applySnapshot method defined by {@link SnapshotSource#init init}.
     * @return { Promise<void> }
     */
    async applySnapshot(snapshot) {
        this.wire.sendAction('snapshot-source-apply-snapshot').catch((e) => {
            // don't expose, analytics-only call
        });
        const client = await __classPrivateFieldGet(this, _getClient).call(this);
        return client.dispatch("apply-snapshot" /* APPLY_SNAPSHOT */, { snapshot });
    }
}
exports.SnapshotSource = SnapshotSource;
_identity = new WeakMap(), _getConnection = new WeakMap(), _getClient = new WeakMap(), _startConnection = new WeakMap(), _setUpConnectionListener = new WeakMap();


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/snapshot-source/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/snapshot-source/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Factory_1 = __webpack_require__(/*! ./Factory */ "./node_modules/openfin-adapter/src/api/snapshot-source/Factory.js");
exports["default"] = Factory_1.default;
__exportStar(__webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/snapshot-source/Instance.js"), exports);


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/snapshot-source/utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/snapshot-source/utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SnapshotSourceActions = exports.getSnapshotSourceChannelName = void 0;
const channelPrefix = 'snapshot-source-provider-';
exports.getSnapshotSourceChannelName = (id) => `${channelPrefix}${id.uuid}`;
var SnapshotSourceActions;
(function (SnapshotSourceActions) {
    SnapshotSourceActions["GET_SNAPSHOT"] = "get-snapshot";
    SnapshotSourceActions["APPLY_SNAPSHOT"] = "apply-snapshot";
})(SnapshotSourceActions = exports.SnapshotSourceActions || (exports.SnapshotSourceActions = {}));


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/system/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/system/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const transport_errors_1 = __webpack_require__(/*! ../../transport/transport-errors */ "./node_modules/openfin-adapter/src/transport/transport-errors.js");
const window_1 = __webpack_require__(/*! ../window */ "./node_modules/openfin-adapter/src/api/window/index.js");
/**
 * AppAssetInfo interface
 * @typedef { object } AppAssetInfo
 * @property { string } src  The URL to a zip file containing the package files (executables, dlls, etc…)
 * @property { string } alias The name of the asset
 * @property { string } version The version of the package
 * @property { string } target Specify default executable to launch. This option can be overridden in launchExternalProcess
 * @property { string } args The default command line arguments for the aforementioned target.
 * @property { boolean } mandatory When set to true, the app will fail to load if the asset cannot be downloaded.
 * When set to false, the app will continue to load if the asset cannot be downloaded. (Default: true)
 */
/**
 * AppAssetRequest interface
 * @typedef { object } AppAssetRequest
 * @property { string } alias The name of the asset
 */
/**
 * ApplicationInfo interface
 * @typedef { object } ApplicationInfo
 * @property { boolean } isPlatform true when the application is a Platform controller
 * @property { boolean } isRunning  true when the application is running
 * @property { string } uuid uuid of the application
 * @property { string } parentUuid uuid of the application that launches this application
 */
/**
 * @typedef { object } ClearCacheOption
 * @summary Clear cache options.
 * @desc These are the options required by the clearCache function.
 *
 * @property {boolean} appcache html5 application cache
 * @property {boolean} cache browser data cache for html files and images
 * @property {boolean} cookies browser cookies
 * @property {boolean} localStorage browser data that can be used across sessions
 */
/**
 * CookieInfo interface
 * @typedef { object } CookieInfo
 * @property { string } name  The name of the cookie
 * @property { string } domain The domain of the cookie
 * @property { string } path The path of the cookie
 */
/**
 * CookieOption interface
 * @typedef { object } CookieOption
 * @property { string } name The name of the cookie
 */
/**
 * CpuInfo interface
 * @typedef { object } CpuInfo
 * @property { string } model The model of the cpu
 * @property { number } speed The number in MHz
 * @property { Time } times The numbers of milliseconds the CPU has spent in different modes.
 */
/**
 * CrashReporterOption interface
 * @typedef { object } CrashReporterOption
 * @property { boolean } diagnosticMode In diagnostic mode the crash reporter will send diagnostic logs to
 *  the OpenFin reporting service on runtime shutdown
 * @property { boolean } isRunning check if it's running
 */
/**
 * DipRect interface
 * @typedef { object } DipRect
 * @property { Rect } dipRect The DIP coordinates
 * @property { Rect } scaledRect The scale coordinates
 */
/**
 * DipScaleRects interface
 * @typedef { object } DipScaleRects
 * @property { Rect } dipRect The DIP coordinates
 * @property { Rect } scaledRect The scale coordinates
 */
/**
 * DownloadPreloadInfo interface
 * @typedef { object } DownloadPreloadInfo
 * @desc downloadPreloadScripts function return value
 * @property { string } url url to the preload script
 * @property { string } error error during preload script acquisition
 * @property { boolean } succeess download operation success
 */
/**
 * DownloadPreloadOption interface
 * @typedef { object } DownloadPreloadOption
 * @desc These are the options object required by the downloadPreloadScripts function
 * @property { string } url url to the preload script
 */
/**
 * Entity interface
 * @typedef { object } Entity
 * @property { string } type The type of the entity
 * @property { string } uuid The uuid of the entity
 */
/**
 * EntityInfo interface
 * @typedef { object } EntityInfo
 * @property { string } name The name of the entity
 * @property { string } uuid The uuid of the entity
 * @property { Identity } parent The parent of the entity
 * @property { string } entityType The type of the entity
 */
/**
 * ExternalApplicationInfo interface
 * @typedef { object } ExternalApplicationInfo
 * @property { Identity } parent The parent identity
 */
/**
 * ExternalConnection interface
 * @typedef { object } ExternalConnection
 * @property { string } token The token to broker an external connection
 * @property { string } uuid The uuid of the external connection
 */
/**
 * ExternalProcessRequestType interface
 * @typedef { object } ExternalProcessRequestType
 * @property { string } path The file path to where the running application resides
 * @property { string } arguments The argument passed to the running application
 * @property { LaunchExternalProcessListener } listener This is described in the {LaunchExternalProcessListner} type definition
 * @property { string } initialWindowState Initial window state after launching: 'normal' (default), 'minimized', 'maximized'
 */
/**
 * FrameInfo interface
 * @typedef { object } FrameInfo
 * @property { string } name The name of the frame
 * @property { string } uuid The uuid of the frame
 * @property { EntityType } entityType The entity type, could be 'window', 'iframe', 'external connection' or 'unknown'
 * @property { Identity } parent The parent identity
 */
/**
 * GetLogRequestType interface
 * @typedef { object } GetLogRequestType
 * @property { string } name The name of the running application
 * @property { number } endFile The file length of the log file
 * @property { number } sizeLimit The set size limit of the log file
 */
/**
 * GpuInfo interface
 * @typedef { object } GpuInfo
 * @property { string } name The graphics card name
 */
/**
 * HostSpecs interface
 * @typedef { object } HostSpecs
 * @property { boolean } aeroGlassEnabled Value to check if Aero Glass theme is supported on Windows platforms
 * @property { string } arch "x86" for 32-bit or "x86_64" for 64-bit
 * @property { Array<CpuInfo> } cpus The same payload as Node's os.cpus()
 * @property { GpuInfo } gpu The graphics card name
 * @property { number } memory The same payload as Node's os.totalmem()
 * @property { string } name The OS name and version/edition
 * @property { boolean } screenSaver Value to check if screensaver is running. Supported on Windows only
 */
/**
 * Identity interface
 * @typedef { object } Identity
 * @property { string } name Optional - the name of the component
 * @property { string } uuid Universally unique identifier of the application
 */
/**
 * LogInfo interface
 * @typedef { object } LogInfo
 * @property { string } name The filename of the log
 * @property { number } size The size of the log in bytes
 * @property { string } date The unix time at which the log was created "Thu Jan 08 2015 14:40:30 GMT-0500 (Eastern Standard Time)"
 */
/**
 * ManifestInfo interface
 * @typedef { object } ManifestInfo
 * @property { string } uuid The uuid of the application
 * @property { string } manifestUrl The runtime manifest URL
 */
/**
 * MonitorDetails interface
 * @typedef { object } MonitorDetails
 * @property { DipScaleRects } available The available DIP scale coordinates
 * @property { Rect } availableRect The available monitor coordinates
 * @property { string } deviceId The device id of the display
 * @property { boolean } displayDeviceActive true if the display is active
 * @property { number } deviceScaleFactor The device scale factor
 * @property { Rect } monitorRect The monitor coordinates
 * @property { string } name The name of the display
 * @property { Point } dpi The dots per inch
 * @property { DipScaleRects } monitor The monitor coordinates
 */
/**
 * MonitorInfo interface
 * @typedef { object } MonitorInfo
 * @property { number } deviceScaleFactor The device scale factor
 * @property { Point } dpi The dots per inch
 * @property { Array<MonitorDetails> } nonPrimaryMonitors The array of monitor details
 * @property { MonitorDetails } primaryMonitor The monitor details
 * @property { string } reason always "api-query"
 * @property { TaskBar } taskBar The taskbar on monitor
 * @property { DipRect } virtualScreen The virtual display screen coordinates
 */
/**
 * @typedef { verbose | info | warning | error | fatal } LogLevel
 * @summary Log verbosity levels.
 * @desc Describes the minimum level (inclusive) above which logs will be written
 *
 * @property { string } verbose all logs written
 * @property { string } info info and above
 * @property { string } warning warning and above
 * @property { string } error error and above
 * @property { string } fatal fatal only, indicates a crash is imminent
 */
/**
 * PointTopLeft interface
 * @typedef { object } PointTopLeft
 * @property { number } top The mouse top position in virtual screen coordinates
 * @property { number } left The mouse left position in virtual screen coordinates
 */
/**
 * Point interface
 * @typedef { object } Point
 * @property { number } x The mouse x position
 * @property { number } y The mouse y position
 */
/**
 * ProcessInfo interface
 * @typedef { object } ProcessInfo
 * @property { number } cpuUsage The percentage of total CPU usage
 * @property { string } name The application name
 * @property { number } nonPagedPoolUsage The current nonpaged pool usage in bytes
 * @property { number } pageFaultCount The number of page faults
 * @property { number } pagedPoolUsage The current paged pool usage in bytes
 * @property { number } pagefileUsage The total amount of memory in bytes that the memory manager has committed
 * @property { number } peakNonPagedPoolUsage The peak nonpaged pool usage in bytes
 * @property { number } peakPagedPoolUsage The peak paged pool usage in bytes
 * @property { number } peakPagefileUsage The peak value in bytes of pagefileUsage during the lifetime of this process
 * @property { number } peakWorkingSetSize The peak working set size in bytes
 * @property { number } processId The native process identifier
 * @property { string } uuid The application UUID
 * @property { number } workingSetSize The current working set size (both shared and private data) in bytes
 */
/**
 * SystemProcessInfo interface
 * @typedef { object } SystemProcessInfo
 * @property { ProcessDetails } browserProcess Info on browser process
 * @property { Array<AppProcessInfo> } apps Array of apps and their process info
 */
/**
 * AppProcessInfo interface
 * @typedef { object } AppProcessInfo
 * @property { string } uuid The uuid of the application
 * @property { Array<EntityProcessDetails> } entities  Array of process info for each window and view for the application
 */
/**
 * EntityProcessDetails interface
 * @typedef { object } EntityProcessDetails
 * @property { string } uuid The uuid for the entity
 * @property { string } name The name for the entity
 * @property { string } url URL associated with the entity
 * @property { string } entityType Type for the entity: window or view
 * @property { number } cpuUsage The percentage of total CPU usage
 * @property { number } nonPagedPoolUsage The current nonpaged pool usage in bytes
 * @property { number } pageFaultCount The number of page faults
 * @property { number } pagedPoolUsage The current paged pool usage in bytes
 * @property { number } pagefileUsage The total amount of memory in bytes that the memory manager has committed
 * @property { number } peakNonPagedPoolUsage The peak nonpaged pool usage in bytes
 * @property { number } peakPagedPoolUsage The peak paged pool usage in bytes
 * @property { number } peakPagefileUsage The peak value in bytes of pagefileUsage during the lifetime of this process
 * @property { number } peakWorkingSetSize The peak working set size in bytes
 * @property { number } workingSetSize The current working set size (both shared and private data) in bytes
 * @property { number } pid The native process identifier
 * @property { Array<FrameProcessDetails> } frames Array of process info for each iframe corresponeding to the entity
 */
/**
 * FrameProcessDetails interface
 * @typedef { object } FrameProcessDetails
 * @property { string } url Current URL associated with the process
 * @property { string } entityType Type for the frame
 * @property { number } cpuUsage The percentage of total CPU usage
 * @property { number } nonPagedPoolUsage The current nonpaged pool usage in bytes
 * @property { number } pageFaultCount The number of page faults
 * @property { number } pagedPoolUsage The current paged pool usage in bytes
 * @property { number } pagefileUsage The total amount of memory in bytes that the memory manager has committed
 * @property { number } peakNonPagedPoolUsage The peak nonpaged pool usage in bytes
 * @property { number } peakPagedPoolUsage The peak paged pool usage in bytes
 * @property { number } peakPagefileUsage The peak value in bytes of pagefileUsage during the lifetime of this process
 * @property { number } peakWorkingSetSize The peak working set size in bytes
 * @property { number } workingSetSize The current working set size (both shared and private data) in bytes
 * @property { number } pid The native process identifier
 */
/**
 * ProcessDetails interface
 * @typedef { object } ProcessDetails
 * @property { number } cpuUsage The percentage of total CPU usage
 * @property { number } nonPagedPoolUsage The current nonpaged pool usage in bytes
 * @property { number } pageFaultCount The number of page faults
 * @property { number } pagedPoolUsage The current paged pool usage in bytes
 * @property { number } pagefileUsage The total amount of memory in bytes that the memory manager has committed
 * @property { number } peakNonPagedPoolUsage The peak nonpaged pool usage in bytes
 * @property { number } peakPagedPoolUsage The peak paged pool usage in bytes
 * @property { number } peakPagefileUsage The peak value in bytes of pagefileUsage during the lifetime of this process
 * @property { number } peakWorkingSetSize The peak working set size in bytes
 * @property { number } workingSetSize The current working set size (both shared and private data) in bytes
 * @property { number } pid The native process identifier
 */
/**
 * ProxyConfig interface
 * @typedef { object } ProxyConfig
 * @property { string } proxyAddress The configured proxy address
 * @property { number } proxyPort The configured proxy port
 * @property { string } type The proxy Type
 */
/**
 * ProxyInfo interface
 * @typedef { object } ProxyInfo
 * @property { ProxyConfig } config The proxy config
 * @property { ProxySystemInfo } system The proxy system info
 */
/**
 * QueryPermissionResult interface
 * @typedef { object } QueryPermissionResult
 * @property { string } permission The full name of a secured API
 * @property { string } state 'granted' | 'denied' | 'unavailable'
 * @property { boolean } granted true if permission is granted
 * @property { object } [rawValue] The value of permission
 */
/**
 * ProxySystemInfo interface
 * @typedef { object } ProxySystemInfo
 * @property { string } autoConfigUrl The auto configuration url
 * @property { string } bypass The proxy bypass info
 * @property { boolean } enabled Value to check if a proxy is enabled
 * @property { string } proxy The proxy info
 */
/**
 * Rect interface
 * @typedef { object } Rect
 * @property { number } bottom The bottom-most coordinate
 * @property { number } left The left-most coordinate
 * @property { number } right The right-most coordinate
 * @property { number } top The top-most coordinate
 */
/**
 * RegistryInfo interface
 * @typedef { object } RegistryInfo
 * @property { any } data The registry data
 * @property { string } rootKey The registry root key
 * @property { string } subkey The registry key
 * @property { string } type The registry type
 * @property { string } value The registry value name
 */
/**
 * RuntimeDownloadOptions interface
 * @typedef { object } RuntimeDownloadOptions
 * @desc These are the options object required by the downloadRuntime function.
 * @property { string } version The given version to download
 */
/**
 * RuntimeInfo interface
 * @typedef { object } RuntimeInfo
 * @property { string } architecture The runtime build architecture
 * @property { string } manifestUrl The runtime manifest URL
 * @property { number } port The runtime websocket port
 * @property { string } securityRealm The runtime security realm
 * @property { string } version The runtime version
 * @property { object } args the command line argument used to start the Runtime
 * @property { string } chromeVersion The chrome version
 * @property { string } electronVersion The electron version
 */
/**
 * RVMInfo interface
 * @typedef { object } RVMInfo
 * @property { string } action The name of action: "get-rvm-info"
 * @property { string } appLogDirectory The app log directory
 * @property { string } path The path of OpenfinRVM.exe
 * @property { string } 'start-time' The start time of RVM
 * @property { string } version The version of RVM
 * @property { string } 'working-dir' The working directory
 */
/**
 * RvmLaunchOptions interface
 * @typedef { object } RvmLaunchOptions
 * @property { boolean } [noUi] true if no UI when launching
 * @property { object } [userAppConfigArgs] The user app configuration args
 */
/**
 * ServiceIdentifier interface
 * @typedef { object } ServiceIdentifier
 * @property { string } name The name of the service
 */
/**
 * ServiceConfiguration interface
 * @typedef { object } ServiceConfiguration
 * @property { object } config The service configuration
 * @property { string } name The name of the service
 */
/**
 * ShortCutConfig interface
 * @typedef { object } ShortCutConfig
 * @property { boolean } desktop true if application has a shortcut on the desktop
 * @property { boolean } startMenu true if application has shortcut in the start menu
 * @property { boolean } systemStartup true if application will be launched on system startup
 */
/**
 * SubOptions interface
 * @typedef { Object } SubOptions
 * @property { number } timestamp The event timestamp
 */
/**
 * TaskBar interface
 * @typedef { object } TaskBar
 * @property { string } edge which edge of a monitor the taskbar is on
 * @property { Rect } rect The taskbar coordinates
 */
/**
 * TerminateExternalRequestType interface
 * @typedef { object } TerminateExternalRequestType
 * @property { string } uuid The uuid of the running application
 * @property { number } timeout Time out period before the running application terminates
 * @property { boolean } killtree Value to terminate the running application
 */
/**
 * Time interface
 * @typedef { object } Time
 * @property { number } user The number of milliseconds the CPU has spent in user mode
 * @property { number } nice The number of milliseconds the CPU has spent in nice mode
 * @property { number } sys The number of milliseconds the CPU has spent in sys mode
 * @property { number } idle The number of milliseconds the CPU has spent in idle mode
 * @property { number } irq The number of milliseconds the CPU has spent in irq mode
 */
/**
 * TrayInfo interface
 * @typedef { object } TrayInfo
 * @property { Bounds } bounds The bound of tray icon in virtual screen pixels
 * @property { MonitorInfo } monitorInfo Please see fin.System.getMonitorInfo for more information
 * @property { number } x copy of bounds.x
 * @property { number } y copy of bounds.y
 */
/**
 * WindowDetail interface
 * @typedef { object } WindowDetail
 * @property { number } bottom The bottom-most coordinate of the window
 * @property { number } height The height of the window
 * @property { boolean } isShowing Value to check if the window is showing
 * @property { number } left The left-most coordinate of the window
 * @property { string } name The name of the window
 * @property { number } right The right-most coordinate of the window
 * @property { string } state The window state
 * @property { number } top The top-most coordinate of the window
 * @property { number } width The width of the window
 */
/**
 * WindowInfo interface
 * @typedef { object } WindowInfo
 * @property { Array<WindowDetail> } childWindows The array of child windows details
 * @property { WindowDetail } mainWindow The main window detail
 * @property { string } uuid The uuid of the application
 */
/**
 * CertifiedAppInfo interface
 * @typedef { object } CertifiedAppInfo
 * @property { boolean } isRunning true if the app is running
 * @property { boolean } [isOptedIntoCertfiedApp] true if the app has opted into certification
 * @property { boolean } [isCertified] true if the app is certified
 * @property { boolean } [isSSLCertified] true if the app manifest's SSL certificate is valid
 * @property { boolean } [isPresentInAppDirectory] true if the app is present in the OpenFin app directory
 */
/**
 * An object representing the core of OpenFin Runtime. Allows the developer
 * to perform system-level actions, such as accessing logs, viewing processes,
 * clearing the cache and exiting the runtime as well as listen to <a href="tutorial-System.EventEmitter.html">system events</a>.
 * @namespace
 */
class System extends base_1.EmitterBase {
    constructor(wire) {
        super(wire, ['system']);
    }
    sendExternalProcessRequest(action, options) {
        return new Promise((resolve, reject) => {
            const exitEventKey = 'external-process-exited';
            let processUuid;
            let exitPayload;
            let externalProcessExitHandler;
            let ofWindow;
            if (typeof options.listener === 'function') {
                externalProcessExitHandler = (payload) => {
                    const data = payload || {};
                    exitPayload = {
                        topic: 'exited',
                        uuid: data.processUuid || '',
                        exitCode: data.exitCode || 0
                    };
                    if (processUuid === payload.processUuid) {
                        options.listener(exitPayload);
                        ofWindow.removeListener(exitEventKey, externalProcessExitHandler);
                    }
                };
                // window constructor expects the name is not undefined
                if (!this.wire.me.name) {
                    this.wire.me.name = this.wire.me.uuid;
                }
                ofWindow = new window_1._Window(this.wire, this.wire.me);
                ofWindow.on(exitEventKey, externalProcessExitHandler);
            }
            this.wire
                .sendAction(action, options)
                .then(({ payload }) => {
                processUuid = payload.data.uuid;
                resolve(payload.data);
                if (exitPayload && processUuid === exitPayload.uuid) {
                    options.listener(exitPayload);
                    ofWindow.removeListener(exitEventKey, externalProcessExitHandler);
                }
            })
                .catch((err) => {
                if (ofWindow) {
                    ofWindow.removeListener(exitEventKey, externalProcessExitHandler);
                }
                reject(err);
            });
        });
    }
    /**
     * Adds a listener to the end of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - Called whenever an event of the specified type occurs.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function addListener
     * @memberof System
     * @instance
     * @tutorial System.EventEmitter
     */
    /**
     * Adds a listener to the end of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - Called whenever an event of the specified type occurs.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function on
     * @memberof System
     * @instance
     * @tutorial System.EventEmitter
     */
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function once
     * @memberof System
     * @instance
     * @tutorial System.EventEmitter
     */
    /**
     * Adds a listener to the beginning of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function prependListener
     * @memberof System
     * @instance
     * @tutorial System.EventEmitter
     */
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.
     * The listener is added to the beginning of the listeners array.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function prependOnceListener
     * @memberof System
     * @instance
     * @tutorial System.EventEmitter
     */
    /**
     * Remove a listener from the listener array for the specified event.
     * Caution: Calling this method changes the array indices in the listener array behind the listener.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function removeListener
     * @memberof System
     * @instance
     * @tutorial System.EventEmitter
     */
    /**
     * Removes all listeners, or those of the specified event.
     * @param { string | symbol } [eventType]  - The type of the event.
     * @return {Promise.<this>}
     * @function removeAllListeners
     * @memberof System
     * @instance
     * @tutorial System.EventEmitter
     */
    /**
     * Returns the version of the runtime. The version contains the major, minor,
     * build and revision numbers.
     * @return {Promise.<string>}
     * @tutorial System.getVersion
     */
    getVersion() {
        return this.wire.sendAction('get-version').then(({ payload }) => payload.data);
    }
    /**
     * Clears cached data containing application resource
     * files (images, HTML, JavaScript files), cookies, and items stored in the
     * Local Storage.
     * @param { ClearCacheOption } options - See tutorial for more details.
     * @return {Promise.<void>}
     * @tutorial System.clearCache
     */
    clearCache(options) {
        return this.wire.sendAction('clear-cache', options).then(() => undefined);
    }
    /**
     * Clears all cached data when OpenFin Runtime exits.
     * @return {Promise.<void>}
     * @tutorial System.deleteCacheOnExit
     */
    deleteCacheOnExit() {
        return this.wire.sendAction('delete-cache-request').then(() => undefined);
    }
    /**
     * Exits the Runtime.
     * @return {Promise.<void>}
     * @tutorial System.exit
     */
    exit() {
        return this.wire.sendAction('exit-desktop').then(() => undefined);
    }
    /**
     * Fetches a JSON manifest using the browser process and returns a Javascript object.
     * @param { string } manifestUrl The URL of the manifest to fetch.
     * @return {Promise.<any>}
     * @tutorial System.fetchManifest
     */
    async fetchManifest(manifestUrl) {
        const { payload: { data } } = await this.wire.sendAction('fetch-manifest', { manifestUrl });
        return data;
    }
    /**
     * Writes any unwritten cookies data to disk.
     * @return {Promise.<void>}
     * @tutorial System.flushCookieStore
     */
    flushCookieStore() {
        return this.wire.sendAction('flush-cookie-store').then(() => undefined);
    }
    /**
     * Retrieves an array of data (name, ids, bounds) for all application windows.
     * @return {Promise.Array.<WindowInfo>}
     * @tutorial System.getAllWindows
     */
    getAllWindows() {
        return this.wire.sendAction('get-all-windows').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an array of data for all applications.
     * @return {Promise.Array.<ApplicationInfo>}
     * @tutorial System.getAllApplications
     */
    getAllApplications() {
        return this.wire.sendAction('get-all-applications').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves the command line argument string that started OpenFin Runtime.
     * @return {Promise.<string>}
     * @tutorial System.getCommandLineArguments
     */
    getCommandLineArguments() {
        return this.wire.sendAction('get-command-line-arguments').then(({ payload }) => payload.data);
    }
    /**
     * Get the current state of the crash reporter.
     * @return {Promise.<CrashReporterOption>}
     * @tutorial System.getCrashReporterState
     */
    getCrashReporterState() {
        return this.wire.sendAction('get-crash-reporter-state').then(({ payload }) => payload.data);
    }
    /* <-- Note the one asterisk to hide from jsdoc because we don't want to publish this method anymore.
     * @deprecated Use {@link System.getMachineId} instead.
     */
    getDeviceId() {
        console.warn('Function is deprecated; use getMachineId instead.');
        return this.wire.sendAction('get-device-id').then(({ payload }) => payload.data);
    }
    /**
     * Start the crash reporter for the browser process if not already running.
     * You can optionally specify `diagnosticMode` to have the logs sent to
     * OpenFin on runtime close
     *
     * @param { CrashReporterOption } options - configure crash reporter
     * @return {Promise.<CrashReporterOption>}
     * @tutorial System.startCrashReporter
     */
    startCrashReporter(options) {
        return new Promise((resolve, reject) => {
            if (!options.diagnosticMode) {
                return reject(new Error('diagnosticMode not found in options'));
            }
            return this.wire
                .sendAction('start-crash-reporter', options)
                .then(({ payload }) => resolve(payload.data))
                .catch((err) => {
                reject(err);
            });
        });
    }
    /**
     * Returns a hex encoded hash of the mac address and the currently logged in user name
     * @return {Promise.<string>}
     * @tutorial System.getDeviceUserId
     */
    getDeviceUserId() {
        console.warn('Deprecation Warning: getDeviceUserId is deprecated. Please use System.getUniqueUserId');
        return this.wire.sendAction('get-device-user-id').then(({ payload }) => payload.data);
    }
    /**
     * Returns a hex encoded hash of the machine id and the currently logged in user name.
     * This is the recommended way to uniquely identify a user / machine combination.
     * @return {Promise.<string>}
     * @tutorial System.getUniqueUserId
     * @static
     */
    getUniqueUserId() {
        return this.wire.sendAction('get-unique-user-id').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves a frame info object for the uuid and name passed in
     * @param { string } uuid - The UUID of the target.
     * @param { string } name - The name of the target.
     * @return {Promise.<EntityInfo>}
     * @tutorial System.getEntityInfo
     */
    getEntityInfo(uuid, name) {
        return this.wire.sendAction('get-entity-info', { uuid, name }).then(({ payload }) => payload.data);
    }
    /**
     * Gets the value of a given environment variable on the computer on which the runtime is installed
     * @return {Promise.<string>}
     * @tutorial System.getEnvironmentVariable
     */
    getEnvironmentVariable(envName) {
        return this.wire
            .sendAction('get-environment-variable', {
            environmentVariables: envName
        })
            .then(({ payload }) => payload.data);
    }
    /**
     * Get current focused window.
     * @return {Promise.<WindowInfo>}
     * @tutorial System.getFocusedWindow
     */
    getFocusedWindow() {
        return this.wire.sendAction('get-focused-window').then(({ payload }) => payload.data);
    }
    /**
     * Get currently focused external window.
     * @return {Promise.<Identity>}
     * @experimental
     * @deprecated System.getFocusedExternalWindow will be removed by major version 22.
     */
    async getFocusedExternalWindow() {
        console.warn('Deprecation Warning: System.getFocusedExternalWindow will be removed by major version 22.');
        const { payload: { data } } = await this.wire.sendAction('get-focused-external-window');
        return data;
    }
    /**
     * Returns information about the given app's certification status
     * @return {Promise.<CertifiedAppInfo>}
     * @tutorial System.isAppCertified
     */
    async isAppCertified(manifestUrl) {
        const { payload: { data: { certifiedInfo } } } = await this.wire.sendAction('is-app-certified', { manifestUrl });
        return certifiedInfo;
    }
    /**
     * Returns an array of all the installed runtime versions in an object.
     * @return {Promise.<string[]>}
     * @tutorial System.getInstalledRuntimes
     */
    // incompatible with standalone node process.
    getInstalledRuntimes() {
        return this.wire.sendAction('get-installed-runtimes').then(({ payload }) => payload.data.runtimes);
    }
    // incompatible with standalone node process.
    async getInstalledApps() {
        const { payload: { data: { installedApps } } } = await this.wire.sendAction('get-installed-apps');
        return installedApps;
    }
    /**
     * Retrieves the contents of the log with the specified filename.
     * @param { GetLogRequestType } options A object that id defined by the GetLogRequestType interface
     * @return {Promise.<string>}
     * @tutorial System.getLog
     */
    getLog(options) {
        return this.wire.sendAction('view-log', options).then(({ payload }) => payload.data);
    }
    /**
     * Returns a unique identifier (UUID) provided by the machine.
     * @return {Promise.<string>}
     * @tutorial System.getMachineId
     */
    getMachineId() {
        return this.wire.sendAction('get-machine-id').then(({ payload }) => payload.data);
    }
    /**
     * Returns the minimum (inclusive) logging level that is currently being written to the log.
     * @return {Promise.<LogLevel>}
     * @tutorial System.getMinLogLevel
     */
    getMinLogLevel() {
        return this.wire.sendAction('get-min-log-level').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an array containing information for each log file.
     * @return {Promise.Array<LogInfo>}
     * @tutorial System.getLogList
     */
    getLogList() {
        return this.wire.sendAction('list-logs').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an object that contains data about the monitor setup of the
     * computer that the runtime is running on.
     * @return {Promise.<MonitorInfo>}
     * @tutorial System.getMonitorInfo
     */
    getMonitorInfo() {
        return this.wire.sendAction('get-monitor-info').then(({ payload }) => payload.data);
    }
    /**
     * Returns the mouse in virtual screen coordinates (left, top).
     * @return {Promise.<PointTopLeft>}
     * @tutorial System.getMousePosition
     */
    getMousePosition() {
        return this.wire.sendAction('get-mouse-position').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an array of all of the runtime processes that are currently
     * running. Each element in the array is an object containing the uuid
     * and the name of the application to which the process belongs.
     * @deprecated Please use our new set of process APIs:
     * [Window.getProcessInfo]{@link Window#getProcessInfo}
     * [View.getProcessInfo]{@link View#getProcessInfo}
     * [Application.getProcessInfo]{@link Application#getProcessInfo}
     * [System.getAllProcessInfo]{@link System#getAllProcessInfo}
     * @return {Promise.Array.<ProcessInfo>}
     * @tutorial System.getProcessList
     */
    getProcessList() {
        // eslint-disable-next-line no-console
        console.warn('System.getProcessList has been deprecated. Please consider using our new process APIs: Window.getProcessInfo, View.getProcessInfo, Application.getProcessInfo, System.getAllProcessInfo');
        return this.wire.sendAction('process-snapshot').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves all process information. This includes the browser process and every process associated to all entities (windows and views).
     * @return {Promise.<SystemProcessInfo>}
     * @tutorial System.getAllProcessInfo
     * @experimental
     */
    async getAllProcessInfo() {
        const { payload: { data } } = await this.wire.sendAction('get-all-process-info', this.identity);
        return data;
    }
    /**
     * Retrieves the Proxy settings.
     * @return {Promise.<ProxyInfo>}
     * @tutorial System.getProxySettings
     */
    getProxySettings() {
        return this.wire.sendAction('get-proxy-settings').then(({ payload }) => payload.data);
    }
    /**
     * Returns information about the running Runtime in an object.
     * @return {Promise.<RuntimeInfo>}
     * @tutorial System.getRuntimeInfo
     */
    getRuntimeInfo() {
        return this.wire.sendAction('get-runtime-info').then(({ payload }) => payload.data);
    }
    /**
     * Returns information about the running RVM in an object.
     * @return {Promise.<RVMInfo>}
     * @tutorial System.getRvmInfo
     */
    // incompatible with standalone node process.
    getRvmInfo() {
        return this.wire.sendAction('get-rvm-info').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves system information.
     * @return {Promise.<HostSpecs>}
     * @tutorial System.getHostSpecs
     */
    getHostSpecs() {
        return this.wire.sendAction('get-host-specs').then(({ payload }) => payload.data);
    }
    /**
     * Runs an executable or batch file. A path to the file must be included in options.
     * <br> A uuid may be optionally provided. If not provided, OpenFin will create a uuid for the new process.
     * <br> Note: This method is restricted by default and must be enabled via
     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>.
     * @param { ExternalProcessRequestType } options A object that is defined in the ExternalProcessRequestType interface
     * @return {Promise.<Identity>}
     * @tutorial System.launchExternalProcess
     */
    launchExternalProcess(options) {
        return this.sendExternalProcessRequest('launch-external-process', options);
    }
    /**
     * Monitors a running process. A pid for the process must be included in options.
     * <br> A uuid may be optionally provided. If not provided, OpenFin will create a uuid for the new process.
     * @param { ExternalProcessInfo } options See tutorial for more details
     * @return {Promise.<Identity>}
     * @tutorial System.monitorExternalProcess
     */
    monitorExternalProcess(options) {
        return this.sendExternalProcessRequest('monitor-external-process', options);
    }
    /**
     * Writes the passed message into both the log file and the console.
     * @param { string } level The log level for the entry. Can be either "info", "warning" or "error"
     * @param { string } message The log message text
     * @return {Promise.<void>}
     * @tutorial System.log
     */
    log(level, message) {
        return this.wire.sendAction('write-to-log', { level, message }).then(() => undefined);
    }
    /**
     * Opens the passed URL in the default web browser. It only supports http(s) and fin(s) protocols by default.
     * In order to use other custom protocols, they have to be enabled via
     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>.
     * File protocol and file path are not supported.
     * @param { string } url The URL to open
     * @return {Promise.<void>}
     * @tutorial System.openUrlWithBrowser
     */
    openUrlWithBrowser(url) {
        return this.wire.sendAction('open-url-with-browser', { url }).then(() => undefined);
    }
    /**
     * Removes the process entry for the passed UUID obtained from a prior call
     * of fin.System.launchExternalProcess().
     * @param { string } uuid The UUID for a process obtained from a prior call to fin.desktop.System.launchExternalProcess()
     * @return {Promise.<void>}
     * @tutorial System.releaseExternalProcess
     */
    releaseExternalProcess(uuid) {
        return this.wire.sendAction('release-external-process', { uuid }).then(() => undefined);
    }
    /**
     * Shows the Chromium Developer Tools for the specified window
     * @param { Identity } identity This is a object that is defined by the Identity interface
     * @return {Promise.<void>}
     * @tutorial System.showDeveloperTools
     */
    showDeveloperTools(identity) {
        return this.wire.sendAction('show-developer-tools', identity).then(() => undefined);
    }
    /**
     * Attempt to close an external process. The process will be terminated if it
     * has not closed after the elapsed timeout in milliseconds.<br>
     * Note: This method is restricted by default and must be enabled via
     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>.
     * @param { TerminateExternalRequestType } options A object defined in the TerminateExternalRequestType interface
     * @return {Promise.<void>}
     * @tutorial System.terminateExternalProcess
     */
    terminateExternalProcess(options) {
        return this.wire.sendAction('terminate-external-process', options).then(() => undefined);
    }
    /**
     * Update the OpenFin Runtime Proxy settings.
     * @param { ProxyConfig } options A config object defined in the ProxyConfig interface
     * @return {Promise.<void>}
     * @tutorial System.updateProxySettings
     */
    updateProxySettings(options) {
        return this.wire.sendAction('update-proxy', options).then(() => undefined);
    }
    /**
     * Downloads the given application asset<br>
     * Note: This method is restricted by default and must be enabled via
     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>.
     * @param { AppAssetInfo } appAsset App asset object
     * @return {Promise.<void>}
     * @tutorial System.downloadAsset
     */
    // incompatible with standalone node process.
    downloadAsset(appAsset, progressListener) {
        return new Promise((resolve, reject) => {
            // node.js environment not supported
            if (this.wire.environment.constructor.name === 'NodeEnvironment') {
                reject(new transport_errors_1.NotSupportedError('downloadAsset only supported in an OpenFin Render process'));
                return;
            }
            const downloadId = this.wire.environment.getNextMessageId().toString();
            const dlProgressKey = `asset-download-progress-${downloadId}`;
            const dlErrorKey = `asset-download-error-${downloadId}`;
            const dlCompleteKey = `asset-download-complete-${downloadId}`;
            const dlProgress = (progress) => {
                const p = {
                    downloadedBytes: progress.downloadedBytes,
                    totalBytes: progress.totalBytes
                };
                progressListener(p);
            };
            const cleanListeners = () => {
                this.removeListener(dlProgressKey, dlProgress);
            };
            const dlError = (r, err) => {
                const error = err || r;
                cleanListeners();
                reject(new transport_errors_1.RuntimeError(error));
            };
            const dlComplete = () => {
                cleanListeners();
                resolve();
            };
            this.on(dlProgressKey, dlProgress);
            this.once(dlErrorKey, dlError);
            this.once(dlCompleteKey, dlComplete);
            const downloadOptions = Object.assign(appAsset, { downloadId });
            this.wire.sendAction('download-asset', downloadOptions).catch((err) => {
                cleanListeners();
                reject(err);
            });
        });
    }
    /**
     * Downloads a version of the runtime.
     * @param { RuntimeDownloadOptions } options - Download options.
     * @param {Function} [progressListener] - called as the runtime is downloaded with progress information.
     * @return {Promise.<void>}
     * @tutorial System.downloadRuntime
     */
    downloadRuntime(options, progressListener) {
        return new Promise((resolve, reject) => {
            // node.js environment not supported
            if (this.wire.environment.constructor.name === 'NodeEnvironment') {
                reject(new transport_errors_1.NotSupportedError('downloadRuntime only supported in an OpenFin Render process'));
                return;
            }
            const downloadId = this.wire.environment.getNextMessageId().toString();
            const dlProgressKey = `runtime-download-progress-${downloadId}`;
            const dlErrorKey = `runtime-download-error-${downloadId}`;
            const dlCompleteKey = `runtime-download-complete-${downloadId}`;
            const dlProgress = (progress) => {
                const p = {
                    downloadedBytes: progress.downloadedBytes,
                    totalBytes: progress.totalBytes
                };
                progressListener(p);
            };
            const cleanListeners = () => {
                this.removeListener(dlProgressKey, dlProgress);
            };
            const dlError = (r, err) => {
                const error = err || r;
                cleanListeners();
                reject(new transport_errors_1.RuntimeError(error));
            };
            const dlComplete = () => {
                cleanListeners();
                resolve();
            };
            this.on(dlProgressKey, dlProgress);
            this.once(dlErrorKey, dlError);
            this.once(dlCompleteKey, dlComplete);
            const downloadOptions = Object.assign(options, { downloadId });
            this.wire.sendAction('download-runtime', downloadOptions).catch((err) => {
                cleanListeners();
                reject(err);
            });
        });
    }
    /**
     * Download preload scripts from given URLs
     * @param {DownloadPreloadOption[]} scripts - URLs of preload scripts. See tutorial for more details.
     * @return {Promise.Array<DownloadPreloadInfo>}
     * @tutorial System.downloadPreloadScripts
     */
    downloadPreloadScripts(scripts) {
        return this.wire.sendAction('download-preload-scripts', { scripts }).then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an array of data (name, ids, bounds) for all application windows.
     * @return {Promise.Array.<Identity>}
     * @tutorial System.getAllExternalApplications
     */
    getAllExternalApplications() {
        return this.wire.sendAction('get-all-external-applications').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an array of objects representing information about currently
     * running user-friendly native windows on the system.<br>
     * Note: This method is restricted by default and must be enabled via
     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>.
     * @return {Promise.Array.<Identity>}
     * @experimental
     * @deprecated System.getAllExternalWindows will be removed by major version 22.
     */
    getAllExternalWindows() {
        console.warn('Deprecation Warning: System.getAllExternalWindows will be removed by major version 22.');
        return this.wire.sendAction('get-all-external-windows').then(({ payload }) => payload.data);
    }
    /**
     * Retrieves app asset information.
     * @param { AppAssetRequest } options
     * @return {Promise.<AppAssetInfo>}
     * @tutorial System.getAppAssetInfo
     */
    getAppAssetInfo(options) {
        return this.wire.sendAction('get-app-asset-info', options).then(({ payload }) => payload.data);
    }
    /**
     * Get additional info of cookies.
     * @param { CookieOption } options - See tutorial for more details.
     * @return {Promise.Array.<CookieInfo>}
     * @tutorial System.getCookies
     */
    getCookies(options) {
        const url = this.wire.environment.getUrl();
        const newOptions = Object.assign(options, { url });
        return this.wire.sendAction('get-cookies', newOptions).then(({ payload }) => payload.data);
    }
    /**
     * Set the minimum log level above which logs will be written to the OpenFin log
     * @param { LogLevel } The minimum level (inclusive) above which all calls to log will be written
     * @return {Promise.<void>}
     * @tutorial System.setMinLogLevel
     */
    setMinLogLevel(level) {
        return this.wire.sendAction('set-min-log-level', { level }).then(() => undefined);
    }
    /**
     * Retrieves the UUID of the computer on which the runtime is installed
     * @param { string } uuid The uuid of the running application
     * @return {Promise.<Entity>}
     * @tutorial System.resolveUuid
     */
    resolveUuid(uuid) {
        return this.wire
            .sendAction('resolve-uuid', {
            entityKey: uuid
        })
            .then(({ payload }) => payload.data);
    }
    /**
     * Retrieves an array of data for all external applications
     * @param { Identity } requestingIdentity This object is described in the Identity typedef
     * @param { any } data Any data type to pass to the method
     * @return {Promise.<any>}
     * @ignore
     */
    executeOnRemote(requestingIdentity, data) {
        data.requestingIdentity = requestingIdentity;
        return this.wire.ferryAction(data);
    }
    /**
     * Reads the specifed value from the registry.<br>
     * Note: This method is restricted by default and must be enabled via
     * <a href="https://developers.openfin.co/docs/api-security">API security settings</a>.
     * @param { string } rootKey - The registry root key.
     * @param { string } subkey - The registry key.
     * @param { string } value - The registry value name.
     * @return {Promise.<RegistryInfo>}
     * @tutorial System.readRegistryValue
     */
    readRegistryValue(rootKey, subkey, value) {
        return this.wire
            .sendAction('read-registry-value', {
            rootKey,
            subkey,
            value
        })
            .then(({ payload }) => payload.data);
    }
    /**
     * This function call will register a unique id and produce a token.
     * The token can be used to broker an external connection.
     * @param { string } uuid - A UUID for the remote connection.
     * @return {Promise.<ExternalConnection>}
     * @tutorial System.registerExternalConnection
     */
    registerExternalConnection(uuid) {
        return this.wire.sendAction('register-external-connection', { uuid }).then(({ payload }) => payload.data);
    }
    /**
     * Returns the json blob found in the [desktop owner settings](https://openfin.co/documentation/desktop-owner-settings/)
     * for the specified service.
     * More information about desktop services can be found [here](https://developers.openfin.co/docs/desktop-services).
     * @param { ServiceIdentifier } serviceIdentifier An object containing a name key that identifies the service.
     * @return {Promise.<ServiceConfiguration>}
     * @tutorial System.getServiceConfiguration
     */
    async getServiceConfiguration(serviceIdentifier) {
        if (typeof serviceIdentifier.name !== 'string') {
            throw new Error('Must provide an object with a `name` property having a string value');
        }
        const { name } = serviceIdentifier;
        return this.wire.sendAction('get-service-configuration', { name }).then(({ payload }) => payload.data);
    }
    async getSystemAppConfig(name) {
        if (typeof name !== 'string') {
            throw new Error('Must provide a string value for name of system app');
        }
        return this.wire.sendAction('get-system-app-configuration', { name }).then(({ payload }) => payload.data);
    }
    /**
     * Signals the RVM to perform a health check and returns the results as json.
     * @return {Promise.<string[]>}
     * @tutorial System.runRvmHealthCheck
     */
    runRvmHealthCheck() {
        return this.wire.sendAction('run-rvm-health-check').then(({ payload }) => payload.data);
    }
    /**
     * Launch application using a manifest URL/path. It differs from Application.startFromManifest in that this API can accept a manifest using the fin protocol.
     * @param {string} manifestUrl - The manifest's URL or path.
     * @param {RvmLaunchOptions} [opts] - Parameters that the RVM will use.
     * @return {Promise.<Manifest>}
     * @experimental
     * @tutorial System.launchManifest
     * @static
     */
    async launchManifest(manifestUrl, opts) {
        const response = await this.wire.sendAction('launch-manifest', {
            manifestUrl,
            opts
        });
        return response.payload.data.manifest;
    }
    /**
     * Query permission of a secured api in current context.
     * @param {string} apiName - The full name of a secured API.
     * @return {Promise.<QueryPermissionResult>}
     * @tutorial System.queryPermissionForCurrentContext
     */
    async queryPermissionForCurrentContext(apiName) {
        const identity = { uuid: this.wire.me.uuid, name: this.wire.me.name };
        const response = await this.wire.sendAction('query-permission-for-current-context', {
            apiName,
            identity
        });
        return response.payload.data;
    }
    // Not documenting, internal use only.
    async enableNativeWindowIntegrationProvider(permissions) {
        const { payload } = await this.wire.sendAction('enable-native-window-integration-provider', { permissions });
        return payload.data;
    }
}
exports["default"] = System;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/view/Factory.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/view/Factory.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const validate_1 = __webpack_require__(/*! ../../util/validate */ "./node_modules/openfin-adapter/src/util/validate.js");
const EntityType_1 = __webpack_require__(/*! ../../shapes/EntityType */ "./node_modules/openfin-adapter/src/shapes/EntityType.js");
const index_1 = __webpack_require__(/*! ./index */ "./node_modules/openfin-adapter/src/api/view/index.js");
/**
 * @lends View
 */
class ViewModule extends base_1.Base {
    /**
     * Creates a new View.
     * @param { View~options } options - View creation options
     * @return {Promise.<View>}
     * @tutorial View.create
     * @experimental
     * @static
     */
    async create(options) {
        const { uuid } = this.wire.me;
        if (!options.name || typeof options.name !== 'string') {
            throw new Error('Please provide a name property as a string in order to create a View.');
        }
        if (this.wire.environment.childViews) {
            await this.wire.environment.createChildContent({
                entityType: EntityType_1.default.VIEW,
                options: { ...options, uuid }
            });
        }
        else {
            await this.wire.sendAction('create-view', { ...options, uuid });
        }
        return this.wrapSync({ uuid, name: options.name });
    }
    /**
     * Asynchronously returns a View object that represents an existing view.
     * @param { Identity } identity
     * @return {Promise.<View>}
     * @tutorial View.wrap
     * @experimental
     * @static
     */
    async wrap(identity) {
        this.wire.sendAction('view-wrap');
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new index_1.View(this.wire, identity);
    }
    /**
     * Synchronously returns a View object that represents an existing view.
     * @param { Identity } identity
     * @return {View}
     * @tutorial View.wrapSync
     * @experimental
     * @static
     */
    wrapSync(identity) {
        this.wire.sendAction('view-wrap-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new index_1.View(this.wire, identity);
    }
    /**
     * Asynchronously returns a View object that represents the current view
     * @return {Promise.<View>}
     * @tutorial View.getCurrent
     * @experimental
     * @static
     */
    getCurrent() {
        this.wire.sendAction('view-get-current').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        if (!this.wire.me.isView) {
            throw new Error('You are not in a View context');
        }
        const { uuid, name } = this.wire.me;
        return this.wrap({ uuid, name });
    }
    /**
     * Synchronously returns a View object that represents the current view
     * @return {View}
     * @tutorial View.getCurrentSync
     * @experimental
     * @static
     */
    getCurrentSync() {
        this.wire.sendAction('view-get-current-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        if (!this.wire.me.isView) {
            throw new Error('You are not in a View context');
        }
        const { uuid, name } = this.wire.me;
        return this.wrapSync({ uuid, name });
    }
}
exports["default"] = ViewModule;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/view/Instance.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/view/Instance.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.View = void 0;
/* eslint-disable import/prefer-default-export */
const webcontents_1 = __webpack_require__(/*! ../webcontents */ "./node_modules/openfin-adapter/src/api/webcontents/index.js");
const window_1 = __webpack_require__(/*! ../window */ "./node_modules/openfin-adapter/src/api/window/index.js");
/**
 * @typedef {object} View~options
 * @summary View creation options.
 * @desc This is the options object required by {@link View.create View.create}.
 *
 * Note that `name` and `target` are the only required properties — albeit the `url` property is usually provided as well
 * (defaults to `"about:blank"` when omitted).
 *
 * @property {object} [experimental]
 * Configurations for API injection.
 *
 * @property {boolean} [experimental.childWindows] Configure if the runtime should enable child windows for views.
 *
 * @property {object} [api]
 * Configurations for API injection.
 *
 * @property {object} [api.iframe] Configure if the the API should be injected into iframes based on domain.
 *
 * @property {boolean} [api.iframe.crossOriginInjection=false] Controls if the `fin` API object is present for cross origin iframes.
 * @property {boolean} [api.iframe.sameOriginInjection=true] Controls if the `fin` API object is present for same origin iframes.
 *
 * @property {object} [autoResize] AutoResize options
 *
 * @property {object} [bounds] initial bounds given relative to the window.
 *
 * @property {string} [backgroundColor="#FFF"] - _Updatable._
 * The view’s _backfill_ color as a hexadecimal value. Not to be confused with the content background color
 * (`document.body.style.backgroundColor`),
 * this color briefly fills a view’s (a) content area before its content is loaded as well as (b) newly exposed
 * areas when growing a window. Setting
 * this value to the anticipated content background color can help improve user experience.
 * Default is white.
 *
 * @property {object} [contentNavigation]
 * Restrict navigation to URLs that match a whitelisted pattern.
 * In the lack of a whitelist, navigation to URLs that match a blacklisted pattern would be prohibited.
 * See [here](https://developer.chrome.com/extensions/match_patterns) for more details.
 * @property {string[]} [contentNavigation.whitelist=[]] List of whitelisted URLs.
 * @property {string[]} [contentNavigation.blacklist=[]] List of blacklisted URLs.
 *
 * @property {object} [contextMenuSettings] - _Updatable._
 * Configure the context menu when right-clicking on a view.
 * @property {boolean} [contextMenuSettings.enable=true] Should the context menu display on right click.
 * @property {boolean} [contextMenuSettings.devtools=true] Should the context menu contain a button for opening devtools.
 * @property {boolean} [contextMenuSettings.reload=true] Should the context menu contain a button for reloading the page.
 *
 * @property {any} [customData=""] - _Updatable._
 * A field that the user can attach serializable data to to be ferried around with the view options.
 * _When omitted, the default value of this property is the empty string (`""`)._
 *
 * When omitted, the default value of this property is the empty string (`""`).
 * As opposed to customData this is meant for frequent updates and sharing with other contexts. [Example]{@tutorial customContext}
 *
 * @property {object[]} [hotkeys=[]] - _Updatable._
 * Defines the list of hotkeys that will be emitted as a `hotkey` event on the view. For usage example see [example]{@tutorial hotkeys}.
 * Within Platform, OpenFin also implements a set of pre-defined actions called
 * [keyboard commands]{@link https://developers.openfin.co/docs/platform-api#section-5-3-using-keyboard-commands}
 * that can be assigned to a specific hotkey in the platform manifest.
 * @property {string} hotkeys.keys The key combination of the hotkey, i.e. "Ctrl+T"
 * @property {boolean} [hotkeys.preventDefault=false] preventDefault will prevent the page keydown/keyup events from being emitted.
 *
 * @property {boolean} [isClosable=true] **Platforms Only.** If false, the view will be persistent and can't be closed through
 * either UI or `Platform.closeView`. Note that the view will still be closed if the host window is closed or
 * if the view isn't part of the new layout when running `Layout.replace`.
 *
 * @property {string} name
 * The name of the view.
 *
 * @property {boolean} [detachOnClose=false] - _Updatable._
 * Platforms Only.  If true, will hide and detach the View from the window for later use instead of closing,
 * allowing the state of the View to be saved and the View to be immediately shown in a new Layout.
 *
 * @property {string} [manifestUrl] **Platforms Only.** Url to a manifest that contains View Options. Properties other than manifestUrl can still be used
 * but the properties in the manifest will take precedence if there is any collision.
 *
 * @property {preloadScript[]} [preloadScripts] - _Inheritable_
 * A list of scripts that are eval'ed before other scripts in the page. When omitted, _inherits_
 * from the parent application.
 *
 * @property {boolean} [preventDragOut=false] **Platforms Only.** If true, the tab of the view can't be dragged out of its host window.
 *
 * @property {string} [processAffinity=<application uuid>]
 * A string to attempt to group renderers together. Will only be used if pages are on the same origin.
 *
 * @property {Identity} [target]
 * The identity of the window this view should be attached to.
 *
 * @property {string} [url="about:blank"]
 * The URL of the view.
 *
 * @property {string} [uuid=<application uuid>]
 * The `uuid` of the application, unique within the set of all `Application`s running in OpenFin Runtime.
 * If omitted, defaults to the `uuid` of the application spawning the view.
 * If given, must match the `uuid` of the application spawning the view.
 * In other words, the application's `uuid` is the only acceptable value, but is the default, so there's
 * really no need to provide it.
 */
/**
 * @classdesc a View can be used to embed additional web content into a Window.
 * It is like a child window, except it is positioned relative to its owning window.
 * It has the ability to listen for <a href="tutorial-View.EventEmitter.html">View-specific events</a>.
 *
 * By default, a View will try to share the same renderer process as other Views owned by its parent Application.
 * To change that behavior, see the processAffinity {@link View~options view option}.
 *
 * A View's lifecycle is tied to its owning window and can be re-attached to a different window at any point during its lifecycle.
 * @class
 * @alias View
 * @hideconstructor
 */
class View extends webcontents_1.WebContents {
    constructor(wire, identity) {
        super(wire, identity, 'view');
        this.identity = identity;
        /**
         * Returns the zoom level of the view.
         * @function getZoomLevel
         * @memberOf View
         * @instance
         * @return {Promise.<number>}
         * @tutorial View.getZoomLevel
         */
        /**
         * Sets the zoom level of the view.
         * @param { number } level The zoom level
         * @function setZoomLevel
         * @memberOf View
         * @instance
         * @return {Promise.<void>}
         * @tutorial View.setZoomLevel
         */
        /**
         * Find and highlight text on a page.
         * @param { string } searchTerm Term to find in page
         * @param { FindInPageOptions } options Search options
         * @function findInPage
         * @memberOf View
         * @instance
         * @return {Promise.<number>}
         * @tutorial View.findInPage
         */
        /**
         * Stops any findInPage call with the provided action.
         * @param {string} action
         * Action to execute when stopping a find in page:<br>
         * "clearSelection" - Clear the selection.<br>
         * "keepSelection" - Translate the selection into a normal selection.<br>
         * "activateSelection" - Focus and click the selection node.<br>
         * @function stopFindInPage
         * @memberOf View
         * @instance
         * @return {Promise.<void>}
         * @tutorial View.stopFindInPage
         */
        /**
         * Navigates the view to a specified URL. The url must contain the protocol prefix such as http:// or https://.
         * @param { string } url - The URL to navigate the view to.
         * @return {Promise.<void>}
         * @function navigate
         * @memberof View
         * @instance
         * @tutorial View.navigate
         * @experimental
         */
        /**
         * Navigates the view back one page.
         * @function navigateBack
         * @memberOf View
         * @instance
         * @return {Promise.<void>}
         * @tutorial View.navigateBack
         */
        /**
         * Navigates the view forward one page.
         * @function navigateForward
         * @memberOf View
         * @instance
         * @return {Promise.<void>}
         * @tutorial View.navigateForward
         */
        /**
         * Stops any current navigation the view is performing.
         * @function stopNavigation
         * @memberOf View
         * @instance
         * @return {Promise.<void>}
         * @tutorial View.stopNavigation
         */
        /**
         * Reloads the view current page
         * @function reload
         * @memberOf View
         * @instance
         * @return {Promise.<void>}
         * @tutorial View.reload
         */
        /**
         * Prints the view's web page
         * @param { PrintOptions } [options] Printer Options
         * @function print
         * @memberOf View
         * @instance
         * @return {Promise.<void>}
         * @tutorial View.print
         */
        /**
         * Returns an array with all system printers
         * @function getPrinters
         * @memberOf View
         * @instance
         * @return { Promise.Array.<PrinterInfo> }
         * @tutorial View.getPrinters
         */
        /**
         * Shows the Chromium Developer Tools
         * @function showDeveloperTools
         * @memberOf View
         * @instance
         * @return {Promise.<void>}
         * @tutorial View.showDeveloperTools
         */
        /**
         * Retrieves the process information associated with a view.
         * @function getProcessInfo
         * @memberOf View
         * @instance
         * @return {Promise.<EntityProcessDetails>}
         * @tutorial View.getProcessInfo
         */
        /**
         * Retrieves information on all Shared Workers.
         * @function getSharedWorkers
         * @memberOf View
         * @instance
         * @return {Promise.Array.<SharedWorkerInfo>}
         * @tutorial View.getSharedWorkers
         */
        /**
         * Opens the developer tools for the shared worker context.
         * @function inspectSharedWorker
         * @memberOf View
         * @instance
         * @return {Promise.<void>}
         * @tutorial View.inspectSharedWorker
         */
        /**
         * Inspects the shared worker based on its ID.
         * @param { string } workerId - The id of the shared worker.
         * @function inspectSharedWorkerById
         * @memberOf View
         * @instance
         * @return {Promise.<void>}
         * @tutorial View.inspectSharedWorkerById
         */
        /**
         * Opens the developer tools for the service worker context.
         * @function inspectServiceWorker
         * @memberOf View
         * @instance
         * @return {Promise.<void>}
         * @tutorial View.inspectServiceWorker
         */
        /**
         * Attaches the current view to a the given window identity.
         * Identity must be the identity of a window in the same application.
         * This detaches the view from its current window, and sets the view to be destroyed when its new window closes.
         * @param target {Identity}
         * @return {Promise.<void>}
         * @tutorial View.attach
         * @experimental
         */
        this.attach = async (target) => {
            await this.wire.sendAction('attach-view', { target, ...this.identity });
        };
        /**
         * Destroys the current view
         * @return {Promise.<void>}
         * @tutorial View.destroy
         * @experimental
         */
        this.destroy = async () => {
            await this.wire.sendAction('destroy-view', { ...this.identity });
        };
        /**
         * Shows the current view if it is currently hidden.
         * @return {Promise.<void>}
         * @tutorial View.show
         * @experimental
         */
        this.show = async () => {
            await this.wire.sendAction('show-view', { ...this.identity });
        };
        /**
         * Hides the current view if it is currently visible.
         * @return {Promise.<void>}
         * @tutorial View.hide
         * @experimental
         */
        this.hide = async () => {
            await this.wire.sendAction('hide-view', { ...this.identity });
        };
        /**
         * Sets the bounds (top, left, width, height) of the view relative to its window.
         * @param bounds {ViewBounds}
         * @return {Promise.<void>}
         * @tutorial View.setBounds
         * @experimental
         */
        this.setBounds = async (bounds) => {
            await this.wire.sendAction('set-view-bounds', { bounds, ...this.identity });
        };
        /**
         * Gets the bounds (top, left, width, height) of the view relative to its window.
         * @return {Promise.<ViewBounds>}
         * @tutorial View.getBounds
         * @experimental
         */
        this.getBounds = async () => {
            const ack = await this.wire.sendAction('get-view-bounds', { ...this.identity });
            return ack.payload.data;
        };
        /**
         * Gets the View's info.
         * @return {Promise.<ViewInfo>}
         * @tutorial View.getInfo
         * @experimental
         */
        this.getInfo = async () => {
            const ack = await this.wire.sendAction('get-view-info', { ...this.identity });
            return ack.payload.data;
        };
        /**
         * Retrieves the layout for the window the view is attached to.
         * @return {Promise.<Layout>}
         * @tutorial View.getParentLayout
         * @experimental
         */
        this.getParentLayout = async () => {
            this.wire.sendAction('view-get-parent-layout', { ...this.identity }).catch((e) => {
                // don't expose
            });
            const currentWindow = await this.getCurrentWindow();
            return currentWindow.getLayout();
        };
        /**
         * Gets the View's options.
         * @return {Promise<ViewOptions>}
         * @tutorial View.getOptions
         * @experimental
         */
        this.getOptions = async () => {
            return this.wire.sendAction('get-view-options', { ...this.identity }).then(({ payload }) => payload.data);
        };
        /**
         * Updates the view's options.
         * @param { Partial<ViewOptions> } options
         * @return {Promise.<void>}
         * @tutorial View.updateOptions
         * @experimental
         */
        this.updateOptions = async (options) => {
            return this.wire.sendAction('update-view-options', { options, ...this.identity }).then(() => undefined);
        };
        /**
         * Retrieves the window the view is currently attached to.
         * @return {Promise.<_Window>}
         * @experimental
         */
        this.getCurrentWindow = async () => {
            const { payload: { data } } = await this.wire.sendAction('get-view-window', { ...this.identity });
            return new window_1._Window(this.wire, data);
        };
        this.topic = 'view';
    }
    /**
     * Gets a base64 encoded image of the view or a part of it.
     * @function capturePage
     * @param { CapturePageOptions } [options] Options for the capturePage call.
     * @memberOf View
     * @instance
     * @return {Promise.<string>}
     * @tutorial View.capturePage
     */
    /**
     * Executes Javascript on the view, restricted to contents you own or contents owned by
     * applications you have created.
     * @param { string } code JavaScript code to be executed on the view.
     * @function executeJavaScript
     * @memberOf View
     * @instance
     * @return {Promise.<void>}
     * @tutorial View.executeJavaScript
     */
    /**
     * Focuses the view
     * @return {Promise.<void>}
     * @function focus
     * @memberof View
     * @emits focused
     * @instance
     * @tutorial View.focus
     * @experimental
     */
    async focus({ emitSynthFocused } = { emitSynthFocused: true }) {
        const win = await this.getCurrentWindow();
        await win.focusedWebViewWasChanged();
        await super.focus({ emitSynthFocused });
    }
}
exports.View = View;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/view/index.js":
/*!************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/view/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Factory_1 = __webpack_require__(/*! ./Factory */ "./node_modules/openfin-adapter/src/api/view/Factory.js");
exports["default"] = Factory_1.default;
__exportStar(__webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/view/Instance.js"), exports);


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/webcontents/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/webcontents/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebContents = void 0;
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
class WebContents extends base_1.EmitterBase {
    constructor(wire, identity, entityType) {
        super(wire, [entityType, identity.uuid, identity.name]);
        this.entityType = entityType;
    }
    capturePage(options) {
        return this.wire.sendAction('capture-page', { options, ...this.identity }).then(({ payload }) => payload.data);
    }
    executeJavaScript(code) {
        return this.wire
            .sendAction('execute-javascript-in-window', { ...this.identity, code })
            .then(({ payload }) => payload.data);
    }
    getZoomLevel() {
        return this.wire.sendAction('get-zoom-level', this.identity).then(({ payload }) => payload.data);
    }
    setZoomLevel(level) {
        return this.wire.sendAction('set-zoom-level', { ...this.identity, level }).then(() => undefined);
    }
    navigate(url) {
        return this.wire.sendAction('navigate-window', { ...this.identity, url }).then(() => undefined);
    }
    navigateBack() {
        return this.wire.sendAction('navigate-window-back', { ...this.identity }).then(() => undefined);
    }
    async navigateForward() {
        await this.wire.sendAction('navigate-window-forward', { ...this.identity });
    }
    stopNavigation() {
        return this.wire.sendAction('stop-window-navigation', { ...this.identity }).then(() => undefined);
    }
    reload(ignoreCache = false) {
        return this.wire
            .sendAction('reload-window', {
            ignoreCache,
            ...this.identity
        })
            .then(() => undefined);
    }
    print(options) {
        return this.wire.sendAction('print', { ...this.identity, options }).then(() => undefined);
    }
    findInPage(searchTerm, options) {
        return this.wire
            .sendAction('find-in-page', { ...this.identity, searchTerm, options })
            .then(({ payload }) => payload.data);
    }
    stopFindInPage(action) {
        return this.wire.sendAction('stop-find-in-page', { ...this.identity, action }).then(() => undefined);
    }
    getPrinters() {
        return this.wire.sendAction('get-printers', { ...this.identity }).then(({ payload }) => payload.data);
    }
    async focus({ emitSynthFocused } = { emitSynthFocused: true }) {
        await this.wire.sendAction('focus-window', { emitSynthFocused, ...this.identity });
    }
    async showDeveloperTools() {
        // Note this hits the system action map in core state for legacy reasons.
        await this.wire.sendAction('show-developer-tools', this.identity);
    }
    async getProcessInfo() {
        const { payload: { data } } = await this.wire.sendAction('get-process-info', this.identity);
        return data;
    }
    async getSharedWorkers() {
        return this.wire.sendAction('get-shared-workers', this.identity).then(({ payload }) => payload.data);
    }
    async inspectSharedWorker() {
        await this.wire.sendAction('inspect-shared-worker', { ...this.identity });
    }
    async inspectSharedWorkerById(workerId) {
        await this.wire.sendAction('inspect-shared-worker-by-id', { ...this.identity, workerId });
    }
    async inspectServiceWorker() {
        await this.wire.sendAction('inspect-service-worker', { ...this.identity });
    }
}
exports.WebContents = WebContents;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/window/Factory.js":
/*!****************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/window/Factory.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
const validate_1 = __webpack_require__(/*! ../../util/validate */ "./node_modules/openfin-adapter/src/util/validate.js");
const Instance_1 = __webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/window/Instance.js");
/**
 * @lends Window
 */
class _WindowModule extends base_1.Base {
    /**
     * Asynchronously returns a Window object that represents an existing window.
     * @param { Identity } identity
     * @return {Promise.<_Window>}
     * @tutorial Window.wrap
     * @static
     */
    async wrap(identity) {
        this.wire.sendAction('window-wrap').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1._Window(this.wire, identity);
    }
    /**
     * Synchronously returns a Window object that represents an existing window.
     * @param { Identity } identity
     * @return {_Window}
     * @tutorial Window.wrapSync
     * @static
     */
    wrapSync(identity) {
        this.wire.sendAction('window-wrap-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const errorMsg = validate_1.validateIdentity(identity);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
        return new Instance_1._Window(this.wire, identity);
    }
    /**
     * Creates a new Window.
     * @param { Window~options } options - Window creation options
     * @return {Promise.<_Window>}
     * @tutorial Window.create
     * @static
     */
    create(options) {
        this.wire.sendAction('create-window').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        const win = new Instance_1._Window(this.wire, { uuid: this.me.uuid, name: options.name });
        return win.createWindow(options);
    }
    /**
     * Asynchronously returns a Window object that represents the current window
     * @return {Promise.<_Window>}
     * @tutorial Window.getCurrent
     * @static
     */
    getCurrent() {
        this.wire.sendAction('get-current-window').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        if (!this.wire.me.isWindow) {
            throw new Error('You are not in a Window context');
        }
        const { uuid, name } = this.wire.me;
        return this.wrap({ uuid, name });
    }
    /**
     * Synchronously returns a Window object that represents the current window
     * @return {_Window}
     * @tutorial Window.getCurrentSync
     * @static
     */
    getCurrentSync() {
        this.wire.sendAction('get-current-window-sync').catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        if (!this.wire.me.isWindow) {
            throw new Error('You are not in a Window context');
        }
        const { uuid, name } = this.wire.me;
        return this.wrapSync({ uuid, name });
    }
}
exports["default"] = _WindowModule;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/window/Instance.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/window/Instance.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._Window = void 0;
const application_1 = __webpack_require__(/*! ../application */ "./node_modules/openfin-adapter/src/api/application/index.js");
const external_window_1 = __webpack_require__(/*! ../external-window */ "./node_modules/openfin-adapter/src/api/external-window/index.js");
const webcontents_1 = __webpack_require__(/*! ../webcontents */ "./node_modules/openfin-adapter/src/api/webcontents/index.js");
const view_1 = __webpack_require__(/*! ../view */ "./node_modules/openfin-adapter/src/api/view/index.js");
const EntityType_1 = __webpack_require__(/*! ../../shapes/EntityType */ "./node_modules/openfin-adapter/src/shapes/EntityType.js");
/**
 * @typedef { object } Margins
 * @property { string } [marginType]
 * Can be `default`, `none`, `printableArea`, or `custom`. If `custom` is chosen,
 * you will also need to specify `top`, `bottom`, `left`, and `right`.
 *
 * @property { number } [top] The top margin of the printed web page, in pixels.
 * @property { number } [bottom] The bottom margin of the printed web page, in pixels.
 * @property { number } [left] The left margin of the printed web page, in pixels.
 * @property { number } [right] The right margin of the printed web page, in pixels.
 */
/**
 * @typedef { object } Dpi
 * @property { number } [horizontal] The horizontal dpi
 * @property { number } [vertical] The vertical dpi
 */
/**
 * @typedef { object } PrintOptions
 * @property { boolean } [silent=false] Don't ask user for print settings.
 * @property { boolean } [printBackground=false] Prints the background color and image of the web page.
 * @property { string } [deviceName=''] Set the printer device name to use.
 * @property { boolean } [color=true] Set whether the printed web page will be in color or grayscale.
 * @property { Margins } [margins] Set margins for the printed web page
 * @property { boolean } [landscape=false] Whether the web page should be printed in landscape mode.
 * @property { number } [scaleFactor] The scale factor of the web page.
 * @property { number } [pagesPerSheet] The number of pages to print per page sheet.
 * @property { boolean } [collate] Whether the web page should be collated.
 * @property { number } [copies] The number of copies of the web page to print.
 * @property { Record<string, number> } [pageRanges] The page range to print. Should have two keys: from and to.
 * @property { string } [duplexMode] Set the duplex mode of the printed web page. Can be simplex, shortEdge, or longEdge.
 * @property { Dpi } [dpi] Set dpi for the printed web page
 */
/**
 * PrinterInfo interface
 * @typedef { object } PrinterInfo
 * @property { string } name Printer Name
 * @property { string } description Printer Description
 * @property { number } status Printer Status
 * @property { boolean } isDefault Indicates that system's default printer
 */
/**
 * SharedWorkerInfo interface
 * @typedef { object } SharedWorkerInfo
 * @property { string } id The unique id of the shared worker.
 * @property { string } url The url of the shared worker.
 */
/**
 * ContentCreationRule interface
 * @typedef { object } ContentCreationRule
 * @property { string } behavior 'view' | 'window' | 'browser' | 'block'
 * @property { string[] } match List of [match patterns](https://developer.chrome.com/extensions/match_patterns).
 * @property { object } options Window creation options or View creation options.
 */
/**
 * @typedef {object} Window~options
 * @summary Window creation options.
 * @desc This is the options object required by {@link Window.create Window.create}.
 *
 * Note that `name` is the only required property — albeit the `url` property is usually provided as well
 * (defaults to `"about:blank"` when omitted).
 *
 * _This jsdoc typedef mirrors the `WindowOptions` TypeScript interface in `@types/openfin`._
 *
 * @property {object} [accelerator]
 * Enable keyboard shortcuts for devtools, zoom, reload, and reload ignoring cache.
 *
 * @property {boolean} [accelerator.devtools=false]
 * If `true`, enables the devtools keyboard shortcut:<br>
 * `Ctrl` + `Shift` + `I` _(Toggles Devtools)_
 *
 * @property {boolean} [accelerator.reload=false]
 * If `true`, enables the reload keyboard shortcuts:<br>
 * `Ctrl` + `R` _(Windows)_<br>
 * `F5` _(Windows)_<br>
 * `Command` + `R` _(Mac)_
 *
 * @property {boolean} [accelerator.reloadIgnoringCache=false]
 * If `true`, enables the reload-from-source keyboard shortcuts:<br>
 * `Ctrl` + `Shift` + `R` _(Windows)_<br>
 * `Shift` + `F5` _(Windows)_<br>
 * `Command` + `Shift` + `R` _(Mac)_
 *
 * @property {boolean} [accelerator.zoom=false]
 * If `true`, enables the zoom keyboard shortcuts:<br>
 * `Ctrl` + `+` _(Zoom In)_<br>
 * `Ctrl` + `Shift` + `+` _(Zoom In)_<br>
 * `Ctrl` + `NumPad+` _(Zoom In)_<br>
 * `Ctrl` + `-` _(Zoom Out)_<br>
 * `Ctrl` + `Shift` + `-` _(Zoom Out)_<br>
 * `Ctrl` + `NumPad-` _(Zoom Out)_<br>
 * `Ctrl` + `Scroll` _(Zoom In & Out)_<br>
 * `Ctrl` + `0` _(Restore to 100%)_
 *
 * @property {object} [alphaMask] - _Experimental._  _Updatable._
 * <br>
 * alphaMask turns anything of matching RGB value transparent.
 * <br>
 * Caveats:
 * * runtime key --disable-gpu is required. Note: Unclear behavior on remote Desktop support
 * * User cannot click-through transparent regions
 * * Not supported on Mac
 * * Windows Aero must be enabled
 * * Won't make visual sense on Pixel-pushed environments such as Citrix
 * * Not supported on rounded corner windows
 * @property {number} [alphaMask.red=-1] 0-255
 * @property {number} [alphaMask.green=-1] 0-255
 * @property {number} [alphaMask.blue=-1] 0-255
 *
 * @property {boolean} [alwaysOnTop=false] - _Updatable._
 * A flag to always position the window at the top of the window stack.
 *
 * @property {object} [api]
 * Configurations for API injection.
 *
 * @property {object} [api.iframe] Configure if the the API should be injected into iframes based on domain.
 *
 * @property {boolean} [api.iframe.crossOriginInjection=false] Controls if the `fin` API object is present for cross origin iframes.
 * @property {boolean} [api.iframe.sameOriginInjection=true] Controls if the `fin` API object is present for same origin iframes.
 *
 * @property {string} [applicationIcon = ""] - _Deprecated_ - use `icon` instead.
 *
 * @property {number} [aspectRatio=0] - _Updatable._
 * The aspect ratio of width to height to enforce for the window. If this value is equal to or less than zero,
 * an aspect ratio will not be enforced.
 *
 * @property {boolean} [autoShow=true]
 * A flag to automatically show the window when it is created.
 *
 * @property {string} [backgroundColor="#FFF"]
 * The window’s _backfill_ color as a hexadecimal value. Not to be confused with the content background color
 * (`document.body.style.backgroundColor`),
 * this color briefly fills a window’s (a) content area before its content is loaded as well as (b) newly exposed
 * areas when growing a window. Setting
 * this value to the anticipated content background color can help improve user experience.
 * Default is white.
 *
 * @property {object} [contentCreation]
 * Apply rules that determine how user interaction (`window.open` and links) creates content.
 * @property {ContentCreationRule[]} [contentCreation.rules = []] List of content creation rules.
 *
 * @property {object} [contentNavigation]
 * Restrict navigation to URLs that match a whitelisted pattern.
 * In the lack of a whitelist, navigation to URLs that match a blacklisted pattern would be prohibited.
 * See [here](https://developer.chrome.com/extensions/match_patterns) for more details.
 * @property {string[]} [contentNavigation.whitelist=[]] List of whitelisted URLs.
 * @property {string[]} [contentNavigation.blacklist=[]] List of blacklisted URLs.

 * @property {boolean} [contextMenu=true] - _Updatable._
 * A flag to show the context menu when right-clicking on a window.
 * Gives access to the devtools for the window.
 *
 * @property {object} [contextMenuSettings] - _Updatable._
 * Configure the context menu when right-clicking on a window.
 * @property {boolean} [contextMenuSettings.enable=true] Should the context menu display on right click.
 * @property {boolean} [contextMenuSettings.devtools=true] Should the context menu contain a button for opening devtools.
 * @property {boolean} [contextMenuSettings.reload=true] Should the context menu contain a button for reloading the page.
 *
 * @property {object} [cornerRounding] - _Updatable._
 * Defines and applies rounded corners for a frameless window. **NOTE:** On macOS corner is not ellipse but circle rounded by the
 *  average of _height_ and _width_.
 * @property {number} [cornerRounding.height=0] The height in pixels.
 * @property {number} [cornerRounding.width=0] The width in pixels.
 *
 * @property {any} [customContext=""] - _Updatable._
 * A field that the user can use to attach serializable data that will be saved when {@link Platform#getSnapshot Platform.getSnapshot}
 * is called.  If a window in a Platform is trying to update or retrieve its own context, it can use the
 * {@link Platform#setWindowContext Platform.setWindowContext} and {@link Platform#getWindowContext Platform.getWindowContext} calls.
 * When omitted, the default value of this property is the empty string (`""`).
 * As opposed to customData this is meant for frequent updates and sharing with other contexts. [Example]{@tutorial customContext}
 *
 * @property {any} [customData=""] - _Updatable._
 * A field that the user can attach serializable data to to be ferried around with the window options.
 * _When omitted, the default value of this property is the empty string (`""`)._
 *
 * @property {object[]} [customRequestHeaders]
 * Defines list of custom headers for requests sent by the window.
 * @property {string[]} [customRequestHeaders.urlPatterns=[]] The URL patterns for which the headers will be applied
 * @property {object[]} [customRequestHeaders.headers=[]] Objects representing headers and their values,
 * where the object key is the name of header and value at key is the value of the header
 *
 * @property {boolean} [closeOnLastViewRemoved=true] - _Experimental._  _Updatable._
 * Toggling off would keep the Window alive even if all its Views were closed.
 * This is meant for advanced users and should be used with caution.
 * Limitations - Once a Layout has been emptied out of all views it's not usable anymore, and certain API calls will fail.
 * Use `layout.replace` to create a fresh Layout instance in case you want to populate it with Views again.
 * ** note ** - This option is ignored in non-Platforms apps.
 *
 * @property {boolean} [defaultCentered=false]
 * Centers the window in the primary monitor. This option overrides `defaultLeft` and `defaultTop`. When `saveWindowState` is `true`,
 * this value will be ignored for subsequent launches in favor of the cached value. **NOTE:** On macOS _defaultCenter_ is
 * somewhat above center vertically.
 *
 * @property {number} [defaultHeight=500]
 * The default height of the window. When `saveWindowState` is `true`, this value will be ignored for subsequent launches
 * in favor of the cached value.
 *
 * @property {number} [defaultLeft=100]
 * The default left position of the window. When `saveWindowState` is `true`, this value will be ignored for subsequent
 * launches in favor of the cached value.
 *
 * @property {number} [defaultTop=100]
 * The default top position of the window. When `saveWindowState` is `true`, this value will be ignored for subsequent
 * launches in favor of the cached value.
 *
 * @property {number} [defaultWidth=800]
 * The default width of the window. When `saveWindowState` is `true`, this value will be ignored for subsequent
 * launches in favor of the cached value.
 *
 * @property {boolean} [includeInSnapshots=true] - _Updatable._
 * When true, the window will be be included in snapshots returned by Platform.getSnapshot(). Turning this off may be desirable when dealing with
 * inherently temporary windows whose state shouldn't be preserved, such as modals, menus, or popups.
 *
 * @property {boolean} [frame=true] - _Updatable._
 * A flag to show the frame.
 *
 * @hidden-property {boolean} [hideOnClose=false] - A flag to allow a window to be hidden when the close button is clicked.
 *
 * @property {object[]} [hotkeys=[]] - _Updatable._
 * Defines the list of hotkeys that will be emitted as a `hotkey` event on the window. For usage example see [example]{@tutorial hotkeys}.
 * Within Platform, OpenFin also implements a set of pre-defined actions called
 * [keyboard commands]{@link https://developers.openfin.co/docs/platform-api#section-5-3-using-keyboard-commands}
 * that can be assigned to a specific hotkey in the platform manifest.
 * @property {string} hotkeys.keys The key combination of the hotkey, i.e. "Ctrl+T"
 * @property {boolean} [hotkeys.preventDefault=false] Whether or not to prevent default key handling before emitting the event
 *
 * @property {string} [icon] - _Updatable. Inheritable._
 * A URL for the icon to be shown in the window title bar and the taskbar.
 * _When omitted, inherits from the parent application._
 *  note: Window OS caches taskbar icons, therefore an icon change might only be visible after the cache is removed or the uuid is changed.
 *
 * @property {number} [maxHeight=-1] - _Updatable._
 * The maximum height of a window. Will default to the OS defined value if set to -1.
 *
 * @property {boolean} [maximizable=true] - _Updatable._
 * A flag that lets the window be maximized.
 *
 * @property {number} [maxWidth=-1] - _Updatable._
 * The maximum width of a window. Will default to the OS defined value if set to -1.
 *
 * @property {number} [minHeight=0] - _Updatable._
 * The minimum height of a window.
 *
 * @property {boolean} [minimizable=true] - _Updatable._
 * A flag that lets the window be minimized.
 *
 * @property {number} [minWidth=0] - _Updatable._
 * The minimum width of a window.
 *
 * @property {Identity} [modalParentIdentity]
 * Parent identity of a modal window. It will create a modal child window when this option is set.
 *
 * @property {string} name
 * The name of the window.
 *
 * @property {number} [opacity=1.0] - _Updatable._
 * A flag that specifies how transparent the window will be.
 * Changing opacity doesn't work on Windows 7 without Aero so setting this value will have no effect there.
 * This value is clamped between `0.0` and `1.0`.
 *
 * @property {preloadScript[]} [preloadScripts] - _Inheritable_
 * A list of scripts that are eval'ed before other scripts in the page. When omitted, _inherits_
 * from the parent application.
 *
 * @property {string} [processAffinity]
 * A string to attempt to group renderers together. Will only be used if pages are on the same origin.
 *
 * @property {boolean} [resizable=true] - _Updatable._
 * A flag to allow the user to resize the window.
 *
 * @property {object} [resizeRegion] - _Updatable._
 * Defines a region in pixels that will respond to user mouse interaction for resizing a frameless window.
 * @property {number} [resizeRegion.bottomRightCorner=9]
 * The size in pixels of an additional square resizable region located at the bottom right corner of a frameless window.
 * @property {number} [resizeRegion.size=7]
 * The size in pixels.
 * @property {object} [resizeRegion.sides={top:true,right:true,bottom:true,left:true}]
 * Sides that a window can be resized from.
 *
 * @property {boolean} [saveWindowState=true]
 * A flag to cache the location of the window.
 * ** note ** - This option is ignored in Platforms as it would cause inconsistent {@link Platform#applySnapshot applySnapshot} behavior.
 *
 * @property {boolean} [shadow=false]
 * A flag to display a shadow on frameless windows.
 * `shadow` and `cornerRounding` are mutually exclusive.
 * On Windows 7, Aero theme is required.
 *
 * @property {boolean} [showBackgroundImages=false] - _Updatable._
 * Platforms Only.  If true, will show background images in the layout when the Views are hidden.
 * This occurs when the window is resizing or a tab is being dragged within the layout.
 *
 * @property {boolean} [showTaskbarIcon=true] - _Updatable._ _Windows_.
 * A flag to show the window's icon in the taskbar.
 *
 * @property {boolean} [smallWindow=false]
 * A flag to specify a frameless window that can be be created and resized to less than 41x36px (width x height).
 * _Note: Caveats of small windows are no Aero Snap and drag to/from maximize._
 *
 * @property {string} [state="normal"]
 * The visible state of the window on creation.
 * One of:
 * * `"maximized"`
 * * `"minimized"`
 * * `"normal"`
 *
 * @property {string} [taskbarIcon=string] - Deprecated - use `icon` instead._Windows_.
 *
 * @property {string} [taskbarIconGroup=<application uuid>] - _Windows_.
 * Specify a taskbar group for the window.
 * _If omitted, defaults to app's uuid (`fin.Application.getCurrentSync().identity.uuid`)._
 *
 * @property {string} [url="about:blank"]
 * The URL of the window.
 *
 * @property {string} [uuid=<application uuid>]
 * The `uuid` of the application, unique within the set of all `Application`s running in OpenFin Runtime.
 * If omitted, defaults to the `uuid` of the application spawning the window.
 * If given, must match the `uuid` of the  application spawning the window.
 * In other words, the application's `uuid` is the only acceptable value, but is the default, so there's
 * really no need to provide it.
 *
 * @property {boolean} [waitForPageLoad=false]
 * When set to `true`, the window will not appear until the `window` object's `load` event fires.
 * When set to `false`, the window will appear immediately without waiting for content to be loaded.
 */
/**
 * @typedef {object} CapturePageOptions
 * @property { Area } [area] The area of the window to be captured.
 * @property { string } [format='png'] The format of the captured image.  Can be 'png', 'jpg', or 'bmp'.
 * @property { number } [quality=100] Number representing quality of JPEG image only. Between 0 - 100.
 */
/**
 * @typedef { object } Area
 * @property { number } height Area's height
 * @property { number } width Area's width
 * @property { number } x X coordinate of area's starting point
 * @property { number } y Y coordinate of area's starting point
 */
/**
 * @typedef { object } WindowMovementOptions
 * @property { boolean } moveIndependently - Move a window independently of its group or along with its group. Defaults to false.
 */
/**
 * @typedef {object} FindInPageOptions
 * @property {boolean} [forward=true] Whether to search forward or backward.
 * @property {boolean} [findNext=false] Whether the operation is first request or a follow up.
 * @property {boolean} [matchCase=false] Whether search should be case-sensitive.
 * @property {boolean} [wordStart=false] Whether to look only at the start of words.
 * @property {boolean} [medialCapitalAsWordStart=false]
 * When combined with wordStart, accepts a match in the middle of a word if the match begins with an uppercase letter followed by a<br>
 * lowercase or non-letter. Accepts several other intra-word matches.
 */
/**
 * @typedef {object} Transition
 * @property {Opacity} opacity - The Opacity transition
 * @property {Position} position - The Position transition
 * @property {Size} size - The Size transition
 */
/**
 * @typedef {object} TransitionOptions
 * @property {boolean} interrupt - This option interrupts the current animation. When false it pushes
this animation onto the end of the animation queue.
 * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.
 */
/**
 * @typedef {object} Size
 * @property {number} duration - The total time in milliseconds this transition should take.
 * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.
 * @property {number} width - Optional if height is present. Defaults to the window's current width.
 * @property {number} height - Optional if width is present. Defaults to the window's current height.
 */
/**
 * @typedef {object} Position
 * @property {number} duration - The total time in milliseconds this transition should take.
 * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.
 * @property {number} left - Defaults to the window's current left position in virtual screen coordinates.
 * @property {number} top - Defaults to the window's current top position in virtual screen coordinates.
 */
/**
 * @typedef {object} Opacity
 * @property {number} duration - The total time in milliseconds this transition should take.
 * @property {boolean} relative - Treat 'opacity' as absolute or as a delta. Defaults to false.
 * @property {number} opacity - This value is clamped from 0.0 to 1.0.
 */
/**
 * Bounds is a interface that has the properties of height,
 * width, left, top which are all numbers
 * @typedef { object } Bounds
 * @property { number } height Get the application height bound
 * @property { number } width Get the application width bound
 * @property { number } top Get the application top bound
 * @property { number } left Get the application left bound
 * @property { number } right Get the application right bound
 * @property { number } bottom Get the application bottom bound
 */
/**
 * @classdesc A basic window that wraps a native HTML window. Provides more fine-grained
 * control over the window state such as the ability to minimize, maximize, restore, etc.
 * By default a window does not show upon instantiation; instead the window's show() method
 * must be invoked manually. The new window appears in the same process as the parent window.
 * It has the ability to listen for <a href="tutorial-Window.EventEmitter.html">window specific events</a>.
 * @class
 * @alias Window
 * @hideconstructor
 */
// The window.Window name is taken
class _Window extends webcontents_1.WebContents {
    constructor(wire, identity) {
        super(wire, identity, 'window');
        this.identity = identity;
    }
    /**
     * Adds a listener to the end of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - Called whenever an event of the specified type occurs.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function addListener
     * @memberof Window
     * @instance
     * @tutorial Window.EventEmitter
     */
    /**
     * Adds a listener to the end of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - Called whenever an event of the specified type occurs.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function on
     * @memberof Window
     * @instance
     * @tutorial Window.EventEmitter
     */
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function once
     * @memberof Window
     * @instance
     * @tutorial Window.EventEmitter
     */
    /**
     * Adds a listener to the beginning of the listeners array for the specified event.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function prependListener
     * @memberof Window
     * @instance
     * @tutorial Window.EventEmitter
     */
    /**
     * Adds a one time listener for the event. The listener is invoked only the first time the event is fired, after which it is removed.
     * The listener is added to the beginning of the listeners array.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function prependOnceListener
     * @memberof Window
     * @instance
     * @tutorial Window.EventEmitter
     */
    /**
     * Remove a listener from the listener array for the specified event.
     * Caution: Calling this method changes the array indices in the listener array behind the listener.
     * @param { string | symbol } eventType  - The type of the event.
     * @param { Function } listener - The callback function.
     * @param { SubOptions } [options] - Option to support event timestamps.
     * @return {Promise.<this>}
     * @function removeListener
     * @memberof Window
     * @instance
     * @tutorial Window.EventEmitter
     */
    /**
     * Removes all listeners, or those of the specified event.
     * @param { string | symbol } [eventType]  - The type of the event.
     * @return {Promise.<this>}
     * @function removeAllListeners
     * @memberof Window
     * @instance
     * @tutorial Window.EventEmitter
     */
    /**
     * Gets a base64 encoded image of the window or a part of it.
     * @function capturePage
     * @param { CapturePageOptions } [options] options for capturePage call.
     * @return {Promise.<string>}
     * @memberof Window
     * @instance
     * @tutorial Window.capturePage
     */
    /**
     * Executes Javascript on the window, restricted to windows you own or windows owned by
     * applications you have created.
     * @param { string } code JavaScript code to be executed on the window.
     * @function executeJavaScript
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.executeJavaScript
     */
    /**
     * Gives focus to the window.
     * @return {Promise.<void>}
     * @function focus
     * @emits focused
     * @memberOf Window
     * @instance
     * @tutorial Window.focus
     */
    /**
     * Returns the zoom level of the window.
     * @function getZoomLevel
     * @memberOf Window
     * @instance
     * @return {Promise.<number>}
     * @tutorial Window.getZoomLevel
     */
    /**
     * Sets the zoom level of the window.
     * @param { number } level The zoom level
     * @function setZoomLevel
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.setZoomLevel
     */
    /**
     * Find and highlight text on a page.
     * @param { string } searchTerm Term to find in page
     * @param { FindInPageOptions } options Search options
     * @function findInPage
     * @memberOf Window
     * @instance
     * @return {Promise.<number>}
     * @tutorial Window.findInPage
     */
    /**
     * Stops any findInPage call with the provided action.
     * @param {string} action
     * Action to execute when stopping a find in page:<br>
     * "clearSelection" - Clear the selection.<br>
     * "keepSelection" - Translate the selection into a normal selection.<br>
     * "activateSelection" - Focus and click the selection node.<br>
     * @function stopFindInPage
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.stopFindInPage
     */
    /**
     * Navigates the window to a specified URL. The url must contain the protocol prefix such as http:// or https://.
     * @param {string} url - The URL to navigate the window to.
     * @function navigate
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.navigate
     */
    /**
     * Navigates the window back one page.
     * @function navigateBack
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.navigateBack
     */
    /**
     * Navigates the window forward one page.
     * @function navigateForward
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.navigateForward
     */
    /**
     * Stops any current navigation the window is performing.
     * @function stopNavigation
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.stopNavigation
     */
    /**
     * Reloads the window current page
     * @function reload
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.reload
     */
    /**
     * Prints the window's web page
     * @param { PrintOptions } [options] Printer Options
     * @function print
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.print
     */
    /**
     * Returns an array with all system printers
     * @function getPrinters
     * @memberOf Window
     * @instance
     * @return { Promise.Array.<PrinterInfo> }
     * @tutorial Window.getPrinters
     */
    /**
     * Retrieves the process information associated with a window.
     * @function getProcessInfo
     * @memberOf Window
     * @instance
     * @return {Promise.<EntityProcessDetails>}
     * @tutorial Window.getProcessInfo
     */
    /**
     * Retrieves information on all Shared Workers.
     * @function getSharedWorkers
     * @memberOf Window
     * @instance
     * @return {Promise.Array.<SharedWorkerInfo>}
     * @tutorial Window.getSharedWorkers
     */
    /**
     * Opens the developer tools for the shared worker context.
     * @function inspectSharedWorker
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.inspectSharedWorker
     */
    /**
     * Inspects the shared worker based on its ID.
     * @param { string } workerId - The id of the shared worker.
     * @function inspectSharedWorkerById
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.inspectSharedWorkerById
     */
    /**
     * Opens the developer tools for the service worker context.
     * @function inspectServiceWorker
     * @memberOf Window
     * @instance
     * @return {Promise.<void>}
     * @tutorial Window.inspectServiceWorker
     */
    // create a new window
    createWindow(options) {
        this.wire.sendAction('window-create-window', this.identity).catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return new Promise((resolve, reject) => {
            const CONSTRUCTOR_CB_TOPIC = 'fire-constructor-callback';
            // need to call pageResponse, otherwise when a child window is created, page is not loaded
            const pageResponse = new Promise((resolve) => {
                this.on(CONSTRUCTOR_CB_TOPIC, function fireConstructor(response) {
                    let cbPayload;
                    const { success } = response;
                    const responseData = response.data;
                    const { message } = responseData;
                    if (success) {
                        cbPayload = {
                            httpResponseCode: responseData.httpResponseCode,
                            apiInjected: responseData.apiInjected
                        };
                    }
                    else {
                        cbPayload = {
                            message: responseData.message,
                            networkErrorCode: responseData.networkErrorCode,
                            stack: responseData.stack
                        };
                    }
                    this.removeListener(CONSTRUCTOR_CB_TOPIC, fireConstructor);
                    resolve({
                        message,
                        cbPayload,
                        success
                    });
                });
            });
            // set defaults:
            if (options.waitForPageLoad === undefined) {
                options.waitForPageLoad = false;
            }
            if (options.autoShow === undefined) {
                options.autoShow = true;
            }
            const windowCreation = this.wire.environment.createChildContent({ entityType: EntityType_1.default.WINDOW, options });
            Promise.all([pageResponse, windowCreation])
                .then((resolvedArr) => {
                const pageResolve = resolvedArr[0];
                if (pageResolve.success) {
                    resolve(this);
                }
                else {
                    reject(pageResolve);
                }
                try {
                    // this is to enforce a 5.0 contract that the child's main function
                    // will not fire before the parent's success callback on creation.
                    // if the child window is not accessible (CORS) this contract does
                    // not hold.
                    const webWindow = this.getWebWindow();
                    webWindow.fin.__internal_.openerSuccessCBCalled();
                }
                catch (e) {
                    // common for main windows, we do not want to expose this error. here just to have a debug target.
                    // console.error(e);
                }
            })
                .catch(reject);
        });
    }
    windowListFromNameList(identityList) {
        return identityList.map(({ uuid, name, isExternalWindow }) => {
            if (isExternalWindow) {
                return new external_window_1.ExternalWindow(this.wire, { uuid });
            }
            return new _Window(this.wire, { uuid, name });
        });
    }
    /**
     * Retrieves an array of frame info objects representing the main frame and any
     * iframes that are currently on the page.
     * @return {Promise.<Array<FrameInfo>>}
     * @tutorial Window.getAllFrames
     */
    getAllFrames() {
        return this.wire.sendAction('get-all-frames', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Gets the current bounds (top, bottom, right, left, width, height) of the window.
     * @return {Promise.<Bounds>}
     * @tutorial Window.getBounds
     */
    getBounds() {
        return this.wire
            .sendAction('get-window-bounds', this.identity)
            .then(({ payload }) => payload.data);
    }
    /**
     * Centers the window on its current screen.
     * @return {Promise.<void>}
     * @tutorial Window.center
     */
    center() {
        return this.wire.sendAction('center-window', this.identity).then(() => undefined);
    }
    /**
     * Removes focus from the window.
     * @return {Promise.<void>}
     * @tutorial Window.blur
     */
    blur() {
        return this.wire.sendAction('blur-window', this.identity).then(() => undefined);
    }
    /**
     * Brings the window to the front of the window stack.
     * @return {Promise.<void>}
     * @tutorial Window.bringToFront
     */
    bringToFront() {
        return this.wire.sendAction('bring-window-to-front', this.identity).then(() => undefined);
    }
    /**
     * Performs the specified window transitions.
     * @param {Transition} transitions - Describes the animations to perform. See the tutorial.
     * @param {TransitionOptions} options - Options for the animation. See the tutorial.
     * @return {Promise.<void>}
     * @tutorial Window.animate
     */
    animate(transitions, options) {
        return this.wire
            .sendAction('animate-window', {
            transitions,
            options,
            ...this.identity
        })
            .then(() => undefined);
    }
    /**
     * Hides the window.
     * @return {Promise.<void>}
     * @tutorial Window.hide
     */
    hide() {
        return this.wire.sendAction('hide-window', this.identity).then(() => undefined);
    }
    /**
     * closes the window application
     * @param { boolean } [force = false] Close will be prevented from closing when force is false and
     *  ‘close-requested’ has been subscribed to for application’s main window.
     * @return {Promise.<void>}
     * @tutorial Window.close
     */
    close(force = false) {
        return this.wire.sendAction('close-window', { force, ...this.identity }).then(() => {
            Object.setPrototypeOf(this, null);
            return undefined;
        });
    }
    focusedWebViewWasChanged() {
        return this.wire.sendAction('focused-webview-changed', this.identity).then(() => undefined);
    }
    /**
     * Returns the native OS level Id.
     * In Windows, it will return the Windows [handle](https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types#HWND).
     * @return {Promise.<string>}
     * @tutorial Window.getNativeId
     */
    getNativeId() {
        return this.wire.sendAction('get-window-native-id', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Retrieves window's attached views.
     * @experimental
     * @return {Promise.Array.<View>}
     * @tutorial Window.getCurrentViews
     */
    async getCurrentViews() {
        const { payload } = await this.wire.sendAction('window-get-views', this.identity);
        return payload.data.map((id) => new view_1.View(this.wire, id));
    }
    /*
     * @deprecated Use {@link Window.disableUserMovement} instead.
     */
    disableFrame() {
        console.warn('Function is deprecated; use disableUserMovement instead.');
        return this.wire.sendAction('disable-window-frame', this.identity).then(() => undefined);
    }
    /**
     * Prevents a user from changing a window's size/position when using the window's frame.
     * @return {Promise.<void>}
     * @tutorial Window.disableUserMovement
     */
    disableUserMovement() {
        return this.wire.sendAction('disable-window-frame', this.identity).then(() => undefined);
    }
    /*
     * @deprecated Use {@link Window.enableUserMovement} instead.
     */
    enableFrame() {
        console.warn('Function is deprecated; use enableUserMovement instead.');
        return this.wire.sendAction('enable-window-frame', this.identity).then(() => undefined);
    }
    /**
     * Re-enables user changes to a window's size/position when using the window's frame.
     * @return {Promise.<void>}
     * @tutorial Window.enableUserMovement
     */
    enableUserMovement() {
        return this.wire.sendAction('enable-window-frame', this.identity).then(() => undefined);
    }
    /**
     * Flashes the window’s frame and taskbar icon until stopFlashing is called or until a focus event is fired.
     * @return {Promise.<void>}
     * @tutorial Window.flash
     */
    flash() {
        return this.wire.sendAction('flash-window', this.identity).then(() => undefined);
    }
    /**
     * Stops the taskbar icon from flashing.
     * @return {Promise.<void>}
     * @tutorial Window.stopFlashing
     */
    stopFlashing() {
        return this.wire.sendAction('stop-flash-window', this.identity).then(() => undefined);
    }
    /**
     * Retrieves an array containing wrapped fin.Windows that are grouped with this window.
     * If a window is not in a group an empty array is returned. Please note that
     * calling window is included in the result array.
     * @return {Promise.<Array<_Window|ExternalWindow>>}
     * @deprecated All Window Group APIs will be removed by major version 22.
     * @tutorial Window.getGroup
     */
    getGroup() {
        console.warn('Deprecation Warning: All Window Group APIs will be removed by major version 22.');
        return this.wire
            .sendAction('get-window-group', {
            crossApp: true,
            ...this.identity
        })
            .then(({ payload }) => {
            let winGroup = [];
            if (payload.data.length) {
                winGroup = this.windowListFromNameList(payload.data);
            }
            return winGroup;
        });
    }
    /**
     * Gets an information object for the window.
     * @return {Promise.<WindowInfo>}
     * @tutorial Window.getInfo
     */
    getInfo() {
        return this.wire.sendAction('get-window-info', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Retrieves the window's Layout
     * @return {Promise.<Layout>}
     * @tutorial Window.getLayout
     * @experimental
     */
    async getLayout() {
        this.wire.sendAction('window-get-layout', this.identity).catch((e) => {
            // don't expose
        });
        const opts = await this.getOptions();
        if (!opts.layout) {
            throw new Error('Window does not have a Layout');
        }
        return this.fin.Platform.Layout.wrap(this.identity);
    }
    /**
     * Gets the current settings of the window.
     * @return {Promise.<any>}
     * @tutorial Window.getOptions
     */
    getOptions() {
        return this.wire.sendAction('get-window-options', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Gets the parent application.
     * @return {Promise.<Application>}
     * @tutorial Window.getParentApplication
     */
    getParentApplication() {
        this.wire.sendAction('window-get-parent-application', this.identity).catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return Promise.resolve(new application_1.Application(this.wire, this.identity));
    }
    /**
     * Gets the parent window.
     * @return {Promise.<_Window>}
     * @tutorial Window.getParentWindow
     */
    getParentWindow() {
        this.wire.sendAction('window-get-parent-window', this.identity).catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return Promise.resolve(new application_1.Application(this.wire, this.identity)).then((app) => app.getWindow());
    }
    /**
     * ***DEPRECATED - please use Window.capturePage.***
     * Gets a base64 encoded PNG image of the window or just part a of it.
     * @param { Area } [area] The area of the window to be captured.
     * Omitting it will capture the whole visible window.
     * @return {Promise.<string>}
     * @tutorial Window.capturePage
     */
    async getSnapshot(area) {
        const req = { area, ...this.identity };
        console.warn('Window.getSnapshot has been deprecated, please use Window.capturePage');
        const res = await this.wire.sendAction('get-window-snapshot', req);
        return res.payload.data;
    }
    /**
     * Gets the current state ("minimized", "maximized", or "restored") of the window.
     * @return {Promise.<string>}
     * @tutorial Window.getState
     */
    getState() {
        return this.wire.sendAction('get-window-state', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Previously called getNativeWindow.
     * Returns the [Window Object](https://developer.mozilla.org/en-US/docs/Web/API/Window)
     * that represents the web context of the target window. This is the same object that
     * you would get from calling [window.open()](https://developer.mozilla.org/en-US/docs/Web/API/Window/open) in a standard web context.
     * The target window needs to be in the same application as the requesting window
     * as well as comply with [same-origin](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) policy requirements.
     * @return {object}
     * @tutorial Window.getWebWindow
     */
    getWebWindow() {
        this.wire.sendAction('window-get-web-window', this.identity).catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return this.wire.environment.getWebWindow(this.identity);
    }
    /**
     * Determines if the window is a main window.
     * @return {boolean}
     * @tutorial Window.isMainWindow
     */
    isMainWindow() {
        this.wire.sendAction('window-is-main-window', this.identity).catch((e) => {
            // we do not want to expose this error, just continue if this analytics-only call fails
        });
        return this.me.uuid === this.me.name;
    }
    /**
     * Determines if the window is currently showing.
     * @return {Promise.<boolean>}
     * @tutorial Window.isShowing
     */
    isShowing() {
        return this.wire.sendAction('is-window-showing', this.identity).then(({ payload }) => payload.data);
    }
    /**
     * Joins the same window group as the specified window.
     * Joining a group with native windows is currently not supported(method will nack).
     * @param { _Window | ExternalWindow } target The window whose group is to be joined
     * @deprecated All Window Group APIs will be removed by major version 22.
     * @return {Promise.<void>}
     * @tutorial Window.joinGroup
     */
    joinGroup(target) {
        console.warn('Deprecation Warning: All Window Group APIs will be removed by major version 22.');
        return this.wire
            .sendAction('join-window-group', {
            groupingUuid: target.identity.uuid,
            groupingWindowName: target.identity.name,
            ...this.identity
        })
            .then(() => undefined);
    }
    /**
     * Leaves the current window group so that the window can be move independently of those in the group.
     * @return {Promise.<void>}
     * @deprecated All Window Group APIs will be removed by major version 22.
     * @tutorial Window.leaveGroup
     */
    leaveGroup() {
        console.warn('Deprecation Warning: All Window Group APIs will be removed by major version 22.');
        return this.wire.sendAction('leave-window-group', this.identity).then(() => undefined);
    }
    /**
     * Maximizes the window
     * @return {Promise.<void>}
     * @tutorial Window.maximize
     */
    maximize() {
        return this.wire.sendAction('maximize-window', this.identity).then(() => undefined);
    }
    /**
     * Merges the instance's window group with the same window group as the specified window
     * @param { _Window | ExternalWindow } target The window whose group is to be merged with
     * @deprecated All Window Group APIs will be removed by major version 22.
     * @return {Promise.<void>}
     * @tutorial Window.mergeGroups
     */
    mergeGroups(target) {
        console.warn('Deprecation Warning: All Window Group APIs will be removed by major version 22.');
        return this.wire
            .sendAction('merge-window-groups', {
            groupingUuid: target.identity.uuid,
            groupingWindowName: target.identity.name,
            ...this.identity
        })
            .then(() => undefined);
    }
    /**
     * Minimizes the window.
     * @return {Promise.<void>}
     * @tutorial Window.minimize
     */
    minimize() {
        return this.wire.sendAction('minimize-window', this.identity).then(() => undefined);
    }
    /**
     * Moves the window by a specified amount.
     * @param { number } deltaLeft The change in the left position of the window
     * @param { number } deltaTop The change in the top position of the window
     * @param { WindowMovementOptions } options Optional parameters to modify window movement
     * @return {Promise.<void>}
     * @tutorial Window.moveBy
     */
    moveBy(deltaLeft, deltaTop, options = { moveIndependently: false }) {
        return this.wire
            .sendAction('move-window-by', {
            deltaLeft,
            deltaTop,
            options,
            ...this.identity
        })
            .then(() => undefined);
    }
    /**
     * Moves the window to a specified location.
     * @param { number } left The left position of the window
     * @param { number } top The top position of the window
     * @param { WindowMovementOptions } options Optional parameters to modify window movement
     * @return {Promise.<void>}
     * @tutorial Window.moveTo
     */
    moveTo(left, top, options = { moveIndependently: false }) {
        return this.wire
            .sendAction('move-window', {
            left,
            top,
            options,
            ...this.identity
        })
            .then(() => undefined);
    }
    /**
     * Resizes the window by a specified amount.
     * @param { number } deltaWidth The change in the width of the window
     * @param { number } deltaHeight The change in the height of the window
     * @param { AnchorType } anchor Specifies a corner to remain fixed during the resize.
     * Can take the values: "top-left", "top-right", "bottom-left", or "bottom-right".
     * If undefined, the default is "top-left"
     * @param { WindowMovementOptions } options Optional parameters to modify window movement
     * @return {Promise.<void>}
     * @tutorial Window.resizeBy
     */
    resizeBy(deltaWidth, deltaHeight, anchor, options = { moveIndependently: false }) {
        return this.wire
            .sendAction('resize-window-by', {
            deltaWidth: Math.floor(deltaWidth),
            deltaHeight: Math.floor(deltaHeight),
            anchor,
            options,
            ...this.identity
        })
            .then(() => undefined);
    }
    /**
     * Resizes the window to the specified dimensions.
     * @param { number } width The change in the width of the window
     * @param { number } height The change in the height of the window
     * @param { AnchorType } anchor Specifies a corner to remain fixed during the resize.
     * Can take the values: "top-left", "top-right", "bottom-left", or "bottom-right".
     * If undefined, the default is "top-left"
     * @param { WindowMovementOptions } options Optional parameters to modify window movement
     * @return {Promise.<void>}
     * @tutorial Window.resizeTo
     */
    resizeTo(width, height, anchor, options = { moveIndependently: false }) {
        return this.wire
            .sendAction('resize-window', {
            width: Math.floor(width),
            height: Math.floor(height),
            anchor,
            options,
            ...this.identity
        })
            .then(() => undefined);
    }
    /**
     * Restores the window to its normal state (i.e., unminimized, unmaximized).
     * @return {Promise.<void>}
     * @tutorial Window.restore
     */
    restore() {
        return this.wire.sendAction('restore-window', this.identity).then(() => undefined);
    }
    /**
     * Will bring the window to the front of the entire stack and give it focus.
     * @return {Promise.<void>}
     * @tutorial Window.setAsForeground
     */
    setAsForeground() {
        return this.wire.sendAction('set-foreground-window', this.identity).then(() => undefined);
    }
    /**
     * Sets the window's size and position.
     * @property { Bounds } bounds This is a * @type {string} name - name of the window.object that holds the propertys of
     * @param { WindowMovementOptions } options Optional parameters to modify window movement
     * @return {Promise.<void>}
     * @tutorial Window.setBounds
     */
    setBounds(bounds, options = { moveIndependently: false }) {
        return this.wire
            .sendAction('set-window-bounds', { ...bounds, options, ...this.identity })
            .then(() => undefined);
    }
    /**
     * Shows the window if it is hidden.
     * @param { boolean } [force = false] Show will be prevented from showing when force is false and
     *  ‘show-requested’ has been subscribed to for application’s main window.
     * @return {Promise.<void>}
     * @tutorial Window.show
     */
    show(force = false) {
        return this.wire.sendAction('show-window', { force, ...this.identity }).then(() => undefined);
    }
    /**
     * Shows the window if it is hidden at the specified location.
     * If the toggle parameter is set to true, the window will
     * alternate between showing and hiding.
     * @param { number } left The left position of the window
     * @param { number } top The right position of the window
     * @param { boolean } force Show will be prevented from closing when force is false and
     * ‘show-requested’ has been subscribed to for application’s main window
     * @param { WindowMovementOptions } options Optional parameters to modify window movement
     * @return {Promise.<void>}
     * @tutorial Window.showAt
     */
    showAt(left, top, force = false, options = { moveIndependently: false }) {
        return this.wire
            .sendAction('show-at-window', {
            force,
            left: Math.floor(left),
            top: Math.floor(top),
            options,
            ...this.identity
        })
            .then(() => undefined);
    }
    /**
     * Shows the Chromium Developer Tools
     * @return {Promise.<void>}
     * @tutorial Window.showDeveloperTools
     */
    /**
     * Updates the window using the passed options.
     * Values that are objects are deep-merged, overwriting only the values that are provided.
     * @param {*} options Changes a window's options that were defined upon creation. See tutorial
     * @return {Promise.<void>}
     * @tutorial Window.updateOptions
     */
    updateOptions(options) {
        return this.wire.sendAction('update-window-options', { options, ...this.identity }).then(() => undefined);
    }
    /**
     * Provides credentials to authentication requests
     * @param { string } userName userName to provide to the authentication challenge
     * @param { string } password password to provide to the authentication challenge
     * @return {Promise.<void>}
     * @tutorial Window.authenticate
     */
    authenticate(userName, password) {
        return this.wire
            .sendAction('window-authenticate', { userName, password, ...this.identity })
            .then(() => undefined);
    }
    /**
     * @typedef {object} ShowPopupMenuOptions
     * @property {Array<MenuItemTemplate>} template - An array describing the menu to show.
     * @property {number} [x] - The window x coordinate where to show the menu. Defaults to mouse position. If using must also use `y`.
     * @property {number} [y] - The window y coordinate where to show the menu. Defaults to mouse position. If using must also use `x`
     */
    /**
     * @typedef {object} MenuItemTemplate
     * @property {*} data Data to be returned if the user selects the element. Must be serializable. Large objects can have a performance impact.
     * @property {'normal' | 'separator' | 'submenu' | 'checkbox'} [type] - Defaults to 'normal' unless a 'submenu' key exists
     * @property {string} [label] - The text to show on the menu item. Should be left undefined for `type: 'separator'`
     * @property {boolean} [enabled] - If false, the menu item will be greyed out and unclickable.
     * @property {boolean} [visible] - If false, the menu item will be entirely hidden.
     * @property {boolean} [checked] - Should only be specified for `checkbox` type menu items.
     * @property {Array<MenuItemTemplate>} [submenu] Should be specified for `submenu` type menu items. If `submenu` is specified, the `type: 'submenu'` can be omitted.
     */
    /**
     * @typedef {object} MenuResult
     * @property {'clicked' | 'closed'} result - Whether the user clicked on a menu item or the menu was closed (user clicked elsewhere).
     * @property {* | undefined} [data] - The data property of the menu item clicked by the user. Only defined if result was `clicked`.
     */
    /**
     * Shows a menu on the window. Returns a promise that resolves when the user has either selected an item or closed the menu. (This may take longer than other apis).
     * Resolves to an object with `{result: 'clicked', data }` where data is the data field on the menu item clicked, or `{result 'closed'}` when the user doesn't select anything.
     * Calling this method will close previously opened menus.
     * @experimental
     * @param {ShowPopupMenuOptions} options
     * @return {Promise<MenuResult>}
     * @tutorial Window.showPopupMenu
     */
    async showPopupMenu(options) {
        const { payload } = await this.wire.sendAction('show-popup-menu', { options, ...this.identity });
        return payload.data;
    }
    /**
     * Closes the window's popup menu, if one exists.
     * @experimental
     * @return {Promise<void>}
     * @tutorial Window.closePopupMenu
     */
    async closePopupMenu() {
        return this.wire.sendAction('close-popup-menu', { ...this.identity }).then(() => undefined);
    }
}
exports._Window = _Window;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/window/bounds-changed.js":
/*!***********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/window/bounds-changed.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BoundsChangeType = void 0;
const base_1 = __webpack_require__(/*! ../base */ "./node_modules/openfin-adapter/src/api/base.js");
class BoundsChangedReply extends base_1.Reply {
}
exports["default"] = BoundsChangedReply;
var BoundsChangeType;
(function (BoundsChangeType) {
    BoundsChangeType[BoundsChangeType["POSITION"] = 0] = "POSITION";
    BoundsChangeType[BoundsChangeType["SIZE"] = 1] = "SIZE";
    BoundsChangeType[BoundsChangeType["POSITION_AND_SIZE"] = 2] = "POSITION_AND_SIZE";
})(BoundsChangeType = exports.BoundsChangeType || (exports.BoundsChangeType = {}));


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/window/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/window/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Factory_1 = __webpack_require__(/*! ./Factory */ "./node_modules/openfin-adapter/src/api/window/Factory.js");
exports["default"] = Factory_1.default;
__exportStar(__webpack_require__(/*! ./shapes */ "./node_modules/openfin-adapter/src/api/window/shapes.js"), exports);
__exportStar(__webpack_require__(/*! ./Instance */ "./node_modules/openfin-adapter/src/api/window/Instance.js"), exports);
__exportStar(__webpack_require__(/*! ./bounds-changed */ "./node_modules/openfin-adapter/src/api/window/bounds-changed.js"), exports);


/***/ }),

/***/ "./node_modules/openfin-adapter/src/api/window/shapes.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/api/window/shapes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/openfin-adapter/src/mock.js":
/*!**************************************************!*\
  !*** ./node_modules/openfin-adapter/src/mock.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inOpenFin = exports.fin = void 0;
/* eslint-disable import/prefer-default-export */
/* eslint-disable spaced-comment */
/* eslint-disable @typescript-eslint/triple-slash-reference */
/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable class-methods-use-this */
/// <reference path="../OpenFin.d.ts"/>
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const fin_1 = __webpack_require__(/*! ./api/fin */ "./node_modules/openfin-adapter/src/api/fin.js");
const EntityType_1 = __webpack_require__(/*! ./shapes/EntityType */ "./node_modules/openfin-adapter/src/shapes/EntityType.js");
const transport_1 = __webpack_require__(/*! ./transport/transport */ "./node_modules/openfin-adapter/src/transport/transport.js");
class MockWire extends events_1.EventEmitter {
    connect(address) {
        throw new Error('You are not running in OpenFin.');
    }
    connectSync() {
        throw new Error('You are not running in OpenFin.');
    }
    send(data) {
        throw new Error('You are not running in OpenFin.');
    }
    shutdown() {
        throw new Error('You are not running in OpenFin.');
    }
    // eslint-disable-next-line no-useless-constructor
    constructor() {
        super();
    }
}
class MockEnvironment {
    constructor() {
        this.childViews = true;
    }
    getManagerConstructor() {
        throw new Error('Method not implemented.');
    }
    getProviderInitializer() {
        throw new Error('Method not implemented.');
    }
    writeToken(path, token) {
        throw new Error('Method not implemented.');
    }
    retrievePort(config) {
        throw new Error('Method not implemented.');
    }
    getNextMessageId() {
        throw new Error('Method not implemented.');
    }
    getRandomId() {
        throw new Error('Method not implemented.');
    }
    createChildContent(options) {
        throw new Error('Method not implemented.');
    }
    getWebWindow(identity) {
        throw new Error('Method not implemented.');
    }
    getCurrentEntityIdentity() {
        throw new Error('Method not implemented.');
    }
    getCurrentEntityType() {
        return EntityType_1.default.UNKNOWN;
    }
    raiseEvent(eventName, eventArgs) {
        throw new Error('Method not implemented.');
    }
    getUrl() {
        throw new Error('Method not implemented.');
    }
}
exports.fin = ((typeof window !== 'undefined' && ((_a = window) === null || _a === void 0 ? void 0 : _a.fin)) ||
    (() => {
        const environment = new MockEnvironment();
        const transport = new transport_1.default(MockWire, environment, {
            uuid: '',
            name: ''
        });
        return new fin_1.default(transport);
    })());
exports.inOpenFin = typeof window !== 'undefined' && typeof window.fin === 'object';


/***/ }),

/***/ "./node_modules/openfin-adapter/src/shapes/EntityType.js":
/*!***************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/shapes/EntityType.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var EntityType;
(function (EntityType) {
    EntityType["WINDOW"] = "window";
    EntityType["IFRAME"] = "iframe";
    EntityType["EXTERNAL"] = "external connection";
    EntityType["VIEW"] = "view";
    EntityType["UNKNOWN"] = "unknown";
})(EntityType || (EntityType = {}));
exports["default"] = EntityType;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/shapes/Platform.js":
/*!*************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/shapes/Platform.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowCreationReason = exports.HostContextChangedReasons = void 0;
var HostContextChangedReasons;
(function (HostContextChangedReasons) {
    HostContextChangedReasons["updated"] = "updated";
    HostContextChangedReasons["reparented"] = "reparented";
})(HostContextChangedReasons = exports.HostContextChangedReasons || (exports.HostContextChangedReasons = {}));
var WindowCreationReason;
(function (WindowCreationReason) {
    WindowCreationReason["Tearout"] = "tearout";
    WindowCreationReason["CreateViewWithoutTarget"] = "create-view-without-target";
    WindowCreationReason["APICall"] = "api-call";
    WindowCreationReason["AppCreation"] = "app-creation";
    WindowCreationReason["Restore"] = "restore";
})(WindowCreationReason = exports.WindowCreationReason || (exports.WindowCreationReason = {}));


/***/ }),

/***/ "./node_modules/openfin-adapter/src/transport/fin_store.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/transport/fin_store.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFin = exports.registerFin = void 0;
const finMap = new WeakMap();
function registerFin(wire, fin) {
    finMap.set(wire, fin);
}
exports.registerFin = registerFin;
function getFin(wire) {
    const fin = finMap.get(wire);
    if (!fin) {
        throw new Error('Could not locate fin api for given transport');
    }
    return fin;
}
exports.getFin = getFin;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/transport/transport-errors.js":
/*!************************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/transport/transport-errors.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RuntimeError = exports.NotSupportedError = exports.NotImplementedError = exports.NoAckError = exports.DuplicateCorrelationError = exports.UnexpectedActionError = exports.DisconnectedError = void 0;
/* eslint-disable max-classes-per-file */
const wire_1 = __webpack_require__(/*! ./wire */ "./node_modules/openfin-adapter/src/transport/wire.js");
class DisconnectedError extends Error {
    constructor(readyState) {
        super(`Expected websocket state OPEN but found ${wire_1.READY_STATE[readyState]}`);
        this.readyState = readyState;
    }
}
exports.DisconnectedError = DisconnectedError;
class UnexpectedActionError extends Error {
}
exports.UnexpectedActionError = UnexpectedActionError;
class DuplicateCorrelationError extends Error {
}
exports.DuplicateCorrelationError = DuplicateCorrelationError;
class NoAckError extends Error {
}
exports.NoAckError = NoAckError;
class NotImplementedError extends Error {
}
exports.NotImplementedError = NotImplementedError;
class NotSupportedError extends Error {
}
exports.NotSupportedError = NotSupportedError;
class RuntimeError extends Error {
    constructor(data) {
        const payload = data.payload || data;
        const { reason, error } = payload;
        super(reason);
        this.name = 'RuntimeError';
        if (error === null || error === void 0 ? void 0 : error.stack) {
            this.stack = error.stack;
        }
    }
}
exports.RuntimeError = RuntimeError;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/transport/transport.js":
/*!*****************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/transport/transport.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _wire;
Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const wire_1 = __webpack_require__(/*! ./wire */ "./node_modules/openfin-adapter/src/transport/wire.js");
const transport_errors_1 = __webpack_require__(/*! ./transport-errors */ "./node_modules/openfin-adapter/src/transport/transport-errors.js");
const eventAggregator_1 = __webpack_require__(/*! ../api/events/eventAggregator */ "./node_modules/openfin-adapter/src/api/events/eventAggregator.js");
const me_1 = __webpack_require__(/*! ../api/me */ "./node_modules/openfin-adapter/src/api/me.js");
class Transport extends events_1.EventEmitter {
    constructor(WireType, environment, config) {
        super();
        this.wireListeners = new Map();
        this.topicRefMap = new Map();
        this.eventAggregator = new eventAggregator_1.default();
        this.messageHandlers = [this.eventAggregator.dispatchEvent];
        _wire.set(this, void 0);
        this.connectSync = () => {
            const wire = __classPrivateFieldGet(this, _wire);
            wire.connectSync();
        };
        // This function is only used in our tests.
        this.getPort = () => {
            if (this.environment.constructor.name !== 'NodeEnvironment') {
                throw new transport_errors_1.NotImplementedError('Not Implemented');
            }
            const wire = __classPrivateFieldGet(this, _wire);
            return wire.wire.url.split(':').slice(-1)[0];
        };
        /* `READY_STATE` is an instance var set by `constructor` to reference the `WebTransportSocket.READY_STATE` enum.
         * This is syntactic sugar that makes the enum accessible through the `wire` property of the various `fin` singletons.
         * For example, `fin.system.wire.READY_STATE` is a shortcut to `fin.system.wire.wire.constructor.READY_STATE`.
         * However it is accessed, the enum is useful for interrogating the state of the web socket on send failure.
         * The `err.readyState` value is passed to the `reject` handler of the promise returned by either of
         * `sendAction` or `ferryAction`, and hence all the API methods in the various `fin` singletons that call them.
         * The enum can be used in two distinct ways by the `reject` handler (using `fin.System.getVersion` by way of example):
         * 1. State name by state value:
         * fin.system.getVersion().catch(err => { console.log('State:', fin.system.wire.READY_STATE[err.readyState]); });
         * 2. State value by state name:
         * fin.system.getVersion().catch(err => { console.log('Closed:', err.readyState === fin.system.wire.READY_STATE.CLOSED); });
         * Note that `reject` is called when and only when `readyState` is not `OPEN`.
         */
        this.READY_STATE = wire_1.READY_STATE;
        __classPrivateFieldSet(this, _wire, new WireType(this.onmessage.bind(this)));
        this.environment = environment;
        this.sendRaw = __classPrivateFieldGet(this, _wire).send.bind(__classPrivateFieldGet(this, _wire));
        this.registerMessageHandler(this.handleMessage.bind(this));
        __classPrivateFieldGet(this, _wire).on('disconnected', () => {
            for (const [, { reject }] of this.wireListeners) {
                reject('Remote connection has closed');
            }
            this.wireListeners.clear();
            this.emit('disconnected');
        });
        const { uuid, name } = config;
        const entityType = this.environment.getCurrentEntityType();
        this.me = me_1.getBaseMe(entityType, uuid, name);
    }
    shutdown() {
        const wire = __classPrivateFieldGet(this, _wire);
        return wire.shutdown();
    }
    async connect(config) {
        if (wire_1.isExistingConnectConfig(config)) {
            return this.connectByPort(config);
        }
        if (wire_1.isNewConnectConfig(config)) {
            const port = await this.environment.retrievePort(config);
            return this.connectByPort({ ...config, address: `ws://localhost:${port}` });
        }
        return undefined;
    }
    async connectByPort(config) {
        const { address, uuid } = config;
        const reqAuthPayload = { ...config, type: 'file-token' };
        const wire = __classPrivateFieldGet(this, _wire);
        await wire.connect(address);
        const requestExtAuthRet = await this.sendAction('request-external-authorization', {
            uuid,
            type: 'file-token'
        }, true);
        if (requestExtAuthRet.action !== 'external-authorization-response') {
            throw new transport_errors_1.UnexpectedActionError(requestExtAuthRet.action);
        }
        const { token } = requestExtAuthRet.payload;
        await this.environment.writeToken(requestExtAuthRet.payload.file, requestExtAuthRet.payload.token);
        const requestAuthRet = await this.sendAction('request-authorization', reqAuthPayload, true);
        if (requestAuthRet.action !== 'authorization-response') {
            throw new transport_errors_1.UnexpectedActionError(requestAuthRet.action);
        }
        else if (requestAuthRet.payload.success !== true) {
            throw new transport_errors_1.RuntimeError(requestAuthRet.payload);
        }
        else {
            return token;
        }
    }
    sendAction(action, payload = {}, uncorrelated = false
    // specialResponse type is only used for 'requestAuthorization'
    ) {
        return new Promise((resolve, reject) => {
            const id = this.environment.getNextMessageId();
            const msg = {
                action,
                payload,
                messageId: id
            };
            const wire = __classPrivateFieldGet(this, _wire);
            this.addWireListener(id, resolve, reject, uncorrelated);
            return wire.send(msg).catch(reject);
        });
    }
    ferryAction(origData) {
        return new Promise((resolve, reject) => {
            const id = this.environment.getNextMessageId();
            origData.messageId = id;
            const resolver = (data) => {
                resolve(data.payload);
            };
            const wire = __classPrivateFieldGet(this, _wire);
            return wire
                .send(origData)
                .then(() => this.addWireListener(id, resolver, reject, false))
                .catch(reject);
        });
    }
    registerMessageHandler(handler) {
        this.messageHandlers.push(handler);
    }
    addWireListener(id, resolve, reject, uncorrelated) {
        if (uncorrelated) {
            this.uncorrelatedListener = resolve;
        }
        else if (this.wireListeners.has(id)) {
            reject(new transport_errors_1.DuplicateCorrelationError(String(id)));
        }
        else {
            this.wireListeners.set(id, { resolve, reject });
        }
        // Timeout and reject()?
    }
    // This method executes message handlers until the _one_ that handles the message (returns truthy) has run
    onmessage(data) {
        for (const h of this.messageHandlers) {
            h.call(null, data);
        }
    }
    handleMessage(data) {
        const id = data.correlationId || NaN;
        if (!('correlationId' in data)) {
            if (this.uncorrelatedListener) {
                this.uncorrelatedListener.call(null, data);
            }
            this.uncorrelatedListener = () => {
                // empty block
            };
        }
        else if (!this.wireListeners.has(id)) {
            return false;
        }
        else {
            // We just checked for existence above
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const { resolve, reject } = this.wireListeners.get(id);
            if (data.action !== 'ack') {
                reject(new transport_errors_1.NoAckError(data.action));
            }
            else if (!('payload' in data)) {
                reject(new transport_errors_1.RuntimeError(data));
            }
            else if (!data.payload.success) {
                reject(new transport_errors_1.RuntimeError(data.payload));
            }
            else {
                resolve.call(null, data);
            }
            this.wireListeners.delete(id);
        }
        return true;
    }
}
_wire = new WeakMap();
exports["default"] = Transport;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/transport/wire.js":
/*!************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/transport/wire.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.READY_STATE = exports.isInternalConnectConfig = exports.isPortDiscoveryConfig = exports.isNewConnectConfig = exports.isExistingConnectConfig = exports.isExternalConfig = void 0;
function isExternalConfig(config) {
    if (typeof config.manifestUrl === 'string') {
        return true;
    }
    return false;
}
exports.isExternalConfig = isExternalConfig;
function isExistingConnectConfig(config) {
    return hasUuid(config) && typeof config.address === 'string';
}
exports.isExistingConnectConfig = isExistingConnectConfig;
function hasUuid(config) {
    return typeof config.uuid === 'string';
}
function hasRuntimeVersion(config) {
    return config.runtime && typeof config.runtime.version === 'string';
}
function isNewConnectConfig(config) {
    return hasUuid(config) && hasRuntimeVersion(config);
}
exports.isNewConnectConfig = isNewConnectConfig;
function isPortDiscoveryConfig(config) {
    return (isExternalConfig(config) && hasRuntimeVersion(config)) || isNewConnectConfig(config);
}
exports.isPortDiscoveryConfig = isPortDiscoveryConfig;
function isInternalConnectConfig(config) {
    return isExistingConnectConfig(config) || isNewConnectConfig(config);
}
exports.isInternalConnectConfig = isInternalConnectConfig;
var READY_STATE;
(function (READY_STATE) {
    READY_STATE[READY_STATE["CONNECTING"] = 0] = "CONNECTING";
    READY_STATE[READY_STATE["OPEN"] = 1] = "OPEN";
    READY_STATE[READY_STATE["CLOSING"] = 2] = "CLOSING";
    READY_STATE[READY_STATE["CLOSED"] = 3] = "CLOSED"; // The connection is closed.
})(READY_STATE = exports.READY_STATE || (exports.READY_STATE = {}));


/***/ }),

/***/ "./node_modules/openfin-adapter/src/util/promises.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfin-adapter/src/util/promises.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.promiseMapSerial = exports.serial = exports.promiseMap = exports.promisify = void 0;
function promisify(func) {
    return (...args) => new Promise((resolve, reject) => {
        func(...args, (err, val) => (err ? reject(err) : resolve(val)));
    });
}
exports.promisify = promisify;
async function promiseMap(arr, asyncF) {
    return Promise.all(arr.map(asyncF));
}
exports.promiseMap = promiseMap;
async function serial(arr) {
    const ret = [];
    for (const func of arr) {
        // eslint-disable-next-line no-await-in-loop
        const next = await func();
        ret.push(next);
    }
    return ret;
}
exports.serial = serial;
async function promiseMapSerial(arr, func) {
    return serial(arr.map((value, index, array) => () => func(value, index, array)));
}
exports.promiseMapSerial = promiseMapSerial;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/util/ref-counter.js":
/*!**************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/util/ref-counter.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class RefCoutner {
    constructor() {
        this.topicRefMap = new Map();
    }
    // returns the ref count after incrementing
    incRefCount(key) {
        const refCount = this.topicRefMap.get(key);
        let returnCount;
        if (!refCount) {
            this.topicRefMap.set(key, 1);
            returnCount = 1;
        }
        else {
            const newRefCount = refCount + 1;
            returnCount = newRefCount;
            this.topicRefMap.set(key, newRefCount);
        }
        return returnCount;
    }
    // returns the ref count after decrementing, or -1 if the key already had no references
    decRefCount(key) {
        const refCount = this.topicRefMap.get(key);
        let returnCount;
        if (refCount) {
            const newRefCount = refCount - 1;
            this.topicRefMap.set(key, newRefCount);
            returnCount = newRefCount;
        }
        else {
            returnCount = -1;
        }
        return returnCount;
    }
    // Execute firstAction if it is the first such ref, else execute nonFirstAction.
    // In either case the return value is that of the action executed
    actOnFirst(key, firstAction, nonFirstAction) {
        const numRefs = this.incRefCount(key);
        const isFirstRef = numRefs === 1;
        return isFirstRef ? firstAction() : nonFirstAction();
    }
    // Execute lastAction if it is the first such ref, else execute nonLastAction.
    // In either case the return value is that of the action executed
    actOnLast(key, lastAction, nonLastAction) {
        const numRefs = this.decRefCount(key);
        const isLastRef = numRefs === 0;
        return isLastRef ? lastAction() : nonLastAction();
    }
}
exports["default"] = RefCoutner;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/util/runtimeVersioning.js":
/*!********************************************************************!*\
  !*** ./node_modules/openfin-adapter/src/util/runtimeVersioning.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runtimeUuidMeetsMinimumRuntimeVersion = exports.parseRuntimeUuid = exports.meetsMinimumRuntimeVersion = void 0;
function vNum(x) {
    return [...x.split('.').reverse().entries()].reduce((p, [i, v]) => p + +v * 10000 ** i, 0);
}
/*
  Compares runtime versions to see if the current runtime meets your desired minimum.
*/
function meetsMinimumRuntimeVersion(currentVersion, minVersion) {
    const currentVersionParsed = vNum(currentVersion);
    const minVersionParsed = vNum(minVersion);
    return currentVersionParsed >= minVersionParsed;
}
exports.meetsMinimumRuntimeVersion = meetsMinimumRuntimeVersion;
// Strips the port info from the runtimeUuid, leaving just the runtime version.
function parseRuntimeUuid(runtimeUuid) {
    return runtimeUuid.split('/')[0];
}
exports.parseRuntimeUuid = parseRuntimeUuid;
function runtimeUuidMeetsMinimumRuntimeVersion(runtimeUuid, minVersion) {
    const runtimeVersion = parseRuntimeUuid(runtimeUuid);
    return meetsMinimumRuntimeVersion(runtimeVersion, minVersion);
}
exports.runtimeUuidMeetsMinimumRuntimeVersion = runtimeUuidMeetsMinimumRuntimeVersion;


/***/ }),

/***/ "./node_modules/openfin-adapter/src/util/validate.js":
/*!***********************************************************!*\
  !*** ./node_modules/openfin-adapter/src/util/validate.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateIdentity = void 0;
function validateIdentity(identity) {
    let errorMsg;
    if (typeof identity !== 'object' || typeof identity.uuid !== 'string') {
        errorMsg = 'Not a valid identity object';
    }
    return errorMsg;
}
exports.validateIdentity = validateIdentity;
exports["default"] = { validateIdentity };


/***/ }),

/***/ "./client/src/apps.ts":
/*!****************************!*\
  !*** ./client/src/apps.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getApps": () => (/* binding */ getApps),
/* harmony export */   "getAppsByTag": () => (/* binding */ getAppsByTag)
/* harmony export */ });
/* harmony import */ var openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openfin-adapter/src/mock */ "./node_modules/openfin-adapter/src/mock.js");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings */ "./client/src/settings.ts");


let cachedApps;
async function validateEntries(apps) {
    let canLaunchExternalProcessResponse = await openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_0__.fin.System.queryPermissionForCurrentContext('System.launchExternalProcess');
    let canLaunchExternalProcess = canLaunchExternalProcessResponse !== undefined && canLaunchExternalProcessResponse.granted;
    let canDownloadAppAssetsResponse = await openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_0__.fin.System.queryPermissionForCurrentContext('System.downloadAsset');
    let canDownloadAppAssets = canDownloadAppAssetsResponse !== undefined && canDownloadAppAssetsResponse.granted;
    if (canLaunchExternalProcess && canDownloadAppAssets) {
        return apps;
    }
    let validatedApps = [];
    let rejectedAppIds = [];
    let settings = await (0,_settings__WEBPACK_IMPORTED_MODULE_1__.getSettings)();
    let appAssetTag = settings?.appProvider?.appAssetTag ?? "appasset";
    for (let i = 0; i < apps.length; i++) {
        if (apps[i].manifestType !== "external") {
            validatedApps.push(apps[i]);
        }
        else {
            if (canLaunchExternalProcess === false) {
                rejectedAppIds.push(apps[i].appId);
            }
            else if (Array.isArray(apps[i].tags) && apps[i].tags.indexOf(appAssetTag) > -1 && canDownloadAppAssets === false) {
                rejectedAppIds.push(apps[i].appId);
            }
            else {
                validatedApps.push(apps[i]);
            }
        }
    }
    if (rejectedAppIds.length > 0) {
        console.warn("Apps.ts: validateEntries: Not passing the following list of applications as they will not be able to run on this machine due to missing permissions. Alternatively this logic could be moved to the launch function where a selection is not launched but the user is presented with a modal saying they can't launch it due to permissions.", rejectedAppIds);
    }
    return validatedApps;
}
async function getRestEntries(url, credentials, cacheDuration) {
    const options = credentials !== undefined ? { credentials } : undefined;
    if (url === undefined) {
        return [];
    }
    const response = await fetch(url, options);
    let apps = await response.json();
    cachedApps = await validateEntries(apps);
    if (cacheDuration !== undefined) {
        let setTimeoutInMs = cacheDuration * 60 * 1000;
        setTimeout(() => {
            console.log("Clearing cache of apps as cache duration has passed.");
            cachedApps = undefined;
        }, setTimeoutInMs);
    }
    return cachedApps;
}
async function getApps() {
    console.log("Requesting apps.");
    try {
        let settings = await (0,_settings__WEBPACK_IMPORTED_MODULE_1__.getSettings)();
        let apps = cachedApps ?? await getRestEntries(settings?.appProvider?.appsSourceUrl, settings?.appProvider?.includeCredentialOnSourceRequest, settings?.appProvider?.cacheDurationInMinutes);
        return apps;
    }
    catch (err) {
        console.error("Error retrieving apps. Returning empty list.", err);
        return [];
    }
}
async function getAppsByTag(tags) {
    let apps = await getApps();
    let filteredApps = apps.filter((value) => {
        if (value.tags === undefined) {
            return false;
        }
        for (let i = 0; i < tags.length; i++) {
            if (value.tags.indexOf(tags[i]) > -1) {
                return true;
            }
        }
        return false;
    });
    return filteredApps;
}


/***/ }),

/***/ "./client/src/bootstrapper.ts":
/*!************************************!*\
  !*** ./client/src/bootstrapper.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "init": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./search */ "./client/src/search.ts");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ "./client/src/store.ts");
/* harmony import */ var _workspace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./workspace */ "./client/src/workspace.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings */ "./client/src/settings.ts");




async function init() {
    // you can kick off your bootstrapping process here where you may decide to prompt for authentication, 
    // gather reference data etc before starting workspace and interacting with it.
    console.log("Initialising the bootstrapper");
    let settings = await (0,_settings__WEBPACK_IMPORTED_MODULE_3__.getSettings)();
    let workspaceLoaded = false;
    let setupSearch = settings?.bootstrap?.search ?? true;
    let setupStore = settings?.bootstrap?.store ?? true;
    if (setupSearch) {
        await (0,_workspace__WEBPACK_IMPORTED_MODULE_2__.start)();
        workspaceLoaded = true;
        // only register search logic once workspace is running
        await (0,_search__WEBPACK_IMPORTED_MODULE_0__.init)();
    }
    if (setupStore) {
        await (0,_store__WEBPACK_IMPORTED_MODULE_1__.init)();
        if (!workspaceLoaded) {
            await (0,_store__WEBPACK_IMPORTED_MODULE_1__.show)();
        }
    }
}


/***/ }),

/***/ "./client/src/launch.ts":
/*!******************************!*\
  !*** ./client/src/launch.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "launch": () => (/* binding */ launch)
/* harmony export */ });
/* harmony import */ var _openfin_workspace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @openfin/workspace */ "./node_modules/@openfin/workspace/index.js");
/* harmony import */ var _openfin_workspace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_openfin_workspace__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! openfin-adapter/src/mock */ "./node_modules/openfin-adapter/src/mock.js");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settings */ "./client/src/settings.ts");



async function launch(appEntry) {
    console.log("Application launch requested: ", appEntry);
    if (appEntry.manifestType === "external") {
        let settings = await (0,_settings__WEBPACK_IMPORTED_MODULE_2__.getSettings)();
        let appAssetTag = settings?.appProvider?.appAssetTag ?? "appasset";
        if (appEntry.tags !== undefined && appEntry.tags.indexOf(appAssetTag) > -1) {
            console.log("Application requested is a native app with a tag of appasset so it is provided by this workspace platform. Managing request via platform and not Workspace.");
            let options = {};
            options.alias = appEntry.manifest;
            options.uuid = appEntry.appId;
            await openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_1__.fin.System.launchExternalProcess(options);
        }
        else {
            console.log("Application requested is a native app. Managing request via platform and not Workspace.");
            let options = {};
            options.path = appEntry.manifest;
            options.uuid = appEntry.appId;
            await openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_1__.fin.System.launchExternalProcess(options);
        }
    }
    else {
        await (0,_openfin_workspace__WEBPACK_IMPORTED_MODULE_0__.launchApp)(appEntry);
    }
    console.log("Finished application launch request");
}


/***/ }),

/***/ "./client/src/platform.ts":
/*!********************************!*\
  !*** ./client/src/platform.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "init": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openfin-adapter/src/mock */ "./node_modules/openfin-adapter/src/mock.js");

async function init() {
    console.log("Initialising platform");
    await openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_0__.fin.Platform.init({});
}


/***/ }),

/***/ "./client/src/search.ts":
/*!******************************!*\
  !*** ./client/src/search.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "init": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var _openfin_search_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @openfin/search-api */ "./node_modules/@openfin/search-api/index.js");
/* harmony import */ var _openfin_search_api__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_openfin_search_api__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings */ "./client/src/settings.ts");
/* harmony import */ var _launch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./launch */ "./client/src/launch.ts");
/* harmony import */ var _workspace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./workspace */ "./client/src/workspace.ts");
/* harmony import */ var _apps__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./apps */ "./client/src/apps.ts");





async function getResults() {
    let settings = await (0,_settings__WEBPACK_IMPORTED_MODULE_1__.getSettings)();
    let apps = await (0,_apps__WEBPACK_IMPORTED_MODULE_4__.getApps)();
    if (Array.isArray(apps)) {
        let results = [];
        let defaultAction = settings.searchProvider.defaultAction;
        for (let i = 0; i < apps.length; i++) {
            if (apps[i].description !== undefined) {
                let entry = {
                    key: apps[i].appId,
                    title: apps[i].title,
                    actions: [{ name: defaultAction }],
                    data: apps[i],
                    description: apps[i].description,
                    shortDescription: apps[i].description,
                    template: _openfin_search_api__WEBPACK_IMPORTED_MODULE_0__.TemplateNames.SimpleText,
                    templateContent: apps[i].description,
                };
                results.push(entry);
            }
            else {
                let entry = {
                    key: apps[i].appId,
                    title: apps[i].title,
                    actions: [{ name: defaultAction }],
                    data: apps[i],
                    template: _openfin_search_api__WEBPACK_IMPORTED_MODULE_0__.TemplateNames.Plain
                };
                results.push(entry);
            }
        }
        return results;
    }
    else {
        return [];
    }
}
async function init() {
    console.log("Initialising search.");
    let settings = await (0,_settings__WEBPACK_IMPORTED_MODULE_1__.getSettings)();
    if (settings.searchProvider === undefined || settings.searchProvider.name === undefined || settings.searchProvider.title === undefined) {
        console.warn("searchProvider: not configured in the customSettings of your manifest correctly. Ensure you have the searchProvider object defined in customSettings with the following defined: name, title");
        return;
    }
    const topics = settings?.searchProvider?.topics || ["all", "apps"];
    let searchTopicClients = [];
    for (let i = 0; i < topics.length; i++) {
        let searchTopicClient = await (0,_openfin_search_api__WEBPACK_IMPORTED_MODULE_0__.subscribe)({ topic: topics[i], uuid: _workspace__WEBPACK_IMPORTED_MODULE_3__.UUID });
        searchTopicClients.push(searchTopicClient);
    }
    const queryMinLength = settings?.searchProvider?.queryMinLength || 3;
    const queryAgainst = settings?.searchProvider?.queryAgainst || ["title"];
    const onSearch = async (request, response) => {
        // These results are pulled in by the search requester.
        let results = await getResults();
        let query = request.query.toLowerCase();
        if (query.indexOf("/") === 0) {
            return [];
        }
        if (query.length < queryMinLength) {
            return results;
        }
        return results.filter(entry => {
            let matchFound = queryAgainst.some(target => {
                let path = target.split('.');
                if (path.length === 1) {
                    let targetValue = entry[path[0]];
                    if (targetValue !== undefined && targetValue !== null && typeof targetValue === "string") {
                        return targetValue.toLowerCase().indexOf(query) > -1;
                    }
                }
                else if (path.length === 2) {
                    let target = entry[path[0]];
                    let targetValue;
                    if (target !== undefined && target !== null) {
                        targetValue = target[path[1]];
                    }
                    if (targetValue !== undefined && targetValue !== null && typeof targetValue === "string") {
                        return targetValue.toLowerCase().indexOf(query) > -1;
                    }
                    if (targetValue !== undefined && targetValue !== null && Array.isArray(targetValue)) {
                        if (targetValue.length > 0 && typeof targetValue[0] === "string" && targetValue.some(target => target.toLowerCase().indexOf(query) === 0)) {
                            return true;
                        }
                        else {
                            console.warn("Manifest configuration for search specified a queryAgainst target that is an array but not an array of strings. Only string values and arrays are supported: " + target);
                        }
                    }
                }
                else {
                    console.warn("The manifest configuration for search has a queryAgainst entry that has a depth greater than 1. You can search for e.g. data.tags if data has tags in it and it is either a string or an array of strings.");
                }
                return false;
            });
            return matchFound;
        });
    };
    const onSelection = async (result) => {
        if (result.data !== undefined) {
            await (0,_launch__WEBPACK_IMPORTED_MODULE_2__.launch)(result.data);
        }
        else {
            console.warn("Unable to execute result without data being passed");
        }
    };
    const searchProvider = {
        title: settings.searchProvider.title,
        name: settings.searchProvider.name,
        onSearch: onSearch,
        onResultDispatch: onSelection
    };
    // Register the search data provider.
    for (let stc = 0; stc < searchTopicClients.length; stc++) {
        await searchTopicClients[stc].register(searchProvider);
    }
    console.log("Search configured.");
}


/***/ }),

/***/ "./client/src/settings.ts":
/*!********************************!*\
  !*** ./client/src/settings.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSettings": () => (/* binding */ getSettings)
/* harmony export */ });
/* harmony import */ var openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openfin-adapter/src/mock */ "./node_modules/openfin-adapter/src/mock.js");

let settings;
async function getConfiguredSettings() {
    const app = await openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_0__.fin.Application.getCurrent();
    const manifest = await app.getManifest();
    if (manifest.customSettings !== undefined) {
        settings = manifest.customSettings;
    }
    else {
        settings = {};
    }
    return settings;
}
async function getSettings() {
    if (settings === undefined) {
        settings = await getConfiguredSettings();
    }
    return settings;
}


/***/ }),

/***/ "./client/src/store.ts":
/*!*****************************!*\
  !*** ./client/src/store.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "init": () => (/* binding */ init),
/* harmony export */   "show": () => (/* binding */ show),
/* harmony export */   "hide": () => (/* binding */ hide)
/* harmony export */ });
/* harmony import */ var _openfin_workspace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @openfin/workspace */ "./node_modules/@openfin/workspace/index.js");
/* harmony import */ var _openfin_workspace__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_openfin_workspace__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _apps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./apps */ "./client/src/apps.ts");
/* harmony import */ var _launch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./launch */ "./client/src/launch.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings */ "./client/src/settings.ts");




async function init() {
    console.log("Initialising the storefront provider.");
    let provider = await getStoreProvider();
    if (provider !== null) {
        try {
            await _openfin_workspace__WEBPACK_IMPORTED_MODULE_0__.Storefront.register(provider);
            console.log("Storefront provider initialised.");
        }
        catch (err) {
            console.error("An error was encountered while trying to register the content store provider", err);
        }
    }
}
async function show() {
    console.log("Showing the store.");
    return _openfin_workspace__WEBPACK_IMPORTED_MODULE_0__.Storefront.show();
}
async function hide() {
    console.log("Hiding the store.");
    return _openfin_workspace__WEBPACK_IMPORTED_MODULE_0__.Storefront.show();
}
/**
 * This function is used when a navigation item or section hasn't been configured with an ID. This is to simplify configuration for this demo.
 * In a real application you would need an idempotent and unique ID (think GUID) that doesn't change for that navigation item/section regardless of how
 * many times it is regenerated (e.g. more items can be added to the item/section but the ID stays the same).
 * As you navigate around the store this ID is used as a route. So if a user clicks on a link, navigates to a new page and the re-requested navigation item has
 * a different ID then the store will not be able to find a match and it won't be able to render the navigation item.
 * A real application would not use this approach (as an update to the tag list would result in a new ID which would fail if the config was fetched from a server and not a manifest)
 */
function getId(title, tags = []) {
    const search = " ";
    const replaceWith = "-";
    let result = title.replaceAll(search, replaceWith);
    result += "-" + tags.join("-");
    return result.toLowerCase();
}
function isStorefrontConfigurationValid(config) {
    let idList = [];
    let hasDuplicateIds = false;
    if (config === undefined ||
        config.storefrontProvider === undefined ||
        config.storefrontProvider.id === undefined ||
        config.storefrontProvider.title === undefined ||
        (config.storefrontProvider.footer === undefined &&
            config.storefrontProvider.landingPage !== undefined &&
            config.storefrontProvider.landingPage.topRow !== undefined &&
            config.storefrontProvider.landingPage.middleRow !== undefined &&
            config.storefrontProvider.landingPage.bottomRow !== undefined &&
            config.storefrontProvider.navigation !== undefined)) {
        console.error("StorefrontProvider is not correctly configured in the customSettings of this manifest. You must ensure that storefrontProvider is defined, that it has an id and title and that the footer, landingPage (top row, middle row and bottom row) and navigation sections have been defined.");
        return false;
    }
    let validateId = (id, namespace, warning) => {
        if (id === undefined) {
            console.warn(namespace + ": " + warning);
        }
        else {
            if (idList.indexOf(id) > -1) {
                hasDuplicateIds = true;
                console.error(namespace +
                    ": The id is used in more than one place. Please have a unique and idempotent id: " +
                    id);
            }
            else {
                idList.push(id);
            }
        }
    };
    let warningMessage = "The id is not defined. This demo will generate an id based on title but you should have a unique and idempotent id when building your own store.";
    console.log("Validating settings storefrontProvider navigation config");
    let navigation = config.storefrontProvider.navigation;
    for (let i = 0; i < navigation.length; i++) {
        validateId(navigation[i].id, "storefrontProvider.navigation[" + i + "].id", warningMessage);
        let items = navigation[i].items;
        for (let n = 0; n < items.length; n++) {
            validateId(items[n].id, "storefrontProvider.navigation[" + i + "].items[" + n + "].id", warningMessage);
        }
    }
    console.log("Validating settings storefrontProvider landing page hero config");
    let landingPage = config.storefrontProvider.landingPage;
    if (landingPage?.hero?.cta !== undefined) {
        validateId(landingPage.hero.cta.id, "storefrontProvider.landingPage.hero.cta.id", warningMessage);
    }
    console.log("Validating settings storefrontProvider landing page top row config");
    let topRow = landingPage.topRow;
    if (topRow.items !== undefined) {
        for (let i = 0; i < topRow.items.length; i++) {
            validateId(topRow.items[i].id, "storefrontProvider.landingPage.topRow.items[" + i + "].id", warningMessage);
        }
    }
    console.log("Validating settings storefrontProvider landing page bottom row config");
    let bottomRow = landingPage.bottomRow;
    if (bottomRow.items !== undefined) {
        for (let i = 0; i < bottomRow.items.length; i++) {
            validateId(bottomRow.items[i].id, "storefrontProvider.landingPage.bottomRow.items[" + i + "].id", warningMessage);
        }
    }
    console.log("Validating ids, checking for duplicate ids.");
    if (hasDuplicateIds) {
        console.error("You have defined duplicate ids (please see the other error messages) which could result in strange behaviour (if we are routing by id and you have two or more items that resolve to the same id then it could navigate to something unexpected. Please ensure ids are unique and idempotent.");
        return false;
    }
    return true;
}
async function getStoreProvider() {
    console.log("Getting the store provider.");
    let settings = await (0,_settings__WEBPACK_IMPORTED_MODULE_3__.getSettings)();
    if (isStorefrontConfigurationValid(settings)) {
        return {
            id: settings.storefrontProvider.id,
            title: settings.storefrontProvider.title,
            getNavigation: getNavigation.bind(this),
            getLandingPage: getLandingPage.bind(this),
            getFooter: getFooter.bind(this),
            getApps: _apps__WEBPACK_IMPORTED_MODULE_1__.getApps,
            launchApp: _launch__WEBPACK_IMPORTED_MODULE_2__.launch,
        };
    }
    return null;
}
async function getNavigation() {
    console.log("Showing the store navigation.");
    const navigationSectionItemLimit = 5;
    const navigationSectionLimit = 2;
    let settings = await (0,_settings__WEBPACK_IMPORTED_MODULE_3__.getSettings)();
    let navigationSections = [];
    if (settings?.storefrontProvider?.navigation === undefined) {
        return [];
    }
    for (let i = 0; i < settings.storefrontProvider.navigation.length; i++) {
        if (navigationSections.length === navigationSectionLimit) {
            console.log("More than 2 navigation sections defined in StorefrontProvider settings. Only two are taken.");
            break;
        }
        let navigationSection = {
            id: settings.storefrontProvider.navigation[i].id ??
                getId(settings.storefrontProvider.navigation[i].title),
            title: settings.storefrontProvider.navigation[i].title,
            items: (await getNavigationItems(settings.storefrontProvider.navigation[i].items, navigationSectionItemLimit)),
        };
        navigationSections.push(navigationSection);
    }
    return navigationSections;
}
async function getLandingPage() {
    console.log("Getting the store landing page.");
    let landingPage = {
        topRow: null,
        middleRow: null,
        bottomRow: null,
    };
    let settings = await (0,_settings__WEBPACK_IMPORTED_MODULE_3__.getSettings)();
    const storeFrontDetailedNavigationItemBottomRowLimit = 3;
    const storeFrontDetailedNavigationItemTopRowLimit = 4;
    const middleRowAppLimit = 6;
    if (settings?.storefrontProvider?.landingPage?.hero !== undefined) {
        let hero = settings.storefrontProvider.landingPage.hero;
        let cta = await getNavigationItem(hero.cta.id, hero.cta.title, hero.cta.tags);
        landingPage.hero = {
            title: hero.title,
            image: hero.image,
            description: hero.description,
            cta,
        };
    }
    if (settings?.storefrontProvider?.landingPage?.topRow !== undefined) {
        landingPage.topRow = await getLandingPageRow(settings?.storefrontProvider?.landingPage?.topRow, storeFrontDetailedNavigationItemTopRowLimit);
    }
    else {
        console.error("You need to have a topRow defined in your landing page.");
    }
    if (settings?.storefrontProvider?.landingPage?.middleRow !== undefined) {
        let middleRow = settings.storefrontProvider.landingPage.middleRow;
        let middleRowApps = await (0,_apps__WEBPACK_IMPORTED_MODULE_1__.getAppsByTag)(middleRow.tags);
        if (middleRowApps.length > middleRowAppLimit) {
            console.warn(`Too many apps (${middleRowApps.length}) have been returned by the middle row tag definition ${middleRow.tags.join(" ")}. Only ${middleRowAppLimit} will be shown.`);
        }
        let validatedMiddleRowApps = middleRowApps.slice(0, middleRowAppLimit);
        landingPage.middleRow = {
            title: middleRow.title,
            apps: validatedMiddleRowApps,
        };
    }
    else {
        console.error("You need to have a middleRow defined in your landing page.");
    }
    if (settings?.storefrontProvider?.landingPage?.bottomRow !== undefined) {
        landingPage.bottomRow = await getLandingPageRow(settings.storefrontProvider.landingPage.bottomRow, storeFrontDetailedNavigationItemBottomRowLimit);
    }
    else {
        console.error("You need to have a bottomRow defined in your landing page.");
    }
    return landingPage;
}
async function getFooter() {
    console.log("Getting the store footer.");
    let settings = await (0,_settings__WEBPACK_IMPORTED_MODULE_3__.getSettings)();
    if (settings?.storefrontProvider?.footer !== undefined) {
        return settings.storefrontProvider.footer;
    }
    else {
        console.error("Storefront is being initialised without a footer configured.");
        return null;
    }
}
/**
 * This section generates a navigation item for Storefront based on some configuration.
 * @param id
 * This id should be unique and idempotent and isn't changed regardless of how often the same navigation item is regenerated.
 * The reason for this is because it is used for routing in Storefront. If a user navigated from a link and the id changes when the item
 * is re-requested by storefront then it will not be able to render the contents.
 * @param title
 * @param tags
 * Tags are used as a way of filtering out which apps should be assigned to a StorefrontNavigationItem.
 * This allows apps to be tagged on the server and the store would automatically update the apps assigned to a particular section.
 * @returns StorefrontNavigationItem
 */
async function getNavigationItem(id, title, tags) {
    let navigationItem = {
        id: id ?? getId(title, tags),
        title,
        templateId: "appGrid",
        templateData: {
            apps: [],
        },
    };
    let apps = await (0,_apps__WEBPACK_IMPORTED_MODULE_1__.getAppsByTag)(tags);
    if (apps !== undefined && apps.length > 0) {
        navigationItem.templateData.apps = apps;
    }
    return navigationItem;
}
async function getNavigationItems(items, limit) {
    let navigationItems = [];
    for (let i = 0; i < items.length; i++) {
        let navigationItem = await getNavigationItem(items[i].id, items[i].title, items[i].tags);
        navigationItems.push(navigationItem);
    }
    if (navigationItems.length > limit) {
        console.warn(`You have defined too many navigations items (${navigationItems.length}). Please limit it to ${limit} as we will only take the first ${limit}`);
    }
    return navigationItems.slice(0, limit);
}
async function getLandingPageRow(definition, limit) {
    let items = [];
    for (let i = 0; i < definition.items.length; i++) {
        let navigationItem = await getNavigationItem(definition.items[i].id, definition.items[i].title, definition.items[i].tags);
        let item = {
            description: definition.items[i].description,
            image: definition.items[i].image,
            ...navigationItem,
        };
        items.push(item);
    }
    if (items.length > limit) {
        console.warn(`You have defined too many storefront detailed navigation items (${items.length}). Please keep it to the limit of ${limit} as only the first ${limit} will be returned.`);
    }
    let detailedNavigationItems = items.slice(0, limit);
    return {
        title: definition.title,
        items: detailedNavigationItems,
    };
}


/***/ }),

/***/ "./client/src/workspace.ts":
/*!*********************************!*\
  !*** ./client/src/workspace.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "start": () => (/* binding */ start),
/* harmony export */   "UUID": () => (/* binding */ UUID)
/* harmony export */ });
/* harmony import */ var openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openfin-adapter/src/mock */ "./node_modules/openfin-adapter/src/mock.js");

function getWorkspace() {
    let platform = openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_0__.fin.Platform.wrapSync({ uuid: UUID });
    return platform;
}
async function isWorkspaceRunning() {
    return getWorkspace().Application.isRunning();
}
async function launchOpenFinWorkspace() {
    console.log("Launching Workspace.");
    return openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_0__.fin.System.launchManifest("fins://system-apps/workspace");
}
async function start() {
    console.log("Initialising workspace.");
    if (await isWorkspaceRunning()) {
        console.log("Workspace already running and initialised.");
        return true;
    }
    return new Promise(async (resolve) => {
        getWorkspace().once("platform-api-ready", async () => {
            console.log("Workspace is now ready and initialised.");
            resolve(true);
        });
        await launchOpenFinWorkspace();
        isWorkspaceRunning().then(async (isRunning) => {
            if (isRunning) {
                console.log("Workspace status. Is running and initialised: " + isRunning);
                resolve(isRunning);
            }
        });
    });
}
const UUID = "openfin-browser";


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!********************************!*\
  !*** ./client/src/provider.ts ***!
  \********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform */ "./client/src/platform.ts");
/* harmony import */ var _bootstrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bootstrapper */ "./client/src/bootstrapper.ts");
/* harmony import */ var openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! openfin-adapter/src/mock */ "./node_modules/openfin-adapter/src/mock.js");



window.addEventListener('DOMContentLoaded', async () => {
    let platform = openfin_adapter_src_mock__WEBPACK_IMPORTED_MODULE_2__.fin.Platform.getCurrentSync();
    platform.once('platform-api-ready', _bootstrapper__WEBPACK_IMPORTED_MODULE_1__.init.bind(undefined));
    await (0,_platform__WEBPACK_IMPORTED_MODULE_0__.init)();
});

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hmYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsK0RBQVM7QUFDaEMsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQXFCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLGtGQUFZO0FBQ3ZDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsaURBQWlELDBDQUEwQztBQUMzRjtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDZEQUE2RDtBQUM3RCxpREFBaUQsMkNBQTJDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsOEJBQThCO0FBQ2pHO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBLDJEQUEyRCx5QkFBeUI7QUFDcEYsZ0JBQWdCLG9CQUFvQjtBQUNwQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxrQkFBa0I7QUFDakMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGFBQWE7QUFDbkUscUJBQXFCLFNBQVM7QUFDOUI7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQyxTQUFTO0FBQ1Q7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFlOzs7Ozs7Ozs7Ozs7QUMzTkY7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLCtEQUFTO0FBQ2hDLGlCQUFpQixtQkFBTyxDQUFDLHlFQUFXO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyxxRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0IsYUFBYTtBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0IsYUFBYTtBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixTQUFTLDBGQUEwRixvRUFBb0U7QUFDMUwsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLHFGQUFxRixTQUFTO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQseUJBQXlCO0FBQ3JGO0FBQ0E7QUFDQSwyREFBMkQseUJBQXlCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFNBQVM7QUFDekY7QUFDQTtBQUNBLG9DQUFvQyx5Q0FBeUM7QUFDN0UsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw4Q0FBOEM7QUFDdEYsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixTQUFTO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixTQUFTO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsU0FBUztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsU0FBUztBQUNsRztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQscUNBQXFDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx5QkFBeUIsb0NBQW9DLHdCQUF3QjtBQUNsSSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDhDQUE4QztBQUNwRztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0NBQWdDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UscUNBQXFDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSx5QkFBeUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrQ0FBa0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFNBQVM7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsU0FBUztBQUNoRjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVyxTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxvQ0FBb0M7QUFDdkc7QUFDQTtBQUNBLG1CQUFtQjs7Ozs7Ozs7Ozs7O0FDcmJOO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBVztBQUNyQyxhQUFhLG1CQUFPLENBQUMsa0ZBQVk7QUFDakMsa0JBQWU7Ozs7Ozs7Ozs7OztBQ2RGO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxtQkFBbUIsR0FBRyxZQUFZO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLDZFQUFrQjtBQUM3QyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxhQUFhOzs7Ozs7Ozs7Ozs7QUNyS0E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLCtEQUFTO0FBQ2hDO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFNBQVM7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFNBQVM7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFNBQVM7QUFDakY7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFNBQVM7QUFDckY7QUFDQTtBQUNBLGtCQUFlOzs7Ozs7Ozs7Ozs7QUN2RkY7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGlCQUFpQixtQkFBTyxDQUFDLCtDQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVyxTQUFTLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVyxnQkFBZ0IsU0FBUztBQUM1RCxxREFBcUQsZUFBZTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTs7Ozs7Ozs7Ozs7O0FDekVGO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsbUJBQU8sQ0FBQywrREFBUztBQUNoQyxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0VBQStFLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0E7QUFDQSxrQkFBZTs7Ozs7Ozs7Ozs7O0FDdkNGO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQjtBQUNBLGVBQWUsbUJBQU8sQ0FBQywrREFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0IsYUFBYTtBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0IsYUFBYTtBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsU0FBUztBQUNyRztBQUNBO0FBQ0EsMkJBQTJCOzs7Ozs7Ozs7Ozs7QUM1R2Q7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHlGQUFXO0FBQ3JDLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLDJGQUFZOzs7Ozs7Ozs7Ozs7QUNkcEI7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLCtEQUFTO0FBQ2hDLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTs7Ozs7Ozs7Ozs7O0FDN0JGO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QjtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHlFQUFXO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQywrREFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RDtBQUNBLHVEQUF1RCxNQUFNO0FBQzdEO0FBQ0EscURBQXFELFlBQVk7QUFDakUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVyxTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVyxTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWSxlQUFlO0FBQzNDLGlDQUFpQztBQUNqQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0MsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZLGVBQWU7QUFDM0MsaUNBQWlDO0FBQ2pDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7Ozs7Ozs7Ozs7O0FDellUO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBVztBQUNyQyxrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyxzRkFBWTs7Ozs7Ozs7Ozs7O0FDZHBCO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLCtDQUFRO0FBQ2pDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQWdCO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFnQjtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBcUI7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQXFCO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLDBGQUFzQjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBbUI7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsMEdBQThCO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLGdHQUF5QjtBQUNqRCxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBZTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyw0RkFBdUI7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMsMEVBQWM7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQWtCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQywwREFBTTtBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBd0I7QUFDcEQsa0JBQWtCLG1CQUFPLENBQUMsMEVBQVc7QUFDckMsMEJBQTBCLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFlOzs7Ozs7Ozs7Ozs7QUM5Q0Y7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLCtEQUFTO0FBQ2hDLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFlOzs7Ozs7Ozs7Ozs7QUNwRUY7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLCtEQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0IsYUFBYTtBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0IsYUFBYTtBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxTQUFTO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixTQUFTO0FBQ3pGO0FBQ0E7QUFDQSxjQUFjOzs7Ozs7Ozs7Ozs7QUNqSUQ7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLDBFQUFXO0FBQ3JDLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLDRFQUFZOzs7Ozs7Ozs7Ozs7QUNkcEI7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGVBQWUsbUJBQU8sQ0FBQywrREFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdELHVCQUF1QixLQUFLO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsUUFBUTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixRQUFRO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVyxTQUFTLGtGQUFrRixRQUFRO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLGtCQUFlOzs7Ozs7Ozs7Ozs7QUN2RUY7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsTUFBTTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7Ozs7Ozs7Ozs7O0FDNUZOO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHdGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLFlBQVk7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQ0FBcUM7QUFDckQsZ0VBQWdFLHNEQUFzRDtBQUN0SDtBQUNBO0FBQ0E7QUFDQSxrQkFBZTs7Ozs7Ozs7Ozs7O0FDMUNGO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixpQkFBaUIsbUJBQU8sQ0FBQyxzRkFBVTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBWTtBQUN2QyxlQUFlLG1CQUFPLENBQUMsa0VBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixXQUFXLHNCQUFzQixxREFBcUQsc0JBQXNCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxZQUFZO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVcsMkJBQTJCLGlEQUFpRCxhQUFhO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVUsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFVBQVUsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxVQUFVLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlGQUF5RjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywyQkFBMkIsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsbUJBQW1CLFVBQVUsbUJBQW1CO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNkJBQTZCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7Ozs7Ozs7Ozs7OztBQ2pORjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsa0JBQWtCLG1CQUFPLENBQUMsd0ZBQVc7QUFDckMsNEJBQTRCLG1CQUFPLENBQUMscUdBQWlDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVEsUUFBUSxVQUFVLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVEsb0JBQW9CLFVBQVUsb0JBQW9CLGdCQUFnQiwyQkFBMkI7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVEsb0JBQW9CLFVBQVUsb0JBQW9CLGdCQUFnQiwyQkFBMkI7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsUUFBUSxLQUFLLFVBQVUsTUFBTTtBQUMzRyx5RkFBeUYsT0FBTztBQUNoRyxrQkFBa0IsUUFBUSxhQUFhLFVBQVUsY0FBYztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOzs7Ozs7Ozs7Ozs7QUM5R1Y7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGlCQUFpQixtQkFBTyxDQUFDLCtDQUFRO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQywrREFBUztBQUNoQyxzQkFBc0IsbUJBQU8sQ0FBQyxzRkFBd0I7QUFDdEQsZ0JBQWdCLG1CQUFPLENBQUMsNEZBQWlCO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVcsaUVBQWlFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVcsa0NBQWtDO0FBQzdELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkMsS0FBSztBQUNMO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdLYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsK0RBQVM7QUFDaEMsd0JBQXdCLG1CQUFPLENBQUMsd0ZBQWlCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLHdGQUFpQjtBQUNqRDtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0Isa0NBQWtDO0FBQ2xELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2RkFBNkYsS0FBSztBQUNsRztBQUNBO0FBQ0EsbUlBQW1JO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7Ozs7Ozs7Ozs7OztBQ3JERjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsZUFBZSxtQkFBTyxDQUFDLCtEQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUdBQXVHO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0EsaUVBQWlFLG1CQUFtQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLG1CQUFtQixXQUFXLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0EsdUdBQXVHLGVBQWU7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHFCQUFxQixFQUFFLHFCQUFxQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLG1GQUFtRjtBQUN2TDtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0IsMEJBQTBCO0FBQzFDLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLDZCQUE2Qix3QkFBd0I7QUFDckQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWEsRUFBRSxhQUFhO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxhQUFhLEVBQUUsWUFBWTtBQUN2RztBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0JBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9FQUFvRTtBQUNoRztBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0IsaUNBQWlDO0FBQ2pELGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscURBQXFELHFCQUFxQixFQUFFLHFCQUFxQjtBQUNqRztBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyw2RkFBNkY7QUFDdk07QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCLGdDQUFnQztBQUNoRCxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsYUFBYSxFQUFFLFlBQVk7QUFDckc7QUFDQTtBQUNBLDRFQUE0RSxhQUFhLEVBQUUsWUFBWTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdGQUFnRjtBQUM1RztBQUNBLGlCQUFpQjtBQUNqQixtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQ0FBcUM7QUFDckQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNFQUFzRTtBQUNsRztBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixXQUFXO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMENBQTBDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMENBQTBDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Ysb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsMEJBQTBCO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQXVDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBa0Q7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SkFBdUosZUFBZTtBQUN0SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbURBQW1EO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxtREFBbUQ7QUFDakc7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsV0FBVyxhQUFhLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLDBCQUEwQjtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVyxtQkFBbUIsY0FBYyxZQUFZLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLDBCQUEwQjtBQUM1TCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnRkFBZ0Ysb0JBQW9CLElBQUkscUJBQXFCLG1DQUFtQyx1QkFBdUI7QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG9CQUFvQixJQUFJLG9CQUFvQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPLHVCQUF1QixvQkFBb0IsSUFBSSxvQkFBb0I7QUFDckg7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7Ozs7Ozs7Ozs7OztBQzV2QlI7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixlQUFlLG1CQUFPLENBQUMsK0RBQVM7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQVM7QUFDakM7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQThDO0FBQzlEO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQOztBQUVBO0FBQ0EsT0FBTztBQUNQLE9BQU87QUFDUCxPQUFPO0FBQ1AsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILEtBQUs7QUFDekg7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixTQUFTO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZLEdBQUcscUJBQXFCO0FBQ3BGLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx3QkFBd0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsV0FBVztBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx3QkFBd0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkRBQTJELFFBQVE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQkFBZ0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxnQkFBZ0IsU0FBUztBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFdBQVc7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVcsbUJBQW1CLGFBQWEsSUFBSSxNQUFNO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVSxJQUFJLE1BQU07QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7Ozs7Ozs7Ozs7O0FDN1RhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBVztBQUNyQyxrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyx3RkFBaUI7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLHdGQUFpQjs7Ozs7Ozs7Ozs7O0FDZnpCO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixrQkFBa0IsWUFBWSxjQUFjLEVBQUUsV0FBVzs7Ozs7Ozs7Ozs7O0FDSDVDO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxpQkFBaUI7QUFDakMscUJBQXFCLG1CQUFPLENBQUMscUZBQXNCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxvRUFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRTtBQUNBLGFBQWE7QUFDYjtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7Ozs7Ozs7Ozs7OztBQzVEQTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsK0RBQVM7QUFDaEMsaUJBQWlCLG1CQUFPLENBQUMsK0VBQVU7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMsbUZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkRBQTJEO0FBQ2xILGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlOzs7Ozs7Ozs7Ozs7QUNsQ0Y7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLCtEQUFTO0FBQ2hDO0FBQ0E7QUFDQSxtREFBbUQsMkRBQTJEO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkRBQTJEO0FBQ2xILGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyREFBMkQ7QUFDbEgsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDJEQUEyRDtBQUNsSCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQjs7Ozs7Ozs7Ozs7O0FDM0dSO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBVztBQUNyQyxhQUFhLG1CQUFPLENBQUMsK0VBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG1GQUFZO0FBQ2pDLGtCQUFlOzs7Ozs7Ozs7Ozs7QUNmRjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxjQUFjO0FBQzVDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixnQkFBZ0IseUNBQXlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7Ozs7Ozs7Ozs7OztBQ3JCZDtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLGVBQWUsbUJBQU8sQ0FBQywrREFBUztBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsK0VBQVk7QUFDdkM7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsNENBQTRDO0FBQzVDLFFBQVEsNENBQTRDO0FBQ3BELGNBQWMsZ0JBQWdCO0FBQzlCLHdEQUF3RCwwRkFBMEY7QUFDbEosY0FBYyxzQkFBc0I7QUFDcEMsY0FBYyxjQUFjO0FBQzVCLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxRQUFRLG9DQUFvQztBQUM1QztBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlDQUF5QyxxQkFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx5Q0FBeUMscUJBQXFCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLGlFQUFpRSxnREFBZ0Q7QUFDakgsNkVBQTZFLE1BQU07QUFDbkY7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0JBQWtCO0FBQ2pDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHlCQUF5QjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWU7Ozs7Ozs7Ozs7OztBQzNMRjtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixlQUFlLG1CQUFPLENBQUMsK0RBQVM7QUFDaEMsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQXFCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLG9GQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLFdBQVc7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1JQUFtSSx5QkFBeUI7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUlBQXFJLHlCQUF5QjtBQUM5SjtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLFdBQVc7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHVDQUF1QztBQUNsRztBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEMsZ0JBQWdCLHVCQUF1QjtBQUN2QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTyxJQUFJLElBQUk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtDQUFrQztBQUNuRSxnQkFBZ0IsU0FBUztBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsYUFBYTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDJGQUEyRixnQ0FBZ0M7QUFDM0gsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0RBQWtELFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaURBQWlEO0FBQ25GLGVBQWUsS0FBSztBQUNwQixlQUFlLFVBQVU7QUFDekI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsU0FBUztBQUNUO0FBQ0E7QUFDQSwrRUFBK0UsaURBQWlEO0FBQ2hJO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0EsZ0NBQWdDLGdEQUFnRDtBQUNoRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7Ozs7Ozs7Ozs7QUMzU2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsa0JBQWUsS0FBSzs7Ozs7Ozs7Ozs7O0FDZlA7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLDZFQUFXO0FBQ3JDLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLCtFQUFZOzs7Ozs7Ozs7Ozs7QUNkcEI7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBWTtBQUN2QyxlQUFlLG1CQUFPLENBQUMsa0VBQVk7QUFDbkM7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMscUdBQXFHO0FBQ3JHLFdBQVcsMkZBQTJGO0FBQ3RHLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QiwwRUFBMEUsd0NBQXdDO0FBQ2xILElBQUksMkZBQTJGO0FBQy9GLGVBQWUsU0FBUztBQUN4QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsNkRBQTZEO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QiwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCLCtCQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7Ozs7Ozs7Ozs7OztBQzNMYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDbkQsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQWlCO0FBQ2hELGVBQWUsbUJBQU8sQ0FBQyxrRUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLCtDQUErQywwRUFBMEU7QUFDekgscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0Isb0JBQW9CLGVBQWU7QUFDbkMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxQkFBcUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxjQUFjOzs7Ozs7Ozs7Ozs7QUNsR0Q7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxvRkFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsc0ZBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGtGQUFVOzs7Ozs7Ozs7Ozs7QUNkbEI7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7Ozs7Ozs7Ozs7OztBQ0RoRDtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsK0RBQVM7QUFDaEMsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQVM7QUFDakM7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxhQUFhO0FBQzNCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxtRUFBbUUsVUFBVTtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQkFBZTs7Ozs7Ozs7Ozs7O0FDaEVGO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEI7QUFDQSxlQUFlLG1CQUFPLENBQUMsK0RBQVM7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1Q0FBdUM7QUFDL0Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxhQUFhO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFrRDtBQUNyRixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLCtCQUErQjtBQUMvRixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwrQkFBK0I7QUFDakcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7Ozs7Ozs7Ozs7O0FDcklhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBVztBQUNyQyxrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyxzRkFBWTs7Ozs7Ozs7Ozs7O0FDZHBCO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLG9DQUFvQztBQUNwRTtBQUNBLG9DQUFvQyxjQUFjLGNBQWMsRUFBRSxRQUFRO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0REFBNEQsNkJBQTZCLEtBQUs7Ozs7Ozs7Ozs7OztBQ1RsRjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsK0RBQVM7QUFDaEMsMkJBQTJCLG1CQUFPLENBQUMsMEdBQWtDO0FBQ3JFLGlCQUFpQixtQkFBTyxDQUFDLHlFQUFXO0FBQ3BDO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsV0FBVztBQUMxQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLGdDQUFnQyxtQ0FBbUMsOEJBQThCO0FBQ2hILGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsVUFBVTtBQUN6QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLHdCQUF3QjtBQUN2QyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsa0JBQWtC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwwQkFBMEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsa0JBQWtCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwQkFBMEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGtCQUFrQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxrQkFBa0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsa0JBQWtCO0FBQy9FO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0JBQWtCLFVBQVUsU0FBUztBQUNuRztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwyQkFBMkI7QUFDNUY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXLFNBQVMsa0RBQWtELGtCQUFrQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQixJQUFJLHdCQUF3QjtBQUNqRTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0EsWUFBWTs7Ozs7Ozs7Ozs7O0FDL1pDO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBVztBQUNyQyxrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQywyRUFBWTs7Ozs7Ozs7Ozs7O0FDZHBCO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixlQUFlLG1CQUFPLENBQUMsK0RBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDJCQUEyQixVQUFVLFNBQVM7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHdCQUF3QjtBQUNsRixxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0EsNkVBQTZFLFNBQVM7QUFDdEY7QUFDQTtBQUNBLHdEQUF3RCx5QkFBeUI7QUFDakY7QUFDQTtBQUNBLHlEQUF5RCx1QkFBdUI7QUFDaEY7QUFDQTtBQUNBLDhEQUE4RCxrQkFBa0I7QUFDaEY7QUFDQTtBQUNBLGdFQUFnRSxrQkFBa0I7QUFDbEY7QUFDQTtBQUNBLGdFQUFnRSxrQkFBa0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywyQkFBMkI7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRixxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0EsMkRBQTJELDBCQUEwQjtBQUNyRjtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQixVQUFVLFNBQVM7QUFDM0Y7QUFDQSxrQkFBa0IsbUJBQW1CLElBQUksd0JBQXdCO0FBQ2pFLHFEQUFxRCxvQ0FBb0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVcsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsU0FBUztBQUMxRjtBQUNBO0FBQ0EsOERBQThELGtCQUFrQjtBQUNoRjtBQUNBO0FBQ0Esb0VBQW9FLDRCQUE0QjtBQUNoRztBQUNBO0FBQ0EsK0RBQStELGtCQUFrQjtBQUNqRjtBQUNBO0FBQ0EsbUJBQW1COzs7Ozs7Ozs7Ozs7QUNqRk47QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLCtEQUFTO0FBQ2hDLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0RBQXdELHdDQUF3QztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0IsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QiwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0Esa0JBQWU7Ozs7Ozs7Ozs7OztBQzFGRjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Ysc0JBQXNCLG1CQUFPLENBQUMsbUZBQWdCO0FBQzlDLDBCQUEwQixtQkFBTyxDQUFDLDJGQUFvQjtBQUN0RCxzQkFBc0IsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLHFFQUFTO0FBQ2hDLHFCQUFxQixtQkFBTyxDQUFDLHdGQUF5QjtBQUN0RDtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsU0FBUztBQUN4QixlQUFlLHlCQUF5QjtBQUN4QyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxpREFBaUQsa0NBQWtDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTs7QUFFeEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxLQUFLO0FBQ25CLHNGQUFzRjtBQUN0RjtBQUNBLElBQUksMkRBQTJELEtBQUssMkRBQTJEO0FBQy9IO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQSxjQUFjLFVBQVU7QUFDeEIsdUhBQXVILGtCQUFrQjtBQUN6STtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUSxxQkFBcUIsMENBQTBDO0FBQ3JGO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxvRkFBb0YsNENBQTRDO0FBQ2hJO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0IsYUFBYTtBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixXQUFXO0FBQzNCLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0IsV0FBVztBQUMzQixnQkFBZ0IsYUFBYTtBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLFdBQVc7QUFDM0IsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsa0RBQWtEO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DLDhCQUE4QjtBQUNqRTtBQUNBLHlFQUF5RSxNQUFNO0FBQy9FO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxTQUFTO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsbUJBQW1CO0FBQ2xDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QjtBQUMvRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsU0FBUztBQUN2RjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFNBQVM7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsU0FBUztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsU0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLHdCQUF3QjtBQUN4QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDRDQUE0QywwQkFBMEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLHdCQUF3QjtBQUN4QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGtDQUFrQywwQkFBMEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSwwREFBMEQsMEJBQTBCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnREFBZ0QsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVMsMEJBQTBCLFFBQVE7QUFDOUQsZ0JBQWdCLHdCQUF3QjtBQUN4QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGtDQUFrQywwQkFBMEI7QUFDNUQ7QUFDQSwrQ0FBK0Msc0NBQXNDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EscURBQXFELHlCQUF5QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsaURBQWlELDBCQUEwQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsMkJBQTJCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxzQ0FBc0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsa0JBQWtCLHlCQUF5QjtBQUMzQyxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsa0JBQWtCLEdBQUc7QUFDckIsa0JBQWtCLGlEQUFpRDtBQUNuRSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsU0FBUztBQUMzQixrQkFBa0IsU0FBUztBQUMzQixrQkFBa0IsU0FBUztBQUMzQixrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixrQkFBa0Isc0JBQXNCO0FBQ3hDLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUIsOERBQThELGdCQUFnQjtBQUMzSTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVLGtEQUFrRCwyQkFBMkI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQSxlQUFlOzs7Ozs7Ozs7Ozs7QUM5d0NGO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixlQUFlLG1CQUFPLENBQUMsK0RBQVM7QUFDaEM7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHdCQUF3QixLQUFLOzs7Ozs7Ozs7Ozs7QUNabkU7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLDJFQUFXO0FBQ3JDLGtCQUFlO0FBQ2YsYUFBYSxtQkFBTyxDQUFDLHlFQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyw2RUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMseUZBQWtCOzs7Ozs7Ozs7Ozs7QUNoQjFCO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDOzs7Ozs7Ozs7Ozs7QUNEaEQ7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLCtDQUFRO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxnRUFBVztBQUNqQyxxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBcUI7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxpQkFBaUI7Ozs7Ozs7Ozs7OztBQ2xGSjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDLGtCQUFlOzs7Ozs7Ozs7Ozs7QUNWRjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEIsR0FBRyxpQ0FBaUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9FQUFvRSxpQ0FBaUMsS0FBSztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMERBQTBELDRCQUE0QixLQUFLOzs7Ozs7Ozs7Ozs7QUNmL0U7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7Ozs7Ozs7Ozs7OztBQ2ZEO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLGtCQUFrQixHQUFHLGlDQUFpQyxHQUFHLDZCQUE2QixHQUFHLHlCQUF5QjtBQUNuTTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvRUFBUTtBQUMvQjtBQUNBO0FBQ0EseURBQXlELCtCQUErQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7Ozs7Ozs7Ozs7OztBQ3RDUDtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsK0NBQVE7QUFDakMsZUFBZSxtQkFBTyxDQUFDLG9FQUFRO0FBQy9CLDJCQUEyQixtQkFBTyxDQUFDLDRGQUFvQjtBQUN2RCwwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBK0I7QUFDakUsYUFBYSxtQkFBTyxDQUFDLCtEQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFFQUFxRTtBQUN2SDtBQUNBLGtEQUFrRCxnRkFBZ0Y7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNDQUFzQyxLQUFLLEdBQUc7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7Ozs7Ozs7Ozs7OztBQ2xNRjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRywrQkFBK0IsR0FBRyw2QkFBNkIsR0FBRywwQkFBMEIsR0FBRywrQkFBK0IsR0FBRyx3QkFBd0I7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELENBQUMsd0NBQXdDLG1CQUFtQixLQUFLOzs7Ozs7Ozs7Ozs7QUN0Q3BEO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLGNBQWMsR0FBRyxrQkFBa0IsR0FBRyxpQkFBaUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOzs7Ozs7Ozs7Ozs7QUMxQlg7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7Ozs7Ozs7Ozs7OztBQ2xERjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2Q0FBNkMsR0FBRyx3QkFBd0IsR0FBRyxrQ0FBa0M7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7Ozs7Ozs7Ozs7O0FDeEJoQztBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsa0JBQWUsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1YyQjtBQUNOO0FBRXpDLElBQUksVUFBVSxDQUFDO0FBRWYsS0FBSyxVQUFVLGVBQWUsQ0FBQyxJQUFVO0lBQ3JDLElBQUksZ0NBQWdDLEdBQUcsTUFBTSxpR0FBMkMsQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO0lBQ3pILElBQUksd0JBQXdCLEdBQUcsZ0NBQWdDLEtBQUssU0FBUyxJQUFJLGdDQUFnQyxDQUFDLE9BQU8sQ0FBQztJQUUxSCxJQUFJLDRCQUE0QixHQUFHLE1BQU0saUdBQTJDLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUM3RyxJQUFJLG9CQUFvQixHQUFHLDRCQUE0QixLQUFLLFNBQVMsSUFBSSw0QkFBNEIsQ0FBQyxPQUFPLENBQUM7SUFFOUcsSUFBRyx3QkFBd0IsSUFBSSxvQkFBb0IsRUFBRTtRQUNqRCxPQUFPLElBQUksQ0FBQztLQUNmO0lBRUQsSUFBSSxhQUFhLEdBQUcsRUFBRSxDQUFDO0lBQ3ZCLElBQUksY0FBYyxHQUFHLEVBQUUsQ0FBQztJQUN4QixJQUFJLFFBQVEsR0FBRyxNQUFNLHNEQUFXLEVBQUUsQ0FBQztJQUNuQyxJQUFJLFdBQVcsR0FBRyxRQUFRLEVBQUUsV0FBVyxFQUFFLFdBQVcsSUFBSSxVQUFVLENBQUM7SUFFbkUsS0FBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDakMsSUFBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxLQUFLLFVBQVUsRUFBRTtZQUNwQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQy9CO2FBQU07WUFDSCxJQUFHLHdCQUF3QixLQUFLLEtBQUssRUFBRTtnQkFDbkMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDdEM7aUJBQU0sSUFBRyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxvQkFBb0IsS0FBSyxLQUFLLEVBQUU7Z0JBQy9HLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3RDO2lCQUFNO2dCQUNILGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDL0I7U0FDSjtLQUNKO0lBRUQsSUFBRyxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUMxQixPQUFPLENBQUMsSUFBSSxDQUFDLDhVQUE4VSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0tBQ2hYO0lBRUQsT0FBTyxhQUFhLENBQUM7QUFDekIsQ0FBQztBQUVELEtBQUssVUFBVSxjQUFjLENBQUMsR0FBVSxFQUFFLFdBQStDLEVBQUUsYUFBc0I7SUFDN0csTUFBTSxPQUFPLEdBQUcsV0FBVyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQ3hFLElBQUcsR0FBRyxLQUFLLFNBQVMsRUFBRTtRQUNsQixPQUFPLEVBQUUsQ0FBQztLQUNiO0lBQ0QsTUFBTSxRQUFRLEdBQUcsTUFBTSxLQUFLLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRTNDLElBQUksSUFBSSxHQUFVLE1BQU0sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO0lBRXhDLFVBQVUsR0FBRyxNQUFNLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUV6QyxJQUFHLGFBQWEsS0FBSyxTQUFTLEVBQUU7UUFDNUIsSUFBSSxjQUFjLEdBQUcsYUFBYSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDL0MsVUFBVSxDQUFDLEdBQUUsRUFBRTtZQUNYLE9BQU8sQ0FBQyxHQUFHLENBQUMsc0RBQXNELENBQUMsQ0FBQztZQUNwRSxVQUFVLEdBQUcsU0FBUyxDQUFDO1FBQzNCLENBQUMsRUFBRSxjQUFjLENBQUMsQ0FBQztLQUN0QjtJQUNELE9BQU8sVUFBVSxDQUFDO0FBQ3RCLENBQUM7QUFFTSxLQUFLLFVBQVUsT0FBTztJQUN6QixPQUFPLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDaEMsSUFBSTtRQUNBLElBQUksUUFBUSxHQUFHLE1BQU0sc0RBQVcsRUFBRSxDQUFDO1FBQ25DLElBQUksSUFBSSxHQUFHLFVBQVUsSUFBSSxNQUFNLGNBQWMsQ0FBQyxRQUFRLEVBQUUsV0FBVyxFQUFFLGFBQWEsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLGdDQUFnQyxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztRQUM1TCxPQUFPLElBQUksQ0FBQztLQUNmO0lBQUMsT0FBTyxHQUFHLEVBQUU7UUFDVixPQUFPLENBQUMsS0FBSyxDQUFDLDhDQUE4QyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ25FLE9BQU8sRUFBRSxDQUFDO0tBQ2I7QUFDTCxDQUFDO0FBRU0sS0FBSyxVQUFVLFlBQVksQ0FBQyxJQUFhO0lBQzVDLElBQUksSUFBSSxHQUFHLE1BQU0sT0FBTyxFQUFFLENBQUM7SUFDM0IsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBQyxFQUFFO1FBQ3BDLElBQUcsS0FBSyxDQUFDLElBQUksS0FBSyxTQUFTLEVBQUU7WUFDekIsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCxLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNqQyxJQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUNqQyxPQUFPLElBQUksQ0FBQzthQUNmO1NBQ0o7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDLENBQUMsQ0FBQztJQUNILE9BQU8sWUFBWSxDQUFDO0FBQ3hCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUY2QztBQUNpQjtBQUNUO0FBQ2I7QUFFbEMsS0FBSyxVQUFVLElBQUk7SUFDdEIsdUdBQXVHO0lBQ3ZHLCtFQUErRTtJQUMvRSxPQUFPLENBQUMsR0FBRyxDQUFDLCtCQUErQixDQUFDLENBQUM7SUFDN0MsSUFBSSxRQUFRLEdBQUcsTUFBTSxzREFBVyxFQUFFLENBQUM7SUFDbkMsSUFBSSxlQUFlLEdBQUcsS0FBSyxDQUFDO0lBQzVCLElBQUksV0FBVyxHQUFHLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxJQUFJLElBQUksQ0FBQztJQUN0RCxJQUFJLFVBQVUsR0FBRyxRQUFRLEVBQUUsU0FBUyxFQUFFLEtBQUssSUFBSSxJQUFJLENBQUM7SUFFcEQsSUFBRyxXQUFXLEVBQUU7UUFDWixNQUFNLGlEQUFjLEVBQUUsQ0FBQztRQUN2QixlQUFlLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLHVEQUF1RDtRQUN2RCxNQUFNLDZDQUFVLEVBQUUsQ0FBQztLQUN0QjtJQUVELElBQUcsVUFBVSxFQUFFO1FBQ1gsTUFBTSw0Q0FBUyxFQUFFLENBQUM7UUFDbEIsSUFBRyxDQUFDLGVBQWUsRUFBRTtZQUNqQixNQUFNLDRDQUFTLEVBQUUsQ0FBQztTQUNyQjtLQUNKO0FBQ0wsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQjhDO0FBRUE7QUFDTjtBQUVsQyxLQUFLLFVBQVUsTUFBTSxDQUFDLFFBQWE7SUFDdEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQ0FBZ0MsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN4RCxJQUFHLFFBQVEsQ0FBQyxZQUFZLEtBQUssVUFBVSxFQUFFO1FBQ3JDLElBQUksUUFBUSxHQUFHLE1BQU0sc0RBQVcsRUFBRSxDQUFDO1FBQ25DLElBQUksV0FBVyxHQUFHLFFBQVEsRUFBRSxXQUFXLEVBQUUsV0FBVyxJQUFJLFVBQVUsQ0FBQztRQUVuRSxJQUFHLFFBQVEsQ0FBQyxJQUFJLEtBQUssU0FBUyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQ3ZFLE9BQU8sQ0FBQyxHQUFHLENBQUMsNkpBQTZKLENBQUMsQ0FBQztZQUMzSyxJQUFJLE9BQU8sR0FBdUMsRUFBRSxDQUFDO1lBQ3JELE9BQU8sQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQztZQUNsQyxPQUFPLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUM7WUFFOUIsTUFBTSxzRkFBZ0MsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNuRDthQUFNO1lBQ0gsT0FBTyxDQUFDLEdBQUcsQ0FBQyx5RkFBeUYsQ0FBQyxDQUFDO1lBQ3ZHLElBQUksT0FBTyxHQUF1QyxFQUFFLENBQUM7WUFDckQsT0FBTyxDQUFDLElBQUksR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDO1lBQ2pDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQztZQUU5QixNQUFNLHNGQUFnQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ25EO0tBQ0o7U0FBTTtRQUNILE1BQU0sNkRBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUM3QjtJQUNELE9BQU8sQ0FBQyxHQUFHLENBQUMscUNBQXFDLENBQUMsQ0FBQztBQUN2RCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzlCOEM7QUFFeEMsS0FBSyxVQUFVLElBQUk7SUFDdEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0lBQ3JDLE1BQU0sdUVBQWlCLENBQUMsRUFDdkIsQ0FBQyxDQUFDO0FBQ1AsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ055UTtBQUNqTztBQUNQO0FBQ2tCO0FBQ25CO0FBRWpDLEtBQUssVUFBVSxVQUFVO0lBQ3JCLElBQUksUUFBUSxHQUFHLE1BQU0sc0RBQVcsRUFBRSxDQUFDO0lBQ25DLElBQUksSUFBSSxHQUFHLE1BQU0sOENBQU8sRUFBRSxDQUFDO0lBRTNCLElBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBQztRQUNuQixJQUFJLE9BQU8sR0FBbUIsRUFBRSxDQUFDO1FBQ2pDLElBQUksYUFBYSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDO1FBRTFELEtBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2pDLElBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsS0FBSyxTQUFTLEVBQUU7Z0JBQ2xDLElBQUksS0FBSyxHQUEyQjtvQkFDaEMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLO29CQUNsQixLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUs7b0JBQ3BCLE9BQU8sRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRSxDQUFDO29CQUNsQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztvQkFDYixXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVc7b0JBQ2hDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXO29CQUNyQyxRQUFRLEVBQUUseUVBQXdCO29CQUNsQyxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVc7aUJBQ3ZDLENBQUM7Z0JBQ0YsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUN2QjtpQkFBTTtnQkFDSCxJQUFJLEtBQUssR0FBc0I7b0JBQzNCLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSztvQkFDbEIsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLO29CQUNwQixPQUFPLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsQ0FBQztvQkFDbEMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7b0JBQ2IsUUFBUSxFQUFFLG9FQUFtQjtpQkFDaEMsQ0FBQztnQkFDRixPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3ZCO1NBQ0o7UUFDRCxPQUFPLE9BQU8sQ0FBQztLQUNsQjtTQUFNO1FBQ0gsT0FBTyxFQUFFLENBQUM7S0FDYjtBQUNMLENBQUM7QUFFTSxLQUFLLFVBQVUsSUFBSTtJQUN0QixPQUFPLENBQUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDcEMsSUFBSSxRQUFRLEdBQUcsTUFBTSxzREFBVyxFQUFFLENBQUM7SUFDbkMsSUFBRyxRQUFRLENBQUMsY0FBYyxLQUFLLFNBQVMsSUFBSSxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksS0FBSyxTQUFTLElBQUksUUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFO1FBQ25JLE9BQU8sQ0FBQyxJQUFJLENBQUMsOExBQThMLENBQUMsQ0FBQztRQUM3TSxPQUFPO0tBQ1Y7SUFDRCxNQUFNLE1BQU0sR0FBRyxRQUFRLEVBQUUsY0FBYyxFQUFFLE1BQU0sSUFBSSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNuRSxJQUFJLGtCQUFrQixHQUF3QixFQUFFLENBQUM7SUFFakQsS0FBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDbkMsSUFBSSxpQkFBaUIsR0FBRyxNQUFNLDhEQUFTLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSw0Q0FBYSxFQUFFLENBQUMsQ0FBQztRQUNuRixrQkFBa0IsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztLQUM5QztJQUVELE1BQU0sY0FBYyxHQUFHLFFBQVEsRUFBRSxjQUFjLEVBQUUsY0FBYyxJQUFJLENBQUMsQ0FBQztJQUNyRSxNQUFNLFlBQVksR0FBRyxRQUFRLEVBQUUsY0FBYyxFQUFFLFlBQVksSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRXpFLE1BQU0sUUFBUSxHQUFtQixLQUFLLEVBQUUsT0FBOEIsRUFBRSxRQUFnQyxFQUFFLEVBQUU7UUFDeEcsdURBQXVEO1FBQ3ZELElBQUksT0FBTyxHQUFHLE1BQU0sVUFBVSxFQUFFLENBQUM7UUFDakMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN4QyxJQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3pCLE9BQU8sRUFBRSxDQUFDO1NBQ2I7UUFFRCxJQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsY0FBYyxFQUFFO1lBQzlCLE9BQU8sT0FBTyxDQUFDO1NBQ2xCO1FBRUQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzFCLElBQUksVUFBVSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQ3hDLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQzdCLElBQUcsSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7b0JBQ2xCLElBQUksV0FBVyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFFakMsSUFBRyxXQUFXLEtBQUssU0FBUyxJQUFJLFdBQVcsS0FBSyxJQUFJLElBQUksT0FBTyxXQUFXLEtBQUssUUFBUSxFQUFFO3dCQUNyRixPQUFPLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7cUJBQ3hEO2lCQUNKO3FCQUFNLElBQUcsSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7b0JBQ3pCLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDNUIsSUFBSSxXQUE4QixDQUFDO29CQUNuQyxJQUFHLE1BQU0sS0FBSyxTQUFTLElBQUksTUFBTSxLQUFLLElBQUksRUFBRTt3QkFDeEMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDakM7b0JBRUQsSUFBRyxXQUFXLEtBQUssU0FBUyxJQUFJLFdBQVcsS0FBSyxJQUFJLElBQUksT0FBTyxXQUFXLEtBQUssUUFBUSxFQUFFO3dCQUNyRixPQUFPLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7cUJBQ3hEO29CQUVELElBQUcsV0FBVyxLQUFLLFNBQVMsSUFBSSxXQUFXLEtBQUssSUFBSSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUU7d0JBQ2hGLElBQUcsV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksT0FBTyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFOzRCQUN0SSxPQUFPLElBQUksQ0FBQzt5QkFDZjs2QkFBTTs0QkFDSCxPQUFPLENBQUMsSUFBSSxDQUFDLCtKQUErSixHQUFHLE1BQU0sQ0FBQyxDQUFDO3lCQUMxTDtxQkFDSjtpQkFDRjtxQkFBTTtvQkFDSCxPQUFPLENBQUMsSUFBSSxDQUFDLDRNQUE0TSxDQUFDLENBQUM7aUJBQzlOO2dCQUNELE9BQU8sS0FBSyxDQUFDO1lBQ25CLENBQUMsQ0FBQyxDQUFDO1lBRUgsT0FBTyxVQUFVLENBQUM7UUFDdEIsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDLENBQUM7SUFFRixNQUFNLFdBQVcsR0FBMkIsS0FBSyxFQUFFLE1BQTZCLEVBQUUsRUFBRTtRQUNoRixJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQzNCLE1BQU0sK0NBQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDN0I7YUFBTztZQUNKLE9BQU8sQ0FBQyxJQUFJLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN0RTtJQUNMLENBQUMsQ0FBQztJQUVGLE1BQU0sY0FBYyxHQUFrQjtRQUNsQyxLQUFLLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxLQUFLO1FBQ3BDLElBQUksRUFBRSxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUk7UUFDbEMsUUFBUSxFQUFFLFFBQVE7UUFDbEIsZ0JBQWdCLEVBQUUsV0FBVztLQUMvQixDQUFDO0lBRUgscUNBQXFDO0lBQ3JDLEtBQUksSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDckQsTUFBTSxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUM7S0FDMUQ7SUFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDdEMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuSThDO0FBRy9DLElBQUksUUFBdUIsQ0FBQztBQUU1QixLQUFLLFVBQVUscUJBQXFCO0lBQ2hDLE1BQU0sR0FBRyxHQUFHLE1BQU0sZ0ZBQTBCLEVBQUUsQ0FBQztJQUMvQyxNQUFNLFFBQVEsR0FBRyxNQUFNLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUV6QyxJQUFJLFFBQVEsQ0FBQyxjQUFjLEtBQUssU0FBUyxFQUFFO1FBQ3pDLFFBQVEsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDO0tBQ3BDO1NBQU07UUFDSCxRQUFRLEdBQUcsRUFBRSxDQUFDO0tBQ2pCO0lBRUQsT0FBTyxRQUFRLENBQUM7QUFDcEIsQ0FBQztBQUVNLEtBQUssVUFBVSxXQUFXO0lBQzdCLElBQUcsUUFBUSxLQUFLLFNBQVMsRUFBRTtRQUN2QixRQUFRLEdBQUcsTUFBTSxxQkFBcUIsRUFBRSxDQUFDO0tBQzVDO0lBQ0QsT0FBTyxRQUFRLENBQUM7QUFDcEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2QitDO0FBV0Q7QUFDYjtBQUNPO0FBT2xDLEtBQUssVUFBVSxJQUFJO0lBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUNBQXVDLENBQUMsQ0FBQztJQUNyRCxJQUFJLFFBQVEsR0FBRyxNQUFNLGdCQUFnQixFQUFFLENBQUM7SUFDeEMsSUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFO1FBQ3JCLElBQUk7WUFDRixNQUFNLG1FQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3BDLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0NBQWtDLENBQUMsQ0FBQztTQUNqRDtRQUFDLE9BQU8sR0FBRyxFQUFFO1lBQ1osT0FBTyxDQUFDLEtBQUssQ0FDWCw4RUFBOEUsRUFDOUUsR0FBRyxDQUNKLENBQUM7U0FDSDtLQUNGO0FBQ0gsQ0FBQztBQUVNLEtBQUssVUFBVSxJQUFJO0lBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUNsQyxPQUFPLCtEQUFlLEVBQUUsQ0FBQztBQUMzQixDQUFDO0FBRU0sS0FBSyxVQUFVLElBQUk7SUFDeEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBQ2pDLE9BQU8sK0RBQWUsRUFBRSxDQUFDO0FBQzNCLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsU0FBUyxLQUFLLENBQUMsS0FBYSxFQUFFLE9BQWlCLEVBQUU7SUFDL0MsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDO0lBQ25CLE1BQU0sV0FBVyxHQUFHLEdBQUcsQ0FBQztJQUN4QixJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQztJQUNuRCxNQUFNLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsT0FBTyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDOUIsQ0FBQztBQUVELFNBQVMsOEJBQThCLENBQUMsTUFBc0I7SUFDNUQsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO0lBQ2hCLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQztJQUU1QixJQUNFLE1BQU0sS0FBSyxTQUFTO1FBQ3BCLE1BQU0sQ0FBQyxrQkFBa0IsS0FBSyxTQUFTO1FBQ3ZDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLEtBQUssU0FBUztRQUMxQyxNQUFNLENBQUMsa0JBQWtCLENBQUMsS0FBSyxLQUFLLFNBQVM7UUFDN0MsQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUMsTUFBTSxLQUFLLFNBQVM7WUFDN0MsTUFBTSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsS0FBSyxTQUFTO1lBQ25ELE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsTUFBTSxLQUFLLFNBQVM7WUFDMUQsTUFBTSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxTQUFTLEtBQUssU0FBUztZQUM3RCxNQUFNLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLFNBQVMsS0FBSyxTQUFTO1lBQzdELE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLEtBQUssU0FBUyxDQUFDLEVBQ3JEO1FBQ0EsT0FBTyxDQUFDLEtBQUssQ0FDWCx5UkFBeVIsQ0FDMVIsQ0FBQztRQUNGLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFFRCxJQUFJLFVBQVUsR0FBRyxDQUFDLEVBQVUsRUFBRSxTQUFpQixFQUFFLE9BQWUsRUFBRSxFQUFFO1FBQ2xFLElBQUksRUFBRSxLQUFLLFNBQVMsRUFBRTtZQUNwQixPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLEdBQUcsT0FBTyxDQUFDLENBQUM7U0FDMUM7YUFBTTtZQUNMLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtnQkFDM0IsZUFBZSxHQUFHLElBQUksQ0FBQztnQkFDdkIsT0FBTyxDQUFDLEtBQUssQ0FDWCxTQUFTO29CQUNQLG1GQUFtRjtvQkFDbkYsRUFBRSxDQUNMLENBQUM7YUFDSDtpQkFBTTtnQkFDTCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ2pCO1NBQ0Y7SUFDSCxDQUFDLENBQUM7SUFFRixJQUFJLGNBQWMsR0FDaEIsa0pBQWtKLENBQUM7SUFFbkosT0FBTyxDQUFDLEdBQUcsQ0FBQywwREFBMEQsQ0FBQyxDQUFDO0lBQzFFLElBQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUM7SUFDdEQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDMUMsVUFBVSxDQUNSLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQ2hCLGdDQUFnQyxHQUFHLENBQUMsR0FBRyxNQUFNLEVBQzdDLGNBQWMsQ0FDZixDQUFDO1FBQ0YsSUFBSSxLQUFLLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUNoQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNyQyxVQUFVLENBQ1IsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFDWCxnQ0FBZ0MsR0FBRyxDQUFDLEdBQUcsVUFBVSxHQUFHLENBQUMsR0FBRyxNQUFNLEVBQzlELGNBQWMsQ0FDZixDQUFDO1NBQ0g7S0FDRjtJQUVELE9BQU8sQ0FBQyxHQUFHLENBQUMsaUVBQWlFLENBQUMsQ0FBQztJQUMvRSxJQUFJLFdBQVcsR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDO0lBRXhELElBQUksV0FBVyxFQUFFLElBQUksRUFBRSxHQUFHLEtBQUssU0FBUyxFQUFFO1FBQ3hDLFVBQVUsQ0FDUixXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQ3ZCLDRDQUE0QyxFQUM1QyxjQUFjLENBQ2YsQ0FBQztLQUNIO0lBRUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvRUFBb0UsQ0FBQyxDQUFDO0lBQ2xGLElBQUksTUFBTSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7SUFFaEMsSUFBSSxNQUFNLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRTtRQUM5QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDNUMsVUFBVSxDQUNSLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUNsQiw4Q0FBOEMsR0FBRyxDQUFDLEdBQUcsTUFBTSxFQUMzRCxjQUFjLENBQ2YsQ0FBQztTQUNIO0tBQ0Y7SUFFRCxPQUFPLENBQUMsR0FBRyxDQUFDLHVFQUF1RSxDQUFDLENBQUM7SUFDckYsSUFBSSxTQUFTLEdBQUcsV0FBVyxDQUFDLFNBQVMsQ0FBQztJQUN0QyxJQUFJLFNBQVMsQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFO1FBQ2pDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMvQyxVQUFVLENBQ1IsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQ3JCLGlEQUFpRCxHQUFHLENBQUMsR0FBRyxNQUFNLEVBQzlELGNBQWMsQ0FDZixDQUFDO1NBQ0g7S0FDRjtJQUVELE9BQU8sQ0FBQyxHQUFHLENBQUMsNkNBQTZDLENBQUMsQ0FBQztJQUMzRCxJQUFJLGVBQWUsRUFBRTtRQUNuQixPQUFPLENBQUMsS0FBSyxDQUNYLCtSQUErUixDQUNoUyxDQUFDO1FBQ0YsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVELEtBQUssVUFBVSxnQkFBZ0I7SUFDN0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO0lBQzNDLElBQUksUUFBUSxHQUFHLE1BQU0sc0RBQVcsRUFBRSxDQUFDO0lBQ25DLElBQUksOEJBQThCLENBQUMsUUFBUSxDQUFDLEVBQUU7UUFDNUMsT0FBTztZQUNMLEVBQUUsRUFBRSxRQUFRLENBQUMsa0JBQWtCLENBQUMsRUFBRTtZQUNsQyxLQUFLLEVBQUUsUUFBUSxDQUFDLGtCQUFrQixDQUFDLEtBQUs7WUFDeEMsYUFBYSxFQUFFLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ3ZDLGNBQWMsRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUN6QyxTQUFTLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDL0IsT0FBTztZQUNQLFNBQVMsRUFBRSwyQ0FBTTtTQUNsQixDQUFDO0tBQ0g7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFFRCxLQUFLLFVBQVUsYUFBYTtJQUcxQixPQUFPLENBQUMsR0FBRyxDQUFDLCtCQUErQixDQUFDLENBQUM7SUFDN0MsTUFBTSwwQkFBMEIsR0FBRyxDQUFDLENBQUM7SUFDckMsTUFBTSxzQkFBc0IsR0FBRyxDQUFDLENBQUM7SUFDakMsSUFBSSxRQUFRLEdBQUcsTUFBTSxzREFBVyxFQUFFLENBQUM7SUFDbkMsSUFBSSxrQkFBa0IsR0FHbEIsRUFBRSxDQUFDO0lBRVAsSUFBSSxRQUFRLEVBQUUsa0JBQWtCLEVBQUUsVUFBVSxLQUFLLFNBQVMsRUFBRTtRQUMxRCxPQUFPLEVBQUUsQ0FBQztLQUNYO0lBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RFLElBQUksa0JBQWtCLENBQUMsTUFBTSxLQUFLLHNCQUFzQixFQUFFO1lBQ3hELE9BQU8sQ0FBQyxHQUFHLENBQ1QsNkZBQTZGLENBQzlGLENBQUM7WUFDRixNQUFNO1NBQ1A7UUFDRCxJQUFJLGlCQUFpQixHQUFnQztZQUNuRCxFQUFFLEVBQ0EsUUFBUSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUM1QyxLQUFLLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFDeEQsS0FBSyxFQUFFLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSztZQUN0RCxLQUFLLEVBQUUsQ0FBQyxNQUFNLGtCQUFrQixDQUM5QixRQUFRLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFDL0MsMEJBQTBCLENBQzNCLENBTUE7U0FDRixDQUFDO1FBQ0Ysa0JBQWtCLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7S0FDNUM7SUFFRCxPQUFPLGtCQUFrQixDQUFDO0FBQzVCLENBQUM7QUFFRCxLQUFLLFVBQVUsY0FBYztJQUMzQixPQUFPLENBQUMsR0FBRyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7SUFDL0MsSUFBSSxXQUFXLEdBQTBCO1FBQ3ZDLE1BQU0sRUFBRSxJQUFJO1FBQ1osU0FBUyxFQUFFLElBQUk7UUFDZixTQUFTLEVBQUUsSUFBSTtLQUNoQixDQUFDO0lBRUYsSUFBSSxRQUFRLEdBQUcsTUFBTSxzREFBVyxFQUFFLENBQUM7SUFDbkMsTUFBTSw4Q0FBOEMsR0FBRyxDQUFDLENBQUM7SUFDekQsTUFBTSwyQ0FBMkMsR0FBRyxDQUFDLENBQUM7SUFDdEQsTUFBTSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7SUFFNUIsSUFBSSxRQUFRLEVBQUUsa0JBQWtCLEVBQUUsV0FBVyxFQUFFLElBQUksS0FBSyxTQUFTLEVBQUU7UUFDakUsSUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7UUFDeEQsSUFBSSxHQUFHLEdBQUcsTUFBTSxpQkFBaUIsQ0FDL0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQ1gsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQ2QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQ2QsQ0FBQztRQUNGLFdBQVcsQ0FBQyxJQUFJLEdBQUc7WUFDakIsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO1lBQ2pCLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztZQUNqQixXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7WUFDN0IsR0FBRztTQUNKLENBQUM7S0FDSDtJQUVELElBQUksUUFBUSxFQUFFLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxNQUFNLEtBQUssU0FBUyxFQUFFO1FBQ25FLFdBQVcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxpQkFBaUIsQ0FDMUMsUUFBUSxFQUFFLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQ2pELDJDQUEyQyxDQUM1QyxDQUFDO0tBQ0g7U0FBTTtRQUNMLE9BQU8sQ0FBQyxLQUFLLENBQUMseURBQXlELENBQUMsQ0FBQztLQUMxRTtJQUVELElBQUksUUFBUSxFQUFFLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxTQUFTLEtBQUssU0FBUyxFQUFFO1FBQ3RFLElBQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDO1FBQ2xFLElBQUksYUFBYSxHQUFHLE1BQU0sbURBQVksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkQsSUFBSSxhQUFhLENBQUMsTUFBTSxHQUFHLGlCQUFpQixFQUFFO1lBQzVDLE9BQU8sQ0FBQyxJQUFJLENBQ1Ysa0JBQ0UsYUFBYSxDQUFDLE1BQ2hCLHlEQUF5RCxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FDMUUsR0FBRyxDQUNKLFVBQVUsaUJBQWlCLGlCQUFpQixDQUM5QyxDQUFDO1NBQ0g7UUFDRCxJQUFJLHNCQUFzQixHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLGlCQUFpQixDQU9wRSxDQUFDO1FBQ0YsV0FBVyxDQUFDLFNBQVMsR0FBRztZQUN0QixLQUFLLEVBQUUsU0FBUyxDQUFDLEtBQUs7WUFDdEIsSUFBSSxFQUFFLHNCQUFzQjtTQUM3QixDQUFDO0tBQ0g7U0FBTTtRQUNMLE9BQU8sQ0FBQyxLQUFLLENBQUMsNERBQTRELENBQUMsQ0FBQztLQUM3RTtJQUVELElBQUksUUFBUSxFQUFFLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxTQUFTLEtBQUssU0FBUyxFQUFFO1FBQ3RFLFdBQVcsQ0FBQyxTQUFTLEdBQUcsTUFBTSxpQkFBaUIsQ0FDN0MsUUFBUSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQ2pELDhDQUE4QyxDQUMvQyxDQUFDO0tBQ0g7U0FBTTtRQUNMLE9BQU8sQ0FBQyxLQUFLLENBQUMsNERBQTRELENBQUMsQ0FBQztLQUM3RTtJQUVELE9BQU8sV0FBVyxDQUFDO0FBQ3JCLENBQUM7QUFFRCxLQUFLLFVBQVUsU0FBUztJQUN0QixPQUFPLENBQUMsR0FBRyxDQUFDLDJCQUEyQixDQUFDLENBQUM7SUFDekMsSUFBSSxRQUFRLEdBQUcsTUFBTSxzREFBVyxFQUFFLENBQUM7SUFDbkMsSUFBSSxRQUFRLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxLQUFLLFNBQVMsRUFBRTtRQUN0RCxPQUFPLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUM7S0FDM0M7U0FBTTtRQUNMLE9BQU8sQ0FBQyxLQUFLLENBQ1gsOERBQThELENBQy9ELENBQUM7UUFDRixPQUFPLElBQUksQ0FBQztLQUNiO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsS0FBSyxVQUFVLGlCQUFpQixDQUM5QixFQUFVLEVBQ1YsS0FBYSxFQUNiLElBQWM7SUFFZCxJQUFJLGNBQWMsR0FBNkI7UUFDN0MsRUFBRSxFQUFFLEVBQUUsSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQztRQUM1QixLQUFLO1FBQ0wsVUFBVSxFQUFFLFNBQXVDO1FBQ25ELFlBQVksRUFBRTtZQUNaLElBQUksRUFBRSxFQUFFO1NBQ1Q7S0FDRixDQUFDO0lBRUYsSUFBSSxJQUFJLEdBQUcsTUFBTSxtREFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXBDLElBQUksSUFBSSxLQUFLLFNBQVMsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN6QyxjQUFjLENBQUMsWUFBWSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7S0FDekM7SUFFRCxPQUFPLGNBQWMsQ0FBQztBQUN4QixDQUFDO0FBRUQsS0FBSyxVQUFVLGtCQUFrQixDQUMvQixLQUF5QyxFQUN6QyxLQUFhO0lBRWIsSUFBSSxlQUFlLEdBQStCLEVBQUUsQ0FBQztJQUVyRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNyQyxJQUFJLGNBQWMsR0FBRyxNQUFNLGlCQUFpQixDQUMxQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUNYLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQ2QsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDZCxDQUFDO1FBQ0YsZUFBZSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUN0QztJQUVELElBQUksZUFBZSxDQUFDLE1BQU0sR0FBRyxLQUFLLEVBQUU7UUFDbEMsT0FBTyxDQUFDLElBQUksQ0FDVixnREFBZ0QsZUFBZSxDQUFDLE1BQU0seUJBQXlCLEtBQUssbUNBQW1DLEtBQUssRUFBRSxDQUMvSSxDQUFDO0tBQ0g7SUFDRCxPQUFPLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRCxLQUFLLFVBQVUsaUJBQWlCLENBQzlCLFVBQTRDLEVBQzVDLEtBQWE7SUFFYixJQUFJLEtBQUssR0FBdUMsRUFBRSxDQUFDO0lBRW5ELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNoRCxJQUFJLGNBQWMsR0FBRyxNQUFNLGlCQUFpQixDQUMxQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFDdEIsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQ3pCLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUN6QixDQUFDO1FBQ0YsSUFBSSxJQUFJLEdBQXFDO1lBQzNDLFdBQVcsRUFBRSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVc7WUFDNUMsS0FBSyxFQUFFLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSztZQUNoQyxHQUFHLGNBQWM7U0FDbEIsQ0FBQztRQUNGLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDbEI7SUFFRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSyxFQUFFO1FBQ3hCLE9BQU8sQ0FBQyxJQUFJLENBQ1YsbUVBQW1FLEtBQUssQ0FBQyxNQUFNLHFDQUFxQyxLQUFLLHNCQUFzQixLQUFLLG9CQUFvQixDQUN6SyxDQUFDO0tBQ0g7SUFFRCxJQUFJLHVCQUF1QixHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBUSxDQUFDO0lBRTNELE9BQU87UUFDTCxLQUFLLEVBQUUsVUFBVSxDQUFDLEtBQUs7UUFDdkIsS0FBSyxFQUFFLHVCQUF1QjtLQUMvQixDQUFDO0FBQ0osQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM1o4QztBQUUvQyxTQUFTLFlBQVk7SUFDbkIsSUFBSSxRQUFRLEdBQUcsMkVBQXFCLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUNyRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBRUQsS0FBSyxVQUFVLGtCQUFrQjtJQUMvQixPQUFPLFlBQVksRUFBRSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNoRCxDQUFDO0FBRUQsS0FBSyxVQUFVLHNCQUFzQjtJQUNqQyxPQUFPLENBQUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDcEMsT0FBTywrRUFBeUIsQ0FDNUIsOEJBQThCLENBQ2pDLENBQUM7QUFDTixDQUFDO0FBRU0sS0FBSyxVQUFVLEtBQUs7SUFDekIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQ3ZDLElBQUksTUFBTSxrQkFBa0IsRUFBRSxFQUFFO1FBQzlCLE9BQU8sQ0FBQyxHQUFHLENBQUMsNENBQTRDLENBQUMsQ0FBQztRQUMxRCxPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsT0FBTyxJQUFJLE9BQU8sQ0FBVSxLQUFLLEVBQUUsT0FBTyxFQUFFLEVBQUU7UUFDNUMsWUFBWSxFQUFFLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ2pELE9BQU8sQ0FBQyxHQUFHLENBQUMseUNBQXlDLENBQUMsQ0FBQztZQUN2RCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEIsQ0FBQyxDQUFDLENBQUM7UUFDSCxNQUFNLHNCQUFzQixFQUFFLENBQUM7UUFDL0Isa0JBQWtCLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxFQUFFO1lBQzVDLElBQUksU0FBUyxFQUFFO2dCQUNiLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0RBQWdELEdBQUcsU0FBUyxDQUFDLENBQUM7Z0JBQzFFLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNwQjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRU0sTUFBTSxJQUFJLEdBQUcsaUJBQWlCLENBQUM7Ozs7Ozs7VUN4Q3RDO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7Ozs7Ozs7Ozs7Ozs7QUNMd0Q7QUFDTDtBQUNKO0FBRS9DLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsRUFBRSxLQUFLLElBQUksRUFBRTtJQUNyRCxJQUFJLFFBQVEsR0FBRyxpRkFBMkIsRUFBRSxDQUFDO0lBQzdDLFFBQVEsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsb0RBQWMsQ0FBQyxTQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzFELE1BQU0sK0NBQWtCLEVBQUUsQ0FBQztBQUM3QixDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9Ab3BlbmZpbi9zZWFyY2gtYXBpL2luZGV4LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9Ab3BlbmZpbi93b3Jrc3BhY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL2FwcGxpY2F0aW9uL0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL2FwcGxpY2F0aW9uL0luc3RhbmNlLmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9hcHBsaWNhdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvYmFzZS5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvY2xpcGJvYXJkL2luZGV4LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9ldmVudHMvZW1pdHRlck1hcC5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvZXZlbnRzL2V2ZW50QWdncmVnYXRvci5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvZXh0ZXJuYWwtYXBwbGljYXRpb24vRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvZXh0ZXJuYWwtYXBwbGljYXRpb24vSW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL2V4dGVybmFsLWFwcGxpY2F0aW9uL2luZGV4LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9leHRlcm5hbC13aW5kb3cvRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvZXh0ZXJuYWwtd2luZG93L0luc3RhbmNlLmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9leHRlcm5hbC13aW5kb3cvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL2Zpbi5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvZnJhbWUvRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvZnJhbWUvSW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL2ZyYW1lL2luZGV4LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9nbG9iYWwtaG90a2V5L2luZGV4LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9pbnRlcmFwcGJ1cy9jaGFubmVsL2NoYW5uZWwuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL2ludGVyYXBwYnVzL2NoYW5uZWwvY2xpZW50LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9pbnRlcmFwcGJ1cy9jaGFubmVsL2luZGV4LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9pbnRlcmFwcGJ1cy9jaGFubmVsL3Byb3ZpZGVyLmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9pbnRlcmFwcGJ1cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvaW50ZXJvcC9GYWN0b3J5LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9pbnRlcm9wL0ludGVyb3BCcm9rZXIuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL2ludGVyb3AvSW50ZXJvcENsaWVudC5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvaW50ZXJvcC9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvaW50ZXJvcC91dGlscy5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvbWUuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL25vdGlmaWNhdGlvbi9GYWN0b3J5LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9ub3RpZmljYXRpb24vSW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL25vdGlmaWNhdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvbm90aWZpY2F0aW9uL3NoYXBlcy5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvcGxhdGZvcm0vRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvcGxhdGZvcm0vSW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL3BsYXRmb3JtL2NvbW1vbi11dGlscy5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvcGxhdGZvcm0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL3BsYXRmb3JtL2xheW91dC9GYWN0b3J5LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9wbGF0Zm9ybS9sYXlvdXQvSW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL3BsYXRmb3JtL2xheW91dC9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvcGxhdGZvcm0vbGF5b3V0L3NoYXBlcy5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvc25hcHNob3Qtc291cmNlL0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL3NuYXBzaG90LXNvdXJjZS9JbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvc25hcHNob3Qtc291cmNlL2luZGV4LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS9zbmFwc2hvdC1zb3VyY2UvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL3N5c3RlbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvdmlldy9GYWN0b3J5LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS92aWV3L0luc3RhbmNlLmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS92aWV3L2luZGV4LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS93ZWJjb250ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvd2luZG93L0ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL3dpbmRvdy9JbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9hcGkvd2luZG93L2JvdW5kcy1jaGFuZ2VkLmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL2FwaS93aW5kb3cvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvYXBpL3dpbmRvdy9zaGFwZXMuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvbW9jay5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9zaGFwZXMvRW50aXR5VHlwZS5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy9zaGFwZXMvUGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvdHJhbnNwb3J0L2Zpbl9zdG9yZS5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy90cmFuc3BvcnQvdHJhbnNwb3J0LWVycm9ycy5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy90cmFuc3BvcnQvdHJhbnNwb3J0LmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL3RyYW5zcG9ydC93aXJlLmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL3V0aWwvcHJvbWlzZXMuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vbm9kZV9tb2R1bGVzL29wZW5maW4tYWRhcHRlci9zcmMvdXRpbC9yZWYtY291bnRlci5qcyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9ub2RlX21vZHVsZXMvb3BlbmZpbi1hZGFwdGVyL3NyYy91dGlsL3J1bnRpbWVWZXJzaW9uaW5nLmpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL25vZGVfbW9kdWxlcy9vcGVuZmluLWFkYXB0ZXIvc3JjL3V0aWwvdmFsaWRhdGUuanMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vY2xpZW50L3NyYy9hcHBzLnRzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL2NsaWVudC9zcmMvYm9vdHN0cmFwcGVyLnRzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL2NsaWVudC9zcmMvbGF1bmNoLnRzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL2NsaWVudC9zcmMvcGxhdGZvcm0udHMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vY2xpZW50L3NyYy9zZWFyY2gudHMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250Ly4vY2xpZW50L3NyYy9zZXR0aW5ncy50cyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9jbGllbnQvc3JjL3N0b3JlLnRzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC8uL2NsaWVudC9zcmMvd29ya3NwYWNlLnRzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS1hZGQtYXBwbGljYXRpb24tdG8tc3RvcmVmcm9udC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLWFkZC1hcHBsaWNhdGlvbi10by1zdG9yZWZyb250L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0tYWRkLWFwcGxpY2F0aW9uLXRvLXN0b3JlZnJvbnQvLi9jbGllbnQvc3JjL3Byb3ZpZGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXtkOih0LG4pPT57Zm9yKHZhciByIGluIG4pZS5vKG4scikmJiFlLm8odCxyKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQscix7ZW51bWVyYWJsZTohMCxnZXQ6bltyXX0pfSxvOihlLHQpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSxyOmU9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfX0sdD17fTtlLnIodCksZS5kKHQse1RlbXBsYXRlTmFtZXM6KCk9PmVlLGNyZWF0ZTooKT0+U2UsZGVmYXVsdFRvcGljOigpPT5CZSxzdWJzY3JpYmU6KCk9PkNlfSk7dmFyIG49e307ZS5yKG4pLGUuZChuLHtzdWJzY3JpYmU6KCk9Pkt9KTt2YXIgcj17fTtlLnIociksZS5kKHIse2NyZWF0ZTooKT0+UmV9KTtjb25zdCBvPVwiZGVyZWdpc3RlcmVkIG9yIGRvZXMgbm90IGV4aXN0XCIscz1uZXcgRXJyb3IoYHByb3ZpZGVyICR7b31gKSxpPW5ldyBFcnJvcihcInByb3ZpZGVyIHdpdGggbmFtZSBhbHJlYWR5IGV4aXN0c1wiKSxjPW5ldyBFcnJvcihcImJhZCBwYXlsb2FkXCIpLHU9bmV3IEVycm9yKFwic3Vic2NyaXB0aW9uIHJlamVjdGVkXCIpLGE9bmV3IEVycm9yKGBjaGFubmVsICR7b31gKSxsPW5ldyBNYXA7ZnVuY3Rpb24gZChlKXtjb25zdCB0PWYoZSk7aWYodClyZXR1cm4gdDt0aHJvdyBhfWZ1bmN0aW9uIGYoZSl7Y29uc3QgdD1sLmdldChlKTtpZih0KXJldHVybiB0fWZ1bmN0aW9uIHAoZSx0KXtsLnNldChlLHQpfXZhciBnOyFmdW5jdGlvbihlKXtlW2UuSW5pdGlhbD0wXT1cIkluaXRpYWxcIixlW2UuT3Blbj0xXT1cIk9wZW5cIixlW2UuQ2xvc2U9Ml09XCJDbG9zZVwifShnfHwoZz17fSkpO2NvbnN0IGg9XCJhbGxcIix2PVwiMFwiLHk9XCI1XCIsdz1cIjZcIixtPSgpPT57fTtmdW5jdGlvbiBiKGUsdCl7cmV0dXJuYCR7ZX0tJHt0fWB9ZnVuY3Rpb24gUihlKXtyZXR1cm5gX19zZWFyY2gtJHtlfS10b3BpY19fYH1jb25zdCBTPW5ldyBNYXA7ZnVuY3Rpb24gQyhlLHQpe1MuaGFzKGUpfHxTLnNldChlLG5ldyBNYXApLFMuZ2V0KGUpLnNldCh0Lm5hbWUsdCl9ZnVuY3Rpb24gQihlLHQpe2NvbnN0IG49Uy5nZXQoZSk7biYmbi5kZWxldGUodCl9ZnVuY3Rpb24gayhlKXtyZXR1cm4gUy5nZXQoZSk/Wy4uLlMuZ2V0KGUpLnZhbHVlcygpXTpbXX1mdW5jdGlvbiAkKGUpe2NvbnN0IHQ9Uy5nZXQoZSk7dCYmdC5jbGVhcigpfWZ1bmN0aW9uIFAoZSx0KXtjb25zdCBuPVMuZ2V0KGUpO3JldHVybiBuP24uZ2V0KHQpOm51bGx9ZnVuY3Rpb24gSShlLHQsbil7dmFyIHI7bGV0IG89bjtpZighbyYmKG51bGw9PT0ocj1lLmFjdGlvbnMpfHx2b2lkIDA9PT1yP3ZvaWQgMDpyLmxlbmd0aCkpe2NvbnN0IHQ9ZS5hY3Rpb25zWzBdO289XCJzdHJpbmdcIiE9dHlwZW9mIHQ/bnVsbD09dD92b2lkIDA6dC5uYW1lOnR9cmV0dXJuey4uLmUsYWN0aW9uOm8sZGlzcGF0Y2hlcklkZW50aXR5OnR9fWZ1bmN0aW9uIE8oZSx0LG49XCJhc2NlbmRpbmdcIil7Y29uc3Qgcj1lfHxbXTtpZighKG51bGw9PXQ/dm9pZCAwOnQubGVuZ3RoKSlyZXR1cm4gcjtjb25zdCBvPVtdLHM9bmV3IE1hcDt0LmZvckVhY2goKGU9PntpZihlLmtleSlyZXR1cm4gcy5zZXQoZS5rZXksZSk7by5wdXNoKGUpfSkpO2xldCBpPXIubWFwKChlPT57Y29uc3R7a2V5OnR9PWU7aWYodCYmcy5oYXModCkpe2NvbnN0IGU9cy5nZXQodCk7cmV0dXJuIHMuZGVsZXRlKHQpLGV9cmV0dXJuIGV9KSk7cmV0dXJuIGkucHVzaCguLi5zLnZhbHVlcygpLC4uLm8pLGk9XCJhc2NlbmRpbmdcIj09PW4/aS5zb3J0KCgoZSx0KT0+KG51bGwhPT1lLnNjb3JlJiZ2b2lkIDAhPT1lLnNjb3JlP2Uuc2NvcmU6MS8wKS0obnVsbCE9PXQuc2NvcmUmJnZvaWQgMCE9PXQuc2NvcmU/dC5zY29yZToxLzApKSk6aS5zb3J0KCgoZSx0KT0+KG51bGwhPT10LnNjb3JlJiZ2b2lkIDAhPT10LnNjb3JlP3Quc2NvcmU6MS8wKS0obnVsbCE9PWUuc2NvcmUmJnZvaWQgMCE9PWUuc2NvcmU/ZS5zY29yZToxLzApKSksaX1mdW5jdGlvbiBNKGUpe2NvbnN0IHQ9e307bGV0IG49W10scj1bXSxvPWcuSW5pdGlhbDt0LmdldFN0YXR1cz0oKT0+byx0LmdldFJlc3VsdEJ1ZmZlcj0oKT0+bix0LnNldFJlc3VsdEJ1ZmZlcj1lPT57bj1lLChudWxsPT1uP3ZvaWQgMDpuLmxlbmd0aCkmJnQub25DaGFuZ2UoKX0sdC5nZXRSZXZva2VkQnVmZmVyPSgpPT5yLHQuc2V0UmV2b2tlZEJ1ZmZlcj1lPT57cj1lLChudWxsPT1yP3ZvaWQgMDpyLmxlbmd0aCkmJnQub25DaGFuZ2UoKX0sdC5vbkNoYW5nZT1tO2NvbnN0IHM9e307cmV0dXJuIHQucmVzPXMscy5jbG9zZT0oKT0+e28hPT1nLkNsb3NlJiYobz1nLkNsb3NlLHQub25DaGFuZ2UoKSl9LHMub3Blbj0oKT0+e28hPT1nLk9wZW4mJihvPWcuT3Blbix0Lm9uQ2hhbmdlKCkpfSxzLnJlc3BvbmQ9bj0+e2NvbnN0IHI9Tyh0LmdldFJlc3VsdEJ1ZmZlcigpLG4sZSk7dC5zZXRSZXN1bHRCdWZmZXIocil9LHMucmV2b2tlPSguLi5lKT0+e2NvbnN0IG49bmV3IFNldChlKSxyPXQuZ2V0UmVzdWx0QnVmZmVyKCkuZmlsdGVyKCgoe2tleTplfSk9Pntjb25zdCB0PW4uaGFzKGUpO3JldHVybiB0JiZuLmRlbGV0ZShlKSwhdH0pKTt0LnNldFJlc3VsdEJ1ZmZlcihyKSxuLnNpemUmJih0LmdldFJldm9rZWRCdWZmZXIoKS5mb3JFYWNoKChlPT5uLmFkZChlKSkpLHQuc2V0UmV2b2tlZEJ1ZmZlcihbLi4ubl0pKX0sdH1mdW5jdGlvbiBOKGUsdCl7Y29uc3Qgbj1uZXcgU2V0O2xldCByPSExO3JldHVybntjbG9zZTooKT0+e3I9ITA7Zm9yKGNvbnN0IGUgb2YgbillKCl9LHJlcTp7aWQ6ZSwuLi50LG9uQ2xvc2U6ZT0+e24uYWRkKGUpLHImJmUoKX0scmVtb3ZlTGlzdGVuZXI6ZT0+e24uZGVsZXRlKGUpfX19fWZ1bmN0aW9uIEUoKXtyZXR1cm57bmFtZTpmaW4ubWUubmFtZSx1dWlkOmZpbi5tZS51dWlkfX1mdW5jdGlvbiB4KCl7bGV0IGU7dHJ5e2NvbnN0IHQ9ZmluLlBsYXRmb3JtLmdldEN1cnJlbnRTeW5jKCk7aWYoIShudWxsPT10P3ZvaWQgMDp0LmlkZW50aXR5KSlyZXR1cm47ZT10LmlkZW50aXR5LnV1aWR9Y2F0Y2goZSl7fXJldHVybiBlfWZ1bmN0aW9uIFQoZSl7Y29uc29sZS5lcnJvcihcIk9wZW5GaW4gU2VhcmNoIEFQSTogXCIsZSl9Y29uc3QgRj1uZXcgTWFwO2Z1bmN0aW9uIHEoZSl7Ri5oYXMoZSl8fEYuc2V0KGUsbmV3IE1hcCk7Y29uc3QgdD1GLmdldChlKTtyZXR1cm57Z2V0UmVxdWVzdHNGb3JJZGVudGl0eTplPT57Y29uc3Qgbj1mdW5jdGlvbihlKXtyZXR1cm5gJHtlLnV1aWR9OiR7ZS5uYW1lfWB9KGUpO3JldHVybiB0LmhhcyhuKXx8dC5zZXQobixuZXcgTWFwKSx0LmdldChuKX19fWZ1bmN0aW9uIEQoZSx0KXtyZXR1cm4gZChlKS5kaXNwYXRjaCh2LHQpfWZ1bmN0aW9uIEwoZSl7Y29uc3QgdD1QLmJpbmQobnVsbCxlKSxuPXEoZSkscj1ELmJpbmQobnVsbCxlKTtyZXR1cm4gYXN5bmMoZSxvKT0+e2lmKCFlfHwhZS5pZHx8IWUucHJvdmlkZXJOYW1lKXtjb25zdCBlPWM7cmV0dXJuIFQoZSkse2Vycm9yOmUubWVzc2FnZX19Y29uc3R7aWQ6aSxwcm92aWRlck5hbWU6dX09ZSxhPXQodSk7aWYoIWEpe2NvbnN0IGU9cztyZXR1cm4gVChlKSx7ZXJyb3I6ZS5tZXNzYWdlfX1jb25zdCBsPW4uZ2V0UmVxdWVzdHNGb3JJZGVudGl0eShvKTtsZXQgZD1sLmdldChlLmlkKTtkfHwoZD1OKGksZSksbC5zZXQoZS5pZCxkKSk7Y29uc3QgZj1NKCkscD0oKT0+e2NvbnN0IGU9Zi5nZXRSZXN1bHRCdWZmZXIoKTtmLnNldFJlc3VsdEJ1ZmZlcihbXSk7Y29uc3QgdD1mLmdldFJldm9rZWRCdWZmZXIoKTtmLnNldFJldm9rZWRCdWZmZXIoW10pO2NvbnN0IG49Zi5nZXRTdGF0dXMoKTtyKHtpZDppLHByb3ZpZGVyTmFtZTp1LHJlc3VsdHM6ZSxyZXZva2VkOnQsc3RhdHVzOm59KX07bGV0IGc9ITAsaD0hMTtmLm9uQ2hhbmdlPSgpPT57aWYoZylyZXR1cm4gZz0hMSx2b2lkIHAoKTtofHwoaD0hMCxzZXRUaW1lb3V0KCgoKT0+e2g9ITEscCgpfSksMTAwKSl9O3RyeXtjb25zdCBlPWF3YWl0IGEub25TZWFyY2goZC5yZXEsZi5yZXMpLHQ9Zi5nZXRTdGF0dXMoKTtyZXR1cm57aWQ6aSxwcm92aWRlck5hbWU6dSxzdGF0dXM6dCxyZXN1bHRzOmV9fWNhdGNoKGUpe3JldHVybiBUKGUpLHtpZDppLHByb3ZpZGVyTmFtZTp1LGVycm9yOmUubWVzc2FnZX19fX1hc3luYyBmdW5jdGlvbiBfKGUsdCl7Y29uc3Qgbj1kKGUpLHI9RSgpLG89e2lkZW50aXR5OnIsLi4udCxvblNlYXJjaDp2b2lkIDAsb25SZXN1bHREaXNwYXRjaDp2b2lkIDB9O2F3YWl0IG4uZGlzcGF0Y2goXCIyXCIsbyksQyhlLHtpZGVudGl0eTpyLC4uLnR9KX1hc3luYyBmdW5jdGlvbiBqKGUsdCl7Y29uc3Qgbj1kKGUpO3JldHVybiBhd2FpdCBuLmRpc3BhdGNoKFwiM1wiLHQpLEIoZSx0KX1hc3luYyBmdW5jdGlvbiBBKGUsdCxuLHIpe2NvbnN0IG89SShuLEUoKSxyKSxzPVAoZSx0KTtpZihzKXtjb25zdHtvblJlc3VsdERpc3BhdGNoOmV9PXM7aWYoIWUpcmV0dXJuO3JldHVybiBlKG8pfWNvbnN0IGk9e3Byb3ZpZGVyTmFtZTp0LHJlc3VsdDpvfTtyZXR1cm4gZChlKS5kaXNwYXRjaCh5LGkpfWFzeW5jIGZ1bmN0aW9uIHooZSx0KXtjb25zdCBuPXsuLi50fTtsZXQgcjtyZXR1cm4gcj1hc3luYyBmdW5jdGlvbiooZSx0LHtzZXRTdGF0ZTpufSl7Y29uc3Qgcj1kKGUpO2Zvcig7Oyl7Y29uc3QgZT1hd2FpdCByLmRpc3BhdGNoKFwiMVwiLHQpLG89ZS5lcnJvcjtpZihvKXRocm93IG5ldyBFcnJvcihvKTtjb25zdCBzPWU7aWYodC5pZD1zLmlkLG4ocy5zdGF0ZSkscy5kb25lKXJldHVybiBzLnZhbHVlO3lpZWxkIHMudmFsdWV9fShlLG4se3NldFN0YXRlOmU9PntyLnN0YXRlPWV9fSksYXdhaXQgci5uZXh0KCksci5pZD1uLmlkLHIuY2xvc2U9KCk9PnshZnVuY3Rpb24oZSx0KXtkKGUpLmRpc3BhdGNoKHcse2lkOnR9KX0oZSxyLmlkKX0scn1hc3luYyBmdW5jdGlvbiBHKGUpe3JldHVybiBkKGUpLmRpc3BhdGNoKFwiNFwiLG51bGwpfWFzeW5jIGZ1bmN0aW9uIEgoZSl7Y29uc3QgdD1kKGUpOyFmdW5jdGlvbihlKXtsLmRlbGV0ZShlKX0oZSksJChlKSxhd2FpdCB0LmRpc2Nvbm5lY3QoKX1hc3luYyBmdW5jdGlvbiBKKGUpe2NvbnN0IHQ9UihlKSxuPWF3YWl0IGFzeW5jIGZ1bmN0aW9uKGUpe2xldCB0PSExO2ZvcihsZXQgbj0wO248MTA7bisrKXRyeXtjb25zdCBuPWF3YWl0IFByb21pc2UucmFjZShbZmluLkludGVyQXBwbGljYXRpb25CdXMuQ2hhbm5lbC5jb25uZWN0KGUpLG5ldyBQcm9taXNlKCgoZSxuKT0+c2V0VGltZW91dCgoKCk9Pnt0fHxuKGEpfSksMmUzKSkpXSk7cmV0dXJuIHQ9ITAsbn1jYXRjaChlKXtpZig5PT09bil0aHJvdyBlfX0odCk7dmFyIHI7cmV0dXJuIG4ucmVnaXN0ZXIodixMKGUpKSxuLnJlZ2lzdGVyKHcsZnVuY3Rpb24oZSl7Y29uc3QgdD1xKGUpO3JldHVybihlLG4pPT57Y29uc3Qgcj10LmdldFJlcXVlc3RzRm9ySWRlbnRpdHkobiksbz1yLmdldChlLmlkKTtvJiYoby5jbG9zZSgpLHIuZGVsZXRlKGUuaWQpKX19KGUpKSxuLnJlZ2lzdGVyKHksKHI9ZSxhc3luYyhlLHQpPT57aWYoIWV8fCFlLnByb3ZpZGVyTmFtZXx8IWUucmVzdWx0KXJldHVybiB2b2lkIFQoYyk7Y29uc3Qgbj1QKHIsZS5wcm92aWRlck5hbWUpO2lmKCFuKXJldHVybiB2b2lkIFQocyk7Y29uc3R7b25SZXN1bHREaXNwYXRjaDpvfT1uO3JldHVybiBvPyhlLnJlc3VsdC5kaXNwYXRjaGVySWRlbnRpdHk9dCxvKGUucmVzdWx0KSk6dm9pZCAwfSkpLG4ub25EaXNjb25uZWN0aW9uKGZ1bmN0aW9uKGUpe2NvbnN0IHQ9cShlKTtyZXR1cm4gYXN5bmMgbj0+e2lmKCFmKGUpKXJldHVybjtjb25zdCByPXQuZ2V0UmVxdWVzdHNGb3JJZGVudGl0eShuKTtmb3IoY29uc3R7cmVxOmUsY2xvc2U6dH1vZiByLnZhbHVlcygpKXQoKSxyLmRlbGV0ZShlLmlkKTtsZXQgbyxzPSEwO2Zvcig7czspdHJ5e289YXdhaXQgSihlKSxzPSExfWNhdGNoKGUpe2F3YWl0IG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KGUsMmUzKSkpfXAoZSxvKTtmb3IoY29uc3QgdCBvZiBrKGUpKXRyeXthd2FpdCBfKGUsdCl9Y2F0Y2goZSl7fX19KGUpKSxufWFzeW5jIGZ1bmN0aW9uIEsoZSl7Y29uc3QgdD1cInN0cmluZ1wiPT10eXBlb2YgZT9lOm51bGw9PWU/dm9pZCAwOmUudG9waWMsbj1mdW5jdGlvbihlLHQpe2NvbnN0IG49ZXx8eCgpLHI9dHx8aDtyZXR1cm4gbj9iKG4scik6cn0oXCJzdHJpbmdcIj09dHlwZW9mIGU/bnVsbDpudWxsPT1lP3ZvaWQgMDplLnV1aWQsdCk7bGV0IHI9ZihuKTtyZXR1cm4gcnx8KHI9YXdhaXQgSihuKSxwKG4scikpLHtnZXRBbGxQcm92aWRlcnM6Ry5iaW5kKG51bGwsbikscmVnaXN0ZXI6Xy5iaW5kKG51bGwsbiksc2VhcmNoOnouYmluZChudWxsLG4pLGRlcmVnaXN0ZXI6ai5iaW5kKG51bGwsbiksZGlzcGF0Y2g6QS5iaW5kKG51bGwsbiksZGlzY29ubmVjdDpILmJpbmQobnVsbCxuKX19Y29uc3QgUT1uZXcgTWFwO2Z1bmN0aW9uIFUoZSl7Y29uc3QgdD1WKGUpO2lmKHQpcmV0dXJuIHQ7dGhyb3cgYX1mdW5jdGlvbiBWKGUpe2NvbnN0IHQ9US5nZXQoZSk7aWYodClyZXR1cm4gdH1jb25zdCBXPW5ldyBNYXA7ZnVuY3Rpb24gWChlLHQpe1cuaGFzKGUpfHxXLnNldChlLFtdKSxXLmdldChlKS5wdXNoKHQpfWZ1bmN0aW9uIFkoZSx0KXtjb25zdCBuPVcuZ2V0KGUpO2lmKCFuKXJldHVybjtjb25zdCByPW4uZmluZEluZGV4KChlPT5lPT09dCkpOy0xIT09ciYmbi5zcGxpY2UociwxKX12YXIgWixlZTtmdW5jdGlvbiB0ZShlKXtyZXR1cm5bLi4uayhlKV0ubWFwKChlPT4oey4uLmUsb25TZWFyY2g6dm9pZCAwLG9uUmVzdWx0RGlzcGF0Y2g6dm9pZCAwfSkpKX1mdW5jdGlvbiBuZShlLHQpe2lmKFAoZSx0Lm5hbWUpKXRocm93IG5ldyBFcnJvcihcInByb3ZpZGVyIHdpdGggbmFtZSBhbHJlYWR5IGV4aXN0c1wiKTtDKGUse2lkZW50aXR5OkUoKSwuLi50fSl9ZnVuY3Rpb24gcmUoZSx0KXtCKGUsdCl9YXN5bmMgZnVuY3Rpb24gb2UoZSx0LG4scil7Y29uc3Qgbz1QKGUsdCk7aWYoIW8pdGhyb3cgcztjb25zdHtvblJlc3VsdERpc3BhdGNoOml9PW87aWYoaSlyZXR1cm4gaShJKG4sRSgpLHIpKX0hZnVuY3Rpb24oZSl7ZS5GZXRjaGluZz1cImZldGNoaW5nXCIsZS5GZXRjaGVkPVwiZmV0Y2hlZFwiLGUuQ29tcGxldGU9XCJjb21wbGV0ZVwifShafHwoWj17fSkpLGZ1bmN0aW9uKGUpe2UuQ29udGFjdD1cIkNvbnRhY3RcIixlLkxpc3Q9XCJMaXN0XCIsZS5QbGFpbj1cIlBsYWluXCIsZS5TaW1wbGVUZXh0PVwiU2ltcGxlVGV4dFwifShlZXx8KGVlPXt9KSk7bGV0IHNlPTA7ZnVuY3Rpb24gaWUoZSx0KXtzZSs9MTtjb25zdCBuPU4oc2UudG9TdHJpbmcoKSx0KTtsZXQgcjtyZXR1cm4gcj1hc3luYyBmdW5jdGlvbiooZSx0LG4pe2NvbnN0IHI9ZnVuY3Rpb24oZSx0KXtjb25zdCBuPVtdLHI9W10sbz1bXSxzPVtdO2Zvcihjb25zdCBpIG9mIGUpe2NvbnN0IGU9TShpLnNjb3JlT3JkZXIpLGM9e3Jlc3VsdHM6W10scHJvdmlkZXI6e25hbWU6aS5uYW1lLGlkZW50aXR5OmkuaWRlbnRpdHksdGl0bGU6aS50aXRsZSxzY29yZU9yZGVyOmkuc2NvcmVPcmRlcn19O24ucHVzaChjKSxyLnB1c2goZSk7Y29uc3QgdT0oYXN5bmMoKT0+e3RyeXtjb25zdCBuPWF3YWl0IGkub25TZWFyY2godCxlLnJlcyk7Yy5yZXN1bHRzPU8oYy5yZXN1bHRzLG4pfWNhdGNoKGUpe2MuZXJyb3I9ZX11LmRvbmU9ITB9KSgpO3MucHVzaCh1KSxvLnB1c2goby5sZW5ndGgpfXJldHVybntwcm92aWRlclJlc3BvbnNlczpuLGxpc3RlbmVyUmVzcG9uc2VzOnIsb3Blbkxpc3RlbmVyUmVzcG9uc2VzOm8saW50aWFsUmVzcG9uc2VQcm9taXNlczpzfX0odC50YXJnZXRzP3QudGFyZ2V0cy5tYXAoKHQ9PlAoZSx0KSkpLmZpbHRlcigoZT0+ISFlKSk6Wy4uLmsoZSldLHQpLHtwcm92aWRlclJlc3BvbnNlczpvLGxpc3RlbmVyUmVzcG9uc2VzOnN9PXI7bGV0e29wZW5MaXN0ZW5lclJlc3BvbnNlczppLGludGlhbFJlc3BvbnNlUHJvbWlzZXM6Y309cix1PVouRmV0Y2hpbmc7Y29uc3QgYT1lPT57dT1lLG4uc2V0U3RhdGUodSl9O2xldCBsLGQ9ITE7dC5vbkNsb3NlKCgoKT0+e2Q9ITAsbCYmbCgpfSkpO2Rve2xldCBlPSExO2lmKGMubGVuZ3RoKXtjb25zdCB0PVtdO2Zvcihjb25zdCBuIG9mIGMpbi5kb25lP2U9ITA6dC5wdXNoKG4pO2M9dCxjLmxlbmd0aHx8KGEoWi5GZXRjaGVkKSxlPSEwKX1sZXQgdCxuPSExO2NvbnN0IHI9KCk9PntuPSEwLHQmJnQoKX0sZj1bXTtmb3IoY29uc3QgdCBvZiBpKXtjb25zdCBuPXNbdF0saT1vW3RdLGM9bi5nZXRTdGF0dXMoKTsoYz09PWcuT3Blbnx8dT09PVouRmV0Y2hpbmcmJmM9PT1nLkluaXRpYWwpJiYoZi5wdXNoKHQpLG4ub25DaGFuZ2U9cik7Y29uc3QgYT1uLmdldFJlc3VsdEJ1ZmZlcigpO2EubGVuZ3RoJiYobi5zZXRSZXN1bHRCdWZmZXIoW10pLGkucmVzdWx0cz1PKGkucmVzdWx0cyxhKSxlPSEwKTtjb25zdCBsPW4uZ2V0UmV2b2tlZEJ1ZmZlcigpO2lmKGwubGVuZ3RoKXtuLnNldFJldm9rZWRCdWZmZXIoW10pO2NvbnN0IHQ9bmV3IFNldChsKTtpLnJlc3VsdHM9aS5yZXN1bHRzLmZpbHRlcigoKHtrZXk6ZX0pPT4hdC5oYXMoZSkpKSxlPSEwfX1pZihpPWYsZSYmKHlpZWxkIG8pLGQpYnJlYWs7bnx8KGkubGVuZ3RofHxjLmxlbmd0aCkmJmF3YWl0IFByb21pc2UucmFjZShbLi4uYyxuZXcgUHJvbWlzZSgoZT0+e3Q9ZX0pKSxuZXcgUHJvbWlzZSgoZT0+e2w9ZX0pKV0pfXdoaWxlKGkubGVuZ3RofHxjLmxlbmd0aCk7cmV0dXJuIGEoWi5Db21wbGV0ZSksb30oZSxuLnJlcSx7c2V0U3RhdGU6ZT0+e3Iuc3RhdGU9ZX19KSxyLmlkPXNlLnRvU3RyaW5nKCksci5jbG9zZT1uLmNsb3NlLHIuc3RhdGU9Wi5GZXRjaGluZyxyfWNvbnN0IGNlPW5ldyBNYXA7ZnVuY3Rpb24gdWUoZSx0KXtyZXR1cm5gJHtlfToke3R9YH1mdW5jdGlvbiBhZShlLHQsbil7cmV0dXJuIFUoZSkuZGlzcGF0Y2godCx3LHtpZDpufSl9YXN5bmMgZnVuY3Rpb24gbGUoZSx0LHtpZDpuLHF1ZXJ5OnIsY29udGV4dDpvLHRhcmdldHM6c30pe2NvbnN0IGk9VShlKSxjPXtpZDpuLHF1ZXJ5OnIsY29udGV4dDpvLHRhcmdldHM6cyxwcm92aWRlck5hbWU6dC5uYW1lfSx1PWF3YWl0IGkuZGlzcGF0Y2godC5pZGVudGl0eSx2LGMpLGE9dS5lcnJvcjtpZihhKXRocm93IG5ldyBFcnJvcihhKTtyZXR1cm4gdX1jb25zdCBkZT1uZXcgTWFwO2Z1bmN0aW9uIGZlKGUsdCxuKXtyZXR1cm5gJHtlfToke3QubmFtZX06JHt0LnV1aWR9OiR7bn1gfWNvbnN0IHBlPW5ldyBNYXA7ZnVuY3Rpb24gZ2UoZSx0LG4pe3JldHVybmAke2V9OiR7dH06JHtufWB9ZnVuY3Rpb24gaGUoZSx0KXtjb25zdCBuPWZlLmJpbmQobnVsbCxlLHQuaWRlbnRpdHkpLHI9YWUuYmluZChudWxsLGUsdC5pZGVudGl0eSksbz1sZS5iaW5kKG51bGwsZSx0KTtyZXR1cm4gYXN5bmMocyxpKT0+e2NvbnN0IGM9bihzLmlkKTtpZighZGUuaGFzKGMpKXtjb25zdCBlPSgpPT57cihzLmlkKSxkZS5kZWxldGUoYyl9O2RlLnNldChjLGUpLHMub25DbG9zZShlKX1jb25zdCB1PWdlKGUsdC5uYW1lLHMuaWQpLGE9KCk9PntwZS5kZWxldGUodSksaS5jbG9zZSgpfTtzLm9uQ2xvc2UoYSkscGUuc2V0KHUsKGU9Pnt2YXIgdCxuOyhudWxsPT09KHQ9ZS5yZXN1bHRzKXx8dm9pZCAwPT09dD92b2lkIDA6dC5sZW5ndGgpJiZpLnJlc3BvbmQoZS5yZXN1bHRzKSwobnVsbD09PShuPWUucmV2b2tlZCl8fHZvaWQgMD09PW4/dm9pZCAwOm4ubGVuZ3RoKSYmaS5yZXZva2UoLi4uZS5yZXZva2VkKSxlLnN0YXR1cz09PWcuT3BlbiYmaS5vcGVuKCksZS5zdGF0dXM9PT1nLkNsb3NlJiZhKCl9KSk7Y29uc3QgbD1hd2FpdCBvKHMpO3JldHVybiBsLnN0YXR1cz09PWcuT3BlbiYmaS5vcGVuKCksbC5zdGF0dXMhPT1nLkNsb3NlJiZsLnN0YXR1cyE9PWcuSW5pdGlhbHx8YSgpLGwucmVzdWx0c319ZnVuY3Rpb24gdmUoZSx0KXtyZXR1cm4gYXN5bmMgbj0+e2NvbnN0IHI9VShlKSxvPXtwcm92aWRlck5hbWU6dC5uYW1lLHJlc3VsdDpufTtyZXR1cm4gci5kaXNwYXRjaCh0LmlkZW50aXR5LHksbyl9fWNvbnN0IHllPW5ldyBNYXA7ZnVuY3Rpb24gd2UoZSx0KXtyZXR1cm5gJHtlfS0ke3QubmFtZX0tJHt0LnV1aWR9YH1hc3luYyBmdW5jdGlvbiBtZShlKXtjb25zdCB0PVIoZSksbj1hd2FpdChyPXQsZmluLkludGVyQXBwbGljYXRpb25CdXMuQ2hhbm5lbC5jcmVhdGUocikpO3ZhciByLG87cmV0dXJuIG4ub25Db25uZWN0aW9uKGZ1bmN0aW9uKGUpe3JldHVybiBhc3luYyB0PT57Y29uc3Qgbj1XLmdldChlKTtpZihuKWZvcihjb25zdCBlIG9mIG4paWYoIWF3YWl0IGUodCkpdGhyb3cgdX19KGUpKSxuLm9uRGlzY29ubmVjdGlvbihmdW5jdGlvbihlKXtyZXR1cm4gYXN5bmMgdD0+eyFmdW5jdGlvbihlLHQpe2NvbnN0IG49d2UoZSx0KSxyPXllLmdldChuKTtpZihyKXtmb3IoY29uc3QgdCBvZiByKUIoZSx0KTt5ZS5kZWxldGUobil9fShlLHQpfX0oZSkpLG4ucmVnaXN0ZXIodyxmdW5jdGlvbihlKXtyZXR1cm4gdD0+ZnVuY3Rpb24oZSx0KXtjb25zdCBuPXVlKGUsdCkscj1jZS5nZXQobik7ciYmci5nZW5lcmF0b3IuY2xvc2UoKX0oZSx0LmlkKX0oZSkpLG4ucmVnaXN0ZXIodixmdW5jdGlvbihlKXtyZXR1cm4gdD0+e2NvbnN0IG49Z2UoZSx0LnByb3ZpZGVyTmFtZSx0LmlkKSxyPXBlLmdldChuKTtyJiZyKHQpfX0oZSkpLG4ucmVnaXN0ZXIoXCIyXCIsZnVuY3Rpb24oZSl7cmV0dXJuKHQsbik9PntpZih0JiZ0Lm5hbWUpe2lmKFAoZSx0Lm5hbWUpKXRocm93IGk7dC5pZGVudGl0eT1uLGZ1bmN0aW9uKGUsdCl7Y29uc3Qgbj13ZShlLHQuaWRlbnRpdHkpO3llLmhhcyhuKXx8eWUuc2V0KG4sW10pLHllLmdldChuKS5wdXNoKHQubmFtZSksQyhlLHsuLi50LG9uU2VhcmNoOmhlKGUsdCksb25SZXN1bHREaXNwYXRjaDp2ZShlLHQpfSl9KGUsdCl9ZWxzZSBUKGMpfX0oZSkpLG4ucmVnaXN0ZXIoXCIzXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHQ9Pnt0P2Z1bmN0aW9uKGUsdCl7Y29uc3Qgbj1QKGUsdCk7aWYoIW4pcmV0dXJuO2NvbnN0IHI9d2UoZSxuLmlkZW50aXR5KSxvPXllLmdldChyKTtpZihvKXtjb25zdCBuPW8uZmluZEluZGV4KChlPT5lPT09dCkpOy0xIT09biYmKG8uc3BsaWNlKG4sMSksQihlLHQpKX19KGUsdCk6VChjKX19KGUpKSxuLnJlZ2lzdGVyKFwiNFwiLChvPWUsYXN5bmMoKT0+dGUobykpKSxuLnJlZ2lzdGVyKFwiMVwiLGZ1bmN0aW9uKGUpe3JldHVybiBhc3luYyB0PT57aWYoIXQpcmV0dXJuIFQoYykse2Vycm9yOmMubWVzc2FnZX07bGV0IG47aWYodC5pZCluPXVlKGUsdC5pZCk7ZWxzZXtjb25zdCByPWllKGUsdCk7bj11ZShlLHIuaWQpLHQuaWQ9ci5pZCxjZS5zZXQobix7Z2VuZXJhdG9yOnJ9KX1jb25zdCByPWNlLmdldChuKTtjbGVhclRpbWVvdXQoci50aW1lb3V0KTtjb25zdCBvPWF3YWl0IHIuZ2VuZXJhdG9yLm5leHQoKTtyZXR1cm4gci50aW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiB3aW5kb3cuc2V0VGltZW91dCgoKCk9PntjZS5kZWxldGUoZSl9KSwxZTQpfShuKSx7Li4ubyxpZDp0LmlkLHN0YXRlOnIuZ2VuZXJhdG9yLnN0YXRlfX19KGUpKSxuLnJlZ2lzdGVyKHksZnVuY3Rpb24oZSl7cmV0dXJuIGFzeW5jKHQsbik9PntpZighdHx8IXQucHJvdmlkZXJOYW1lfHwhdC5yZXN1bHQpcmV0dXJuIHZvaWQgVChjKTtjb25zdCByPVAoZSx0LnByb3ZpZGVyTmFtZSk7aWYoIXIpdGhyb3cgcztjb25zdHtvblJlc3VsdERpc3BhdGNoOm99PXI7cmV0dXJuIG8/KHQucmVzdWx0LmRpc3BhdGNoZXJJZGVudGl0eT1uLG8odC5yZXN1bHQpKTp2b2lkIDB9fShlKSksbn1hc3luYyBmdW5jdGlvbiBiZShlKXtjb25zdCB0PVUoZSk7IWZ1bmN0aW9uKGUpe1EuZGVsZXRlKGUpfShlKSxhd2FpdCB0LmRlc3Ryb3koKSwkKGUpfWFzeW5jIGZ1bmN0aW9uIFJlKGUpe2NvbnN0IHQ9ZnVuY3Rpb24oZSl7Y29uc3QgdD14KCksbj1lfHxoO3JldHVybiB0P2IodCxuKTpufShcInN0cmluZ1wiPT10eXBlb2YgZT9lOm51bGw9PWU/dm9pZCAwOmUudG9waWMpO2xldCBuPVYodCk7cmV0dXJuIG58fChuPWF3YWl0IG1lKHQpLGZ1bmN0aW9uKGUsdCl7US5zZXQoZSx0KX0odCxuKSkse2dldEFsbFByb3ZpZGVyczp0ZS5iaW5kKG51bGwsdCksc2VhcmNoOmllLmJpbmQobnVsbCx0KSxyZWdpc3RlcjpuZS5iaW5kKG51bGwsdCksZGVyZWdpc3RlcjpyZS5iaW5kKG51bGwsdCksb25TdWJzY3JpcHRpb246WC5iaW5kKG51bGwsdCkscmVtb3ZlU3Vic2NyaXB0aW9uTGlzdGVuZXI6WS5iaW5kKG51bGwsdCksZGlzcGF0Y2g6b2UuYmluZChudWxsLHQpLGRpc2Nvbm5lY3Q6YmUuYmluZChudWxsLHQpfX1jb25zdHtjcmVhdGU6U2V9PXIse3N1YnNjcmliZTpDZX09bixCZT1oLGtlPXtjcmVhdGU6U2Usc3Vic2NyaWJlOkNlLGRlZmF1bHRUb3BpYzpCZX0sJGU9KCk9Pntjb25zdCBlPXdpbmRvdztlLnNlYXJjaD1rZSxlLmZpbiYmKGUuZmluLlNlYXJjaD1rZSl9LFBlPWU9Pntjb25zdCB0PSgpPT57JGUoKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLHQpfTtyZXR1cm4gdH07aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyl7JGUoKTtjb25zdCBlPVwibG9hZFwiLHQ9UGUoZSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZSx0KTtjb25zdCBuPVwiRE9NQ29udGVudExvYWRlZFwiLHI9UGUobik7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIobixyKX1tb2R1bGUuZXhwb3J0cz10fSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXtkOihvLHIpPT57Zm9yKHZhciB0IGluIHIpZS5vKHIsdCkmJiFlLm8obyx0KSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sdCx7ZW51bWVyYWJsZTohMCxnZXQ6clt0XX0pfSxvOihlLG8pPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxvKSxyOmU9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfX0sbz17fTtlLnIobyksZS5kKG8se1N0b3JlZnJvbnQ6KCk9PiQsbGF1bmNoQXBwOigpPT5UfSk7dmFyIHIsdCxuPXt9O2UucihuKSxlLmQobix7aGlkZTooKT0+QyxyZWdpc3RlcjooKT0+YixzaG93OigpPT5GfSksZnVuY3Rpb24oZSl7ZS5Mb2NhbD1cImxvY2FsXCIsZS5EZXY9XCJkZXZcIixlLlN0YWdpbmc9XCJzdGFnaW5nXCIsZS5Qcm9kPVwicHJvZFwifSh0fHwodD17fSkpO2NvbnN0IGE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGZpbixpPShcInVuZGVmaW5lZFwiPT10eXBlb2YgcHJvY2Vzc3x8bnVsbD09PShyPXByb2Nlc3MuZW52KXx8dm9pZCAwPT09cnx8ci5KRVNUX1dPUktFUl9JRCxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93KSxkPShpP3dpbmRvdy5vcmlnaW46dC5Mb2NhbCxhJiZmaW4ubWUudXVpZCxhJiZmaW4ubWUubmFtZSxcInVuZGVmaW5lZFwiIT10eXBlb2YgRU5WP0VOVjp0LkxvY2FsLHQuTG9jYWwsdC5EZXYsdC5TdGFnaW5nLHQuUHJvZCwhMCkscz0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdPUktTUEFDRV9BUElfVVJMJiZXT1JLU1BBQ0VfQVBJX1VSTCxcInVuZGVmaW5lZFwiIT10eXBlb2YgV09SS1NQQUNFX0FQUFNfVVJMJiZXT1JLU1BBQ0VfQVBQU19VUkwsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdPUktTUEFDRV9TVE9SRUZST05UX0ZPT1RFUl9VUkwmJldPUktTUEFDRV9TVE9SRUZST05UX0ZPT1RFUl9VUkwsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdPUktTUEFDRV9TVE9SRUZST05UX0xBTkRJTkdfUEFHRV9VUkwmJldPUktTUEFDRV9TVE9SRUZST05UX0xBTkRJTkdfUEFHRV9VUkwsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdPUktTUEFDRV9TVE9SRUZST05UX05BVklHQVRJT05fVVJMJiZXT1JLU1BBQ0VfU1RPUkVGUk9OVF9OQVZJR0FUSU9OX1VSTCxcIiM3Nzk1ZjdcIiksYz17dHJhY2U6ITAsZGVidWc6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIExPR19ERUJVRyYmTE9HX0RFQlVHLGluZm86ITEsd2FybjohMCxlcnJvcjohMCxmYXRhbDohMH07Y29uc3QgcD1mdW5jdGlvbihlLG8pe2NvbnN0IHI9YCR7ZX0gOiBgLHQ9YGNvbG9yOiR7c31gO3JldHVybnt0cmFjZTpjLnRyYWNlPyhlLC4uLm8pPT57Y29uc29sZS50cmFjZShgJWMke3J9JHtlfWAsdCwuLi5vKX06KGUsLi4ubyk9Pnt9LGRlYnVnOmMuZGVidWc/KGUsLi4ubyk9Pntjb25zb2xlLmluZm8oYCVjJHtyfSR7ZX1gLFwiY29sb3I6Izg2ZGI5NFwiLC4uLm8pfTooZSwuLi5vKT0+e30saW5mbzpjLmluZm8/KGUsLi4ubyk9Pntjb25zb2xlLmRlYnVnKGAlYyR7cn0ke2V9YCxcImNvbG9yOiNmZmZmZmZcIiwuLi5vKX06KGUsLi4ubyk9Pnt9LHdhcm46Yy53YXJuPyhlLC4uLm8pPT57Y29uc29sZS53YXJuKGAlYyR7cn0ke2V9YCxcImNvbG9yOiNlZGFkNjhcIiwuLi5vKX06KGUsLi4ubyk9Pnt9LGVycm9yOmMuZXJyb3I/KGUsbywuLi50KT0+e2NvbnNvbGUuZXJyb3IoYCVjJHtyfSR7ZX1gLFwiY29sb3I6I2Y1NWQ2N1wiLC4uLnQsbyl9OihlLG8sLi4ucik9Pnt9LGZhdGFsOmMuZmF0YWw/KGUsbywuLi50KT0+e2NvbnNvbGUuZXJyb3IoYCVjJHtyfSR7ZX1gLFwiY29sb3I6I2Y3MDcyM1wiLC4uLnQsbyl9OihlLG8sLi4ucik9Pnt9fX0oXCJ1dGlscy5jaGFubmVsc1wiKSxnPWkmJlwiY29tcGxldGVcIiE9PWRvY3VtZW50LnJlYWR5U3RhdGUmJm5ldyBQcm9taXNlKChlPT5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCgoKT0+e1wiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUmJmUoKX0pKSkpO3ZhciBmLHcsdSxsLGg7IWZ1bmN0aW9uKGUpe2UuV29ya3NwYWNlPVwib3BlbmZpbi1icm93c2VyXCJ9KGZ8fChmPXt9KSksZnVuY3Rpb24oZSl7ZS5WaWV3UGFnZVRpdGxlVXBkYXRlZD1cInZpZXctcGFnZS10aXRsZS11cGRhdGVkXCIsZS5WaWV3RGVzdHJveWVkPVwidmlldy1kZXN0cm95ZWRcIixlLlJ1blJlcXVlc3RlZD1cInJ1bi1yZXF1ZXN0ZWRcIixlLldpbmRvd09wdGlvbnNDaGFuZ2VkPVwid2luZG93LW9wdGlvbnMtY2hhbmdlZFwiLGUuV2luZG93Q2xvc2VkPVwid2luZG93LWNsb3NlZFwiLGUuV2luZG93Q3JlYXRlZD1cIndpbmRvdy1jcmVhdGVkXCJ9KHd8fCh3PXt9KSksZnVuY3Rpb24oZSl7ZS5GaW5Qcm90b2NvbD1cImZpbi1wcm90b2NvbFwifSh1fHwodT17fSkpLGYuV29ya3NwYWNlLGYuV29ya3NwYWNlLGZ1bmN0aW9uKGUpe2UuSG9tZT1cIm9wZW5maW4taG9tZVwiLGUuRG9jaz1cIm9wZW5maW4tZG9ja1wiLGUuU3RvcmVmcm9udD1cIm9wZW5maW4tc3RvcmVmcm9udFwiLGUuSG9tZUludGVybmFsPVwib3BlbmZpbi1ob21lLWludGVybmFsXCIsZS5Ccm93c2VyTWVudT1cIm9wZW5maW4tYnJvd3Nlci1tZW51XCIsZS5Ccm93c2VySW5kaWNhdG9yPVwib3BlbmZpbi1icm93c2VyLWluZGljYXRvclwiLGUuQnJvd3NlcldpbmRvdz1cImludGVybmFsLWdlbmVyYXRlZC13aW5kb3dcIn0obHx8KGw9e30pKSxmdW5jdGlvbihlKXtlLlNob3duPVwic2hvd25cIixlLkJvdW5kc0NoYW5nZWQ9XCJib3VuZHMtY2hhbmdlZFwiLGUuTGF5b3V0UmVhZHk9XCJsYXlvdXQtcmVhZHlcIixlLkVuZFVzZXJCb3VuZHNDaGFuZ2luZz1cImVuZC11c2VyLWJvdW5kcy1jaGFuZ2luZ1wiLGUuQmx1cnJlZD1cImJsdXJyZWRcIixlLkNsb3NlUmVxdWVzdGVkPVwiY2xvc2UtcmVxdWVzdGVkXCIsZS5Gb2N1c2VkPVwiZm9jdXNlZFwiLGUuU2hvd1JlcXVlc3RlZD1cInNob3ctcmVxdWVzdGVkXCIsZS5WaWV3Q3Jhc2hlZD1cInZpZXctY3Jhc2hlZFwiLGUuVmlld0F0dGFjaGVkPVwidmlldy1hdHRhY2hlZFwiLGUuVmlld0RldGFjaGVkPVwidmlldy1kZXRhY2hlZFwifShofHwoaD17fSkpLGwuSG9tZSxmLldvcmtzcGFjZSxsLkRvY2ssZi5Xb3Jrc3BhY2UsbC5TdG9yZWZyb250LGYuV29ya3NwYWNlO2NvbnN0IHY9e25hbWU6Zi5Xb3Jrc3BhY2UsdXVpZDpmLldvcmtzcGFjZX0sUz1lPT5mdW5jdGlvbihlKXtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJnZXRPRldpbmRvdyBjYW4gb25seSBiZSB1c2VkIGluIGFuIE9wZW5GaW4gZW52LiBBdm9pZCBjYWxsaW5nIHRoaXMgbWV0aG9kIGR1cmluZyBwcmUtcmVuZGVyaW5nLlwiKTtyZXR1cm4gZmluLldpbmRvdy53cmFwU3luYyhlKX0oZSkuZ2V0T3B0aW9ucygpLnRoZW4oKCgpPT4hMCkpLmNhdGNoKCgoKT0+ITEpKTt2YXIgUCxSOyhSPVB8fChQPXt9KSkuTGF1bmNoQXBwPVwibGF1bmNoLWFwcFwiLFIuQ3JlYXRlV29ya3NwYWNlPVwiY3JlYXRlLXdvcmtzcGFjZVwiLFIuVXBkYXRlV29ya3NwYWNlPVwidXBkYXRlLXdvcmtzcGFjZVwiLFIuRGVsZXRlV29ya3NwYWNlPVwiZGVsZXRlLXdvcmtzcGFjZVwiLFIuTGF1bmNoV29ya3NwYWNlPVwibGF1bmNoLXdvcmtzcGFjZVwiLFIuU2hhcmVXb3Jrc3BhY2U9XCJzaGFyZS13b3Jrc3BhY2VcIixSLkdldFdvcmtzcGFjZT1cImdldC13b3Jrc3BhY2VcIixSLkdldFdvcmtzcGFjZUxpc3Q9XCJnZXQtd29ya3NwYWNlLWxpc3RcIixSLkdldEFjdGl2ZVdvcmtzcGFjZT1cImdldC1hY3RpdmUtd29ya3NwYWNlXCIsUi5HZXRQYWdlPVwiZ2V0LXBhZ2VcIixSLkNyZWF0ZVBhZ2U9XCJjcmVhdGUtcGFnZVwiLFIuVXBkYXRlUGFnZT1cInVwZGF0ZS1wYWdlXCIsUi5SZW5hbWVQYWdlPVwicmVuYW1lLXBhZ2VcIixSLkRlbGV0ZVBhZ2U9XCJkZWxldGUtcGFnZVwiLFIuU2hhcmVQYWdlPVwic2hhcmUtcGFnZVwiLFIuTGF1bmNoUGFnZT1cImxhdW5jaC1wYWdlXCIsUi5BdHRhY2hQYWdlc1RvV2luZG93PVwiYXR0YWNoLXBhZ2VzLXRvLXdpbmRvd1wiLFIuRGV0YWNoUGFnZXNGcm9tV2luZG93PVwiZGV0YWNoLXBhZ2VzLWZyb20td2luZG93XCIsUi5SZW9yZGVyUGFnZXNGb3JXaW5kb3c9XCJyZW9yZGVyLXBhZ2VzLWZvci13aW5kb3dcIixSLlNldEFjdGl2ZVBhZ2VGb3JXaW5kb3c9XCJzZXQtYWN0aXZlLXBhZ2UtZm9yLXdpbmRvd1wiLFIuR2V0U2F2ZWRQYWdlTGlzdD1cImdldC1zYXZlZC1wYWdlLWxpc3RcIixSLkdldEF0dGFjaGVkUGFnZUxpc3Q9XCJnZXQtcnVubmluZy1wYWdlLWxpc3RcIixSLkdldEFsbFBhZ2VMaXN0PVwiZ2V0LWFsbC1wYWdlLWxpc3RcIixSLkdldEFjdGl2ZVBhZ2VJZEZvcldpbmRvdz1cImdldC1hY3RpdmUtcGFnZS1pZC1mb3Itd2luZG93XCIsUi5HZXRQYWdlc0ZvcldpbmRvdz1cImdldC1wYWdlcy1mb3Itd2luZG93XCIsUi5HZXRTYXZlZFBhZ2VNZXRhZGF0YT1cImdldC1zYXZlZC1wYWdlLW1ldGFkYXRhXCIsUi5SZWdpc3RlclN0b3JlZnJvbnRQcm92aWRlcj1cInJlZ2lzdGVyLXN0b3JlZnJvbnQtcHJvdmlkZXJcIixSLkdldFN0b3JlZnJvbnRQcm92aWRlcnM9XCJnZXQtc3RvcmVmcm9udC1wcm92aWRlcnNcIixSLkhpZGVTdG9yZWZyb250PVwiaGlkZS1zdG9yZWZyb250XCIsUi5HZXRTdG9yZWZyb250UHJvdmlkZXJBcHBzPVwiZ2V0LXN0b3JlZnJvbnQtcHJvdmlkZXItYXBwc1wiLFIuR2V0U3RvcmVmcm9udFByb3ZpZGVyTGFuZGluZ1BhZ2U9XCJnZXQtc3RvcmVmcm9udC1wcm92aWRlci1sYW5kaW5nLXBhZ2VcIixSLkdldFN0b3JlZnJvbnRQcm92aWRlckZvb3Rlcj1cImdldC1zdG9yZWZyb250LXByb3ZpZGVyLWZvb3RlclwiLFIuR2V0U3RvcmVmcm9udFByb3ZpZGVyTmF2aWdhdGlvbj1cImdldC1zdG9yZWZyb250LXByb3ZpZGVyLW5hdmlnYXRpb25cIixSLkxhdW5jaFN0b3JlZnJvbnRQcm92aWRlckFwcD1cImxhdW5jaC1zdG9yZWZyb250LXByb3ZpZGVyLWFwcFwiLFIuU2hvd1N0b3JlZnJvbnQ9XCJzaG93LXN0b3JlZnJvbnRcIixSLkNyZWF0ZVN0b3JlZnJvbnRXaW5kb3c9XCJjcmVhdGUtc3RvcmVmcm9udC13aW5kb3dcIixSLkNyZWF0ZUJyb3dzZXJXaW5kb3c9XCJjcmVhdGUtYnJvd3Nlci13aW5kb3dcIjtjb25zdCB5PWZ1bmN0aW9uKGUpe2xldCBvO3JldHVybigpPT57aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiZ2V0Q2hhbm5lbENsaWVudCBjYW5ub3QgYmUgdXNlZCBvdXRzaWRlIGFuIE9wZW5GaW4gZW52LiBBdm9pZCB1c2luZyB0aGlzIG1ldGhvZCBkdXJpbmcgcHJlLXJlbmRlcmluZy5cIik7cmV0dXJuIG98fChwLmRlYnVnKGBjb25uZWN0aW5nIHRvIGNoYW5uZWwgcHJvdmlkZXIgJHtlfWApLG89KGFzeW5jKCk9Pnthd2FpdCBnO2NvbnN0IHI9YXdhaXQgZmluLkludGVyQXBwbGljYXRpb25CdXMuQ2hhbm5lbC5jb25uZWN0KGUpO3JldHVybiByLm9uRGlzY29ubmVjdGlvbigoYXN5bmMoKT0+e3Aud2FybihgZGlzY29ubmVjdGVkIGZyb20gY2hhbm5lbCBwcm92aWRlciAke2V9YCksbz12b2lkIDB9KSkscn0pKCkudGhlbigobz0+KHAuZGVidWcoYGNvbm5lY3RlZCB0byBjaGFubmVsIHByb3ZpZGVyICR7ZX1gKSxvKSkpLmNhdGNoKChvPT57cC5lcnJvcihgZmFpbGVkIHRvIGNvbm5lY3QgdG8gY2hhbm5lbCBwcm92aWRlciAke2V9YCxvKX0pKSksb319KFwiX19vZl93b3Jrc3BhY2VfcHJvdG9jb2xfX1wiKSxBPWFzeW5jKCk9PntpZighYXdhaXQgUyh2KSlyZXR1cm4gZmluLlN5c3RlbS5vcGVuVXJsV2l0aEJyb3dzZXIoKCgpPT57Y29uc3QgZT1uZXcgVVJMKFwiZmluczovL3N5c3RlbS1hcHBzL3dvcmtzcGFjZVwiKTtyZXR1cm4gZS5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiaXNMYXVuY2hlZFZpYUxpYlwiLGQudG9TdHJpbmcoKSksZS50b1N0cmluZygpfSkoKSl9LFc9YXN5bmMoKT0+KGF3YWl0IEEoKSx5KCkpO3ZhciBPLF8sTDtsZXQgbTshZnVuY3Rpb24oZSl7ZS5TbmFwc2hvdD1cInNuYXBzaG90XCIsZS5NYW5pZmVzdD1cIm1hbmlmZXN0XCIsZS5WaWV3PVwidmlld1wiLGUuRXh0ZXJuYWw9XCJleHRlcm5hbFwifShPfHwoTz17fSkpLChMPV98fChfPXt9KSkuTGFuZGluZ1BhZ2U9XCJsYW5kaW5nUGFnZVwiLEwuQXBwR3JpZD1cImFwcEdyaWRcIjtjb25zdCBFPW5ldyBNYXA7bGV0IEc9ITE7Y29uc3Qgaz1lPT57aWYoIUUuaGFzKGUpKXRocm93IG5ldyBFcnJvcihgU3RvcmVmcm9udCBQcm92aWRlciB3aXRoIGlkICR7ZX0gaXMgbm90IHJlZ2lzdGVyZWRgKTtyZXR1cm4gRS5nZXQoZSl9LGI9ZT0+KG09KGFzeW5jIGU9Pntjb25zdCBvPWF3YWl0IFcoKTtpZihFLmhhcyhlLmlkKSl0aHJvdyBuZXcgRXJyb3IoYFN0b3JlZnJvbnQgcHJvdmlkZXIgd2l0aCBpZCAke2UuaWR9IGFscmVhZHkgcmVnaXN0ZXJlZGApO3JldHVybiBFLnNldChlLmlkLGUpLChlPT57R3x8KEc9ITAsZS5yZWdpc3RlcihQLkdldFN0b3JlZnJvbnRQcm92aWRlckFwcHMsKGU9PmsoZSkuZ2V0QXBwcygpKSksZS5yZWdpc3RlcihQLkdldFN0b3JlZnJvbnRQcm92aWRlckZvb3RlciwoZT0+ayhlKS5nZXRGb290ZXIoKSkpLGUucmVnaXN0ZXIoUC5HZXRTdG9yZWZyb250UHJvdmlkZXJMYW5kaW5nUGFnZSwoZT0+ayhlKS5nZXRMYW5kaW5nUGFnZSgpKSksZS5yZWdpc3RlcihQLkdldFN0b3JlZnJvbnRQcm92aWRlck5hdmlnYXRpb24sKGU9PmsoZSkuZ2V0TmF2aWdhdGlvbigpKSksZS5yZWdpc3RlcihQLkxhdW5jaFN0b3JlZnJvbnRQcm92aWRlckFwcCwoKHtpZDplLGFwcDpvfSk9PmsoZSkubGF1bmNoQXBwKG8pKSkpfSkobyksby5kaXNwYXRjaChQLlJlZ2lzdGVyU3RvcmVmcm9udFByb3ZpZGVyLGUpfSkoZSksbSksQz1hc3luYygpPT57YXdhaXQgbSxhd2FpdCBBKCksYXdhaXQoYXN5bmMoKT0+KGF3YWl0IHkoKSkuZGlzcGF0Y2goUC5IaWRlU3RvcmVmcm9udCx2b2lkIDApKSgpfSxGPWFzeW5jKCk9Pnthd2FpdCBtLGF3YWl0IEEoKSxhd2FpdChhc3luYygpPT4oYXdhaXQgeSgpKS5kaXNwYXRjaChQLlNob3dTdG9yZWZyb250LG51bGwpKSgpfSxUPWFzeW5jIGU9Pihhd2FpdCBXKCkpLmRpc3BhdGNoKFAuTGF1bmNoQXBwLGUpLCQ9bjttb2R1bGUuZXhwb3J0cz1vfSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3ZhbGlkYXRlXCIpO1xuY29uc3QgSW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlXCIpO1xuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBBcHBsaWNhdGlvbk9wdGlvblxuICogQHN1bW1hcnkgQXBwbGljYXRpb24gY3JlYXRpb24gb3B0aW9ucy5cbiAqIEBkZXNjIFRoaXMgaXMgdGhlIG9wdGlvbnMgb2JqZWN0IHJlcXVpcmVkIGJ5IHtAbGluayBBcHBsaWNhdGlvbi5zdGFydCBBcHBsaWNhdGlvbi5zdGFydH0uXG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSByZXF1aXJlZDpcbiAqICogYHV1aWRgIGlzIHJlcXVpcmVkIGluIHRoZSBhcHAgbWFuaWZlc3QgYXMgd2VsbCBhcyBieSB7QGxpbmsgQXBwbGljYXRpb24uc3RhcnQgQXBwbGljYXRpb24uc3RhcnR9XG4gKiAqIGBuYW1lYCBpcyBvcHRpb25hbCBpbiB0aGUgYXBwIG1hbmlmZXN0IGJ1dCByZXF1aXJlZCBieSB7QGxpbmsgQXBwbGljYXRpb24uc3RhcnQgQXBwbGljYXRpb24uc3RhcnR9XG4gKiAqIGB1cmxgIGlzIG9wdGlvbmFsIGluIGJvdGggdGhlIGFwcCBtYW5pZmVzdCB7QGxpbmsgQXBwbGljYXRpb24uc3RhcnQgQXBwbGljYXRpb24uc3RhcnR9IGFuZCAgYnV0IGlzIHVzdWFsbHkgZ2l2ZW5cbiAqIChkZWZhdWx0cyB0byBgXCJhYm91dDpibGFua1wiYCB3aGVuIG9taXR0ZWQpLlxuICpcbiAqIF9UaGlzIGpzZG9jIHR5cGVkZWYgbWlycm9ycyB0aGUgYEFwcGxpY2F0aW9uT3B0aW9uYCBUeXBlU2NyaXB0IGludGVyZmFjZSBpbiBgQHR5cGVzL29wZW5maW5gLl9cbiAqXG4gKiAqKklNUE9SVEFOVCBOT1RFOioqXG4gKiBUaGlzIG9iamVjdCBpbmhlcml0cyBhbGwgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHdpbmRvdyBjcmVhdGlvbiB7QGxpbmsgV2luZG93fm9wdGlvbnMgb3B0aW9uc30gb2JqZWN0LFxuICogd2hpY2ggd2lsbCB0YWtlIHByaW9yaXR5IG92ZXIgdGhvc2Ugb2YgdGhlIHNhbWUgbmFtZSB0aGF0IG1heSBiZSBwcm92aWRlZCBpbiBgbWFpbldpbmRvd09wdGlvbnNgLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVJYWJTZWN1cmVMb2dnaW5nPWZhbHNlXVxuICogV2hlbiBzZXQgdG8gYHRydWVgIGl0IHdpbGwgZGlzYWJsZSBJQUIgc2VjdXJlIGxvZ2dpbmcgZm9yIHRoZSBhcHAuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsb2FkRXJyb3JNZXNzYWdlPVwiVGhlcmUgd2FzIGFuIGVycm9yIGxvYWRpbmcgdGhlIGFwcGxpY2F0aW9uLlwiXVxuICogQW4gZXJyb3IgbWVzc2FnZSB0byBkaXNwbGF5IHdoZW4gdGhlIGFwcGxpY2F0aW9uIChsYXVuY2hlZCB2aWEgbWFuaWZlc3QpIGZhaWxzIHRvIGxvYWQuXG4gKiBBIGRpYWxvZyBib3ggd2lsbCBiZSBsYXVuY2hlZCB3aXRoIHRoZSBlcnJvciBtZXNzYWdlIGp1c3QgYmVmb3JlIHRoZSBydW50aW1lIGV4aXRzLlxuICogTG9hZCBmYWlscyBzdWNoIGFzIGZhaWxlZCBETlMgcmVzb2x1dGlvbnMgb3IgYWJvcnRlZCBjb25uZWN0aW9ucyBhcyB3ZWxsIGFzIGNhbmNlbGxhdGlvbnMsIF9lLmcuLF8gYHdpbmRvdy5zdG9wKClgLFxuICogd2lsbCB0cmlnZ2VyIHRoaXMgZGlhbG9nLlxuICogQ2xpZW50IHJlc3BvbnNlIGNvZGVzIHN1Y2ggYXMgYDQwNCBOb3QgRm91bmRgIGFyZSBub3QgdHJlYXRlZCBhcyBmYWlscyBhcyB0aGV5IGFyZSB2YWxpZCBzZXJ2ZXIgcmVzcG9uc2VzLlxuICpcbiAqIEBwcm9wZXJ0eSB7V2luZG93fm9wdGlvbnN9IFttYWluV2luZG93T3B0aW9uc11cbiAqIFRoZSBvcHRpb25zIG9mIHRoZSBtYWluIHdpbmRvdyBvZiB0aGUgYXBwbGljYXRpb24uXG4gKiBGb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGVzZSBvcHRpb25zLCBjbGljayB0aGUgbGluayAoaW4gdGhlIFR5cGUgY29sdW1uKS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFZpZXdQb29sU2l6ZT0xMDAwXVxuICogUGxhdGZvcm1zIE9ubHkuICBUaGUgbWF4aW11bSBudW1iZXIgb2YgXCJkZXRhY2hlZFwiIG9yIFwicG9vbGVkXCIgVmlld3MgdGhhdCBjYW4gZXhpc3QgaW4gdGhlIFBsYXRmb3JtIGJlZm9yZSBiZWluZyBjbG9zZWQuXG4gKiBJZiB5b3UgZG8gbm90IHdpc2ggZm9yIHZpZXdzIHRvIGJlIHBvb2xlZCBvbiB5b3VyIHBsYXRmb3JtLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byB6ZXJvLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV1cbiAqIFRoZSBuYW1lIG9mIHRoZSBhcHBsaWNhdGlvbiAoYW5kIHRoZSBhcHBsaWNhdGlvbidzIG1haW4gd2luZG93KS5cbiAqXG4gKiBJZiBwcm92aWRlZCwgX211c3RfIG1hdGNoIGB1dWlkYC5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtub25QZXJzaXN0ZW50PWZhbHNlXVxuICogQSBmbGFnIHRvIGNvbmZpZ3VyZSB0aGUgYXBwbGljYXRpb24gYXMgbm9uLXBlcnNpc3RlbnQuXG4gKiBSdW50aW1lIGV4aXRzIHdoZW4gdGhlcmUgYXJlIG5vIHBlcnNpc3RlbnQgYXBwcyBydW5uaW5nLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BsdWdpbnM9ZmFsc2VdXG4gKiBFbmFibGUgRmxhc2ggYXQgdGhlIGFwcGxpY2F0aW9uIGxldmVsLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NwZWxsQ2hlY2s9ZmFsc2VdXG4gKiBFbmFibGUgc3BlbGwgY2hlY2sgYXQgdGhlIGFwcGxpY2F0aW9uIGxldmVsLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsPVwiYWJvdXQ6YmxhbmtcIl1cbiAqIFRoZSB1cmwgdG8gdGhlIGFwcGxpY2F0aW9uIChzcGVjaWZpY2FsbHkgdGhlIGFwcGxpY2F0aW9uJ3MgbWFpbiB3aW5kb3cpLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1dWlkXG4gKiBUaGUgX1VuaXF1ZSBVbml2ZXJzYWwgSWRlbnRpZmllcl8gKFVVSUQpIG9mIHRoZSBhcHBsaWNhdGlvbiwgdW5pcXVlIHdpdGhpbiB0aGUgc2V0IG9mIGFsbCBvdGhlciBhcHBsaWNhdGlvbnNcbiAqICBydW5uaW5nIGluIHRoZSBPcGVuRmluIFJ1bnRpbWUuXG4gKlxuICogTm90ZSB0aGF0IGBuYW1lYCBhbmQgYHV1aWRgIG11c3QgbWF0Y2guXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd2ViU2VjdXJpdHk9dHJ1ZV1cbiAqIFdoZW4gc2V0IHRvIGBmYWxzZWAgaXQgd2lsbCBkaXNhYmxlIHRoZSBzYW1lLW9yaWdpbiBwb2xpY3kgZm9yIHRoZSBhcHAuXG4gKi9cbi8qKlxuICogQGxlbmRzIEFwcGxpY2F0aW9uXG4gKi9cbmNsYXNzIEFwcGxpY2F0aW9uTW9kdWxlIGV4dGVuZHMgYmFzZV8xLkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHJldHVybnMgYW4gQXBwbGljYXRpb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBleGlzdGluZyBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0geyBJZGVudGl0eSB9IGlkZW50aXR5XG4gICAgICogQHJldHVybiB7UHJvbWlzZS48QXBwbGljYXRpb24+fVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi53cmFwXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGFzeW5jIHdyYXAoaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3dyYXAtYXBwbGljYXRpb24nKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlcnJvck1zZyA9IHZhbGlkYXRlXzEudmFsaWRhdGVJZGVudGl0eShpZGVudGl0eSk7XG4gICAgICAgIGlmIChlcnJvck1zZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEluc3RhbmNlXzEuQXBwbGljYXRpb24odGhpcy53aXJlLCBpZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzbHkgcmV0dXJucyBhbiBBcHBsaWNhdGlvbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGFuIGV4aXN0aW5nIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7IElkZW50aXR5IH0gaWRlbnRpdHlcbiAgICAgKiBAcmV0dXJuIHtBcHBsaWNhdGlvbn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24ud3JhcFN5bmNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgd3JhcFN5bmMoaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3dyYXAtYXBwbGljYXRpb24tc3luYycpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVycm9yTXNnID0gdmFsaWRhdGVfMS52YWxpZGF0ZUlkZW50aXR5KGlkZW50aXR5KTtcbiAgICAgICAgaWYgKGVycm9yTXNnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFuY2VfMS5BcHBsaWNhdGlvbih0aGlzLndpcmUsIGlkZW50aXR5KTtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZShhcHBPcHRpb25zKSB7XG4gICAgICAgIC8vIHNldCBkZWZhdWx0czpcbiAgICAgICAgaWYgKGFwcE9wdGlvbnMud2FpdEZvclBhZ2VMb2FkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFwcE9wdGlvbnMud2FpdEZvclBhZ2VMb2FkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFwcE9wdGlvbnMuYXV0b1Nob3cgPT09IHVuZGVmaW5lZCAmJiBhcHBPcHRpb25zLmlzUGxhdGZvcm1Db250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFwcE9wdGlvbnMuYXV0b1Nob3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjcmVhdGUtYXBwbGljYXRpb24nLCBhcHBPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh7IHV1aWQ6IGFwcE9wdGlvbnMudXVpZCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogREVQUkVDQVRFRCBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IEFwcGxpY2F0aW9uLiBVc2Uge0BsaW5rIEFwcGxpY2F0aW9uLnN0YXJ0fSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSB7IEFwcGxpY2F0aW9uT3B0aW9uIH0gYXBwT3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPEFwcGxpY2F0aW9uPn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uY3JlYXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGNyZWF0ZShhcHBPcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogZmluLkFwcGxpY2F0aW9uLmNyZWF0ZSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGZpbi5BcHBsaWNhdGlvbi5zdGFydCcpO1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignYXBwbGljYXRpb24tY3JlYXRlJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZShhcHBPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgc3RhcnRzIGEgbmV3IEFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7IEFwcGxpY2F0aW9uT3B0aW9uIH0gYXBwT3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPEFwcGxpY2F0aW9uPn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uc3RhcnRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYXN5bmMgc3RhcnQoYXBwT3B0aW9ucykge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignc3RhcnQtYXBwbGljYXRpb24nKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhcHAgPSBhd2FpdCB0aGlzLl9jcmVhdGUoYXBwT3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdydW4tYXBwbGljYXRpb24nLCB7IHV1aWQ6IGFwcE9wdGlvbnMudXVpZCB9KTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgc3RhcnRzIGEgYmF0Y2ggb2YgYXBwbGljYXRpb25zIGdpdmVuIGFuIGFycmF5IG9mIGFwcGxpY2F0aW9uIGlkZW50aWZpZXJzIGFuZCBtYW5pZmVzdFVybHMuXG4gICAgICogUmV0dXJucyBvbmNlIHRoZSBSVk0gaXMgZmluaXNoZWQgYXR0ZW1wdGluZyB0byBsYXVuY2ggdGhlIGFwcGxpY2F0aW9ucy5cbiAgICAgKiBAcGFyYW0geyBBcnJheS48TWFuaWZlc3RJbmZvPiB9IGFwcGxpY2F0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uc3RhcnRNYW55TWFuaWZlc3RzXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0TWFueU1hbmlmZXN0cyhhcHBsaWNhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdydW4tYXBwbGljYXRpb25zJywgeyBhcHBsaWNhdGlvbnMgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSByZXR1cm5zIGFuIEFwcGxpY2F0aW9uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgYXBwbGljYXRpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxBcHBsaWNhdGlvbj59XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLmdldEN1cnJlbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZ2V0Q3VycmVudCgpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1jdXJyZW50LWFwcGxpY2F0aW9uJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh7IHV1aWQ6IHRoaXMud2lyZS5tZS51dWlkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IHJldHVybnMgYW4gQXBwbGljYXRpb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBhcHBsaWNhdGlvblxuICAgICAqIEByZXR1cm4ge0FwcGxpY2F0aW9ufVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi5nZXRDdXJyZW50U3luY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50U3luYygpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1jdXJyZW50LWFwcGxpY2F0aW9uLXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwU3luYyh7IHV1aWQ6IHRoaXMud2lyZS5tZS51dWlkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYXBwbGljYXRpb24ncyBtYW5pZmVzdCBhbmQgcmV0dXJucyBhIHJ1bm5pbmcgaW5zdGFuY2Ugb2YgdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYW5pZmVzdFVybCAtIFRoZSBVUkwgb2YgYXBwJ3MgbWFuaWZlc3QuXG4gICAgICogQHBhcmFtIHtSdm1MYXVuY2hPcHRpb25zfSBbb3B0c10gLSBQYXJhbWV0ZXJzIHRoYXQgdGhlIFJWTSB3aWxsIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxBcHBsaWNhdGlvbj59XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLnN0YXJ0RnJvbU1hbmlmZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0RnJvbU1hbmlmZXN0KG1hbmlmZXN0VXJsLCBvcHRzKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdhcHBsaWNhdGlvbi1zdGFydC1mcm9tLW1hbmlmZXN0JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXBwID0gYXdhaXQgdGhpcy5fY3JlYXRlRnJvbU1hbmlmZXN0KG1hbmlmZXN0VXJsKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgdXNpbmcgcHJpdmF0ZSBtZXRob2Qgd2l0aG91dCB3YXJuaW5nLlxuICAgICAgICBhd2FpdCBhcHAuX3J1bihvcHRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgICByZXR1cm4gYXBwO1xuICAgIH1cbiAgICBjcmVhdGVGcm9tTWFuaWZlc3QobWFuaWZlc3RVcmwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBmaW4uQXBwbGljYXRpb24uY3JlYXRlRnJvbU1hbmlmZXN0IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgZmluLkFwcGxpY2F0aW9uLnN0YXJ0RnJvbU1hbmlmZXN0Jyk7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdhcHBsaWNhdGlvbi1jcmVhdGUtZnJvbS1tYW5pZmVzdCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVGcm9tTWFuaWZlc3QobWFuaWZlc3RVcmwpO1xuICAgIH1cbiAgICBfY3JlYXRlRnJvbU1hbmlmZXN0KG1hbmlmZXN0VXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmVcbiAgICAgICAgICAgIC5zZW5kQWN0aW9uKCdnZXQtYXBwbGljYXRpb24tbWFuaWZlc3QnLCB7IG1hbmlmZXN0VXJsIH0pXG4gICAgICAgICAgICAudGhlbigoeyBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHV1aWQgPSBwYXlsb2FkLmRhdGEucGxhdGZvcm0gPyBwYXlsb2FkLmRhdGEucGxhdGZvcm0udXVpZCA6IHBheWxvYWQuZGF0YS5zdGFydHVwX2FwcC51dWlkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh7IHV1aWQgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoYXBwKSA9PiB7XG4gICAgICAgICAgICBhcHAuX21hbmlmZXN0VXJsID0gbWFuaWZlc3RVcmw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICAgICAgICAgIHJldHVybiBhcHA7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEFwcGxpY2F0aW9uTW9kdWxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwcGxpY2F0aW9uID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG5jb25zdCB3aW5kb3dfMSA9IHJlcXVpcmUoXCIuLi93aW5kb3dcIik7XG5jb25zdCB2aWV3XzEgPSByZXF1aXJlKFwiLi4vdmlld1wiKTtcbi8qKlxuICogQGNsYXNzZGVzYyBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGFuIGFwcGxpY2F0aW9uLiBBbGxvd3MgdGhlIGRldmVsb3BlciB0byBjcmVhdGUsXG4gKiBleGVjdXRlLCBzaG93L2Nsb3NlIGFuIGFwcGxpY2F0aW9uIGFzIHdlbGwgYXMgbGlzdGVuIHRvIDxhIGhyZWY9XCJ0dXRvcmlhbC1BcHBsaWNhdGlvbi5FdmVudEVtaXR0ZXIuaHRtbFwiPmFwcGxpY2F0aW9uIGV2ZW50czwvYT4uXG4gKiBAY2xhc3NcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQXBwbGljYXRpb24gZXh0ZW5kcyBiYXNlXzEuRW1pdHRlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHdpcmUsIGlkZW50aXR5KSB7XG4gICAgICAgIHN1cGVyKHdpcmUsIFsnYXBwbGljYXRpb24nLCBpZGVudGl0eS51dWlkXSk7XG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICAgICAgdGhpcy53aW5kb3cgPSBuZXcgd2luZG93XzEuX1dpbmRvdyh0aGlzLndpcmUsIHtcbiAgICAgICAgICAgIHV1aWQ6IHRoaXMuaWRlbnRpdHkudXVpZCxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuaWRlbnRpdHkudXVpZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2luZG93TGlzdEZyb21JZGVudGl0eUxpc3QoaWRlbnRpdHlMaXN0KSB7XG4gICAgICAgIGNvbnN0IHdpbmRvd0xpc3QgPSBbXTtcbiAgICAgICAgaWRlbnRpdHlMaXN0LmZvckVhY2goKGlkZW50aXR5KSA9PiB7XG4gICAgICAgICAgICB3aW5kb3dMaXN0LnB1c2gobmV3IHdpbmRvd18xLl9XaW5kb3codGhpcy53aXJlLCB7XG4gICAgICAgICAgICAgICAgdXVpZDogaWRlbnRpdHkudXVpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBpZGVudGl0eS5uYW1lXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd2luZG93TGlzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBDYWxsZWQgd2hlbmV2ZXIgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gYWRkTGlzdGVuZXJcbiAgICAgKiBAbWVtYmVyb2YgQXBwbGljYXRpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBDYWxsZWQgd2hlbmV2ZXIgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gb25cbiAgICAgKiBAbWVtYmVyb2YgQXBwbGljYXRpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG9uZSB0aW1lIGxpc3RlbmVyIGZvciB0aGUgZXZlbnQuIFRoZSBsaXN0ZW5lciBpcyBpbnZva2VkIG9ubHkgdGhlIGZpcnN0IHRpbWUgdGhlIGV2ZW50IGlzIGZpcmVkLCBhZnRlciB3aGljaCBpdCBpcyByZW1vdmVkLlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB8IHN5bWJvbCB9IGV2ZW50VHlwZSAgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgRnVuY3Rpb24gfSBsaXN0ZW5lciAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gb25jZVxuICAgICAqIEBtZW1iZXJvZiBBcHBsaWNhdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi5FdmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB8IHN5bWJvbCB9IGV2ZW50VHlwZSAgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgRnVuY3Rpb24gfSBsaXN0ZW5lciAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyXG4gICAgICogQG1lbWJlcm9mIEFwcGxpY2F0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLkV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBvbmUgdGltZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50LiBUaGUgbGlzdGVuZXIgaXMgaW52b2tlZCBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBldmVudCBpcyBmaXJlZCwgYWZ0ZXIgd2hpY2ggaXQgaXMgcmVtb3ZlZC5cbiAgICAgKiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdGVuZXJzIGFycmF5LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB8IHN5bWJvbCB9IGV2ZW50VHlwZSAgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgRnVuY3Rpb24gfSBsaXN0ZW5lciAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lclxuICAgICAqIEBtZW1iZXJvZiBBcHBsaWNhdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi5FdmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsaXN0ZW5lciBmcm9tIHRoZSBsaXN0ZW5lciBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBDYXV0aW9uOiBDYWxsaW5nIHRoaXMgbWV0aG9kIGNoYW5nZXMgdGhlIGFycmF5IGluZGljZXMgaW4gdGhlIGxpc3RlbmVyIGFycmF5IGJlaGluZCB0aGUgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIHwgc3ltYm9sIH0gZXZlbnRUeXBlICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB9IGxpc3RlbmVyIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7IFN1Yk9wdGlvbnMgfSBbb3B0aW9uc10gLSBPcHRpb24gdG8gc3VwcG9ydCBldmVudCB0aW1lc3RhbXBzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fVxuICAgICAqIEBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lclxuICAgICAqIEBtZW1iZXJvZiBBcHBsaWNhdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi5FdmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIHwgc3ltYm9sIH0gW2V2ZW50VHlwZV0gIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fVxuICAgICAqIEBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnNcbiAgICAgKiBAbWVtYmVyb2YgQXBwbGljYXRpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgYXBwbGljYXRpb24gaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48Ym9vbGVhbj59XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLmlzUnVubmluZ1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEp1bXBMaXN0Q2F0ZWdvcnkgaW50ZXJmYWNlXG4gICAgICogQHR5cGVkZWYgeyBvYmplY3QgfSBKdW1wTGlzdENhdGVnb3J5XG4gICAgICogQHByb3BlcnR5IHsgc3RyaW5nIH0gbmFtZSBUaGUgZGlzcGxheSB0aXRsZSBmb3IgdGhlIGNhdGVnb3J5LiBJZiBvbWl0dGVkLCBpdGVtcyBpbiB0aGlzIGNhdGVnb3J5IHdpbGwgYmUgcGxhY2VkIGludG8gdGhlIHN0YW5kYXJkICdUYXNrcycgY2F0ZWdvcnkuIFRoZXJlIGNhbiBiZSBvbmx5IG9uZSBzdWNoIGNhdGVnb3J5LCBhbmQgaXQgd2lsbCBhbHdheXMgYmUgZGlzcGxheWVkIGF0IHRoZSBib3R0b20gb2YgdGhlIEp1bXBMaXN0LlxuICAgICAqIEBwcm9wZXJ0eSB7IEp1bXBMaXN0SXRlbVtdIH0gaXRlbXMgQXJyYXkgb2YgSnVtcExpc3RJdGVtIG9iamVjdHNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBKdW1wTGlzdEl0ZW0gaW50ZXJmYWNlXG4gICAgICogQHR5cGVkZWYgeyBvYmplY3QgfSBKdW1wTGlzdEl0ZW1cbiAgICAgKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB0eXBlIE9uZSBvZiB0aGUgZm9sbG93aW5nOiBcInRhc2tcIiBvciBcInNlcGFyYXRvclwiLiBEZWZhdWx0cyB0byB0YXNrLlxuICAgICAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHRpdGxlIFRoZSB0ZXh0IHRvIGJlIGRpc3BsYXllZCBmb3IgdGhlIEp1bXBMaXN0IEl0ZW0uIFNob3VsZCBvbmx5IGJlIHNldCBpZiB0eXBlIGlzIFwidGFza1wiLlxuICAgICAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IGRlc2NyaXB0aW9uIERlc2NyaXB0aW9uIG9mIHRoZSB0YXNrIChkaXNwbGF5ZWQgaW4gYSB0b29sdGlwKS4gU2hvdWxkIG9ubHkgYmUgc2V0IGlmIHR5cGUgaXMgXCJ0YXNrXCIuXG4gICAgICogQHByb3BlcnR5IHsgc3RyaW5nIH0gZGVlcExpbmsgRGVlcCBsaW5rIHRvIGEgbWFuaWZlc3QsIGkuZTogZmluczovL3BhdGgudG8vbWFuaWZlc3QuanNvbj8kJHBhcmFtMT12YWx1ZTEuIFNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLm9wZW5maW4uY28vZG9jcy9kZWVwLWxpbmtpbmcgZGVlcC1saW5raW5nfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBpY29uUGF0aCBUaGUgYWJzb2x1dGUgcGF0aCB0byBhbiBpY29uIHRvIGJlIGRpc3BsYXllZCBmb3IgdGhlIGl0ZW0sIHdoaWNoIGNhbiBiZSBhbiBhcmJpdHJhcnkgcmVzb3VyY2UgZmlsZSB0aGF0IGNvbnRhaW5zIGFuIGljb24gKGUuZy4gLmljbywgLmV4ZSwgLmRsbCkuXG4gICAgICogQHByb3BlcnR5IHsgbnVtYmVyIH0gaWNvbkluZGV4IFRoZSBpbmRleCBvZiB0aGUgaWNvbiBpbiB0aGUgcmVzb3VyY2UgZmlsZS4gSWYgYSByZXNvdXJjZSBmaWxlIGNvbnRhaW5zIG11bHRpcGxlIGljb25zIHRoaXMgdmFsdWUgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgemVyby1iYXNlZCBpbmRleCBvZiB0aGUgaWNvbiB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgZm9yIHRoaXMgdGFzay4gSWYgYSByZXNvdXJjZSBmaWxlIGNvbnRhaW5zIG9ubHkgb25lIGljb24sIHRoaXMgcHJvcGVydHkgc2hvdWxkIGJlIHNldCB0byB6ZXJvLlxuICAgICAqL1xuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpcy1hcHBsaWNhdGlvbi1ydW5uaW5nJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgYXBwbGljYXRpb24gYW5kIGFueSBjaGlsZCB3aW5kb3dzIGNyZWF0ZWQgYnkgdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqIENsZWFucyB0aGUgYXBwbGljYXRpb24gZnJvbSBzdGF0ZSBzbyBpdCBpcyBubyBsb25nZXIgZm91bmQgaW4gZ2V0QWxsQXBwbGljYXRpb25zLlxuICAgICAqIEBwYXJhbSB7IGJvb2xlYW4gfSBbZm9yY2UgPSBmYWxzZV0gQ2xvc2Ugd2lsbCBiZSBwcmV2ZW50ZWQgZnJvbSBjbG9zaW5nIHdoZW4gZm9yY2UgaXMgZmFsc2UgYW5kXG4gICAgICogIOKAmGNsb3NlLXJlcXVlc3RlZOKAmSBoYXMgYmVlbiBzdWJzY3JpYmVkIHRvIGZvciBhcHBsaWNhdGlvbuKAmXMgbWFpbiB3aW5kb3cuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48Ym9vbGVhbj59XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLnF1aXRcbiAgICAgKi9cbiAgICBhc3luYyBxdWl0KGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fY2xvc2UoZm9yY2UpO1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZGVzdHJveS1hcHBsaWNhdGlvbicsIHsgZm9yY2UsIC4uLnRoaXMuaWRlbnRpdHkgfSk7XG4gICAgfVxuICAgIF9jbG9zZShmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignY2xvc2UtYXBwbGljYXRpb24nLCB7IGZvcmNlLCAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY2xvc2UoZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFwcGxpY2F0aW9uLmNsb3NlIGlzIGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBBcHBsaWNhdGlvbi5xdWl0Jyk7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdhcHBsaWNhdGlvbi1jbG9zZScsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZShmb3JjZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhcnJheSBvZiB3cmFwcGVkIGZpbi5XaW5kb3dzIGZvciBlYWNoIG9mIHRoZSBhcHBsaWNhdGlvbuKAmXMgY2hpbGQgd2luZG93cy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLkFycmF5LjxfV2luZG93Pn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uZ2V0Q2hpbGRXaW5kb3dzXG4gICAgICovXG4gICAgZ2V0Q2hpbGRXaW5kb3dzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1jaGlsZC13aW5kb3dzJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aXR5TGlzdCA9IFtdO1xuICAgICAgICAgICAgcGF5bG9hZC5kYXRhLmZvckVhY2goKHdpbk5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZGVudGl0eUxpc3QucHVzaCh7IHV1aWQ6IHRoaXMuaWRlbnRpdHkudXVpZCwgbmFtZTogd2luTmFtZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2luZG93TGlzdEZyb21JZGVudGl0eUxpc3QoaWRlbnRpdHlMaXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhcnJheSBvZiBhY3RpdmUgd2luZG93IGdyb3VwcyBmb3IgYWxsIG9mIHRoZSBhcHBsaWNhdGlvbidzIHdpbmRvd3MuIEVhY2ggZ3JvdXAgaXNcbiAgICAgKiByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiB3cmFwcGVkIGZpbi5XaW5kb3dzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuQXJyYXkuQXJyYXkuPF9XaW5kb3c+fVxuICAgICAqIEBkZXByZWNhdGVkIEFsbCBXaW5kb3cgR3JvdXAgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uZ2V0R3JvdXBzXG4gICAgICovXG4gICAgZ2V0R3JvdXBzKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBXaW5kb3cgR3JvdXAgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgY29uc3Qgd2luR3JvdXBzID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLndpcmVcbiAgICAgICAgICAgIC5zZW5kQWN0aW9uKCdnZXQtYXBwbGljYXRpb24tZ3JvdXBzJywge1xuICAgICAgICAgICAgY3Jvc3NBcHA6IHRydWUsXG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoeyBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgICAgIHBheWxvYWQuZGF0YS5mb3JFYWNoKCh3aW5kb3dMaXN0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aXR5TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHdpbmRvd0xpc3QuZm9yRWFjaCgod2luSW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZGVudGl0eUxpc3QucHVzaCh7IHV1aWQ6IHdpbkluZm8udXVpZCwgbmFtZTogd2luSW5mby53aW5kb3dOYW1lIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpbkdyb3Vwc1tpbmRleF0gPSB0aGlzLndpbmRvd0xpc3RGcm9tSWRlbnRpdHlMaXN0KGlkZW50aXR5TGlzdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB3aW5Hcm91cHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIEpTT04gbWFuaWZlc3QgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgdGhlIGFwcGxpY2F0aW9uLiBJbnZva2VzIHRoZSBlcnJvciBjYWxsYmFja1xuICAgICAqIGlmIHRoZSBhcHBsaWNhdGlvbiB3YXMgbm90IGNyZWF0ZWQgZnJvbSBhIG1hbmlmZXN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPGFueT59XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLmdldE1hbmlmZXN0XG4gICAgICovXG4gICAgZ2V0TWFuaWZlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWFwcGxpY2F0aW9uLW1hbmlmZXN0JywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBVVUlEIG9mIHRoZSBhcHBsaWNhdGlvbiB0aGF0IGxhdW5jaGVzIHRoaXMgYXBwbGljYXRpb24uIEludm9rZXMgdGhlIGVycm9yIGNhbGxiYWNrXG4gICAgICogaWYgdGhlIGFwcGxpY2F0aW9uIHdhcyBjcmVhdGVkIGZyb20gYSBtYW5pZmVzdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxzdHJpbmc+fVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi5nZXRQYXJlbnRVdWlkXG4gICAgICovXG4gICAgZ2V0UGFyZW50VXVpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtcGFyZW50LWFwcGxpY2F0aW9uJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBjdXJyZW50IGFwcGxpY2F0aW9uJ3Mgc2hvcnRjdXQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxTaG9ydEN1dENvbmZpZz59XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLmdldFNob3J0Y3V0c1xuICAgICAqL1xuICAgIGdldFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtc2hvcnRjdXRzJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBjdXJyZW50IGFwcGxpY2F0aW9uJ3Mgdmlld3MuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuQXJyYXkuPFZpZXc+fVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi5nZXRWaWV3c1xuICAgICAqL1xuICAgIGFzeW5jIGdldFZpZXdzKCkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdhcHBsaWNhdGlvbi1nZXQtdmlld3MnLCB0aGlzLmlkZW50aXR5KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQuZGF0YS5tYXAoKGlkKSA9PiBuZXcgdmlld18xLlZpZXcodGhpcy53aXJlLCBpZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPG51bWJlcj59XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLmdldFpvb21MZXZlbFxuICAgICAqL1xuICAgIGdldFpvb21MZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtYXBwbGljYXRpb24tem9vbS1sZXZlbCcsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIHRoZSBtYWluIFdpbmRvdyBvZiB0aGUgYXBwbGljYXRpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxfV2luZG93Pn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uZ2V0V2luZG93XG4gICAgICovXG4gICAgZ2V0V2luZG93KCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignYXBwbGljYXRpb24tZ2V0LXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy53aW5kb3cpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSByZWdpc3RlcnMgYSB1c2VyIHdpdGggdGhlIGxpY2Vuc2luZyBzZXJ2aWNlLiBUaGUgb25seSBkYXRhIHNlbnQgYnkgdGhpcyBjYWxsIGlzIHVzZXJOYW1lIGFuZCBhcHBOYW1lLlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHVzZXJOYW1lIC0gdXNlcm5hbWUgdG8gYmUgcGFzc2VkIHRvIHRoZSBSVk0uXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gYXBwTmFtZSAtIGFwcCBuYW1lIHRvIGJlIHBhc3NlZCB0byB0aGUgUlZNLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi5yZWdpc3RlclVzZXJcbiAgICAgKi9cbiAgICByZWdpc3RlclVzZXIodXNlck5hbWUsIGFwcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdyZWdpc3Rlci11c2VyJywgeyB1c2VyTmFtZSwgYXBwTmFtZSwgLi4udGhpcy5pZGVudGl0eSB9KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGFwcGxpY2F0aW9u4oCZcyBpY29uIGZyb20gdGhlIHRyYXkuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLnJlbW92ZVRyYXlJY29uXG4gICAgICovXG4gICAgcmVtb3ZlVHJheUljb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigncmVtb3ZlLXRyYXktaWNvbicsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdGFydHMgdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi5yZXN0YXJ0XG4gICAgICovXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdyZXN0YXJ0LWFwcGxpY2F0aW9uJywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBERVBSRUNBVEVEIG1ldGhvZCB0byBydW4gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqIE5lZWRlZCB3aGVuIHN0YXJ0aW5nIGFwcGxpY2F0aW9uIHZpYSB7QGxpbmsgQXBwbGljYXRpb24uY3JlYXRlfSwgYnV0IE5PVCBuZWVkZWQgd2hlbiBzdGFydGluZyB2aWEge0BsaW5rIEFwcGxpY2F0aW9uLnN0YXJ0fS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24ucnVuXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJ1bigpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBcHBsaWNhdGlvbi5ydW4gaXMgZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGZpbi5BcHBsaWNhdGlvbi5zdGFydCcpO1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignYXBwbGljYXRpb24tcnVuJywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bigpO1xuICAgIH1cbiAgICBfcnVuKG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlXG4gICAgICAgICAgICAuc2VuZEFjdGlvbigncnVuLWFwcGxpY2F0aW9uJywge1xuICAgICAgICAgICAgbWFuaWZlc3RVcmw6IHRoaXMuX21hbmlmZXN0VXJsLFxuICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgIC4uLnRoaXMuaWRlbnRpdHlcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RydWN0cyB0aGUgUlZNIHRvIHNjaGVkdWxlIG9uZSByZXN0YXJ0IG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uc2NoZWR1bGVSZXN0YXJ0XG4gICAgICovXG4gICAgc2NoZWR1bGVSZXN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3JlbGF1bmNoLW9uLWNsb3NlJywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIFJWTSB0byB1cGxvYWQgdGhlIGFwcGxpY2F0aW9uJ3MgbG9ncy4gT24gc3VjY2VzcyxcbiAgICAgKiBhbiBvYmplY3QgY29udGFpbmluZyBsb2dJZCBpcyByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxMb2dJbmZvPn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uc2VuZEFwcGxpY2F0aW9uTG9nXG4gICAgICovXG4gICAgYXN5bmMgc2VuZEFwcGxpY2F0aW9uTG9nKCkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZW5kLWFwcGxpY2F0aW9uLWxvZycsIHRoaXMuaWRlbnRpdHkpO1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIHJlbW92ZXMgYSBjdXN0b20gSnVtcExpc3QgZm9yIHRoZSBhcHBsaWNhdGlvbi4gT25seSBhcHBsaWNhYmxlIGluIFdpbmRvd3MgT1MuXG4gICAgICogSWYgY2F0ZWdvcmllcyBpcyBudWxsIHRoZSBwcmV2aW91c2x5IHNldCBjdXN0b20gSnVtcExpc3QgKGlmIGFueSkgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgc3RhbmRhcmQgSnVtcExpc3QgZm9yIHRoZSBhcHAgKG1hbmFnZWQgYnkgV2luZG93cykuXG4gICAgICogTm90ZTogSWYgdGhlIFwibmFtZVwiIHByb3BlcnR5IGlzIG9taXR0ZWQgaXQgZGVmYXVsdHMgdG8gXCJ0YXNrc1wiLlxuICAgICAqIEBwYXJhbSB7IEFycmF5LjxKdW1wTGlzdENhdGVnb3J5PiB8IG51bGwgfSBqdW1wTGlzdENhdGVnb3JpZXMgQW4gYXJyYXkgb2YgSnVtcExpc3QgQ2F0ZWdvcmllcyB0byBwb3B1bGF0ZS4gSWYgbnVsbCwgcmVtb3ZlIGFueSBleGlzdGluZyBKdW1wTGlzdCBjb25maWd1cmF0aW9uIGFuZCBzZXQgdG8gV2luZG93cyBkZWZhdWx0LlxuICAgICAqIEByZXR1cm4geyBQcm9taXNlLjx2b2lkPiB9XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLnNldEp1bXBMaXN0XG4gICAgICovXG4gICAgYXN5bmMgc2V0SnVtcExpc3QoanVtcExpc3RDYXRlZ29yaWVzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZXQtanVtcC1saXN0JywgeyBjb25maWc6IGp1bXBMaXN0Q2F0ZWdvcmllcywgLi4udGhpcy5pZGVudGl0eSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGN1c3RvbWl6YWJsZSBpY29uIGluIHRoZSBzeXN0ZW0gdHJheS4gIFRvIGxpc3RlbiBmb3IgYSBjbGljayBvbiB0aGUgaWNvbiB1c2UgdGhlIGB0cmF5LWljb24tY2xpY2tlZGAgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gaWNvbiBJbWFnZSBVUkwgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGJlIHVzZWQgYXMgdGhlIGljb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uc2V0VHJheUljb25cbiAgICAgKi9cbiAgICBzZXRUcmF5SWNvbihpY29uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmVcbiAgICAgICAgICAgIC5zZW5kQWN0aW9uKCdzZXQtdHJheS1pY29uJywge1xuICAgICAgICAgICAgZW5hYmxlZEljb246IGljb24sXG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG5ldyBhcHBsaWNhdGlvbidzIHNob3J0Y3V0IGNvbmZpZ3VyYXRpb24uIFdpbmRvd3Mgb25seS5cbiAgICAgKiBAcGFyYW0geyBTaG9ydEN1dENvbmZpZyB9IGNvbmZpZyBOZXcgYXBwbGljYXRpb24ncyBzaG9ydGN1dCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7IGJvb2xlYW4gfSBbY29uZmlnLmRlc2t0b3BdIC0gRW5hYmxlL2Rpc2FibGUgZGVza3RvcCBzaG9ydGN1dC5cbiAgICAgKiBAcGFyYW0geyBib29sZWFuIH0gW2NvbmZpZy5zdGFydE1lbnVdIC0gRW5hYmxlL2Rpc2FibGUgc3RhcnQgbWVudSBzaG9ydGN1dC5cbiAgICAgKiBAcGFyYW0geyBib29sZWFuIH0gW2NvbmZpZy5zeXN0ZW1TdGFydHVwXSAtIEVuYWJsZS9kaXNhYmxlIHN5c3RlbSBzdGFydHVwIHNob3J0Y3V0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi5zZXRTaG9ydGN1dHNcbiAgICAgKi9cbiAgICBzZXRTaG9ydGN1dHMoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignc2V0LXNob3J0Y3V0cycsIHsgZGF0YTogY29uZmlnLCAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcXVlcnkgc3RyaW5nIGluIGFsbCBzaG9ydGN1dHMgZm9yIHRoaXMgYXBwLiBSZXF1aXJlcyBSVk0gNS41Ky5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSBxdWVyeVN0cmluZyBUaGUgbmV3IHF1ZXJ5IHN0cmluZyBmb3IgdGhpcyBhcHAncyBzaG9ydGN1dHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLnNldFNob3J0Y3V0UXVlcnlQYXJhbXNcbiAgICAgKi9cbiAgICBhc3luYyBzZXRTaG9ydGN1dFF1ZXJ5UGFyYW1zKHF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZXQtc2hvcnRjdXQtcXVlcnktYXJncycsIHsgZGF0YTogcXVlcnlTdHJpbmcsIC4uLnRoaXMuaWRlbnRpdHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIGFwcGxpY2F0aW9uLiBUaGUgb3JpZ2luYWwgc2l6ZSBpcyAwIGFuZCBlYWNoIGluY3JlbWVudCBhYm92ZSBvciBiZWxvdyByZXByZXNlbnRzIHpvb21pbmcgMjAlXG4gICAgICogbGFyZ2VyIG9yIHNtYWxsZXIgdG8gZGVmYXVsdCBsaW1pdHMgb2YgMzAwJSBhbmQgNTAlIG9mIG9yaWdpbmFsIHNpemUsIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyBudW1iZXIgfSBsZXZlbCBUaGUgem9vbSBsZXZlbFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi5zZXRab29tTGV2ZWxcbiAgICAgKi9cbiAgICBzZXRab29tTGV2ZWwobGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZXQtYXBwbGljYXRpb24tem9vbS1sZXZlbCcsIHsgbGV2ZWwsIC4uLnRoaXMuaWRlbnRpdHkgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdXNlcm5hbWUgdG8gY29ycmVsYXRlIHdpdGggQXBwIExvZyBNYW5hZ2VtZW50LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHVzZXJuYW1lIFVzZXJuYW1lIHRvIGNvcnJlbGF0ZSB3aXRoIEFwcCdzIExvZy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uc2V0QXBwTG9nVXNlcm5hbWVcbiAgICAgKi9cbiAgICBhc3luYyBzZXRBcHBMb2dVc2VybmFtZSh1c2VybmFtZSkge1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignc2V0LWFwcC1sb2ctdXNlcm5hbWUnLCB7IGRhdGE6IHVzZXJuYW1lLCAuLi50aGlzLmlkZW50aXR5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN5c3RlbSB0cmF5LlxuICAgICAqIEBkZXNjIFRoZSBvbmx5IGluZm9ybWF0aW9uIGN1cnJlbnRseSByZXR1cm5lZCBpcyB0aGUgcG9zaXRpb24gYW5kIGRpbWVuc2lvbnMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48VHJheUluZm8+fVxuICAgICAqIEB0dXRvcmlhbCBBcHBsaWNhdGlvbi5nZXRUcmF5SWNvbkluZm9cbiAgICAgKi9cbiAgICBnZXRUcmF5SWNvbkluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXRyYXktaWNvbi1pbmZvJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgYXBwbGljYXRpb24gYnkgdGVybWluYXRpbmcgaXRzIHByb2Nlc3MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLnRlcm1pbmF0ZVxuICAgICAqL1xuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd0ZXJtaW5hdGUtYXBwbGljYXRpb24nLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciBhIGhhbmdpbmcgYXBwbGljYXRpb24uIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gYXBwbGljYXRpb25cbiAgICAgKiBcIm5vdC1yZXNwb25kaW5nXCIgdG8gYWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGNvbnRpbnVlIGFuZCB0byBnZW5lcmF0ZSBhbm90aGVyIFwibm90LXJlc3BvbmRpbmdcIlxuICAgICAqIG1lc3NhZ2UgYWZ0ZXIgYSBjZXJ0YWluIHBlcmlvZCBvZiB0aW1lLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB3YWl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3dhaXQtZm9yLWh1bmctYXBwbGljYXRpb24nLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYXBwbGljYXRpb24uXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48QXBwbGljYXRpb25JbmZvPn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uZ2V0SW5mb1xuICAgICAqL1xuICAgIGdldEluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWluZm8nLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBwcm9jZXNzIGluZm9ybWF0aW9uIGZvciBlbnRpdGllcyAod2luZG93cyBhbmQgdmlld3MpIGFzc29jaWF0ZWQgd2l0aCBhbiBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxBcHBQcm9jZXNzSW5mbz59XG4gICAgICogQHR1dG9yaWFsIEFwcGxpY2F0aW9uLmdldFByb2Nlc3NJbmZvXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb2Nlc3NJbmZvKCkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YSB9IH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignYXBwbGljYXRpb24tZ2V0LXByb2Nlc3MtaW5mbycsIHRoaXMuaWRlbnRpdHkpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBmaWxlIGF1dG8gZG93bmxvYWQgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gZG93bmxvYWRMb2NhdGlvbiBmaWxlIGF1dG8gZG93bmxvYWQgbG9jYXRpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgQXBwbGljYXRpb24uc2V0RmlsZURvd25sb2FkTG9jYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBzZXRGaWxlRG93bmxvYWRMb2NhdGlvbihkb3dubG9hZExvY2F0aW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZXQtZmlsZS1kb3dubG9hZC1sb2NhdGlvbicsIHsgZG93bmxvYWRMb2NhdGlvbiwgLi4udGhpcy5pZGVudGl0eSB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFwcGxpY2F0aW9uID0gQXBwbGljYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRmFjdG9yeV8xID0gcmVxdWlyZShcIi4vRmFjdG9yeVwiKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JbnN0YW5jZVwiKSwgZXhwb3J0cyk7XG5leHBvcnRzLmRlZmF1bHQgPSBGYWN0b3J5XzEuZGVmYXVsdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXBseSA9IGV4cG9ydHMuRW1pdHRlckJhc2UgPSBleHBvcnRzLkJhc2UgPSB2b2lkIDA7XG5jb25zdCBwcm9taXNlc18xID0gcmVxdWlyZShcIi4uL3V0aWwvcHJvbWlzZXNcIik7XG5jb25zdCBmaW5fc3RvcmVfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnQvZmluX3N0b3JlXCIpO1xuY2xhc3MgQmFzZSB7XG4gICAgY29uc3RydWN0b3Iod2lyZSkge1xuICAgICAgICB0aGlzLmlzTm9kZUVudmlyb25tZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5lbnZpcm9ubWVudC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnTm9kZUVudmlyb25tZW50JztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc09wZW5GaW5FbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpcmUuZW52aXJvbm1lbnQuY29uc3RydWN0b3IubmFtZSA9PT0gJ09wZW5GaW5FbnZpcm9ubWVudCc7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2lyZSA9IHdpcmU7XG4gICAgfVxuICAgIGdldCBmaW4oKSB7XG4gICAgICAgIHJldHVybiBmaW5fc3RvcmVfMS5nZXRGaW4odGhpcy53aXJlKTtcbiAgICB9XG4gICAgZ2V0IHRvcGljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9waWMgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnJlcGxhY2UoJ18nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgc2V0IHRvcGljKHQpIHtcbiAgICAgICAgdGhpcy5fdG9waWMgPSB0O1xuICAgIH1cbiAgICBnZXQgbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUubWU7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlID0gQmFzZTtcbmNsYXNzIEVtaXR0ZXJCYXNlIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3Iod2lyZSwgZW1pdHRlckFjY2Vzc29yKSB7XG4gICAgICAgIHN1cGVyKHdpcmUpO1xuICAgICAgICB0aGlzLmVtaXR0ZXJBY2Nlc3NvciA9IGVtaXR0ZXJBY2Nlc3NvcjtcbiAgICAgICAgdGhpcy5ldmVudE5hbWVzID0gKCkgPT4gKHRoaXMuaGFzRW1pdHRlcigpID8gdGhpcy5nZXRPckNyZWF0ZUVtaXR0ZXIoKS5ldmVudE5hbWVzKCkgOiBbXSk7XG4gICAgICAgIHRoaXMuZW1pdCA9IChldmVudE5hbWUsIHBheWxvYWQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0VtaXR0ZXIoKSA/IHRoaXMuZ2V0T3JDcmVhdGVFbWl0dGVyKCkuZW1pdChldmVudE5hbWUsIHBheWxvYWQsIC4uLmFyZ3MpIDogZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFzRW1pdHRlciA9ICgpID0+IHRoaXMud2lyZS5ldmVudEFnZ3JlZ2F0b3IuaGFzKHRoaXMuZW1pdHRlckFjY2Vzc29yKTtcbiAgICAgICAgdGhpcy5nZXRPckNyZWF0ZUVtaXR0ZXIgPSAoKSA9PiB0aGlzLndpcmUuZXZlbnRBZ2dyZWdhdG9yLmdldE9yQ3JlYXRlKHRoaXMuZW1pdHRlckFjY2Vzc29yKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSAodHlwZSkgPT4gdGhpcy5oYXNFbWl0dGVyKCkgPyB0aGlzLmdldE9yQ3JlYXRlRW1pdHRlcigpLmxpc3RlbmVycyh0eXBlKSA6IFtdO1xuICAgICAgICB0aGlzLmxpc3RlbmVyQ291bnQgPSAodHlwZSkgPT4gdGhpcy5oYXNFbWl0dGVyKCkgPyB0aGlzLmdldE9yQ3JlYXRlRW1pdHRlcigpLmxpc3RlbmVyQ291bnQodHlwZSkgOiAwO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lciA9IGFzeW5jIChldmVudFR5cGUsIG9wdGlvbnMgPSB7fSwgYXBwbHlTdWJzY3JpcHRpb24sIHVuZG9TdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bnRpbWVFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5LFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogb3B0aW9ucy50aW1lc3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICB0b3BpYzogdGhpcy50b3BpYyxcbiAgICAgICAgICAgICAgICB0eXBlOiBldmVudFR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBlbWl0dGVyID0gdGhpcy5nZXRPckNyZWF0ZUVtaXR0ZXIoKTtcbiAgICAgICAgICAgIC8vIFdlIGFwcGx5IHRoZSBzdWJzY3JpcHRpb24gYW5kIHRoZW4gdW5kbyBpZiB0aGUgYXN5bmMgY2FsbCBmYWlscyB0byBhdm9pZFxuICAgICAgICAgICAgLy8gaW5kZXRlcm1pbmFjeSBpbiBzdWJzY3JpcHRpb24gYXBwbGljYXRpb24gb3JkZXIsIHdoaWNoIGNhbiBicmVhayB0aGluZ3MgZWxzZXdoZXJlXG4gICAgICAgICAgICBhcHBseVN1YnNjcmlwdGlvbihlbWl0dGVyKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3N1YnNjcmliZS10by1kZXNrdG9wLWV2ZW50JywgcnVudGltZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdW5kb1N1YnNjcmlwdGlvbihlbWl0dGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZUVtaXR0ZXJJZk5vdGhpbmdSZWdpc3RlcmVkKGVtaXR0ZXIpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVyZWdpc3RlckV2ZW50TGlzdGVuZXIgPSBhc3luYyAoZXZlbnRUeXBlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0VtaXR0ZXIoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bnRpbWVFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5pZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCB8fCBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICB0b3BpYzogdGhpcy50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZXZlbnRUeXBlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbigndW5zdWJzY3JpYmUtdG8tZGVza3RvcC1ldmVudCcsIHJ1bnRpbWVFdmVudCkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1pdHRlciA9IHRoaXMuZ2V0T3JDcmVhdGVFbWl0dGVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgb25seSBiZSByZWFjaGVkIGlmIHVuc3Vic2NyaWJlIGZyb20gZXZlbnQgdGhhdCBkb2VzIG5vdCBleGlzdCBidXQgZG8gbm90IHdhbnQgdG8gZXJyb3IgaGVyZVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uID0gYXN5bmMgKGV2ZW50VHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgb3B0aW9ucywgKGVtaXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLm9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSwgKGVtaXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRMaXN0ZW5lciA9IHRoaXMub247XG4gICAgICAgIHRoaXMub25jZSA9IGFzeW5jIChldmVudFR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXJlZ2lzdGVyID0gKCkgPT4gdGhpcy5kZXJlZ2lzdGVyRXZlbnRMaXN0ZW5lcihldmVudFR5cGUpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWdpc3RlckV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBvcHRpb25zLCAoZW1pdHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIub25jZShldmVudFR5cGUsIGRlcmVnaXN0ZXIpO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIub25jZShldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0sIChlbWl0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudFR5cGUsIGRlcmVnaXN0ZXIpO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lciA9IGFzeW5jIChldmVudFR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZ2lzdGVyRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIG9wdGlvbnMsIChlbWl0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9LCAoZW1pdHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBhc3luYyAoZXZlbnRUeXBlLCBsaXN0ZW5lciwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVyZWdpc3RlciA9ICgpID0+IHRoaXMuZGVyZWdpc3RlckV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVnaXN0ZXJFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgb3B0aW9ucywgKGVtaXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLnByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5vbmNlKGV2ZW50VHlwZSwgZGVyZWdpc3Rlcik7XG4gICAgICAgICAgICB9LCAoZW1pdHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudFR5cGUsIGRlcmVnaXN0ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IGFzeW5jIChldmVudFR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbWl0dGVyID0gYXdhaXQgdGhpcy5kZXJlZ2lzdGVyRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGVtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlRW1pdHRlcklmTm90aGluZ1JlZ2lzdGVyZWQoZW1pdHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZXJlZ2lzdGVyQWxsTGlzdGVuZXJzID0gYXN5bmMgKGV2ZW50VHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcnVudGltZUV2ZW50ID0geyAuLi50aGlzLmlkZW50aXR5LCB0eXBlOiBldmVudFR5cGUsIHRvcGljOiB0aGlzLnRvcGljIH07XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNFbWl0dGVyKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWl0dGVyID0gdGhpcy5nZXRPckNyZWF0ZUVtaXR0ZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZDb3VudCA9IGVtaXR0ZXIubGlzdGVuZXJDb3VudChydW50aW1lRXZlbnQudHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZVByb21pc2VzLnB1c2godGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Vuc3Vic2NyaWJlLXRvLWRlc2t0b3AtZXZlbnQnLCBydW50aW1lRXZlbnQpLmNhdGNoKCgpID0+IG51bGwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodW5zdWJzY3JpYmVQcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyA9IGFzeW5jIChldmVudFR5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZUJ5RXZlbnQgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWl0dGVyID0gYXdhaXQgdGhpcy5kZXJlZ2lzdGVyQWxsTGlzdGVuZXJzKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZW1pdHRlcikge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlRW1pdHRlcklmTm90aGluZ1JlZ2lzdGVyZWQoZW1pdHRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmVCeUV2ZW50KGV2ZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0VtaXR0ZXIoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuZ2V0T3JDcmVhdGVFbWl0dGVyKCkuZXZlbnROYW1lcygpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHByb21pc2VzXzEucHJvbWlzZU1hcChldmVudHMsIHJlbW92ZUJ5RXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gKGV2ZW50KSA9PiB0aGlzLmhhc0VtaXR0ZXIoKSA/IHRoaXMuZ2V0T3JDcmVhdGVFbWl0dGVyKCkubGlzdGVuZXJzKGV2ZW50KSA6IFtdO1xuICAgIH1cbiAgICBkZWxldGVFbWl0dGVySWZOb3RoaW5nUmVnaXN0ZXJlZChlbWl0dGVyKSB7XG4gICAgICAgIGlmIChlbWl0dGVyLmV2ZW50TmFtZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMud2lyZS5ldmVudEFnZ3JlZ2F0b3IuZGVsZXRlKHRoaXMuZW1pdHRlckFjY2Vzc29yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW1pdHRlckJhc2UgPSBFbWl0dGVyQmFzZTtcbmNsYXNzIFJlcGx5IHtcbn1cbmV4cG9ydHMuUmVwbHkgPSBSZXBseTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIFdyaXRlUmVxdWVzdFR5cGUgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFdyaXRlUmVxdWVzdFR5cGVcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IGRhdGEgRGF0YSB0byBiZSB3cml0dGVuXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBbdHlwZV0gQ2xpcGJvYXJkIFR5cGVcbiAqL1xuLyoqXG4gKiBUaGUgQ2xpcGJvYXJkIEFQSSBhbGxvd3MgcmVhZGluZyBhbmQgd3JpdGluZyB0byB0aGUgY2xpcGJvYXJkIGluIG11bHRpcGxlIGZvcm1hdHMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbmNsYXNzIENsaXBib2FyZCBleHRlbmRzIGJhc2VfMS5CYXNlIHtcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgZGF0YSBpbnRvIHRoZSBjbGlwYm9hcmQgYXMgcGxhaW4gdGV4dFxuICAgICAqIEBwYXJhbSB7IFdyaXRlUmVxdWVzdFR5cGUgfSB3cml0ZU9iaiBUaGlzIG9iamVjdCBpcyBkZXNjcmliZWQgaW4gdGhlIFdyaXRlUmVxdWVzdFR5cGUgdHlwZW9mXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIENsaXBib2FyZC53cml0ZVRleHRcbiAgICAgKi9cbiAgICB3cml0ZVRleHQod3JpdGVPYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbGlwYm9hcmQtd3JpdGUtdGV4dCcsIHdyaXRlT2JqKS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNvbnRlbnQgb2YgdGhlIGNsaXBib2FyZCBhcyBwbGFpbiB0ZXh0XG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gdHlwZSBDbGlwYm9hcmQgVHlwZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHN0cmluZz59XG4gICAgICogQHR1dG9yaWFsIENsaXBib2FyZC5yZWFkVGV4dFxuICAgICAqL1xuICAgIHJlYWRUZXh0KHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbGlwYm9hcmQtcmVhZC10ZXh0JywgdHlwZSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBkYXRhIGludG8gdGhlIGNsaXBib2FyZCBhcyBIdG1sXG4gICAgICogQHBhcmFtIHsgV3JpdGVSZXF1ZXN0VHlwZSB9IHdyaXRlT2JqIFRoaXMgb2JqZWN0IGlzIGRlc2NyaWJlZCBpbiB0aGUgV3JpdGVSZXF1ZXN0VHlwZSB0eXBlZGVmXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIENsaXBib2FyZC53cml0ZUh0bWxcbiAgICAgKi9cbiAgICB3cml0ZUh0bWwod3JpdGVPYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbGlwYm9hcmQtd3JpdGUtaHRtbCcsIHdyaXRlT2JqKS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNvbnRlbnQgb2YgdGhlIGNsaXBib2FyZCBhcyBIdG1sXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gdHlwZSBDbGlwYm9hcmQgVHlwZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHN0cmluZz59XG4gICAgICogQHR1dG9yaWFsIENsaXBib2FyZC5yZWFkSHRtbFxuICAgICAqL1xuICAgIHJlYWRIdG1sKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbGlwYm9hcmQtcmVhZC1odG1sJywgdHlwZSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBkYXRhIGludG8gdGhlIGNsaXBib2FyZCBhcyBSdGZcbiAgICAgKiBAcGFyYW0geyBXcml0ZVJlcXVlc3RUeXBlIH0gd3JpdGVPYmogVGhpcyBvYmplY3QgaXMgZGVzY3JpYmVkIGluIHRoZSBXcml0ZVJlcXVlc3RUeXBlIHR5cGVkZWZcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgQ2xpcGJvYXJkLndyaXRlUnRmXG4gICAgICovXG4gICAgd3JpdGVSdGYod3JpdGVPYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbGlwYm9hcmQtd3JpdGUtcnRmJywgd3JpdGVPYmopLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY29udGVudCBvZiB0aGUgY2xpcGJvYXJkIGFzIFJ0ZlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHR5cGUgQ2xpcGJvYXJkIFR5cGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxzdHJpbmc+fVxuICAgICAqIEB0dXRvcmlhbCBDbGlwYm9hcmQucmVhZFJ0ZlxuICAgICAqL1xuICAgIHJlYWRSdGYodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2NsaXBib2FyZC1yZWFkLXJ0ZicsIHR5cGUpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgZGF0YSBpbnRvIHRoZSBjbGlwYm9hcmRcbiAgICAgKiBAcGFyYW0geyBXcml0ZUFueVJlcXVlc3RUeXBlIH0gd3JpdGVPYmogVGhpcyBvYmplY3QgaXMgZGVzY3JpYmVkIGluIHRoZSBXcml0ZUFueVJlcXVlc3RUeXBlIHR5cGVkZWZcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgQ2xpcGJvYXJkLndyaXRlXG4gICAgICovXG4gICAgd3JpdGUod3JpdGVPYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbGlwYm9hcmQtd3JpdGUnLCB3cml0ZU9iaikudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhdmFpbGFibGUgZm9ybWF0cyBmb3IgdGhlIGNsaXBib2FyZCB0eXBlXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gdHlwZSBDbGlwYm9hcmQgVHlwZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuQXJyYXkuPHN0cmluZz59XG4gICAgICogQHR1dG9yaWFsIENsaXBib2FyZC5nZXRBdmFpbGFibGVGb3JtYXRzXG4gICAgICovXG4gICAgZ2V0QXZhaWxhYmxlRm9ybWF0cyh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignY2xpcGJvYXJkLXJlYWQtZm9ybWF0cycsIHR5cGUpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENsaXBib2FyZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbWl0dGVyTWFwID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY2xhc3MgRW1pdHRlck1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBoYXNoS2V5cyhrZXlzKSB7XG4gICAgICAgIGNvbnN0IGhhc2hlZCA9IGtleXMubWFwKG5vcm1hbGl6ZVN0cmluZyk7XG4gICAgICAgIHJldHVybiBoYXNoZWQuam9pbignLycpO1xuICAgIH1cbiAgICBnZXRPckNyZWF0ZShrZXlzKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmhhc2hLZXlzKGtleXMpO1xuICAgICAgICBpZiAoIXRoaXMuc3RvcmFnZS5oYXMoaGFzaCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoaGFzaCwgbmV3IGV2ZW50c18xLkV2ZW50RW1pdHRlcigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBzZXQgaXQgYWJvdmVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQoaGFzaCk7XG4gICAgfVxuICAgIGhhcyhrZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuaGFzKHRoaXMuaGFzaEtleXMoa2V5cykpO1xuICAgIH1cbiAgICBkZWxldGUoa2V5cykge1xuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5oYXNoS2V5cyhrZXlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5kZWxldGUoaGFzaCk7XG4gICAgfVxufVxuZXhwb3J0cy5FbWl0dGVyTWFwID0gRW1pdHRlck1hcDtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZyhzKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKHMpO1xuICAgIHJldHVybiBiLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZW1pdHRlck1hcF8xID0gcmVxdWlyZShcIi4vZW1pdHRlck1hcFwiKTtcbmZ1bmN0aW9uIGlzRXZlbnRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5hY3Rpb24gPT09ICdwcm9jZXNzLWRlc2t0b3AtZXZlbnQnO1xufVxuZnVuY3Rpb24gaXNOb3RpZmljYXRpb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5hY3Rpb24gPT09ICdwcm9jZXNzLW5vdGlmaWNhdGlvbi1ldmVudCc7XG59XG5jb25zdCBidWlsZExvY2FsUGF5bG9hZCA9IChyYXdQYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgeyBwYXlsb2FkOiB7IG1lc3NhZ2UgfSwgdHlwZSB9ID0gcmF3UGF5bG9hZDtcbiAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICAgICAgcGF5bG9hZC5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaG93JzpcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbn07XG5mdW5jdGlvbiBtYXBLZXlGcm9tRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7IHRvcGljIH0gPSBldmVudDtcbiAgICBpZiAodG9waWMgPT09ICdmcmFtZScpIHtcbiAgICAgICAgY29uc3QgeyB1dWlkLCBuYW1lIH0gPSBldmVudDtcbiAgICAgICAgcmV0dXJuIFt0b3BpYywgdXVpZCwgbmFtZV07XG4gICAgfVxuICAgIGlmICh0b3BpYyA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgY29uc3QgeyB1dWlkLCBuYW1lIH0gPSBldmVudDtcbiAgICAgICAgcmV0dXJuIFt0b3BpYywgdXVpZCwgbmFtZV07XG4gICAgfVxuICAgIGlmICh0b3BpYyA9PT0gJ2FwcGxpY2F0aW9uJykge1xuICAgICAgICBjb25zdCB7IHV1aWQgfSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gW3RvcGljLCB1dWlkXTtcbiAgICB9XG4gICAgaWYgKHRvcGljID09PSAnZXh0ZXJuYWwtd2luZG93Jykge1xuICAgICAgICBjb25zdCB7IHV1aWQgfSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gW3RvcGljLCB1dWlkXTtcbiAgICB9XG4gICAgaWYgKHRvcGljID09PSAndmlldycpIHtcbiAgICAgICAgY29uc3QgeyB1dWlkLCBuYW1lIH0gPSBldmVudDtcbiAgICAgICAgcmV0dXJuIFt0b3BpYywgdXVpZCwgbmFtZV07XG4gICAgfVxuICAgIHJldHVybiBbdG9waWNdO1xufVxuY2xhc3MgRXZlbnRBZ2dyZWdhdG9yIGV4dGVuZHMgZW1pdHRlck1hcF8xLkVtaXR0ZXJNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRXZlbnRNZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc29yID0gbWFwS2V5RnJvbUV2ZW50KHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhcyhhY2Nlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPckNyZWF0ZShhY2Nlc3NvcikuZW1pdChwYXlsb2FkLnR5cGUsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc05vdGlmaWNhdGlvbk1lc3NhZ2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgbm90aWZpY2F0aW9uSWQgfSwgdHlwZSB9ID0gbWVzc2FnZS5wYXlsb2FkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2Vzc29yID0gWydub3RpZmljYXRpb24nLCBgJHtub3RpZmljYXRpb25JZH1gXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXMoYWNjZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JDcmVhdGUoYWNjZXNzb3IpLmVtaXQodHlwZSwgYnVpbGRMb2NhbFBheWxvYWQobWVzc2FnZS5wYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEFnZ3JlZ2F0b3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuY29uc3QgSW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlXCIpO1xuLyoqXG4gKiBAbGVuZHMgRXh0ZXJuYWxBcHBsaWNhdGlvblxuICovXG5jbGFzcyBFeHRlcm5hbEFwcGxpY2F0aW9uTW9kdWxlIGV4dGVuZHMgYmFzZV8xLkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHJldHVybnMgYW4gRXh0ZXJuYWwgQXBwbGljYXRpb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBleHRlcm5hbCBhcHBsaWNhdGlvbi5cbiAgICAgKiA8YnI+SXQgaXMgcG9zc2libGUgdG8gd3JhcCBhIHByb2Nlc3MgdGhhdCBkb2VzIG5vdCB5ZXQgZXhpc3QsIChmb3IgZXhhbXBsZSwgdG8gbGlzdGVuIGZvciBzdGFydHVwLXJlbGF0ZWQgZXZlbnRzKVxuICAgICAqIHByb3ZpZGVkIGl0cyB1dWlkIGlzIGFscmVhZHkga25vd24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHV1aWQgVGhlIFVVSUQgb2YgdGhlIGV4dGVybmFsIGFwcGxpY2F0aW9uIHRvIGJlIHdyYXBwZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxFeHRlcm5hbEFwcGxpY2F0aW9uPn1cbiAgICAgKiBAdHV0b3JpYWwgRXh0ZXJuYWxBcHBsaWNhdGlvbi53cmFwXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHdyYXAodXVpZCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignZXh0ZXJuYWwtYXBwbGljYXRpb24td3JhcCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEluc3RhbmNlXzEuRXh0ZXJuYWxBcHBsaWNhdGlvbih0aGlzLndpcmUsIHsgdXVpZCB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzbHkgcmV0dXJucyBhbiBFeHRlcm5hbCBBcHBsaWNhdGlvbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGFuIGV4dGVybmFsIGFwcGxpY2F0aW9uLlxuICAgICAqIDxicj5JdCBpcyBwb3NzaWJsZSB0byB3cmFwIGEgcHJvY2VzcyB0aGF0IGRvZXMgbm90IHlldCBleGlzdCwgKGZvciBleGFtcGxlLCB0byBsaXN0ZW4gZm9yIHN0YXJ0dXAtcmVsYXRlZCBldmVudHMpXG4gICAgICogcHJvdmlkZWQgaXRzIHV1aWQgaXMgYWxyZWFkeSBrbm93bi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXVpZCBUaGUgVVVJRCBvZiB0aGUgZXh0ZXJuYWwgYXBwbGljYXRpb24gdG8gYmUgd3JhcHBlZFxuICAgICAqIEByZXR1cm4ge0V4dGVybmFsQXBwbGljYXRpb259XG4gICAgICogQHR1dG9yaWFsIEV4dGVybmFsQXBwbGljYXRpb24ud3JhcFN5bmNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgd3JhcFN5bmModXVpZCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignZXh0ZXJuYWwtYXBwbGljYXRpb24td3JhcC1zeW5jJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW5jZV8xLkV4dGVybmFsQXBwbGljYXRpb24odGhpcy53aXJlLCB7IHV1aWQgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRXh0ZXJuYWxBcHBsaWNhdGlvbk1vZHVsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FeHRlcm5hbEFwcGxpY2F0aW9uID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIEBjbGFzc2Rlc2MgQW4gRXh0ZXJuYWxBcHBsaWNhdGlvbiBvYmplY3QgcmVwcmVzZW50aW5nIG5hdGl2ZSBsYW5ndWFnZSBhZGFwdGVyIGNvbm5lY3Rpb25zIHRvIHRoZSBydW50aW1lLiBBbGxvd3NcbiAqIHRoZSBkZXZlbG9wZXIgdG8gbGlzdGVuIHRvIDxhIGhyZWY9XCJ0dXRvcmlhbC1FeHRlcm5hbEFwcGxpY2F0aW9uLkV2ZW50RW1pdHRlci5odG1sXCI+YXBwbGljYXRpb24gZXZlbnRzLjwvYT5cbiAqIERpc2NvdmVyeSBvZiBjb25uZWN0aW9ucyBpcyBwcm92aWRlZCBieSA8YSBocmVmPVwidHV0b3JpYWwtU3lzdGVtLmdldEFsbEV4dGVybmFsQXBwbGljYXRpb25zLmh0bWxcIj5nZXRBbGxFeHRlcm5hbEFwcGxpY2F0aW9ucy48L2E+XG4gKlxuICogUHJvY2Vzc2VzIHRoYXQgY2FuIGJlIHdyYXBwZWQgYXMgYEV4dGVybmFsQXBwbGljYXRpb25gcyBpbmNsdWRlIHRoZSBmb2xsb3dpbmc6XG4gKiAtIFByb2Nlc3NlcyB3aGljaCBoYXZlIGNvbm5lY3RlZCB0byBhbiBPcGVuRmluIHJ1bnRpbWUgdmlhIGFuIGFkYXB0ZXJcbiAqIC0gUHJvY2Vzc2VzIHN0YXJ0ZWQgdmlhIGBTeXN0ZW0ubGF1bmNoRXh0ZXJuYWxBcHBsaWNhdGlvbmBcbiAqIC0gUHJvY2Vzc2VzIG1vbml0b3JlZCB2aWEgYFN5c3RlbS5tb25pdG9yRXh0ZXJuYWxQcm9jZXNzYFxuICogQGNsYXNzXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEV4dGVybmFsQXBwbGljYXRpb24gZXh0ZW5kcyBiYXNlXzEuRW1pdHRlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHdpcmUsIGlkZW50aXR5KSB7XG4gICAgICAgIHN1cGVyKHdpcmUsIFsnZXh0ZXJuYWwtYXBwbGljYXRpb24nLCBpZGVudGl0eS51dWlkXSk7XG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBDYWxsZWQgd2hlbmV2ZXIgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gYWRkTGlzdGVuZXJcbiAgICAgKiBAbWVtYmVyb2YgRXh0ZXJuYWxBcHBsaWNhdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBFeHRlcm5hbEFwcGxpY2F0aW9uLkV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIHwgc3ltYm9sIH0gZXZlbnRUeXBlICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB9IGxpc3RlbmVyIC0gQ2FsbGVkIHdoZW5ldmVyIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIG9uXG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQXBwbGljYXRpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgRXh0ZXJuYWxBcHBsaWNhdGlvbi5FdmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgb25lIHRpbWUgbGlzdGVuZXIgZm9yIHRoZSBldmVudC4gVGhlIGxpc3RlbmVyIGlzIGludm9rZWQgb25seSB0aGUgZmlyc3QgdGltZSB0aGUgZXZlbnQgaXMgZmlyZWQsIGFmdGVyIHdoaWNoIGl0IGlzIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIHwgc3ltYm9sIH0gZXZlbnRUeXBlICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB9IGxpc3RlbmVyIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7IFN1Yk9wdGlvbnMgfSBbb3B0aW9uc10gLSBPcHRpb24gdG8gc3VwcG9ydCBldmVudCB0aW1lc3RhbXBzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fVxuICAgICAqIEBmdW5jdGlvbiBvbmNlXG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQXBwbGljYXRpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgRXh0ZXJuYWxBcHBsaWNhdGlvbi5FdmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB8IHN5bWJvbCB9IGV2ZW50VHlwZSAgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgRnVuY3Rpb24gfSBsaXN0ZW5lciAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyXG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQXBwbGljYXRpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgRXh0ZXJuYWxBcHBsaWNhdGlvbi5FdmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgb25lIHRpbWUgbGlzdGVuZXIgZm9yIHRoZSBldmVudC4gVGhlIGxpc3RlbmVyIGlzIGludm9rZWQgb25seSB0aGUgZmlyc3QgdGltZSB0aGUgZXZlbnQgaXMgZmlyZWQsIGFmdGVyIHdoaWNoIGl0IGlzIHJlbW92ZWQuXG4gICAgICogVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXJcbiAgICAgKiBAbWVtYmVyb2YgRXh0ZXJuYWxBcHBsaWNhdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBFeHRlcm5hbEFwcGxpY2F0aW9uLkV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZyb20gdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIENhdXRpb246IENhbGxpbmcgdGhpcyBtZXRob2QgY2hhbmdlcyB0aGUgYXJyYXkgaW5kaWNlcyBpbiB0aGUgbGlzdGVuZXIgYXJyYXkgYmVoaW5kIHRoZSBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyXG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQXBwbGljYXRpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgRXh0ZXJuYWxBcHBsaWNhdGlvbi5FdmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIHwgc3ltYm9sIH0gW2V2ZW50VHlwZV0gIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fVxuICAgICAqIEBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnNcbiAgICAgKiBAbWVtYmVyb2YgRXh0ZXJuYWxBcHBsaWNhdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBFeHRlcm5hbEFwcGxpY2F0aW9uLkV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXh0ZXJuYWwgYXBwbGljYXRpb24uXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48RXh0ZXJuYWxBcHBsaWNhdGlvbkluZm8+fVxuICAgICAqIEB0dXRvcmlhbCBFeHRlcm5hbEFwcGxpY2F0aW9uLmdldEluZm9cbiAgICAgKi9cbiAgICBnZXRJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1leHRlcm5hbC1hcHBsaWNhdGlvbi1pbmZvJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbEFwcGxpY2F0aW9uID0gRXh0ZXJuYWxBcHBsaWNhdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9GYWN0b3J5XCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRmFjdG9yeV8xLmRlZmF1bHQ7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSW5zdGFuY2VcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbmNvbnN0IEluc3RhbmNlXzEgPSByZXF1aXJlKFwiLi9JbnN0YW5jZVwiKTtcbi8qKlxuICogQGxlbmRzIEV4dGVybmFsV2luZG93XG4gKi9cbmNsYXNzIEV4dGVybmFsV2luZG93TW9kdWxlIGV4dGVuZHMgYmFzZV8xLkJhc2Uge1xuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHJldHVybnMgYW4gZXh0ZXJuYWwgd2luZG93IG9iamVjdCB0aGF0IHJlcHJlc2VudHNcbiAgICAgKiBhbiBleGlzdGluZyBleHRlcm5hbCB3aW5kb3cuPGJyPlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIHJlc3RyaWN0ZWQgYnkgZGVmYXVsdCBhbmQgbXVzdCBiZSBlbmFibGVkIHZpYVxuICAgICAqIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL2FwaS1zZWN1cml0eVwiPkFQSSBzZWN1cml0eSBzZXR0aW5nczwvYT4uXG4gICAgICogQHBhcmFtIHsgRXh0ZXJuYWxXaW5kb3dJZGVudGl0eSB9IGlkZW50aXR5XG4gICAgICogQHJldHVybiB7UHJvbWlzZS48RXh0ZXJuYWxXaW5kb3c+fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICogQGRlcHJlY2F0ZWQgQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLlxuICAgICAqIEB0dXRvcmlhbCBFeHRlcm5hbFdpbmRvdy53cmFwXG4gICAgICovXG4gICAgYXN5bmMgd3JhcChpZGVudGl0eSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbigncmVnaXN0ZXItbmF0aXZlLWV4dGVybmFsLXdpbmRvdycsIGlkZW50aXR5KTtcbiAgICAgICAgLy8gQWxsb3cgY29yZSB0byBwcm92aWRlIHV1aWQgaWYgbm9uZSBpcyBwcm92aWRlZCBieSB1c2VyLFxuICAgICAgICAvLyBvciBuYXRpdmVJZCB3aGVuIHdyYXBwaW5nIHZpYSBhIHV1aWQgb2J0YWluZWQgZnJvbSBgbGF1bmNoRXh0ZXJuYWxQcm9jZXNzYFxuICAgICAgICBjb25zdCBpZGVudGl0eUZyb21Db3JlID0gcmVzcG9uc2UucGF5bG9hZC5kYXRhO1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbmNlXzEuRXh0ZXJuYWxXaW5kb3codGhpcy53aXJlLCBpZGVudGl0eUZyb21Db3JlKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBFeHRlcm5hbFdpbmRvd01vZHVsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FeHRlcm5hbFdpbmRvdyA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnQgKi9cbmNvbnN0IHdpbmRvd18xID0gcmVxdWlyZShcIi4uL3dpbmRvd1wiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuLyoqXG4gKiBAY2xhc3NkZXNjIEFuIEV4dGVybmFsV2luZG93IGlzIGFuIE9wZW5GaW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIHdpbmRvdyB0aGF0IGJlbG9uZ3MgdG8gYSBub24tb3BlbmZpbiBhcHBsaWNhdGlvbi48YnI+XG4gKiBXaGlsZSBFeHRlcm5hbCBXaW5kb3dzIGRvbid0IGhhdmUgdGhlIGNvbXBsZXRlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gT3BlbkZpbiBXaW5kb3cgb2JqZWN0LFxuICogdGhleSBjYW4gYmUgdXNlZCB0byB0YXAgaW50byBhbnkgYXBwbGljYXRpb24gdGhhdCBpcyBjdXJyZW50bHkgcnVubmluZyBpbiB0aGUgT1MuPGJyPlxuICogRXh0ZXJuYWwgV2luZG93cyBhcmUgdXNlZnVsIGZvciBncm91cGluZywgbW92aW5nIGFuZCByZXNpemluZyBub24tb3BlbmZpbiBhcHBsaWNhdGlvbnNcbiAqIGFzIHdlbGwgYXMgbGlzdGVuaW5nIHRvIGV2ZW50cyB0aGF0IGFyZSBkaXNwYXRjaGVkIGJ5IHRoZXNlIGFwcGxpY2F0aW9ucy48YnI+XG4gKiBUaGV5IGFyZSBhbHNvIGNvbXBhdGlibGUgd2l0aCBPcGVuRmluJ3MgTGF5b3V0cyBzZXJ2aWNlIHRvIGZhY2lsaXRhdGVcbiAqIGNvbXBsZXRlIHBvc2l0aW9uYWwgY29udHJvbCBvdmVyIGFsbCBydW5uaW5nIGFwcGxpY2F0aW9ucy48YnI+XG4gKiBFeHRlcm5hbCBXaW5kb3dzIGhhcyB0aGUgYWJpbGl0eSB0byBsaXN0ZW4gZm9yIDxhIGhyZWY9XCJ0dXRvcmlhbC1FeHRlcm5hbFdpbmRvdy5FdmVudEVtaXR0ZXIuaHRtbFwiPiBleHRlcm5hbCB3aW5kb3ctc3BlY2lmaWMgZXZlbnRzPC9hPi5cbiAqIEBjbGFzc1xuICogQGFsaWFzIEV4dGVybmFsV2luZG93XG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEV4dGVybmFsV2luZG93IGV4dGVuZHMgYmFzZV8xLkVtaXR0ZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih3aXJlLCBpZGVudGl0eSkge1xuICAgICAgICBzdXBlcih3aXJlLCBbJ2V4dGVybmFsLXdpbmRvdycsIGlkZW50aXR5LnV1aWRdKTtcbiAgICAgICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgICAgICB0aGlzLnRvcGljID0gJ2V4dGVybmFsLXdpbmRvdyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyaW5ncyB0aGUgZXh0ZXJuYWwgd2luZG93IHRvIHRoZSBmcm9udCBvZiB0aGUgd2luZG93IHN0YWNrLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5icmluZ1RvRnJvbnRcbiAgICAgKi9cbiAgICBhc3luYyBicmluZ1RvRnJvbnQoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLicpO1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignYnJpbmctZXh0ZXJuYWwtd2luZG93LXRvLWZyb250JywgdGhpcy5pZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgZXh0ZXJuYWwgd2luZG93LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5jbG9zZVxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2Nsb3NlLWV4dGVybmFsLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsYXNoZXMgdGhlIGV4dGVybmFsIHdpbmRvd+KAmXMgZnJhbWUgYW5kIHRhc2tiYXIgaWNvbiB1bnRpbCBzdG9wRmxhc2hpbmcgaXMgY2FsbGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5mbGFzaFxuICAgICAqL1xuICAgIGFzeW5jIGZsYXNoKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ZsYXNoLWV4dGVybmFsLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlcyBmb2N1cyB0byB0aGUgZXh0ZXJuYWwgd2luZG93LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBlbWl0cyBFeHRlcm5hbFdpbmRvdyNmb2N1c2VkXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBkZXByZWNhdGVkIEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmZvY3VzXG4gICAgICovXG4gICAgYXN5bmMgZm9jdXMoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLicpO1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZm9jdXMtZXh0ZXJuYWwtd2luZG93JywgdGhpcy5pZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgYm91bmRzICh0b3AsIGxlZnQsIGV0Yy4pIG9mIHRoZSBleHRlcm5hbCB3aW5kb3cuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48Qm91bmRzPn1cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICogQGRlcHJlY2F0ZWQgQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLlxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZ2V0Qm91bmRzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Qm91bmRzKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IGRhdGEgfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1leHRlcm5hbC13aW5kb3ctYm91bmRzJywgdGhpcy5pZGVudGl0eSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYXJyYXkgY29udGFpbmluZyB3cmFwcGVkIGV4dGVybmFsIHdpbmRvd3MgdGhhdCBhcmUgZ3JvdXBlZFxuICAgICAqIHdpdGggdGhpcyBleHRlcm5hbCB3aW5kb3cuIElmIGEgd2luZG93IGlzIG5vdCBpbiBhIGdyb3VwIGFuIGVtcHR5IGFycmF5XG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48QXJyYXk8RXh0ZXJuYWxXaW5kb3d8X1dpbmRvdz4+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5nZXRHcm91cFxuICAgICAqL1xuICAgIGFzeW5jIGdldEdyb3VwKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IGRhdGEgfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1leHRlcm5hbC13aW5kb3ctZ3JvdXAnLCB0aGlzLmlkZW50aXR5KTtcbiAgICAgICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLm1hcCgoeyB1dWlkLCBuYW1lLCBpc0V4dGVybmFsV2luZG93IH0pID0+IHtcbiAgICAgICAgICAgIGlmIChpc0V4dGVybmFsV2luZG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHRlcm5hbFdpbmRvdyh0aGlzLndpcmUsIHsgdXVpZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93XzEuX1dpbmRvdyh0aGlzLndpcmUsIHsgdXVpZCwgbmFtZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gaW5mb3JtYXRpb24gb2JqZWN0IGZvciB0aGUgd2luZG93LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPGFueT59XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBkZXByZWNhdGVkIEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmdldEluZm9cbiAgICAgKi9cbiAgICBhc3luYyBnZXRJbmZvKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IGRhdGEgfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1leHRlcm5hbC13aW5kb3ctaW5mbycsIHRoaXMuaWRlbnRpdHkpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBleHRlcm5hbCB3aW5kb3cncyBvcHRpb25zLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPGFueT59XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBkZXByZWNhdGVkIEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmdldE9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRPcHRpb25zKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IGRhdGEgfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1leHRlcm5hbC13aW5kb3ctb3B0aW9ucycsIHRoaXMuaWRlbnRpdHkpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBzdGF0ZSAoXCJtaW5pbWl6ZWRcIiwgXCJtYXhpbWl6ZWRcIiwgb3IgXCJyZXN0b3JlZFwiKSBvZlxuICAgICAqIHRoZSBleHRlcm5hbCB3aW5kb3cuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48c3RyaW5nPn1cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICogQGRlcHJlY2F0ZWQgQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLlxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZ2V0U3RhdGVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdGF0ZSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuJyk7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZDogeyBkYXRhIH0gfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtZXh0ZXJuYWwtd2luZG93LXN0YXRlJywgdGhpcy5pZGVudGl0eSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgZXh0ZXJuYWwgd2luZG93LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5oaWRlXG4gICAgICovXG4gICAgYXN5bmMgaGlkZSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuJyk7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdoaWRlLWV4dGVybmFsLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBleHRlcm5hbCB3aW5kb3cgaXMgY3VycmVudGx5IHNob3dpbmcuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48Ym9vbGVhbj59XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBkZXByZWNhdGVkIEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmlzU2hvd2luZ1xuICAgICAqL1xuICAgIGFzeW5jIGlzU2hvd2luZygpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuJyk7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZDogeyBkYXRhIH0gfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpcy1leHRlcm5hbC13aW5kb3ctc2hvd2luZycsIHRoaXMuaWRlbnRpdHkpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbnMgdGhlIHNhbWUgd2luZG93IGdyb3VwIGFzIHRoZSBzcGVjaWZpZWQgd2luZG93LiBDdXJyZW50bHkgdW5zdXBwb3J0ZWQgKG1ldGhvZCB3aWxsIG5hY2spLlxuICAgICAqIEBwYXJhbSB7IF9XaW5kb3cgfCBFeHRlcm5hbFdpbmRvdyB9IHRhcmdldCBUaGUgd2luZG93IHdob3NlIGdyb3VwIGlzIHRvIGJlIGpvaW5lZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5qb2luR3JvdXBcbiAgICAgKi9cbiAgICBhc3luYyBqb2luR3JvdXAodGFyZ2V0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLicpO1xuICAgICAgICBjb25zdCB7IGlkZW50aXR5OiB7IHV1aWQsIG5hbWUgfSB9ID0gdGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXRJZGVudGl0eSA9IHsgZ3JvdXBpbmdVdWlkOiB1dWlkLCBncm91cGluZ1dpbmRvd05hbWU6IG5hbWUgfTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHsgLi4udGhpcy5pZGVudGl0eSwgLi4udGFyZ2V0SWRlbnRpdHkgfTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2pvaW4tZXh0ZXJuYWwtd2luZG93LWdyb3VwJywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyB0aGUgY3VycmVudCB3aW5kb3cgZ3JvdXAgc28gdGhhdCB0aGUgd2luZG93IGNhbiBiZSBtb3ZlZFxuICAgICAqIGluZGVwZW5kZW50bHkgb2YgdGhvc2UgaW4gdGhlIGdyb3VwLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5sZWF2ZUdyb3VwXG4gICAgICovXG4gICAgYXN5bmMgbGVhdmVHcm91cCgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuJyk7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdsZWF2ZS1leHRlcm5hbC13aW5kb3ctZ3JvdXAnLCB0aGlzLmlkZW50aXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF4aW1pemVzIHRoZSBleHRlcm5hbCB3aW5kb3cuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBkZXByZWNhdGVkIEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93Lm1heGltaXplXG4gICAgICovXG4gICAgYXN5bmMgbWF4aW1pemUoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLicpO1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignbWF4aW1pemUtZXh0ZXJuYWwtd2luZG93JywgdGhpcy5pZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgaW5zdGFuY2UncyB3aW5kb3cgZ3JvdXAgd2l0aCB0aGUgc2FtZSB3aW5kb3cgZ3JvdXAgYXMgdGhlIHNwZWNpZmllZCB3aW5kb3dcbiAgICAgKiBAcGFyYW0geyBfV2luZG93IHwgRXh0ZXJuYWxXaW5kb3cgfSB0YXJnZXQgVGhlIHdpbmRvdyB3aG9zZSBncm91cCBpcyB0byBiZSBtZXJnZWQgd2l0aFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5tZXJnZUdyb3Vwc1xuICAgICAqL1xuICAgIGFzeW5jIG1lcmdlR3JvdXBzKHRhcmdldCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgY29uc3QgeyBpZGVudGl0eTogeyB1dWlkLCBuYW1lIH0gfSA9IHRhcmdldDtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWRlbnRpdHkgPSB7IGdyb3VwaW5nVXVpZDogdXVpZCwgZ3JvdXBpbmdXaW5kb3dOYW1lOiBuYW1lIH07XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IC4uLnRoaXMuaWRlbnRpdHksIC4uLnRhcmdldElkZW50aXR5IH07XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdtZXJnZS1leHRlcm5hbC13aW5kb3ctZ3JvdXBzJywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1pbmltaXplcyB0aGUgZXh0ZXJuYWwgd2luZG93LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5taW5pbWl6ZVxuICAgICAqL1xuICAgIGFzeW5jIG1pbmltaXplKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ21pbmltaXplLWV4dGVybmFsLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgZXh0ZXJuYWwgd2luZG93IGJ5IGEgc3BlY2lmaWVkIGFtb3VudC5cbiAgICAgKiBAcGFyYW0geyBudW1iZXIgfSBkZWx0YUxlZnQgVGhlIGNoYW5nZSBpbiB0aGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgd2luZG93XG4gICAgICogQHBhcmFtIHsgbnVtYmVyIH0gZGVsdGFUb3AgVGhlIGNoYW5nZSBpbiB0aGUgdG9wIHBvc2l0aW9uIG9mIHRoZSB3aW5kb3dcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICogQGRlcHJlY2F0ZWQgQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLlxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cubW92ZUJ5XG4gICAgICovXG4gICAgYXN5bmMgbW92ZUJ5KGRlbHRhTGVmdCwgZGVsdGFUb3ApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuJyk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IC4uLnRoaXMuaWRlbnRpdHksIGRlbHRhTGVmdCwgZGVsdGFUb3AgfTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ21vdmUtZXh0ZXJuYWwtd2luZG93LWJ5JywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBleHRlcm5hbCB3aW5kb3cgdG8gYSBzcGVjaWZpZWQgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIHsgbnVtYmVyIH0gbGVmdCBUaGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgd2luZG93XG4gICAgICogQHBhcmFtIHsgbnVtYmVyIH0gdG9wIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIHdpbmRvd1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5tb3ZlVG9cbiAgICAgKi9cbiAgICBhc3luYyBtb3ZlVG8obGVmdCwgdG9wKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLicpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0geyAuLi50aGlzLmlkZW50aXR5LCBsZWZ0LCB0b3AgfTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ21vdmUtZXh0ZXJuYWwtd2luZG93JywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGV4dGVybmFsIHdpbmRvdyBieSBhIHNwZWNpZmllZCBhbW91bnQuXG4gICAgICogQHBhcmFtIHsgbnVtYmVyIH0gZGVsdGFXaWR0aCBUaGUgY2hhbmdlIGluIHRoZSB3aWR0aCBvZiB0aGUgd2luZG93XG4gICAgICogQHBhcmFtIHsgbnVtYmVyIH0gZGVsdGFIZWlnaHQgVGhlIGNoYW5nZSBpbiB0aGUgaGVpZ2h0IG9mIHRoZSB3aW5kb3dcbiAgICAgKiBAcGFyYW0geyBBbmNob3JUeXBlIH0gYW5jaG9yIFNwZWNpZmllcyBhIGNvcm5lciB0byByZW1haW4gZml4ZWQgZHVyaW5nIHRoZSByZXNpemUuXG4gICAgICogQ2FuIHRha2UgdGhlIHZhbHVlczogXCJ0b3AtbGVmdFwiLCBcInRvcC1yaWdodFwiLCBcImJvdHRvbS1sZWZ0XCIsIG9yIFwiYm90dG9tLXJpZ2h0XCIuXG4gICAgICogSWYgdW5kZWZpbmVkLCB0aGUgZGVmYXVsdCBpcyBcInRvcC1sZWZ0XCIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBkZXByZWNhdGVkIEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LnJlc2l6ZUJ5XG4gICAgICovXG4gICAgYXN5bmMgcmVzaXplQnkoZGVsdGFXaWR0aCwgZGVsdGFIZWlnaHQsIGFuY2hvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuaWRlbnRpdHksXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBkZWx0YUhlaWdodDogTWF0aC5mbG9vcihkZWx0YUhlaWdodCksXG4gICAgICAgICAgICBkZWx0YVdpZHRoOiBNYXRoLmZsb29yKGRlbHRhV2lkdGgpXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdyZXNpemUtZXh0ZXJuYWwtd2luZG93LWJ5JywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGV4dGVybmFsIHdpbmRvdyB0byB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvbnMuXG4gICAgICogQHBhcmFtIHsgbnVtYmVyIH0gd2lkdGggVGhlIGNoYW5nZSBpbiB0aGUgd2lkdGggb2YgdGhlIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7IG51bWJlciB9IGhlaWdodCBUaGUgY2hhbmdlIGluIHRoZSBoZWlnaHQgb2YgdGhlIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7IEFuY2hvclR5cGUgfSBhbmNob3IgU3BlY2lmaWVzIGEgY29ybmVyIHRvIHJlbWFpbiBmaXhlZCBkdXJpbmcgdGhlIHJlc2l6ZS5cbiAgICAgKiBDYW4gdGFrZSB0aGUgdmFsdWVzOiBcInRvcC1sZWZ0XCIsIFwidG9wLXJpZ2h0XCIsIFwiYm90dG9tLWxlZnRcIiwgb3IgXCJib3R0b20tcmlnaHRcIi5cbiAgICAgKiBJZiB1bmRlZmluZWQsIHRoZSBkZWZhdWx0IGlzIFwidG9wLWxlZnRcIi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICogQGRlcHJlY2F0ZWQgQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLlxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cucmVzaXplVG9cbiAgICAgKi9cbiAgICBhc3luYyByZXNpemVUbyh3aWR0aCwgaGVpZ2h0LCBhbmNob3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuJyk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5LFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmZsb29yKGhlaWdodCksXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5mbG9vcih3aWR0aClcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Jlc2l6ZS1leHRlcm5hbC13aW5kb3cnLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgdGhlIGV4dGVybmFsIHdpbmRvdyB0byBpdHMgbm9ybWFsIHN0YXRlIChpLmUuIHVubWluaW1pemVkLCB1bm1heGltaXplZCkuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBkZXByZWNhdGVkIEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LnJlc3RvcmVcbiAgICAgKi9cbiAgICBhc3luYyByZXN0b3JlKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Jlc3RvcmUtZXh0ZXJuYWwtd2luZG93JywgdGhpcy5pZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgYnJpbmcgdGhlIGV4dGVybmFsIHdpbmRvdyB0byB0aGUgZnJvbnQgb2YgdGhlIGVudGlyZSBzdGFjayBhbmRcbiAgICAgKiBnaXZlIGl0IGZvY3VzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5zZXRBc0ZvcmVncm91bmRcbiAgICAgKi9cbiAgICBhc3luYyBzZXRBc0ZvcmVncm91bmQoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLicpO1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignc2V0LWV4dGVybmFsLXdpbmRvdy1hcy1mb3JlZ3JvdW5kJywgdGhpcy5pZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGV4dGVybmFsIHdpbmRvdydzIHNpemUgYW5kIHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSB7IEJvdW5kcyB9IGJvdW5kc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5zZXRCb3VuZHNcbiAgICAgKi9cbiAgICBhc3luYyBzZXRCb3VuZHMoYm91bmRzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLicpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0geyAuLi50aGlzLmlkZW50aXR5LCAuLi5ib3VuZHMgfTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3NldC1leHRlcm5hbC13aW5kb3ctYm91bmRzJywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBleHRlcm5hbCB3aW5kb3cgaWYgaXQgaXMgaGlkZGVuLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5zaG93XG4gICAgICovXG4gICAgYXN5bmMgc2hvdygpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuJyk7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzaG93LWV4dGVybmFsLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgZXh0ZXJuYWwgd2luZG93LCBpZiBpdCBpcyBoaWRkZW4sIGF0IHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uXG4gICAgICogSWYgdGhlIHRvZ2dsZSBwYXJhbWV0ZXIgaXMgc2V0IHRvIHRydWUsIHRoZSBleHRlcm5hbCB3aW5kb3cgd2lsbFxuICAgICAqIGFsdGVybmF0ZSBiZXR3ZWVuIHNob3dpbmcgYW5kIGhpZGluZy5cbiAgICAgKiBAcGFyYW0geyBudW1iZXIgfSBsZWZ0IFRoZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSB3aW5kb3dcbiAgICAgKiBAcGFyYW0geyBudW1iZXIgfSB0b3AgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgd2luZG93XG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBkZXByZWNhdGVkIEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LnNob3dBdFxuICAgICAqL1xuICAgIGFzeW5jIHNob3dBdChsZWZ0LCB0b3ApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuJyk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5LFxuICAgICAgICAgICAgbGVmdDogTWF0aC5mbG9vcihsZWZ0KSxcbiAgICAgICAgICAgIHRvcDogTWF0aC5mbG9vcih0b3ApXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzaG93LWV4dGVybmFsLXdpbmRvdy1hdCcsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgdGFza2JhciBpY29uIGZyb20gZmxhc2hpbmcuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBkZXByZWNhdGVkIEFsbCBFeHRlcm5hbCBXaW5kb3cgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LnN0b3BGbGFzaGluZ1xuICAgICAqL1xuICAgIGFzeW5jIHN0b3BGbGFzaGluZygpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuJyk7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzdG9wLWV4dGVybmFsLXdpbmRvdy1mbGFzaGluZycsIHRoaXMuaWRlbnRpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBleHRlcm5hbCB3aW5kb3cgdXNpbmcgdGhlIHBhc3NlZCBvcHRpb25zXG4gICAgICogQHBhcmFtIHsqfSBvcHRpb25zIENoYW5nZXMgYW4gZXh0ZXJuYWwgd2luZG93J3Mgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgRXh0ZXJuYWwgV2luZG93IEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy51cGRhdGVPcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogQWxsIEV4dGVybmFsIFdpbmRvdyBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLicpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0geyAuLi50aGlzLmlkZW50aXR5LCBvcHRpb25zIH07XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCd1cGRhdGUtZXh0ZXJuYWwtd2luZG93LW9wdGlvbnMnLCBwYXlsb2FkKTtcbiAgICB9XG59XG5leHBvcnRzLkV4dGVybmFsV2luZG93ID0gRXh0ZXJuYWxXaW5kb3c7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRmFjdG9yeV8xID0gcmVxdWlyZShcIi4vRmFjdG9yeVwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEZhY3RvcnlfMS5kZWZhdWx0O1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0luc3RhbmNlXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuLy8gSW1wb3J0IGZyb20gdGhlIGZpbGUgcmF0aGVyIHRoYW4gdGhlIGRpcmVjdG9yeSBpbiBjYXNlIHNvbWVvbmUgY29uc3VtaW5nIHR5cGVzIGlzIHVzaW5nIG1vZHVsZSByZXNvbHV0aW9uIG90aGVyIHRoYW4gXCJub2RlXCJcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi9zeXN0ZW0vaW5kZXhcIik7XG5jb25zdCBpbmRleF8yID0gcmVxdWlyZShcIi4vd2luZG93L2luZGV4XCIpO1xuY29uc3QgaW5kZXhfMyA9IHJlcXVpcmUoXCIuL2FwcGxpY2F0aW9uL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfNCA9IHJlcXVpcmUoXCIuL2ludGVyYXBwYnVzL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfNSA9IHJlcXVpcmUoXCIuL25vdGlmaWNhdGlvbi9pbmRleFwiKTtcbmNvbnN0IGluZGV4XzYgPSByZXF1aXJlKFwiLi9jbGlwYm9hcmQvaW5kZXhcIik7XG5jb25zdCBpbmRleF83ID0gcmVxdWlyZShcIi4vZXh0ZXJuYWwtYXBwbGljYXRpb24vaW5kZXhcIik7XG5jb25zdCBpbmRleF84ID0gcmVxdWlyZShcIi4vZXh0ZXJuYWwtd2luZG93L2luZGV4XCIpO1xuY29uc3QgaW5kZXhfOSA9IHJlcXVpcmUoXCIuL2ZyYW1lL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfMTAgPSByZXF1aXJlKFwiLi9nbG9iYWwtaG90a2V5L2luZGV4XCIpO1xuY29uc3QgaW5kZXhfMTEgPSByZXF1aXJlKFwiLi92aWV3L2luZGV4XCIpO1xuY29uc3QgaW5kZXhfMTIgPSByZXF1aXJlKFwiLi9wbGF0Zm9ybS9pbmRleFwiKTtcbmNvbnN0IG1lXzEgPSByZXF1aXJlKFwiLi9tZVwiKTtcbmNvbnN0IGZpbl9zdG9yZV8xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydC9maW5fc3RvcmVcIik7XG5jb25zdCBpbnRlcm9wXzEgPSByZXF1aXJlKFwiLi9pbnRlcm9wXCIpO1xuY29uc3Qgc25hcHNob3Rfc291cmNlXzEgPSByZXF1aXJlKFwiLi9zbmFwc2hvdC1zb3VyY2VcIik7XG5jbGFzcyBGaW4gZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHdpcmUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgZmluX3N0b3JlXzEucmVnaXN0ZXJGaW4od2lyZSwgdGhpcyk7XG4gICAgICAgIHRoaXMud2lyZSA9IHdpcmU7XG4gICAgICAgIHRoaXMuU3lzdGVtID0gbmV3IGluZGV4XzEuZGVmYXVsdCh3aXJlKTtcbiAgICAgICAgdGhpcy5XaW5kb3cgPSBuZXcgaW5kZXhfMi5kZWZhdWx0KHdpcmUpO1xuICAgICAgICB0aGlzLkFwcGxpY2F0aW9uID0gbmV3IGluZGV4XzMuZGVmYXVsdCh3aXJlKTtcbiAgICAgICAgdGhpcy5JbnRlckFwcGxpY2F0aW9uQnVzID0gbmV3IGluZGV4XzQuZGVmYXVsdCh3aXJlKTtcbiAgICAgICAgdGhpcy5Ob3RpZmljYXRpb24gPSBuZXcgaW5kZXhfNS5kZWZhdWx0KHdpcmUpO1xuICAgICAgICB0aGlzLkNsaXBib2FyZCA9IG5ldyBpbmRleF82LmRlZmF1bHQod2lyZSk7XG4gICAgICAgIHRoaXMuRXh0ZXJuYWxBcHBsaWNhdGlvbiA9IG5ldyBpbmRleF83LmRlZmF1bHQod2lyZSk7XG4gICAgICAgIHRoaXMuRXh0ZXJuYWxXaW5kb3cgPSBuZXcgaW5kZXhfOC5kZWZhdWx0KHdpcmUpO1xuICAgICAgICB0aGlzLkZyYW1lID0gbmV3IGluZGV4XzkuZGVmYXVsdCh3aXJlKTtcbiAgICAgICAgdGhpcy5HbG9iYWxIb3RrZXkgPSBuZXcgaW5kZXhfMTAuZGVmYXVsdCh3aXJlKTtcbiAgICAgICAgdGhpcy5QbGF0Zm9ybSA9IG5ldyBpbmRleF8xMi5kZWZhdWx0KHdpcmUsIHRoaXMuSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsKTtcbiAgICAgICAgdGhpcy5WaWV3ID0gbmV3IGluZGV4XzExLmRlZmF1bHQod2lyZSk7XG4gICAgICAgIHRoaXMuSW50ZXJvcCA9IG5ldyBpbnRlcm9wXzEuZGVmYXVsdCh3aXJlKTtcbiAgICAgICAgdGhpcy5TbmFwc2hvdFNvdXJjZSA9IG5ldyBzbmFwc2hvdF9zb3VyY2VfMS5kZWZhdWx0KHdpcmUpO1xuICAgICAgICB0aGlzLm1lID0gbWVfMS5nZXRNZSh3aXJlKTtcbiAgICAgICAgLy8gSGFuZGxlIGRpc2Nvbm5lY3QgZXZlbnRzXG4gICAgICAgIHdpcmUub24oJ2Rpc2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEZpbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvdmFsaWRhdGVcIik7XG5jb25zdCBJbnN0YW5jZV8xID0gcmVxdWlyZShcIi4vSW5zdGFuY2VcIik7XG4vKipcbiAqIEBsZW5kcyBGcmFtZVxuICovXG5jbGFzcyBfRnJhbWVNb2R1bGUgZXh0ZW5kcyBiYXNlXzEuQmFzZSB7XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgc3BlY2lmaWVkIGZyYW1lLiBUaGUgZnJhbWUgZG9lcyBub3QgaGF2ZSB0byBleGlzdFxuICAgICAqIEBwYXJhbSB7SWRlbnRpdHl9IGlkZW50aXR5IC0gdGhlIGlkZW50aXR5IG9mIHRoZSBmcmFtZSB5b3Ugd2FudCB0byB3cmFwXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48X0ZyYW1lPn1cbiAgICAgKiBAdHV0b3JpYWwgRnJhbWUud3JhcFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBhc3luYyB3cmFwKGlkZW50aXR5KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdmcmFtZS13cmFwJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZXJyb3JNc2cgPSB2YWxpZGF0ZV8xLnZhbGlkYXRlSWRlbnRpdHkoaWRlbnRpdHkpO1xuICAgICAgICBpZiAoZXJyb3JNc2cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW5jZV8xLl9GcmFtZSh0aGlzLndpcmUsIGlkZW50aXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBzcGVjaWZpZWQgZnJhbWUuIFRoZSBmcmFtZSBkb2VzIG5vdCBoYXZlIHRvIGV4aXN0XG4gICAgICogQHBhcmFtIHtJZGVudGl0eX0gaWRlbnRpdHkgLSB0aGUgaWRlbnRpdHkgb2YgdGhlIGZyYW1lIHlvdSB3YW50IHRvIHdyYXBcbiAgICAgKiBAcmV0dXJuIHtfRnJhbWV9XG4gICAgICogQHR1dG9yaWFsIEZyYW1lLndyYXBTeW5jXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHdyYXBTeW5jKGlkZW50aXR5KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdmcmFtZS13cmFwLXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlcnJvck1zZyA9IHZhbGlkYXRlXzEudmFsaWRhdGVJZGVudGl0eShpZGVudGl0eSk7XG4gICAgICAgIGlmIChlcnJvck1zZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEluc3RhbmNlXzEuX0ZyYW1lKHRoaXMud2lyZSwgaWRlbnRpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGZyYW1lXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48X0ZyYW1lPn1cbiAgICAgKiBAdHV0b3JpYWwgRnJhbWUuZ2V0Q3VycmVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50KCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignZnJhbWUtZ2V0LWN1cnJlbnQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBJbnN0YW5jZV8xLl9GcmFtZSh0aGlzLndpcmUsIHRoaXMud2lyZS5lbnZpcm9ubWVudC5nZXRDdXJyZW50RW50aXR5SWRlbnRpdHkoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZnJhbWVcbiAgICAgKiBAcmV0dXJuIHtfRnJhbWV9XG4gICAgICogQHR1dG9yaWFsIEZyYW1lLmdldEN1cnJlbnRTeW5jXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGdldEN1cnJlbnRTeW5jKCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignZnJhbWUtZ2V0LWN1cnJlbnQtc3luYycpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFuY2VfMS5fRnJhbWUodGhpcy53aXJlLCB0aGlzLndpcmUuZW52aXJvbm1lbnQuZ2V0Q3VycmVudEVudGl0eUlkZW50aXR5KCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IF9GcmFtZU1vZHVsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5fRnJhbWUgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0ICovXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbi8qKlxuICogQGNsYXNzZGVzY1xuICogQW4gaWZyYW1lIHJlcHJlc2VudHMgYW4gZW1iZWRkZWQgSFRNTCBwYWdlIHdpdGhpbiBhIHBhcmVudCBIVE1MIHBhZ2UuIEJlY2F1c2UgdGhpcyBlbWJlZGRlZCBwYWdlXG4gKiBoYXMgaXRzIG93biBET00gYW5kIGdsb2JhbCBKUyBjb250ZXh0ICh3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBsaW5rZWQgdG8gdGhhdCBvZiB0aGUgcGFyZW50IGRlcGVuZGluZ1xuICogb24gaWYgaXQgaXMgY29uc2lkZXJlZCBvdXQgb2YgdGhlIHJvb3QgZG9tYWluIG9yIG5vdCksIGl0IHJlcHJlc2VudHMgYSB1bmlxdWUgZW5kcG9pbnQgYXMgYW4gT3BlbkZpblxuICogY29ubmVjdGlvbi4gSWZyYW1lcyBtYXkgYmUgZ2VuZXJhdGVkIGR5bmFtaWNhbGx5LCBvciBiZSBwcmVzZW50IG9uIGluaXRpYWwgcGFnZSBsb2FkIGFuZCBlYWNoIG5vbi1DT1JTXG4gKiBpZnJhbWUgaGFzIHRoZSBPcGVuRmluIEFQSSBpbmplY3RlZCBieSBkZWZhdWx0LiBJdCBpcyBwb3NzaWJsZSB0byBvcHQgaW50byBjcm9zcy1vcmlnaW4gaWZyYW1lcyBoYXZpbmdcbiAqIHRoZSBBUEkgYnkgc2V0dGluZyBhcGkuaWZyYW1lLmNyb3NzT3JpZ2luSW5qZWN0aW9uIHRvIHRydWUgaW4gYSB3aW5kb3cncyBvcHRpb25zLiBUbyBibG9jayBhbGwgaWZyYW1lc1xuICogZnJvbSBnZXR0aW5nIHRoZSBBUEkgaW5qZWN0ZWQgeW91IGNhbiBzZXQgYXBpLmZyYW1lLnNhbWVPcmlnaW5JbmplY3Rpb25cbiAqIHRvIGZhbHNlIDxhIGhyZWY9XCJXaW5kb3cuaHRtbCN+b3B0aW9uc1wiIHRhcmdldD1cIl9ibGFua1wiPihzZWUgV2luZG93fm9wdGlvbnMpPC9hPi5cbiAqXG4gKiBUbyBiZSBhYmxlIHRvIGRpcmVjdGx5IGFkZHJlc3MgdGhpcyBjb250ZXh0IGZvciBldmVudGluZyBhbmQgbWVzc2FnaW5nIHB1cnBvc2VzLCBpdCBuZWVkcyBhXG4gKiB1bmlxdWUgdXVpZCBuYW1lIHBhaXJpbmcuIEZvciBPcGVuRmluIGFwcGxpY2F0aW9ucyBhbmQgd2luZG93cyB0aGlzIGlzIHByb3ZpZGVkIHZpYSBhIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBpbiB0aGUgZm9ybSBvZiBhIG1hbmlmZXN0IFVSTCBvciBvcHRpb25zIG9iamVjdCwgYnV0IHRoZXJlIGlzIG5vIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBpZnJhbWVzLlxuICogSnVzdCBhcyBhIGNhbGwgdG8gd2luZG93Lm9wZW4gb3V0c2lkZSBvZiBvdXIgV2luZG93IEFQSSByZXR1cm5zIGEgbmV3IHdpbmRvdyB3aXRoIGEgcmFuZG9tIEdVSUQgYXNzaWduZWRcbiAqIGZvciB0aGUgbmFtZSwgZWFjaCBpZnJhbWUgdGhhdCBoYXMgdGhlIEFQSSBpbmplY3RlZCB3aWxsIGJlIGFzc2lnbmVkIGEgR1VJRCBhcyBpdHMgbmFtZSwgdGhlIFVVSUQgd2lsbCBiZVxuICogdGhlIHNhbWUgYXMgdGhlIHBhcmVudCB3aW5kb3cncy5cbiAqXG4gKiBUaGUgZmluLkZyYW1lIG5hbWVzcGFjZSByZXByZXNlbnRzIGEgd2F5IHRvIGludGVyYWN0IHdpdGggYGlmcmFtZXNgIGFuZCBmYWNpbGl0YXRlcyB0aGUgZGlzY292ZXJ5IG9mIGN1cnJlbnQgY29udGV4dFxuICogKGlmcmFtZSBvciBtYWluIHdpbmRvdykgYXMgd2VsbCBhcyB0aGUgYWJpbGl0eSB0byBsaXN0ZW4gZm9yIDxhIGhyZWY9XCJ0dXRvcmlhbC1GcmFtZS5FdmVudEVtaXR0ZXIuaHRtbFwiPmZyYW1lLXNwZWNpZmljIGV2ZW50czwvYT4uXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBGcmFtZVxuICogQGhpZGVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBfRnJhbWUgZXh0ZW5kcyBiYXNlXzEuRW1pdHRlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHdpcmUsIGlkZW50aXR5KSB7XG4gICAgICAgIHN1cGVyKHdpcmUsIFsnZnJhbWUnLCBpZGVudGl0eS51dWlkLCBpZGVudGl0eS5uYW1lXSk7XG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIHwgc3ltYm9sIH0gZXZlbnRUeXBlICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB9IGxpc3RlbmVyIC0gQ2FsbGVkIHdoZW5ldmVyIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIGFkZExpc3RlbmVyXG4gICAgICogQG1lbWJlcm9mIEZyYW1lXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHR1dG9yaWFsIEZyYW1lLkV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIHwgc3ltYm9sIH0gZXZlbnRUeXBlICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB9IGxpc3RlbmVyIC0gQ2FsbGVkIHdoZW5ldmVyIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIG9uXG4gICAgICogQG1lbWJlcm9mIEZyYW1lXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHR1dG9yaWFsIEZyYW1lLkV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBvbmUgdGltZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50LiBUaGUgbGlzdGVuZXIgaXMgaW52b2tlZCBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBldmVudCBpcyBmaXJlZCwgYWZ0ZXIgd2hpY2ggaXQgaXMgcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIG9uY2VcbiAgICAgKiBAbWVtYmVyb2YgRnJhbWVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgRnJhbWUuRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lclxuICAgICAqIEBtZW1iZXJvZiBGcmFtZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBGcmFtZS5FdmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgb25lIHRpbWUgbGlzdGVuZXIgZm9yIHRoZSBldmVudC4gVGhlIGxpc3RlbmVyIGlzIGludm9rZWQgb25seSB0aGUgZmlyc3QgdGltZSB0aGUgZXZlbnQgaXMgZmlyZWQsIGFmdGVyIHdoaWNoIGl0IGlzIHJlbW92ZWQuXG4gICAgICogVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXJcbiAgICAgKiBAbWVtYmVyb2YgRnJhbWVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgRnJhbWUuRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogQ2F1dGlvbjogQ2FsbGluZyB0aGlzIG1ldGhvZCBjaGFuZ2VzIHRoZSBhcnJheSBpbmRpY2VzIGluIHRoZSBsaXN0ZW5lciBhcnJheSBiZWhpbmQgdGhlIGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB8IHN5bWJvbCB9IGV2ZW50VHlwZSAgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgRnVuY3Rpb24gfSBsaXN0ZW5lciAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJcbiAgICAgKiBAbWVtYmVyb2YgRnJhbWVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgRnJhbWUuRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB8IHN5bWJvbCB9IFtldmVudFR5cGVdICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzXG4gICAgICogQG1lbWJlcm9mIEZyYW1lXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHR1dG9yaWFsIEZyYW1lLkV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmcmFtZSBpbmZvIG9iamVjdCBmb3IgdGhlIHJlcHJlc2VudGVkIGZyYW1lXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48RnJhbWVJbmZvPn1cbiAgICAgKiBAdHV0b3JpYWwgRnJhbWUuZ2V0SW5mb1xuICAgICAqL1xuICAgIGdldEluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWZyYW1lLWluZm8nLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZyYW1lIGluZm8gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgd2luZG93IHRoYXQgdGhlIHJlZmVyZW5jZWQgaWZyYW1lIGlzXG4gICAgICogY3VycmVudGx5IGVtYmVkZGVkIGluXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48RnJhbWVJbmZvPn1cbiAgICAgKiBAdHV0b3JpYWwgRnJhbWUuZ2V0UGFyZW50V2luZG93XG4gICAgICovXG4gICAgZ2V0UGFyZW50V2luZG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1wYXJlbnQtd2luZG93JywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5fRnJhbWUgPSBfRnJhbWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRmFjdG9yeV8xID0gcmVxdWlyZShcIi4vRmFjdG9yeVwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEZhY3RvcnlfMS5kZWZhdWx0O1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0luc3RhbmNlXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub25Ib3RrZXlFdmVudHMgPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbnZhciBhcGlBY3Rpb25zO1xuKGZ1bmN0aW9uIChhcGlBY3Rpb25zKSB7XG4gICAgYXBpQWN0aW9uc1tcIlJFR0lTVEVSXCJdID0gXCJnbG9iYWwtaG90a2V5LXJlZ2lzdGVyXCI7XG4gICAgYXBpQWN0aW9uc1tcIlVOUkVHSVNURVJcIl0gPSBcImdsb2JhbC1ob3RrZXktdW5yZWdpc3RlclwiO1xuICAgIGFwaUFjdGlvbnNbXCJVTlJFR0lTVEVSX0FMTFwiXSA9IFwiZ2xvYmFsLWhvdGtleS11bnJlZ2lzdGVyLWFsbFwiO1xuICAgIGFwaUFjdGlvbnNbXCJJU19SRUdJU1RFUkVEXCJdID0gXCJnbG9iYWwtaG90a2V5LWlzLXJlZ2lzdGVyZWRcIjtcbn0pKGFwaUFjdGlvbnMgfHwgKGFwaUFjdGlvbnMgPSB7fSkpO1xudmFyIG5vbkhvdGtleUV2ZW50cztcbihmdW5jdGlvbiAobm9uSG90a2V5RXZlbnRzKSB7XG4gICAgbm9uSG90a2V5RXZlbnRzW1wiUkVHSVNURVJFRFwiXSA9IFwicmVnaXN0ZXJlZFwiO1xuICAgIG5vbkhvdGtleUV2ZW50c1tcIlVOUkVHSVNURVJFRFwiXSA9IFwidW5yZWdpc3RlcmVkXCI7XG59KShub25Ib3RrZXlFdmVudHMgPSBleHBvcnRzLm5vbkhvdGtleUV2ZW50cyB8fCAoZXhwb3J0cy5ub25Ib3RrZXlFdmVudHMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgR2xvYmFsSG90a2V5IG1vZHVsZSBjYW4gcmVnaXN0ZXIvdW5yZWdpc3RlciBhIGdsb2JhbCBob3RrZXlzLlxuICogQG5hbWVzcGFjZVxuICovXG5jbGFzcyBHbG9iYWxIb3RrZXkgZXh0ZW5kcyBiYXNlXzEuRW1pdHRlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHdpcmUpIHtcbiAgICAgICAgc3VwZXIod2lyZSwgWydnbG9iYWwtaG90a2V5J10pO1xuICAgICAgICB0aGlzLnRvcGljID0gJ2dsb2JhbC1ob3RrZXknO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBnbG9iYWwgaG90a2V5IHdpdGggdGhlIG9wZXJhdGluZyBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gaG90a2V5IGEgaG90a2V5IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgY2FsbGVkIHdoZW4gdGhlIHJlZ2lzdGVyZWQgaG90a2V5IGlzIHByZXNzZWQgYnkgdGhlIHVzZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIEdsb2JhbEhvdGtleS5yZWdpc3RlclxuICAgICAqL1xuICAgIGFzeW5jIHJlZ2lzdGVyKGhvdGtleSwgbGlzdGVuZXIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5vbihob3RrZXksIGxpc3RlbmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oXCJnbG9iYWwtaG90a2V5LXJlZ2lzdGVyXCIgLyogUkVHSVNURVIgKi8sIHsgaG90a2V5IH0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVycyBhIGdsb2JhbCBob3RrZXkgd2l0aCB0aGUgb3BlcmF0aW5nIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSBob3RrZXkgYSBob3RrZXkgc3RyaW5nXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIEdsb2JhbEhvdGtleS51bnJlZ2lzdGVyXG4gICAgICovXG4gICAgYXN5bmMgdW5yZWdpc3Rlcihob3RrZXkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoaG90a2V5KTtcbiAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oXCJnbG9iYWwtaG90a2V5LXVucmVnaXN0ZXJcIiAvKiBVTlJFR0lTVEVSICovLCB7IGhvdGtleSB9KTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlcnMgYWxsIGdsb2JhbCBob3RrZXlzIGZvciB0aGUgY3VycmVudCBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgR2xvYmFsSG90a2V5LnVucmVnaXN0ZXJBbGxcbiAgICAgKi9cbiAgICBhc3luYyB1bnJlZ2lzdGVyQWxsKCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmV2ZW50TmFtZXMoKVxuICAgICAgICAgICAgLmZpbHRlcigobmFtZSkgPT4gIShuYW1lID09PSBcInJlZ2lzdGVyZWRcIiAvKiBSRUdJU1RFUkVEICovIHx8IG5hbWUgPT09IFwidW5yZWdpc3RlcmVkXCIgLyogVU5SRUdJU1RFUkVEICovKSlcbiAgICAgICAgICAgIC5tYXAoKG5hbWUpID0+IHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKG5hbWUpKSk7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKFwiZ2xvYmFsLWhvdGtleS11bnJlZ2lzdGVyLWFsbFwiIC8qIFVOUkVHSVNURVJfQUxMICovLCB7fSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIGhvdGtleSBoYXMgYmVlbiByZWdpc3RlcmVkXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gaG90a2V5IGEgaG90a2V5IHN0cmluZ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPGJvb2xlYW4+fVxuICAgICAqIEB0dXRvcmlhbCBHbG9iYWxIb3RrZXkuaXNSZWdpc3RlcmVkXG4gICAgICovXG4gICAgYXN5bmMgaXNSZWdpc3RlcmVkKGhvdGtleSkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YSB9IH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbihcImdsb2JhbC1ob3RrZXktaXMtcmVnaXN0ZXJlZFwiIC8qIElTX1JFR0lTVEVSRUQgKi8sIHsgaG90a2V5IH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBHbG9iYWxIb3RrZXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbEJhc2UgPSBleHBvcnRzLlByb3RlY3RlZEl0ZW1zID0gdm9pZCAwO1xuY29uc3QgaWRPclJlc3VsdCA9IChmdW5jKSA9PiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGZ1bmMoLi4uYXJncyk7XG4gICAgcmV0dXJuIHJlcyA9PT0gdW5kZWZpbmVkID8gYXJnc1sxXSA6IHJlcztcbn07XG5jbGFzcyBQcm90ZWN0ZWRJdGVtcyB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJJZGVudGl0eSwgc2VuZCkge1xuICAgICAgICB0aGlzLnByb3ZpZGVySWRlbnRpdHkgPSBwcm92aWRlcklkZW50aXR5O1xuICAgICAgICB0aGlzLnNlbmRSYXcgPSBzZW5kO1xuICAgICAgICB0aGlzLnNlbmQgPSBhc3luYyAodG8sIGFjdGlvbiwgcGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gYXdhaXQgc2VuZCgnc2VuZC1jaGFubmVsLW1lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgLi4udG8sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJJZGVudGl0eTogdGhpcy5wcm92aWRlcklkZW50aXR5LFxuICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICBwYXlsb2FkXG4gICAgICAgICAgICB9KS5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbi5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJhdy5wYXlsb2FkLmRhdGEucmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdGVjdGVkSXRlbXMgPSBQcm90ZWN0ZWRJdGVtcztcbmNsYXNzIENoYW5uZWxCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcklkZW50aXR5LCBzZW5kLCBjaGFubmVsUHJvdGVjdGVkTWFwKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFNldCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEFjdGlvbiA9IChhY3Rpb24sIHBheWxvYWQsIGlkKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGFjdGlvbiByZWdpc3RlcmVkIGF0IHRhcmdldCBmb3IgJHthY3Rpb259YCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoZSBpdGVtcyBpbiBQcm90ZWN0ZWRJdGVtcyBhcmUgb25seSB1c2VkIGJ5IHN1YmNsYXNzLCBidXQgbm90IGV4cG9zZWQgdG8gcHVibGljLlxuICAgICAgICAvLyBVc2UgdGhpcyB3YXkgdG8gYXZvaWQgYSBtYWxpY2lvdXMgc2l0ZSB0byBhY2Nlc3MgdGhlbSBkaXJlY3RseS5cbiAgICAgICAgY2hhbm5lbFByb3RlY3RlZE1hcC5zZXQodGhpcywgbmV3IFByb3RlY3RlZEl0ZW1zKHByb3ZpZGVySWRlbnRpdHksIHNlbmQpKTtcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0FjdGlvbihhY3Rpb24sIHBheWxvYWQsIHNlbmRlcklkZW50aXR5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtYWluQWN0aW9uID0gdGhpcy5zdWJzY3JpcHRpb25zLmhhcyhhY3Rpb24pXG4gICAgICAgICAgICAgICAgPyB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KGFjdGlvbilcbiAgICAgICAgICAgICAgICA6IChjdXJyZW50UGF5bG9hZCwgaWQpID0+IHRoaXMuZGVmYXVsdEFjdGlvbihhY3Rpb24sIGN1cnJlbnRQYXlsb2FkLCBpZCk7XG4gICAgICAgICAgICBjb25zdCBwcmVBY3Rpb25Qcm9jZXNzZWQgPSB0aGlzLnByZUFjdGlvbiA/IGF3YWl0IHRoaXMucHJlQWN0aW9uKGFjdGlvbiwgcGF5bG9hZCwgc2VuZGVySWRlbnRpdHkpIDogcGF5bG9hZDtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvblByb2Nlc3NlZCA9IGF3YWl0IG1haW5BY3Rpb24ocHJlQWN0aW9uUHJvY2Vzc2VkLCBzZW5kZXJJZGVudGl0eSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0QWN0aW9uID8gYXdhaXQgdGhpcy5wb3N0QWN0aW9uKGFjdGlvbiwgYWN0aW9uUHJvY2Vzc2VkLCBzZW5kZXJJZGVudGl0eSkgOiBhY3Rpb25Qcm9jZXNzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVycm9yTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yTWlkZGxld2FyZShhY3Rpb24sIGUsIHNlbmRlcklkZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmVmb3JlQWN0aW9uKGZ1bmMpIHtcbiAgICAgICAgaWYgKHRoaXMucHJlQWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FscmVhZHkgcmVnaXN0ZXJlZCBiZWZvcmVBY3Rpb24gbWlkZGxld2FyZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlQWN0aW9uID0gaWRPclJlc3VsdChmdW5jKTtcbiAgICB9XG4gICAgb25FcnJvcihmdW5jKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IHJlZ2lzdGVyZWQgZXJyb3IgbWlkZGxld2FyZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXJyb3JNaWRkbGV3YXJlID0gZnVuYztcbiAgICB9XG4gICAgYWZ0ZXJBY3Rpb24oZnVuYykge1xuICAgICAgICBpZiAodGhpcy5wb3N0QWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FscmVhZHkgcmVnaXN0ZXJlZCBhZnRlckFjdGlvbiBtaWRkbGV3YXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3N0QWN0aW9uID0gaWRPclJlc3VsdChmdW5jKTtcbiAgICB9XG4gICAgcmVtb3ZlKGFjdGlvbikge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKGFjdGlvbik7XG4gICAgfVxuICAgIHNldERlZmF1bHRBY3Rpb24oZnVuYykge1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0U2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmF1bHQgYWN0aW9uIGNhbiBvbmx5IGJlIHNldCBvbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBY3Rpb24gPSBmdW5jO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3Rlcih0b3BpYywgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucy5oYXModG9waWMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1YnNjcmlwdGlvbiBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIGFjdGlvbjogJHt0b3BpY30uIFVuc3Vic2NyaWJlIGJlZm9yZSBhZGRpbmcgbmV3IHN1YnNjcmlwdGlvbmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldCh0b3BpYywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWxCYXNlID0gQ2hhbm5lbEJhc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XG5jb25zdCBjbGllbnRQcm90ZWN0ZWRNYXAgPSBuZXcgV2Vha01hcCgpO1xuY2xhc3MgQ2hhbm5lbENsaWVudCBleHRlbmRzIGNoYW5uZWxfMS5DaGFubmVsQmFzZSB7XG4gICAgY29uc3RydWN0b3Iocm91dGluZ0luZm8sIHNlbmQsIGNsaWVudE1hcCkge1xuICAgICAgICBzdXBlcihyb3V0aW5nSW5mbywgc2VuZCwgY2xpZW50UHJvdGVjdGVkTWFwKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXIgPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2xpZW50TWFwID0gY2xpZW50TWFwO1xuICAgICAgICB0aGlzLmVuZHBvaW50SWQgPSByb3V0aW5nSW5mby5lbmRwb2ludElkO1xuICAgIH1cbiAgICBnZXQgcHJvdmlkZXJJZGVudGl0eSgpIHtcbiAgICAgICAgY29uc3QgcHJvdGVjdGVkT2JqID0gY2xpZW50UHJvdGVjdGVkTWFwLmdldCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHByb3RlY3RlZE9iai5wcm92aWRlcklkZW50aXR5O1xuICAgIH1cbiAgICBhc3luYyBkaXNwYXRjaChhY3Rpb24sIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgcHJvdGVjdGVkT2JqID0gY2xpZW50UHJvdGVjdGVkTWFwLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50TWFwLmdldCh0aGlzLmVuZHBvaW50SWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvdGVjdGVkT2JqLnNlbmQocHJvdGVjdGVkT2JqLnByb3ZpZGVySWRlbnRpdHksIGFjdGlvbiwgcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2xpZW50IHlvdSBhcmUgdHJ5aW5nIHRvIGRpc3BhdGNoIGZyb20gaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIHRhcmdldCBwcm92aWRlci4nKTtcbiAgICB9XG4gICAgb25EaXNjb25uZWN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVyID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBjYWxsaW5nIHRoZSBvbkRpc2Nvbm5lY3Rpb24gY2FsbGJhY2s6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lciA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgcHJvdGVjdGVkT2JqID0gY2xpZW50UHJvdGVjdGVkTWFwLmdldCh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBjaGFubmVsTmFtZSwgdXVpZCwgbmFtZSwgY2hhbm5lbElkIH0gPSBwcm90ZWN0ZWRPYmoucHJvdmlkZXJJZGVudGl0eTtcbiAgICAgICAgYXdhaXQgcHJvdGVjdGVkT2JqLnNlbmRSYXcoJ2Rpc2Nvbm5lY3QtZnJvbS1jaGFubmVsJywgeyBjaGFubmVsTmFtZSwgdXVpZCwgbmFtZSwgZW5kcG9pbnRJZDogdGhpcy5lbmRwb2ludElkIH0pO1xuICAgICAgICB0aGlzLnJlbW92ZUNoYW5uZWwoY2hhbm5lbElkLCB0aGlzLmVuZHBvaW50SWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENoYW5uZWxDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbCA9IHZvaWQgMDtcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xuY29uc3QgcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyXCIpO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uLy4uL2Jhc2VcIik7XG5jbGFzcyBDaGFubmVsIGV4dGVuZHMgYmFzZV8xLkVtaXR0ZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih3aXJlKSB7XG4gICAgICAgIHN1cGVyKHdpcmUsIFsnY2hhbm5lbCddKTtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gICAgICAgICAgICBpZiAobXNnLmFjdGlvbiA9PT0gJ3Byb2Nlc3MtY2hhbm5lbC1tZXNzYWdlJykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NoYW5uZWxNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXNnLmFjdGlvbiA9PT0gJ3Byb2Nlc3MtY2hhbm5lbC1jb25uZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NoYW5uZWxDb25uZWN0aW9uKG1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudG9waWMgPSAnY2hhbm5lbCc7XG4gICAgICAgIHRoaXMucHJvdmlkZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2xpZW50TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmVuZHBvaW50SWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHdpcmUucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcih0aGlzLm9ubWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWxsQ2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWFsbC1jaGFubmVscycpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICBhc3luYyBvbkNoYW5uZWxDb25uZWN0KGxpc3RlbmVyKSB7XG4gICAgICAgIGF3YWl0IHRoaXMub24oJ2Nvbm5lY3RlZCcsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgYXN5bmMgb25DaGFubmVsRGlzY29ubmVjdChsaXN0ZW5lcikge1xuICAgICAgICBhd2FpdCB0aGlzLm9uKCdkaXNjb25uZWN0ZWQnLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3QoY2hhbm5lbE5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFjaGFubmVsTmFtZSB8fCB0eXBlb2YgY2hhbm5lbE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgY2hhbm5lbE5hbWUgc3RyaW5nIHRvIGNvbm5lY3QgdG8gYSBjaGFubmVsLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQgcmVzb2x2ZXI7XG4gICAgICAgIGxldCBsaXN0ZW5lcjtcbiAgICAgICAgY29uc3Qgd2FpdFJlc3BvbnNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbE5hbWUgPT09IHBheWxvYWQuY2hhbm5lbE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY29ubmVjdGVkJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoY2hhbm5lbE5hbWUsIG9wdHMpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub24oJ2Nvbm5lY3RlZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YTogcm91dGluZ0luZm8gfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2Nvbm5lY3QtdG8tY2hhbm5lbCcsIHsgY2hhbm5lbE5hbWUsIC4uLm9wdHMgfSk7XG4gICAgICAgICAgICAvLyBSZXF1aXJlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmICghcm91dGluZ0luZm8uZW5kcG9pbnRJZCkge1xuICAgICAgICAgICAgICAgIHJvdXRpbmdJbmZvLmVuZHBvaW50SWQgPSB0aGlzLndpcmUuZW52aXJvbm1lbnQuZ2V0TmV4dE1lc3NhZ2VJZCgpO1xuICAgICAgICAgICAgICAgIC8vIEZvciBOZXcgQ2xpZW50cyBjb25uZWN0aW5nIHRvIE9sZCBQcm92aWRlcnMuIFRvIHByZXZlbnQgbXVsdGktZGlzcGF0Y2hpbmcgYW5kIHB1Ymxpc2hpbmcsIHdlIGRlbGV0ZSBwcmV2aW91c2x5LWNvbm5lY3RlZFxuICAgICAgICAgICAgICAgIC8vIGNsaWVudHMgdGhhdCBhcmUgaW4gdGhlIHNhbWUgY29udGV4dCBhcyB0aGUgbmV3bHktY29ubmVjdGVkIGNsaWVudC5cbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrRm9yUHJldmlvdXNDbGllbnRDb25uZWN0aW9uKHJvdXRpbmdJbmZvLmNoYW5uZWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGNoYW5uZWxJZCwgZW5kcG9pbnRJZCB9ID0gcm91dGluZ0luZm87XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpc24ndCBhIG1hdGNoaW5nIGNoYW5uZWwsIHRoZSBhYm92ZSBzZW5kQWN0aW9uIGNhbGwgd2lsbCBlcnJvciBvdXQgYW5kIGdvIHRvIGNhdGNoLCBza2lwcGluZyB0aGUgbG9naWMgYmVsb3dcbiAgICAgICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIHJlc29sdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0ZWQnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gbmV3IGNsaWVudF8xLmRlZmF1bHQocm91dGluZ0luZm8sIHRoaXMud2lyZS5zZW5kQWN0aW9uLmJpbmQodGhpcy53aXJlKSwgdGhpcy5jbGllbnRNYXApO1xuICAgICAgICAgICAgdGhpcy5hZGRDaGFubmVsVG9DbGllbnRNYXBzKGNoYW5uZWwsIGNoYW5uZWxJZCwgZW5kcG9pbnRJZCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdXNlIG9mIHByb3RlY3RlZCBwcm9wZXJ0eVxuICAgICAgICAgICAgY2hhbm5lbC5yZW1vdmVDaGFubmVsID0gdGhpcy5yZW1vdmVDaGFubmVsRnJvbUNsaWVudE1hcHMuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2Rpc2Nvbm5lY3RlZCcsIChldmVudFBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRQYXlsb2FkLmNoYW5uZWxOYW1lID09PSBjaGFubmVsTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoYW5uZWxGcm9tQ2xpZW50TWFwcyhjaGFubmVsSWQsIGVuZHBvaW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB1c2Ugb2YgcHJpdmF0ZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLmRpc2Nvbm5lY3RMaXN0ZW5lcihldmVudFBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFdhaXQgPSB7IHdhaXQ6IHRydWUsIC4uLm9wdHMgfS53YWl0O1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxOYWNrTWVzc2FnZSA9ICdpbnRlcm5hbC1uYWNrJztcbiAgICAgICAgICAgIGlmIChzaG91bGRXYWl0ICYmIGUubWVzc2FnZSAmJiBlLm1lc3NhZ2UuaW5jbHVkZXMoaW50ZXJuYWxOYWNrTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENoYW5uZWwgbm90IGZvdW5kIGZvciBjaGFubmVsTmFtZTogJHtjaGFubmVsTmFtZX0sIHdhaXRpbmcgZm9yIGNoYW5uZWwgY3JlYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhaXRSZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLm1lc3NhZ2UgPT09IGludGVybmFsTmFja01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNoYW5uZWwgZm91bmQgZm9yIGNoYW5uZWxOYW1lOiAke2NoYW5uZWxOYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZShjaGFubmVsTmFtZSkge1xuICAgICAgICBpZiAoIWNoYW5uZWxOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgY2hhbm5lbE5hbWUgdG8gY3JlYXRlIGEgY2hhbm5lbCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZDogeyBkYXRhOiBwcm92aWRlcklkZW50aXR5IH0gfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjcmVhdGUtY2hhbm5lbCcsIHsgY2hhbm5lbE5hbWUgfSk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBuZXcgcHJvdmlkZXJfMS5DaGFubmVsUHJvdmlkZXIocHJvdmlkZXJJZGVudGl0eSwgdGhpcy53aXJlLnNlbmRBY3Rpb24uYmluZCh0aGlzLndpcmUpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJvdmlkZXJJZGVudGl0eS5jaGFubmVsSWQ7XG4gICAgICAgIHRoaXMucHJvdmlkZXJNYXAuc2V0KGtleSwgY2hhbm5lbCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAvLyBAdHMtaWdub3JlIHVzZSBvZiBwcm90ZWN0ZWQgcHJvcGVydHlcbiAgICAgICAgY2hhbm5lbC5yZW1vdmVDaGFubmVsID0gdGhpcy5yZW1vdmVDaGFubmVsRnJvbVByb3ZpZGVyTWFwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub24oJ2NsaWVudC1kaXNjb25uZWN0ZWQnLCAoZXZlbnRQYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnRQYXlsb2FkLmNoYW5uZWxOYW1lID09PSBjaGFubmVsTmFtZSkge1xuICAgICAgICAgICAgICAgIGxldCByZW1haW5pbmdDb25uZWN0aW9ucyA9IGNoYW5uZWwuY29ubmVjdGlvbnMuZmlsdGVyKChpZGVudGl0eSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB1c2Ugb2Ygbm9uLWV4aXN0ZWQgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5LmVuZHBvaW50SWQgPT09IHVuZGVmaW5lZCB8fCBpZGVudGl0eS5lbmRwb2ludElkICE9PSBldmVudFBheWxvYWQuZW5kcG9pbnRJZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nQ29ubmVjdGlvbnMubGVuZ3RoID09PSBjaGFubmVsLmNvbm5lY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdDb25uZWN0aW9ucyA9IGNoYW5uZWwuY29ubmVjdGlvbnMuZmlsdGVyKChpZGVudGl0eSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5LnV1aWQgIT09IGV2ZW50UGF5bG9hZC51dWlkIHx8IGlkZW50aXR5Lm5hbWUgIT09IGV2ZW50UGF5bG9hZC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jb25uZWN0aW9ucyA9IHJlbWFpbmluZ0Nvbm5lY3Rpb25zO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdXNlIG9mIHByaXZhdGUgcHJvcGVydHlcbiAgICAgICAgICAgICAgICBjaGFubmVsLmRpc2Nvbm5lY3RMaXN0ZW5lcihldmVudFBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfVxuICAgIGFkZENoYW5uZWxUb0NsaWVudE1hcHMoY2hhbm5lbCwgY2hhbm5lbElkLCBlbmRwb2ludElkKSB7XG4gICAgICAgIHRoaXMuY2xpZW50TWFwLnNldChlbmRwb2ludElkLCBjaGFubmVsKTtcbiAgICAgICAgdGhpcy5lbmRwb2ludElkTWFwLnNldChgJHtjaGFubmVsSWR9LyR7dGhpcy53aXJlLm1lLnV1aWR9LyR7dGhpcy53aXJlLm1lLm5hbWV9YCwgZW5kcG9pbnRJZCk7XG4gICAgfVxuICAgIHJlbW92ZUNoYW5uZWxGcm9tQ2xpZW50TWFwcyhjaGFubmVsSWQsIGVuZHBvaW50SWQpIHtcbiAgICAgICAgdGhpcy5jbGllbnRNYXAuZGVsZXRlKGVuZHBvaW50SWQpO1xuICAgICAgICB0aGlzLmVuZHBvaW50SWRNYXAuZGVsZXRlKGAke2NoYW5uZWxJZH0vJHt0aGlzLndpcmUubWUudXVpZH0vJHt0aGlzLndpcmUubWUubmFtZX1gKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2hhbm5lbEZyb21Qcm92aWRlck1hcChjaGFubmVsSWQpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlck1hcC5kZWxldGUoY2hhbm5lbElkKTtcbiAgICB9XG4gICAgY2hlY2tGb3JQcmV2aW91c0NsaWVudENvbm5lY3Rpb24oY2hhbm5lbElkKSB7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50SWRGcm9tUHJldmlvdXNDb25uZWN0aW9uID0gdGhpcy5lbmRwb2ludElkTWFwLmdldChgJHtjaGFubmVsSWR9LyR7dGhpcy53aXJlLm1lLnV1aWR9LyR7dGhpcy53aXJlLm1lLm5hbWV9YCk7XG4gICAgICAgIGlmIChlbmRwb2ludElkRnJvbVByZXZpb3VzQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGFubmVsRnJvbUNsaWVudE1hcHMoY2hhbm5lbElkLCBlbmRwb2ludElkRnJvbVByZXZpb3VzQ29ubmVjdGlvbik7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1lvdSBoYXZlIGNyZWF0ZWQgYSBzZWNvbmQgY29ubmVjdGlvbiB0byBhbiBvbGRlciBwcm92aWRlci4gRmlyc3QgY29ubmVjdGlvbiBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGNsaWVudE1hcCcpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdJZiB0aGUgcHJvdmlkZXIgY2FsbHMgcHVibGlzaCgpLCB5b3UgbWF5IHJlY2VpdmUgbXVsdGlwbGUgbWVzc2FnZXMuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0NoYW5uZWxNZXNzYWdlKG1zZykge1xuICAgICAgICBjb25zdCB7IHNlbmRlcklkZW50aXR5LCBwcm92aWRlcklkZW50aXR5LCBhY3Rpb24sIGFja1RvU2VuZGVyLCBwYXlsb2FkLCBpbnRlbmRlZFRhcmdldElkZW50aXR5IH0gPSBtc2cucGF5bG9hZDtcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgbGV0IGJ1cztcbiAgICAgICAgLy8gSWYgdGhlIHNlbmRlciBpcyB0aGUgY2xpZW50XG4gICAgICAgIGlmIChpbnRlbmRlZFRhcmdldElkZW50aXR5LmNoYW5uZWxJZCkge1xuICAgICAgICAgICAga2V5ID0gaW50ZW5kZWRUYXJnZXRJZGVudGl0eS5jaGFubmVsSWQ7XG4gICAgICAgICAgICBidXMgPSB0aGlzLnByb3ZpZGVyTWFwLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGludGVuZGVkVGFyZ2V0SWRlbnRpdHkuZW5kcG9pbnRJZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHNlbmRlciBpcyB0aGUgcHJvdmlkZXJcbiAgICAgICAgICAgIGtleSA9IGludGVuZGVkVGFyZ2V0SWRlbnRpdHkuZW5kcG9pbnRJZDtcbiAgICAgICAgICAgIGJ1cyA9IHRoaXMuY2xpZW50TWFwLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gdGhpcy5lbmRwb2ludElkTWFwLmdldChgJHtwcm92aWRlcklkZW50aXR5LmNoYW5uZWxJZH0vJHt0aGlzLndpcmUubWUudXVpZH0vJHt0aGlzLndpcmUubWUubmFtZX1gKTtcbiAgICAgICAgICAgIGJ1cyA9IHRoaXMuY2xpZW50TWFwLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYnVzKSB7XG4gICAgICAgICAgICBhY2tUb1NlbmRlci5wYXlsb2FkLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucmVhc29uID0gYENsaWVudCBjb25uZWN0aW9uIHdpdGggaWRlbnRpdHkgdXVpZDogJHt0aGlzLndpcmUubWUudXVpZH0gLyBuYW1lOiAke3RoaXMud2lyZS5tZS5uYW1lfSBubyBsb25nZXIgY29ubmVjdGVkLmA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRSYXcoYWNrVG9TZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBidXMucHJvY2Vzc0FjdGlvbihhY3Rpb24sIHBheWxvYWQsIHNlbmRlcklkZW50aXR5KTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucGF5bG9hZCA9IGFja1RvU2VuZGVyLnBheWxvYWQucGF5bG9hZCB8fCB7fTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucGF5bG9hZC5yZXN1bHQgPSByZXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRSYXcoYWNrVG9TZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhY2tUb1NlbmRlci5wYXlsb2FkLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucmVhc29uID0gZS5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kUmF3KGFja1RvU2VuZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzQ2hhbm5lbENvbm5lY3Rpb24obXNnKSB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50SWRlbnRpdHksIHByb3ZpZGVySWRlbnRpdHksIGFja1RvU2VuZGVyLCBwYXlsb2FkIH0gPSBtc2cucGF5bG9hZDtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJvdmlkZXJJZGVudGl0eS5jaGFubmVsSWQ7XG4gICAgICAgIGNvbnN0IGJ1cyA9IHRoaXMucHJvdmlkZXJNYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghYnVzKSB7XG4gICAgICAgICAgICBhY2tUb1NlbmRlci5wYXlsb2FkLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucmVhc29uID0gYENoYW5uZWwgXCIke3Byb3ZpZGVySWRlbnRpdHkuY2hhbm5lbE5hbWV9XCIgaGFzIGJlZW4gZGVzdHJveWVkLmA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRSYXcoYWNrVG9TZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIShidXMgaW5zdGFuY2VvZiBwcm92aWRlcl8xLkNoYW5uZWxQcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGNvbm5lY3QgdG8gYSBjaGFubmVsIGNsaWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgYnVzLnByb2Nlc3NDb25uZWN0aW9uKGNsaWVudElkZW50aXR5LCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucGF5bG9hZCA9IGFja1RvU2VuZGVyLnBheWxvYWQucGF5bG9hZCB8fCB7fTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucGF5bG9hZC5yZXN1bHQgPSByZXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRSYXcoYWNrVG9TZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhY2tUb1NlbmRlci5wYXlsb2FkLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGFja1RvU2VuZGVyLnBheWxvYWQucmVhc29uID0gZS5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kUmF3KGFja1RvU2VuZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbCA9IENoYW5uZWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcbmNvbnN0IHJ1bnRpbWVWZXJzaW9uaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbC9ydW50aW1lVmVyc2lvbmluZ1wiKTtcbmNvbnN0IHByb3ZpZGVyUHJvdGVjdGVkTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIENoYW5uZWxQcm92aWRlciBleHRlbmRzIGNoYW5uZWxfMS5DaGFubmVsQmFzZSB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJJZGVudGl0eSwgc2VuZCkge1xuICAgICAgICBzdXBlcihwcm92aWRlcklkZW50aXR5LCBzZW5kLCBwcm92aWRlclByb3RlY3RlZE1hcCk7XG4gICAgICAgIHRoaXMuY29ubmVjdExpc3RlbmVyID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lciA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBkaXNwYXRjaCh0bywgYWN0aW9uLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmICghQ2hhbm5lbFByb3ZpZGVyLmNsaWVudElkZW50aXR5SW5jbHVkZXNFbmRwb2ludElkKHRvKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0Zvck11bHRpcGxlQ2xpZW50cyh0bywgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0NsaWVudENvbm5lY3RlZCh0bykpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlclByb3RlY3RlZE1hcC5nZXQodGhpcykuc2VuZCh0bywgYWN0aW9uLCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBUaGUgY2xpZW50IHlvdSBhcmUgdHJ5aW5nIHRvIGRpc3BhdGNoIHRvIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoaXMgcHJvdmlkZXIuXG4gICAgICAgICAgICAgICAge3V1aWQ6ICR7dG8udXVpZH0sIG5hbWU6ICR7dG8ubmFtZX19YCkpO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzQWN0aW9uKGFjdGlvbiwgcGF5bG9hZCwgc2VuZGVySWRlbnRpdHkpIHtcbiAgICAgICAgaWYgKENoYW5uZWxQcm92aWRlci5jbGllbnRJc011bHRpUnVudGltZShzZW5kZXJJZGVudGl0eSkgJiZcbiAgICAgICAgICAgICFydW50aW1lVmVyc2lvbmluZ18xLnJ1bnRpbWVVdWlkTWVldHNNaW5pbXVtUnVudGltZVZlcnNpb24oc2VuZGVySWRlbnRpdHkucnVudGltZVV1aWQsICcxOC44Ny41Ni4wJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTXVsdGlSdW50aW1lTGVnYWN5Q2xpZW50KHNlbmRlcklkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JDbGllbnRDb25uZWN0aW9uKHNlbmRlcklkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIucHJvY2Vzc0FjdGlvbihhY3Rpb24sIHBheWxvYWQsIHNlbmRlcklkZW50aXR5KTtcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0Nvbm5lY3Rpb24oc2VuZGVySWQsIHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5wdXNoKHNlbmRlcklkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdExpc3RlbmVyKHNlbmRlcklkLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgcHVibGlzaChhY3Rpb24sIHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbnMubWFwKCh0bykgPT4gcHJvdmlkZXJQcm90ZWN0ZWRNYXAuZ2V0KHRoaXMpLnNlbmQodG8sIGFjdGlvbiwgcGF5bG9hZCkpO1xuICAgIH1cbiAgICBvbkNvbm5lY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0TGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICB9XG4gICAgb25EaXNjb25uZWN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgfVxuICAgIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IHByb3RlY3RlZE9iaiA9IHByb3ZpZGVyUHJvdGVjdGVkTWFwLmdldCh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBjaGFubmVsTmFtZSwgY2hhbm5lbElkIH0gPSBwcm90ZWN0ZWRPYmoucHJvdmlkZXJJZGVudGl0eTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucyA9IFtdO1xuICAgICAgICBhd2FpdCBwcm90ZWN0ZWRPYmouc2VuZFJhdygnZGVzdHJveS1jaGFubmVsJywgeyBjaGFubmVsTmFtZSB9KTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGFubmVsKGNoYW5uZWxJZCk7XG4gICAgfVxuICAgIGNoZWNrRm9yQ2xpZW50Q29ubmVjdGlvbihjbGllbnRJZGVudGl0eSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDbGllbnRDb25uZWN0ZWQoY2xpZW50SWRlbnRpdHkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgYWN0aW9uIHdhcyBzZW50IGZyb20gYSBjbGllbnQgdGhhdCBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBwcm92aWRlci5cbiAgICAgICAgICAgICAgICAgICAgQ2xpZW50IElkZW50aXR5OiB7dXVpZDogJHtjbGllbnRJZGVudGl0eS51dWlkfSwgbmFtZTogJHtjbGllbnRJZGVudGl0eS5uYW1lfSwgZW5kcG9pbnRJZDogJHtjbGllbnRJZGVudGl0eS5lbmRwb2ludElkfX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0NsaWVudENvbm5lY3RlZChjbGllbnRJZGVudGl0eSkge1xuICAgICAgICBpZiAoQ2hhbm5lbFByb3ZpZGVyLmNsaWVudElkZW50aXR5SW5jbHVkZXNFbmRwb2ludElkKGNsaWVudElkZW50aXR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbnMuc29tZSgoaWRlbnRpdHkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIC8vIE1pZ2h0IGJlIHJlZHVuZGFudCB0byBjaGVjayBmb3IgdXVpZCBhbmQgbmFtZSBoZXJlIGFmdGVyIHdlIGdldCBhbiBlbmRwb2ludElkIG1hdGNoLCBidXQganVzdCBpbiBjYXNlXG4gICAgICAgICAgICAgICAgaWRlbnRpdHkuZW5kcG9pbnRJZCA9PT0gY2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZCAmJlxuICAgICAgICAgICAgICAgICAgICBpZGVudGl0eS51dWlkID09PSBjbGllbnRJZGVudGl0eS51dWlkICYmXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aXR5Lm5hbWUgPT09IGNsaWVudElkZW50aXR5Lm5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMZWdhY3lDbGllbnRDb25uZWN0ZWQoY2xpZW50SWRlbnRpdHkpO1xuICAgIH1cbiAgICBpc0xlZ2FjeUNsaWVudENvbm5lY3RlZChjbGllbnRJZGVudGl0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9ucy5zb21lKChpZGVudGl0eSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5LnV1aWQgPT09IGNsaWVudElkZW50aXR5LnV1aWQgJiYgaWRlbnRpdHkubmFtZSA9PT0gY2xpZW50SWRlbnRpdHkubmFtZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZU11bHRpUnVudGltZUxlZ2FjeUNsaWVudChzZW5kZXJJZGVudGl0eSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNMZWdhY3lDbGllbnRDb25uZWN0ZWQoc2VuZGVySWRlbnRpdHkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgYWN0aW9uIHdhcyBzZW50IGZyb20gYSBjbGllbnQgdGhhdCBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBwcm92aWRlci4gQ2xpZW50IElkZW50aXR5OlxuICAgICAgICAgICAgICAgICAgICB7dXVpZDogJHtzZW5kZXJJZGVudGl0eS51dWlkfSwgbmFtZTogJHtzZW5kZXJJZGVudGl0eS5uYW1lfSwgZW5kcG9pbnRJZDogJHtzZW5kZXJJZGVudGl0eS5lbmRwb2ludElkfX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0Zvck11bHRpcGxlQ2xpZW50cyhjbGllbnRJZGVudGl0eSwgYWN0aW9uKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKGMubmFtZSA9PT0gY2xpZW50SWRlbnRpdHkubmFtZSAmJiBjLnV1aWQgPT09IGNsaWVudElkZW50aXR5LnV1aWQpIHtcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvdW50ID49IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RlY3RlZE9iaiA9IHByb3ZpZGVyUHJvdGVjdGVkTWFwLmdldCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdXVpZCwgbmFtZSB9ID0gY2xpZW50SWRlbnRpdHk7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlclV1aWQgPSBwcm90ZWN0ZWRPYmogPT09IG51bGwgfHwgcHJvdGVjdGVkT2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm90ZWN0ZWRPYmoucHJvdmlkZXJJZGVudGl0eS51dWlkO1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXJOYW1lID0gcHJvdGVjdGVkT2JqID09PSBudWxsIHx8IHByb3RlY3RlZE9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvdGVjdGVkT2JqLnByb3ZpZGVySWRlbnRpdHkubmFtZTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdBUk5JTkc6IERpc3BhdGNoIGNhbGwgbWF5IGhhdmUgdW5pbnRlbmRlZCByZXN1bHRzLiBUaGUgXCJ0b1wiIGFyZ3VtZW50IG9mIHlvdXIgZGlzcGF0Y2ggY2FsbCBpcyBtaXNzaW5nIHRoZVxuICAgICAgICAgICAgICAgIFwiZW5kcG9pbnRJZFwiIHBhcmFtZXRlci4gVGhlIGlkZW50aXR5IHlvdSBhcmUgZGlzcGF0Y2hpbmcgdG8gKHt1dWlkOiAke3V1aWR9LCBuYW1lOiAke25hbWV9fSlcbiAgICAgICAgICAgICAgICBoYXMgbXVsdGlwbGUgY2hhbm5lbENsaWVudHMgZm9yIHRoaXMgY2hhbm5lbC4gWW91ciBkaXNwYXRjaGVkIGFjdGlvbjogKCR7YWN0aW9ufSkgZnJvbSB0aGUgcHJvdmlkZXI6XG4gICAgICAgICAgICAgICAgKHt1dWlkOiAke3Byb3ZpZGVyVXVpZH0sIG5hbWU6ICR7cHJvdmlkZXJOYW1lfX0pIHdpbGwgb25seSBiZSBwcm9jZXNzZWQgYnkgdGhlIG1vc3QgcmVjZW50bHktY3JlYXRlZCBjbGllbnQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBzdGF0aWMgY2xpZW50SWRlbnRpdHlJbmNsdWRlc0VuZHBvaW50SWQoc3Vic2NyaXB0aW9uSWRlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbklkZW50aXR5LmVuZHBvaW50SWQgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBzdGF0aWMgY2xpZW50SXNNdWx0aVJ1bnRpbWUoc3Vic2NyaXB0aW9uSWRlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbklkZW50aXR5LnJ1bnRpbWVVdWlkICE9PSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsUHJvdmlkZXIgPSBDaGFubmVsUHJvdmlkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJBcHBQYXlsb2FkID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG5jb25zdCByZWZfY291bnRlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvcmVmLWNvdW50ZXJcIik7XG5jb25zdCBpbmRleF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbC9pbmRleFwiKTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC92YWxpZGF0ZVwiKTtcbi8qKlxuICogQSBtZXNzYWdpbmcgYnVzIHRoYXQgYWxsb3dzIGZvciBwdWIvc3ViIG1lc3NhZ2luZyBiZXR3ZWVuIGRpZmZlcmVudCBhcHBsaWNhdGlvbnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbmNsYXNzIEludGVyQXBwbGljYXRpb25CdXMgZXh0ZW5kcyBiYXNlXzEuQmFzZSB7XG4gICAgY29uc3RydWN0b3Iod2lyZSkge1xuICAgICAgICBzdXBlcih3aXJlKTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyQWRkZWQ6ICdzdWJzY3JpYmVyLWFkZGVkJyxcbiAgICAgICAgICAgIHN1YnNjcmliZXJSZW1vdmVkOiAnc3Vic2NyaWJlci1yZW1vdmVkJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlZkNvdW50ZXIgPSBuZXcgcmVmX2NvdW50ZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuQ2hhbm5lbCA9IG5ldyBpbmRleF8xLkNoYW5uZWwod2lyZSk7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBldmVudHNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgd2lyZS5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKHRoaXMub25tZXNzYWdlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm9uID0gdGhpcy5lbWl0dGVyLm9uLmJpbmQodGhpcy5lbWl0dGVyKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSB0aGlzLmVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzLmJpbmQodGhpcy5lbWl0dGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIGEgbWVzc2FnZSB0byBhbGwgYXBwbGljYXRpb25zIHJ1bm5pbmcgb24gT3BlbkZpbiBSdW50aW1lIHRoYXRcbiAgICAgKiBhcmUgc3Vic2NyaWJlZCB0byB0aGUgc3BlY2lmaWVkIHRvcGljLlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHRvcGljIFRoZSB0b3BpYyBvbiB3aGljaCB0aGUgbWVzc2FnZSBpcyBzZW50XG4gICAgICogQHBhcmFtIHsgYW55IH0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBwdWJsaXNoZWQuIENhbiBiZSBlaXRoZXIgYSBwcmltaXRpdmVcbiAgICAgKiBkYXRhIHR5cGUgKHN0cmluZywgbnVtYmVyLCBvciBib29sZWFuKSBvciBjb21wb3NpdGUgZGF0YSB0eXBlIChvYmplY3QsIGFycmF5KVxuICAgICAqIHRoYXQgaXMgY29tcG9zZWQgb2Ygb3RoZXIgcHJpbWl0aXZlIG9yIGNvbXBvc2l0ZSBkYXRhIHR5cGVzXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIEludGVyQXBwbGljYXRpb25CdXMucHVibGlzaFxuICAgICAqL1xuICAgIHB1Ymxpc2godG9waWMsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ3B1Ymxpc2gtbWVzc2FnZScsIHtcbiAgICAgICAgICAgIHRvcGljLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHNvdXJjZVdpbmRvd05hbWU6IHRoaXMubWUubmFtZVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIGEgc3BlY2lmaWMgYXBwbGljYXRpb24gb24gYSBzcGVjaWZpYyB0b3BpYy5cbiAgICAgKiBAcGFyYW0geyBJZGVudGl0eSB9IGRlc3RpbmF0aW9uIFRoZSBpZGVudGl0eSBvZiB0aGUgYXBwbGljYXRpb24gdG8gd2hpY2ggdGhlIG1lc3NhZ2UgaXMgc2VudFxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHRvcGljIFRoZSB0b3BpYyBvbiB3aGljaCB0aGUgbWVzc2FnZSBpcyBzZW50XG4gICAgICogQHBhcmFtIHsgYW55IH0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBzZW50LiBDYW4gYmUgZWl0aGVyIGEgcHJpbWl0aXZlIGRhdGFcbiAgICAgKiB0eXBlIChzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbikgb3IgY29tcG9zaXRlIGRhdGEgdHlwZSAob2JqZWN0LCBhcnJheSkgdGhhdFxuICAgICAqIGlzIGNvbXBvc2VkIG9mIG90aGVyIHByaW1pdGl2ZSBvciBjb21wb3NpdGUgZGF0YSB0eXBlc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBJbnRlckFwcGxpY2F0aW9uQnVzLnNlbmRcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kKGRlc3RpbmF0aW9uLCB0b3BpYywgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBlcnJvck1zZyA9IHZhbGlkYXRlXzEudmFsaWRhdGVJZGVudGl0eShkZXN0aW5hdGlvbik7XG4gICAgICAgIGlmIChlcnJvck1zZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignc2VuZC1tZXNzYWdlJywge1xuICAgICAgICAgICAgZGVzdGluYXRpb25VdWlkOiBkZXN0aW5hdGlvbi51dWlkLFxuICAgICAgICAgICAgZGVzdGluYXRpb25XaW5kb3dOYW1lOiBkZXN0aW5hdGlvbi5uYW1lLFxuICAgICAgICAgICAgdG9waWMsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgc291cmNlV2luZG93TmFtZTogdGhpcy5tZS5uYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIG1lc3NhZ2VzIGZyb20gdGhlIHNwZWNpZmllZCBhcHBsaWNhdGlvbiBvbiB0aGUgc3BlY2lmaWVkIHRvcGljLlxuICAgICAqIEBwYXJhbSB7IElkZW50aXR5IH0gc291cmNlIFRoaXMgb2JqZWN0IGlzIGRlc2NyaWJlZCBpbiB0aGUgSWRlbnRpdHkgaW4gdGhlIHR5cGVkZWZcbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSB0b3BpYyBUaGUgdG9waWMgb24gd2hpY2ggdGhlIG1lc3NhZ2UgaXMgc2VudFxuICAgICAqIEBwYXJhbSB7IGZ1bmN0aW9uIH0gbGlzdGVuZXIgQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgbWVzc2FnZSBoYXNcbiAgICAgKiBiZWVuIHJlY2VpdmVkLiBJdCBpcyBwYXNzZWQgdGhlIG1lc3NhZ2UsIHV1aWQgYW5kIG5hbWUgb2YgdGhlIHNlbmRpbmcgYXBwbGljYXRpb24uXG4gICAgICogVGhlIG1lc3NhZ2UgY2FuIGJlIGVpdGhlciBhIHByaW1pdGl2ZSBkYXRhIHR5cGUgKHN0cmluZywgbnVtYmVyLCBvciBib29sZWFuKSBvclxuICAgICAqIGNvbXBvc2l0ZSBkYXRhIHR5cGUgKG9iamVjdCwgYXJyYXkpIHRoYXQgaXMgY29tcG9zZWQgb2Ygb3RoZXIgcHJpbWl0aXZlIG9yIGNvbXBvc2l0ZVxuICAgICAqIGRhdGEgdHlwZXNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgSW50ZXJBcHBsaWNhdGlvbkJ1cy5zdWJzY3JpYmVcbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoc291cmNlLCB0b3BpYywgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViS2V5ID0gdGhpcy5jcmVhdGVTdWJzY3JpcHRpb25LZXkoc291cmNlLnV1aWQsIHNvdXJjZS5uYW1lIHx8ICcqJywgdG9waWMpO1xuICAgICAgICBjb25zdCBzZW5kU3Vic2NyaXB0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzdWJzY3JpYmUnLCB7XG4gICAgICAgICAgICAgICAgc291cmNlVXVpZDogc291cmNlLnV1aWQsXG4gICAgICAgICAgICAgICAgc291cmNlV2luZG93TmFtZTogc291cmNlLm5hbWUgfHwgJyonLFxuICAgICAgICAgICAgICAgIHRvcGljLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uV2luZG93TmFtZTogdGhpcy5tZS5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWxyZWFkeVN1YnNjcmliZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdHRlci5vbihzdWJLZXksIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmQ291bnRlci5hY3RPbkZpcnN0KHN1YktleSwgc2VuZFN1YnNjcmlwdGlvbiwgYWxyZWFkeVN1YnNjcmliZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgdG8gbWVzc2FnZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGFwcGxpY2F0aW9uIG9uIHRoZSBzcGVjaWZpZWQgdG9waWMuXG4gICAgICogQHBhcmFtIHsgSWRlbnRpdHkgfSBzb3VyY2UgVGhpcyBvYmplY3QgaXMgZGVzY3JpYmVkIGluIHRoZSBJZGVudGl0eSBpbiB0aGUgdHlwZWRlZlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHRvcGljIFRoZSB0b3BpYyBvbiB3aGljaCB0aGUgbWVzc2FnZSBpcyBzZW50XG4gICAgICogQHBhcmFtIHsgZnVuY3Rpb24gfSBsaXN0ZW5lciBBIGNhbGxiYWNrIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIHN1YnNjcmliZSgpXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIEludGVyQXBwbGljYXRpb25CdXMudW5zdWJzY3JpYmVcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShzb3VyY2UsIHRvcGljLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWJLZXkgPSB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbktleShzb3VyY2UudXVpZCwgc291cmNlLm5hbWUgfHwgJyonLCB0b3BpYyk7XG4gICAgICAgIGNvbnN0IHNlbmRVbnN1YnNjcmlwdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigndW5zdWJzY3JpYmUnLCB7XG4gICAgICAgICAgICAgICAgc291cmNlVXVpZDogc291cmNlLnV1aWQsXG4gICAgICAgICAgICAgICAgc291cmNlV2luZG93TmFtZTogc291cmNlLm5hbWUgfHwgJyonLFxuICAgICAgICAgICAgICAgIHRvcGljLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uV2luZG93TmFtZTogdGhpcy5tZS5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZG9udFNlbmRVbnN1YnNjcmlwdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocikgPT4gcikudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoc3ViS2V5LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZkNvdW50ZXIuYWN0T25MYXN0KHN1YktleSwgc2VuZFVuc3Vic2NyaXB0aW9uLCBkb250U2VuZFVuc3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgcHJvY2Vzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgbWVzc2FnZTogcGF5bG9hZE1lc3NhZ2UsIHNvdXJjZVdpbmRvd05hbWUsIHNvdXJjZVV1aWQsIHRvcGljIH0gfSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbktleShzb3VyY2VVdWlkLCBzb3VyY2VXaW5kb3dOYW1lLCB0b3BpYyksXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbktleShzb3VyY2VVdWlkLCAnKicsIHRvcGljKSxcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9uS2V5KCcqJywgJyonLCB0b3BpYylcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgaWRPZlNlbmRlciA9IHsgdXVpZDogc291cmNlVXVpZCwgbmFtZTogc291cmNlV2luZG93TmFtZSB9O1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoa2V5LCBwYXlsb2FkTWVzc2FnZSwgaWRPZlNlbmRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbWl0U3Vic2NyaXZlckV2ZW50KHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IHRhcmdldE5hbWU6IG5hbWUsIHV1aWQsIHRvcGljIH0gfSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IG5hbWUsIHV1aWQsIHRvcGljIH07XG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KHR5cGUsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGNyZWF0ZVN1YnNjcmlwdGlvbktleSh1dWlkLCBuYW1lLCB0b3BpYykge1xuICAgICAgICBjb25zdCBuID0gbmFtZSB8fCAnKic7XG4gICAgICAgIGlmICghKHV1aWQgJiYgbiAmJiB0b3BpYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB1dWlkLCBuYW1lLCBvciB0b3BpYyBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlS2V5KHV1aWQsIG4sIHRvcGljKTtcbiAgICB9XG4gICAgb25tZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgeyBhY3Rpb24gfSA9IG1lc3NhZ2U7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdwcm9jZXNzLW1lc3NhZ2UnOlxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc01lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuZXZlbnRzLnN1YnNjcmliZXJBZGRlZDpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRTdWJzY3JpdmVyRXZlbnQodGhpcy5ldmVudHMuc3Vic2NyaWJlckFkZGVkLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5ldmVudHMuc3Vic2NyaWJlclJlbW92ZWQ6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0U3Vic2NyaXZlckV2ZW50KHRoaXMuZXZlbnRzLnN1YnNjcmliZXJSZW1vdmVkLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gSW50ZXJBcHBsaWNhdGlvbkJ1cztcbmNsYXNzIEludGVyQXBwUGF5bG9hZCB7XG59XG5leHBvcnRzLkludGVyQXBwUGF5bG9hZCA9IEludGVyQXBwUGF5bG9hZDtcbmZ1bmN0aW9uIGNyZWF0ZUtleSguLi50b0hhc2gpIHtcbiAgICByZXR1cm4gdG9IYXNoXG4gICAgICAgIC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGAke2l0ZW19YCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcvJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuY29uc3QgSW50ZXJvcEJyb2tlcl8xID0gcmVxdWlyZShcIi4vSW50ZXJvcEJyb2tlclwiKTtcbmNvbnN0IEludGVyb3BDbGllbnRfMSA9IHJlcXVpcmUoXCIuL0ludGVyb3BDbGllbnRcIik7XG5jb25zdCBkZWZhdWx0T3ZlcnJpZGUgPSAoQ2xhc3MsIC4uLmFyZ3MpID0+IG5ldyBDbGFzcyguLi5hcmdzKTtcbi8qKlxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBJbnRlcm9wQ29uZmlnXG4gKiBAc3VtbWFyeSBJbmZvcm1hdGlvbiByZWxldmFudCB0byB0aGUgSW50ZXJvcCBCcm9rZXIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2N1cnJlbnRDb250ZXh0R3JvdXBdIENvbnRleHQgR3JvdXAgZm9yIHRoZSBjbGllbnQuIChncmVlbiwgeWVsbG93LCByZWQsIGV0Yy4pXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Byb3ZpZGVySWRdIFdoZW4gcHJvdmlkZWQsIGF1dG9tYXRpY2FsbHkgY29ubmVjdHMgdGhlIGNsaWVudCB0byB0aGUgc3BlY2lmaWVkIHByb3ZpZGVyIHV1aWRcbiAqL1xuLyoqXG4gKiBNYW5hZ2VzIGNyZWF0aW9uIG9mIEludGVyb3AgQnJva2VycyBhbmQgSW50ZXJvcCBDbGllbnRzLiBUaGVzZSBBUElzIGFyZSBjYWxsZWQgdW5kZXItdGhlLWhvb2QgaW4gUGxhdGZvcm1zLlxuICogQG5hbWVzcGFjZVxuICogQGFsaWFzIEludGVyb3BcbiAqL1xuY2xhc3MgSW50ZXJvcE1vZHVsZSBleHRlbmRzIGJhc2VfMS5CYXNlIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBJbnRlcm9wIEJyb2tlci4gVGhpcyBpcyBjYWxsZWQgdW5kZXItdGhlLWhvb2QgZm9yIFBsYXRmb3Jtcy5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSBuYW1lIC0gTmFtZSBvZiB0aGUgSW50ZXJvcCBCcm9rZXIuXG4gICAgICogQHBhcmFtIHsgT3ZlcnJpZGVDYWxsYmFjazxJbnRlcm9wQnJva2VyPiB9IFtvdmVycmlkZV0gLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZXh0ZW5kIG9yIHJlcGxhY2UgZGVmYXVsdCBJbnRlcm9wIEJyb2tlciBiZWhhdmlvci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxJbnRlcm9wQnJva2VyPn1cbiAgICAgKiBAdHV0b3JpYWwgSW50ZXJvcC5pbml0XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBhc3luYyBpbml0KG5hbWUsIG92ZXJyaWRlID0gZGVmYXVsdE92ZXJyaWRlKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWluaXQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZmluLkludGVyQXBwbGljYXRpb25CdXMuQ2hhbm5lbC5jcmVhdGUoYGludGVyb3AtYnJva2VyLSR7bmFtZX1gKTtcbiAgICAgICAgLy8gQWxsb3dzIGZvciBtYW5pZmVzdC1sZXZlbCBjb25maWd1cmF0aW9uLCB3aXRob3V0IGhhdmluZyB0byBvdmVycmlkZS4gKGUuZy4gc3BlY2lmeWluZyBjdXN0b20gY29udGV4dCBncm91cHMpXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCB0aGlzLmZpbi5BcHBsaWNhdGlvbi5nZXRDdXJyZW50U3luYygpLmdldEluZm8oKTtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlKEludGVyb3BCcm9rZXJfMS5JbnRlcm9wQnJva2VyLCB0aGlzLndpcmUsIHByb3ZpZGVyLCBvcHRpb25zLmluaXRpYWxPcHRpb25zLmludGVyb3BCcm9rZXJDb25maWd1cmF0aW9uIHx8IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgYSBjbGllbnQgdG8gYW4gSW50ZXJvcCBicm9rZXIuIFRoaXMgaXMgY2FsbGVkIHVuZGVyLXRoZS1ob29kIGZvciBWaWV3cyBpbiBhIFBsYXRmb3JtLlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgSW50ZXJvcCBCcm9rZXIgdG8gY29ubmVjdCB0by4gRm9yIFBsYXRmb3JtcywgdGhpcyB3aWxsIGRlZmF1bHQgdG8gdGhlIHV1aWQgb2YgdGhlIFBsYXRmb3JtLlxuICAgICAqIEBwYXJhbSB7IEludGVyb3BDb25maWcgfSBbaW50ZXJvcENvbmZpZ10gLSBJbmZvcm1hdGlvbiByZWxldmFudCB0byB0aGUgSW50ZXJvcCBCcm9rZXIuIFR5cGljYWxseSBhIGRlY2xhcmF0aW9uIG9mXG4gICAgICogd2hhdCBjb250ZXh0KHMpIHRoZSBlbnRpdHkgd2FudHMgdG8gc3Vic2NyaWJlIHRvLCBhbmQgdGhlIGN1cnJlbnQgQ29udGV4dCBHcm91cCBvZiB0aGUgZW50aXR5LlxuICAgICAqIEByZXR1cm4ge0ludGVyb3BDbGllbnR9XG4gICAgICogQHR1dG9yaWFsIEludGVyb3AuY29ubmVjdFN5bmNcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGNvbm5lY3RTeW5jKG5hbWUsIGludGVyb3BDb25maWcpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtY29ubmVjdC1zeW5jJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcm9wQ2xpZW50XzEuSW50ZXJvcENsaWVudCh0aGlzLndpcmUsIG5hbWUsIGludGVyb3BDb25maWcpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEludGVyb3BNb2R1bGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJvcEJyb2tlciA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xubGV0IGNvbnRleHRHcm91cHMgPSBbXG4gICAge1xuICAgICAgICBpZDogJ2dyZWVuJyxcbiAgICAgICAgZGlzcGxheU1ldGFkYXRhOiB7XG4gICAgICAgICAgICBjb2xvcjogJyMwMENDODgnLFxuICAgICAgICAgICAgbmFtZTogJ2dyZWVuJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiAncHVycGxlJyxcbiAgICAgICAgZGlzcGxheU1ldGFkYXRhOiB7XG4gICAgICAgICAgICBjb2xvcjogJyM4QzYxRkYnLFxuICAgICAgICAgICAgbmFtZTogJ3B1cnBsZSdcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBpZDogJ29yYW5nZScsXG4gICAgICAgIGRpc3BsYXlNZXRhZGF0YToge1xuICAgICAgICAgICAgY29sb3I6ICcjRkY4QzRDJyxcbiAgICAgICAgICAgIG5hbWU6ICdvcmFuZ2UnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWQ6ICdyZWQnLFxuICAgICAgICBkaXNwbGF5TWV0YWRhdGE6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI0ZGNUU2MCcsXG4gICAgICAgICAgICBuYW1lOiAncmVkJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiAncGluaycsXG4gICAgICAgIGRpc3BsYXlNZXRhZGF0YToge1xuICAgICAgICAgICAgY29sb3I6ICcjRkY4RkI4JyxcbiAgICAgICAgICAgIG5hbWU6ICdwaW5rJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiAneWVsbG93JyxcbiAgICAgICAgZGlzcGxheU1ldGFkYXRhOiB7XG4gICAgICAgICAgICBjb2xvcjogJyNFOUZGOEYnLFxuICAgICAgICAgICAgbmFtZTogJ3llbGxvdydcbiAgICAgICAgfVxuICAgIH1cbl07XG4vKipcbiAqIHtAbGluayBodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9vZi1kb2NzL2RvY3MvZW5hYmxlLWNvbG9yLWxpbmtpbmcgKipUSEUgSU5URVJPUCBBUEkgSVMgRVhQRVJJTUVOVEFMLiBJRiBZT1UgV09VTEQgTElLRSBUTyBVU0UgSVQsIFBMRUFTRSBVU0UgT1VSIERFRkFVTFQgSU1QTEVNRU5UQVRJT04gSU4gQlJPV1NFUioqfVxuICpcbiAqIFRoZSBJbnRlcm9wIEJyb2tlciBpcyByZXNwb25zaWJsZSBmb3Iga2VlcGluZyB0cmFjayBvZiB0aGUgSW50ZXJvcCBzdGF0ZSBvZiB0aGUgUGxhdGZvcm0sIGFuZCBmb3IgZGlyZWN0aW5nIG1lc3NhZ2VzIHRvIHRoZSBwcm9wZXIgbG9jYXRpb25zLlxuICpcbiAqIC0tLVxuICpcbiAqIFRoZXJlIGFyZSAyIHdheXMgdG8gaW5qZWN0IGN1c3RvbSBmdW5jdGlvbmFsaXR5IGludG8gdGhlIEludGVyb3AgQnJva2VyOlxuICpcbiAqICoqMS4gQ29uZmlndXJhdGlvbioqXG4gKlxuICogQXQgdGhlIG1vbWVudCwgeW91IGNhbiBjb25maWd1cmUgdGhlIGRlZmF1bHQgY29udGV4dCBncm91cHMgZm9yIHRoZSBJbnRlcm9wIEJyb2tlciB3aXRob3V0IGhhdmluZyB0byBvdmVycmlkZSBpdC4gVG8gZG8gc28sIGluY2x1ZGUgdGhlIGBpbnRlcm9wQnJva2VyQ29uZmlndXJhdGlvbmAgYGNvbnRleHRHcm91cHNgIG9wdGlvbiBpbiB5b3VyIGBwbGF0Zm9ybWAgb3B0aW9ucyBpbiB5b3VyIG1hbmlmZXN0LiBUaGlzIGlzIHRoZSBwcmVmZXJyZWQgbWV0aG9kLlxuICogYGBganNcbiAqIHtcbiAqICAgICAgXCJydW50aW1lXCI6IHtcbiAqICAgICAgICAgIFwiYXJndW1lbnRzXCI6IFwiLS12PTEgLS1pbnNwZWN0XCIsXG4gKiAgICAgICAgICBcInZlcnNpb25cIjogXCJhbHBoYS12MTlcIlxuICogICAgICB9LFxuICogICAgICBcInBsYXRmb3JtXCI6IHtcbiAqICAgICAgICAgIFwidXVpZFwiOiBcInBsYXRmb3JtX2N1c3RvbWl6YXRpb25fbG9jYWxcIixcbiAqICAgICAgICAgIFwiYXBwbGljYXRpb25JY29uXCI6IFwiaHR0cHM6Ly9vcGVuZmluLmdpdGh1Yi5pby9nb2xkZW4tcHJvdG90eXBlL2Zhdmljb24uaWNvXCIsXG4gKiAgICAgICAgICBcImF1dG9TaG93XCI6IGZhbHNlLFxuICogICAgICAgICAgXCJwcm92aWRlclVybFwiOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTU1NS9wcm92aWRlci5odG1sXCIsXG4gKiAgICAgICAgICBcImludGVyb3BCcm9rZXJDb25maWd1cmF0aW9uXCI6IHtcbiAqICAgICAgICAgICAgICBcImNvbnRleHRHcm91cHNcIjogW1xuICogICAgICAgICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiZ3JlZW5cIixcbiAqICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheU1ldGFkYXRhXCI6IHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IFwiIzAwQ0M4OFwiLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImdyZWVuXCJcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcInB1cnBsZVwiLFxuICogICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5TWV0YWRhdGFcIjoge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogXCIjOEM2MUZGXCIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicHVycGxlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgICBdXG4gKiAgICAgICAgICB9XG4gKiAgICAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIC0tLVxuICogKioyLiBPdmVycmlkaW5nKipcbiAqXG4gKiBTaW1pbGFybHkgdG8gaG93IFtQbGF0Zm9ybSBPdmVycmlkaW5nXXtAbGluayBodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL3BsYXRmb3JtLWN1c3RvbWl6YXRpb24jc2VjdGlvbi1jdXN0b21pemluZy1wbGF0Zm9ybS1iZWhhdmlvcn0gd29ya3MsIHlvdSBjYW4gb3ZlcnJpZGUgZnVuY3Rpb25zIGluIHRoZSBJbnRlcm9wIEJyb2tlciBpbiBgZmluLlBsYXRmb3JtLmluaXRgLiBBbiBleGFtcGxlIG9mIHRoYXQgaXMgc2hvd24gYmVsb3cuIE92ZXJyaWRpbmcgYGlzQ29ubmVjdGlvbkF1dGhvcml6ZWRgIGFuZCBgaXNBY3Rpb25BdXRob3JpemVkYCB3aWxsIGFsbG93IHlvdSB0byBjb250cm9sIGFsbG93ZWQgY29ubmVjdGlvbnMgYW5kIGFsbG93ZWQgYWN0aW9ucy5cbiAqXG4gKiBIb3dldmVyLCBpZiB0aGVyZSBpcyBjdXN0b20gZnVuY3Rpb25hbGl0eSB5b3Ugd2lzaCB0byBpbmNsdWRlIGluIHRoZSBJbnRlcm9wIEJyb2tlciwgcGxlYXNlIGxldCB1cyBrbm93LiBXZSB3b3VsZCBsaWtlIHRvIHByb3ZpZGUgYmV0dGVyIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBzbyB0aGF0IHlvdSBkb24ndCBoYXZlIHRvIGNvbnRpbnVhbGx5IG1haW50YWluIHlvdXIgb3duIG92ZXJyaWRlIGNvZGUuXG4gKlxuICogYGBganNcbiAqIGZpbi5QbGF0Zm9ybS5pbml0KHtcbiAqICAgICBvdmVycmlkZUNhbGxiYWNrOiBhc3luYyAoUHJvdmlkZXIpID0+IHtcbiAqICAgICAgICAgY2xhc3MgT3ZlcnJpZGUgZXh0ZW5kcyBQcm92aWRlciB7XG4gKiAgICAgICAgICAgICBhc3luYyBnZXRTbmFwc2hvdCgpIHtcbiAqICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYmVmb3JlIGdldFNuYXBzaG90JylcbiAqICAgICAgICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IHN1cGVyLmdldFNuYXBzaG90KCk7XG4gKiAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2FmdGVyIGdldFNuYXBzaG90JylcbiAqICAgICAgICAgICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gKiAgICAgICAgICAgICB9XG4gKlxuICogICAgICAgICAgICAgYXN5bmMgYXBwbHlTbmFwc2hvdCh7IHNuYXBzaG90LCBvcHRpb25zIH0pIHtcbiAqICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYmVmb3JlIGFwcGx5U25hcHNob3QnKVxuICogICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZSA9IHN1cGVyLmFwcGx5U25hcHNob3QoeyBzbmFwc2hvdCwgb3B0aW9ucyB9KTtcbiAqICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYWZ0ZXIgYXBwbHlTbmFwc2hvdCcpXG4gKlxuICogICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2U7XG4gKiAgICAgICAgICAgICB9XG4gKiAgICAgICAgIH07XG4gKiAgICAgICAgIHJldHVybiBuZXcgT3ZlcnJpZGUoKTtcbiAqICAgICB9LFxuICogICAgIGludGVyb3BPdmVycmlkZTogYXN5bmMgKEludGVyb3BCcm9rZXIsIHByb3ZpZGVyLCBvcHRpb25zLCAuLi5hcmdzKSA9PiB7XG4gKiAgICAgICAgIGNsYXNzIE92ZXJyaWRlIGV4dGVuZHMgSW50ZXJvcEJyb2tlciB7XG4gKiAgICAgICAgICAgICBhc3luYyBqb2luQ29udGV4dEdyb3VwKGNoYW5uZWxOYW1lID0gJ2RlZmF1bHQnLCB0YXJnZXQpIHtcbiAqICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYmVmb3JlIHN1cGVyIGpvaW5Db250ZXh0R3JvdXAnKVxuICogICAgICAgICAgICAgICAgIHN1cGVyLmpvaW5Db250ZXh0R3JvdXAoY2hhbm5lbE5hbWUsIHRhcmdldCk7XG4gKiAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2FmdGVyIHN1cGVyIGpvaW5Db250ZXh0R3JvdXAnKVxuICogICAgICAgICAgICAgfVxuICogICAgICAgICB9XG4gKlxuICogICAgICAgICBvcHRpb25zLnN5c3RlbUNoYW5uZWxzID0gW1xuICogICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgIGlkOiAnZ3JlZW4nLFxuICogICAgICAgICAgICAgICAgIGRpc3BsYXlNZXRhZGF0YToge1xuICogICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyMwMENDODgnLFxuICogICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZ3JlZW4nXG4gKiAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgICBpZDogJ3B1cnBsZScsXG4gKiAgICAgICAgICAgICAgICAgZGlzcGxheU1ldGFkYXRhOiB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzhDNjFGRicsXG4gKiAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwdXJwbGUnXG4gKiAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgICBpZDogJ29yYW5nZScsXG4gKiAgICAgICAgICAgICAgICAgZGlzcGxheU1ldGFkYXRhOiB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI0ZGOEM0QycsXG4gKiAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdvcmFuZ2UnXG4gKiAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgICBpZDogJ3JlZCcsXG4gKiAgICAgICAgICAgICAgICAgZGlzcGxheU1ldGFkYXRhOiB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI0ZGNUU2MCcsXG4gKiAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdyZWQnXG4gKiAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgfVxuICogICAgICAgICBdO1xuICogICAgICAgcmV0dXJuIG5ldyBPdmVycmlkZShwcm92aWRlciwgb3B0aW9ucywgLi4uYXJncyk7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogLS0tXG4gKlxuICogQGhpZGVjb25zdHJ1Y3RvclxuICogQGNsYXNzXG4gKi9cbmNsYXNzIEludGVyb3BCcm9rZXIgZXh0ZW5kcyBiYXNlXzEuQmFzZSB7XG4gICAgY29uc3RydWN0b3Iod2lyZSwgY2hhbm5lbCwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcih3aXJlKTtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5pbnRlcm9wQ2xpZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0R3JvdXBzQnlJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGV4dEdyb3Vwcykge1xuICAgICAgICAgICAgY29udGV4dEdyb3VwcyA9IG9wdGlvbnMuY29udGV4dEdyb3VwcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVudENsaWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0R3JvdXBNYXAoKTtcbiAgICAgICAgdGhpcy53aXJlQ2hhbm5lbChjaGFubmVsKTtcbiAgICB9XG4gICAgLypcbiAgICBDbGllbnQgQVBJXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBTZXRDb250ZXh0T3B0aW9ucyBpbnRlcmZhY2VcbiAgICAgKiBAdHlwZWRlZiB7IG9iamVjdCB9IFNldENvbnRleHRPcHRpb25zXG4gICAgICogQHByb3BlcnR5IHsgQ29udGV4dCB9IHtjb250ZXh0fSAtIE5ldyBjb250ZXh0IHRvIHNldC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY29udGV4dCBmb3IgdGhlIGNvbnRleHQgZ3JvdXAgb2YgdGhlIGluY29taW5nIGN1cnJlbnQgZW50aXR5LlxuICAgICAqIEBwYXJhbSB7IFNldENvbnRleHRPcHRpb25zIH0gc2V0Q29udGV4dE9wdGlvbnMgLSBOZXcgY29udGV4dCB0byBzZXQuXG4gICAgICogQHBhcmFtIHsgQ2xpZW50SWRlbnRpdHkgfSBjbGllbnRJZGVudGl0eSAtIElkZW50aXR5IG9mIHRoZSBjbGllbnQgc2VuZGVyLlxuICAgICAqIEByZXR1cm4geyB2b2lkIH1cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc2V0Q29udGV4dCh7IGNvbnRleHQgfSwgY2xpZW50SWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtYnJva2VyLXNldC1jb250ZXh0JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50U3RhdGUgPSB0aGlzLmdldENsaWVudFN0YXRlKGNsaWVudElkZW50aXR5KTtcbiAgICAgICAgaWYgKGNsaWVudFN0YXRlICYmIGNsaWVudFN0YXRlLmNvbnRleHRHcm91cElkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbnRleHRHcm91cElkIH0gPSBjbGllbnRTdGF0ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0R3JvdXBzQnlJZC5oYXMoY29udGV4dEdyb3VwSWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlb3JldGljYWxseSBub3QgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgaGFzIGEgY29udGV4dCBncm91cCB0aGF0IGlzbid0IGluIHRoZSBjb250ZXh0IGdyb3VwIG1hcHBpbmc6ICR7Y29udGV4dEdyb3VwSWR9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRHcm91cFN0YXRlID0gdGhpcy5jb250ZXh0R3JvdXBzQnlJZC5nZXQoY29udGV4dEdyb3VwSWQpO1xuICAgICAgICAgICAgY29uc3QgYnJvYWRjYXN0ZWRDb250ZXh0VHlwZSA9IGNvbnRleHQudHlwZTtcbiAgICAgICAgICAgIGNvbnRleHRHcm91cFN0YXRlLnNldChicm9hZGNhc3RlZENvbnRleHRUeXBlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudHNJblNhbWVDb250ZXh0R3JvdXAgPSBBcnJheS5mcm9tKHRoaXMuaW50ZXJvcENsaWVudHMudmFsdWVzKCkpLmZpbHRlcigoY29ubmVjdGVkQ2xpZW50KSA9PiBjb25uZWN0ZWRDbGllbnQuY29udGV4dEdyb3VwSWQgPT09IGNvbnRleHRHcm91cElkKTtcbiAgICAgICAgICAgIGNsaWVudHNJblNhbWVDb250ZXh0R3JvdXAuZm9yRWFjaCgoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbLCBoYW5kbGVySW5mb10gb2YgY2xpZW50LmNvbnRleHRIYW5kbGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoSW50ZXJvcEJyb2tlci5pc0NvbnRleHRUeXBlQ29tcGF0aWJsZShicm9hZGNhc3RlZENvbnRleHRUeXBlLCBoYW5kbGVySW5mby5jb250ZXh0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlQ29udGV4dEhhbmRsZXIoY2xpZW50LmNsaWVudElkZW50aXR5LCBoYW5kbGVySW5mby5oYW5kbGVySWQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xpZW50U3RhdGUpIHtcbiAgICAgICAgICAgIC8vIENsaWVudCBoYXMgbm90IGpvaW5lZCBhbnkgY29udGV4dCBncm91cCBiZWhhdmlvci5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgam9pbiBhIGNvbnRleHQgZ3JvdXAgYmVmb3JlIHlvdSBjYW4gc2V0IGNvbnRleHQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBnZXQgaGl0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgd2l0aCBJZGVudGl0eTogJHtjbGllbnRJZGVudGl0eS51dWlkfSAke2NsaWVudElkZW50aXR5Lm5hbWV9IG5vdCBpbiBDbGllbnQgU3RhdGUgTWFwYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICBQbGF0Zm9ybSBXaW5kb3cgQVBJc1xuICAgICovXG4gICAgLy8gam9pbkNvbnRleHRHcm91cCBhbmQgYWRkQ2xpZW50VG9Db250ZXh0R3JvdXAgYXJlIHNlcGFyYXRlIGZ1bmN0aW9ucyBoZXJlLCBmb3IgZWFzaWVyIG92ZXJyaWRlcyBhbmQgc2VwYXJhdGlvbiBvZiBjb25jZXJucy5cbiAgICAvLyBqb2luQ29udGV4dEdyb3VwIGNoZWNrcyBhbGwgY29ubmVjdGlvbnMgZm9yIG1hdGNoaW5nIGlkZW50aXRpZXMsIGluIGNhc2Ugd2UgaGF2ZSBtdWx0aXBsZSBjb25uZWN0aW9uIGZyb20gYW4gZW50aXR5LlxuICAgIC8qKlxuICAgICAqIEpvaW5Db250ZXh0R3JvdXBPcHRpb25zIGludGVyZmFjZVxuICAgICAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gSm9pbkNvbnRleHRHcm91cE9wdGlvbnNcbiAgICAgKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBjb250ZXh0R3JvdXBJZCAtIElkIG9mIHRoZSBjb250ZXh0IGdyb3VwLlxuICAgICAqIEBwcm9wZXJ0eSB7IElkZW50aXR5IHwgQ2xpZW50SWRlbnRpdHkgfSBbdGFyZ2V0XSAtIElkZW50aXR5IG9mIHRoZSBlbnRpdHkgeW91IHdpc2ggdG8gam9pbiB0byBhIGNvbnRleHQgZ3JvdXAuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogSm9pbiBhbGwgY29ubmVjdGlvbnMgYXQgdGhlIGdpdmVuIGlkZW50aXR5IChvciBqdXN0IG9uZSBpZiBlbmRwb2ludElkIHByb3ZpZGVkKSB0byBjb250ZXh0IGdyb3VwIGBjb250ZXh0R3JvdXBJZGAuXG4gICAgICogSWYgbm8gdGFyZ2V0IGlzIHNwZWNpZmllZCwgaXQgYWRkcyB0aGUgc2VuZGVyIHRvIHRoZSBjb250ZXh0IGdyb3VwLlxuICAgICAqIGpvaW5Db250ZXh0R3JvdXAgaXMgcmVzcG9uc2libGUgZm9yIGNoZWNraW5nIGNvbm5lY3Rpb25zIGF0IHRoZSBpbmNvbWluZyBpZGVudGl0eS4gSXQgY2FsbHMge0BsaW5rIEludGVyb3BCcm9rZXIjYWRkQ2xpZW50VG9Db250ZXh0R3JvdXAgSW50ZXJvcEJyb2tlci5hZGRDbGllbnRUb0NvbnRleHRHcm91cH0gdG8gYWN0dWFsbHkgZ3JvdXAgdGhlIGNsaWVudC5cbiAgICAgKiBVc2VkIGJ5IFBsYXRmb3JtIFdpbmRvd3MuXG4gICAgICogQHJldHVybiB7IFByb21pc2U8dm9pZD4gfVxuICAgICAqIEBwYXJhbSB7IEpvaW5Db250ZXh0R3JvdXBPcHRpb25zIH0gam9pbkNvbnRleHRHcm91cE9wdGlvbnMgLSBJZCBvZiB0aGUgQ29udGV4dCBHcm91cCBhbmQgaWRlbnRpdHkgb2YgdGhlIGVudGl0eSB0byBqb2luIHRvIHRoZSBncm91cC5cbiAgICAgKiBAcGFyYW0geyBDbGllbnRJZGVudGl0eSB9IHNlbmRlcklkZW50aXR5IC0gSWRlbnRpdHkgb2YgdGhlIGNsaWVudCBzZW5kZXIuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIGpvaW5Db250ZXh0R3JvdXAoeyBjb250ZXh0R3JvdXBJZCwgdGFyZ2V0IH0sIHNlbmRlcklkZW50aXR5KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWJyb2tlci1qb2luLWNvbnRleHQtZ3JvdXAnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBlbmRwb2ludElkIGlzIHByb3ZpZGVkLCB1c2UgdGhhdC4gVGhpcyB3aWxsIGxpa2VseSBiZSB1c2VkIGJ5IGV4dGVybmFsIGFkYXB0ZXJzLlxuICAgICAgICAgICAgaWYgKEludGVyb3BCcm9rZXIuaGFzRW5kcG9pbnRJZCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGRDbGllbnRUb0NvbnRleHRHcm91cCh7IGNvbnRleHRHcm91cElkIH0sIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2sgaGVyZSBpbiBjYXNlIGEgc2luZ2xlIGFwcCBoYXMgbXVsdGlwbGUgY29ubmVjdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IGFsbENvbm5lY3Rpb25zID0gdGhpcy5jaGFubmVsLmNvbm5lY3Rpb25zLmZpbHRlcigoeCkgPT4geC51dWlkID09PSB0YXJnZXQudXVpZCAmJiB4Lm5hbWUgPT09IHRhcmdldC5uYW1lKTtcbiAgICAgICAgICAgIGlmICghYWxsQ29ubmVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHaXZlbiBJZGVudGl0eSAke3RhcmdldC51dWlkfSAke3RhcmdldC5uYW1lfSBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBJbnRlcm9wIEJyb2tlci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxDb25uZWN0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGZpZ3VyZSBvdXQgaG93IHdlIHdhbnQgdG8gaGFuZGxlIHRoaXMgc2l0dWF0aW9uLiBJbiB0aGUgbWVhbnRpbWUsIGp1c3QgY2hhbmdlIGNvbnRleHQgZ3JvdXAgZm9yIGFsbCBjb25uZWN0aW9ucy5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYE1vcmUgdGhhbiBvbmUgY29ubmVjdGlvbiBmb3VuZCBmb3IgaWRlbnRpdHkgJHt0YXJnZXQudXVpZH0gJHt0YXJnZXQubmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb24gb2YgYWxsQ29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuYWRkQ2xpZW50VG9Db250ZXh0R3JvdXAoeyBjb250ZXh0R3JvdXBJZCB9LCBjb25uZWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyB0YXJnZXQgcHJvdmlkZWQsIGFkZCB0aGUgc2VuZGVyIHRvIHRoZSBjb250ZXh0IGdyb3VwLlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGRDbGllbnRUb0NvbnRleHRHcm91cCh7IGNvbnRleHRHcm91cElkIH0sIHNlbmRlcklkZW50aXR5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRDbGllbnRUb0NvbnRleHRHcm91cE9wdGlvbnMgaW50ZXJmYWNlXG4gICAgICogQHR5cGVkZWYgeyBvYmplY3QgfSBBZGRDbGllbnRUb0NvbnRleHRHcm91cE9wdGlvbnNcbiAgICAgKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBjb250ZXh0R3JvdXBJZCAtIE5hbWUgb2YgdGhlIGNvbnRleHQgZ3JvdXAuXG4gICAgICovXG4gICAgLy8gYWRkQ2xpZW50VG9Db250ZXh0R3JvdXAgZG9lcyB0aGUgYWN0dWFsIGFkZGl0aW9uIG9mIHRoZSBjbGllbnQgdG8gdGhlIENvbnRleHQgR3JvdXBcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHtAbGluayBJbnRlcm9wQnJva2VyI2pvaW5Db250ZXh0R3JvdXAgSW50ZXJvcEJyb2tlci5qb2luQ29udGV4dEdyb3VwfS4gRG9lcyB0aGUgd29yayBvZiBhY3R1YWxseSBhZGRpbmcgdGhlIGNsaWVudCB0byB0aGUgQ29udGV4dCBHcm91cC5cbiAgICAgKiBVc2VkIGJ5IFBsYXRmb3JtIFdpbmRvd3MuXG4gICAgICogQHJldHVybiB7IFByb21pc2U8dm9pZD4gfVxuICAgICAqIEBwYXJhbSB7IEFkZENsaWVudFRvQ29udGV4dEdyb3VwT3B0aW9ucyB9IGFkZENsaWVudFRvQ29udGV4dEdyb3VwT3B0aW9ucyAtIENvbnRhaW5zIHRoZSBjb250ZXh0R3JvdXBJZFxuICAgICAqIEBwYXJhbSB7IENsaWVudElkZW50aXR5IH0gY2xpZW50SWRlbnRpdHkgLSBJZGVudGl0eSBvZiB0aGUgY2xpZW50IHNlbmRlci5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgYWRkQ2xpZW50VG9Db250ZXh0R3JvdXAoeyBjb250ZXh0R3JvdXBJZCB9LCBjbGllbnRJZGVudGl0eSkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1icm9rZXItYWRkLWNsaWVudC10by1jb250ZXh0LWdyb3VwJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50U3Vic2NyaXB0aW9uU3RhdGUgPSB0aGlzLmdldENsaWVudFN0YXRlKGNsaWVudElkZW50aXR5KTtcbiAgICAgICAgaWYgKCFjbGllbnRTdWJzY3JpcHRpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgd2l0aCBJZGVudGl0eTogJHtjbGllbnRJZGVudGl0eS51dWlkfSAke2NsaWVudElkZW50aXR5Lm5hbWV9IG5vdCBpbiBDbGllbnQgU3RhdGUgTWFwYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmdldENvbnRleHRHcm91cHMoKS5maW5kKChjb250ZXh0R3JvdXBJbmZvKSA9PiBjb250ZXh0R3JvdXBJbmZvLmlkID09PSBjb250ZXh0R3JvdXBJZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGluZyB0byBqb2luIGEgY29udGV4dCBncm91cCB0aGF0IGRvZXMgbm90IGV4aXN0OiAke2NvbnRleHRHcm91cElkfS4gWW91IG1heSBvbmx5IGpvaW4gZXhpc3RpbmcgY29udGV4dCBncm91cHMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkQ29udGV4dEdyb3VwSWQgPSBjbGllbnRTdWJzY3JpcHRpb25TdGF0ZS5jb250ZXh0R3JvdXBJZDtcbiAgICAgICAgaWYgKG9sZENvbnRleHRHcm91cElkICE9PSBjb250ZXh0R3JvdXBJZCkge1xuICAgICAgICAgICAgY2xpZW50U3Vic2NyaXB0aW9uU3RhdGUuY29udGV4dEdyb3VwSWQgPSBjb250ZXh0R3JvdXBJZDtcbiAgICAgICAgICAgIGF3YWl0IEludGVyb3BCcm9rZXIuc2V0Q3VycmVudENvbnRleHRHcm91cEluQ2xpZW50T3B0aW9ucyhjbGllbnRJZGVudGl0eSwgY29udGV4dEdyb3VwSWQpO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dEdyb3VwTWFwID0gdGhpcy5jb250ZXh0R3JvdXBzQnlJZC5nZXQoY29udGV4dEdyb3VwSWQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbLCBoYW5kbGVySW5mb10gb2YgY2xpZW50U3Vic2NyaXB0aW9uU3RhdGUuY29udGV4dEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb250ZXh0VHlwZSwgaGFuZGxlcklkIH0gPSBoYW5kbGVySW5mbztcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIHRoaXMgc2luZ2xlIGhhbmRsZXIgYWxsIG9mIHRoZSBjb250ZXh0LCBiZWNhdXNlIGl0IGFjY2VwdHMgYWxsLlxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0R3JvdXBNYXAuZm9yRWFjaCgoY29udGV4dCwgXykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZva2VDb250ZXh0SGFuZGxlcihjbGllbnRJZGVudGl0eSwgaGFuZGxlcklkLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRleHRHcm91cE1hcC5oYXMoY29udGV4dFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRGb3JUeXBlID0gY29udGV4dEdyb3VwTWFwLmdldChjb250ZXh0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Rm9yVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZva2VDb250ZXh0SGFuZGxlcihjbGllbnRJZGVudGl0eSwgaGFuZGxlcklkLCBjb250ZXh0Rm9yVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlRnJvbUNvbnRleHRHcm91cE9wdGlvbnMgaW50ZXJmYWNlXG4gICAgICogQHR5cGVkZWYgeyBvYmplY3QgfSBSZW1vdmVGcm9tQ29udGV4dEdyb3VwT3B0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7IElkZW50aXR5IHwgQ2xpZW50SWRlbnRpdHkgfSB0YXJnZXQgLSBJZGVudGl0eSBvZiB0aGUgZW50aXR5IHlvdSB3aXNoIHRvIGpvaW4gdG8gYSBjb250ZXh0IGdyb3VwLlxuICAgICAqL1xuICAgIC8vIFJlbW92ZXMgdGhlIHRhcmdldCBmcm9tIGl0cyBjb250ZXh0IGdyb3VwLiBTaW1pbGFyIHN0cnVjdHVyZSB0byBqb2luQ29udGV4dEdyb3VwLlxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCB0YXJnZXQgZnJvbSBhIGNvbnRleHQgZ3JvdXAuXG4gICAgICogSWYgbm8gdGFyZ2V0IGlzIHNwZWNpZmllZCwgaXQgcmVtb3ZlcyB0aGUgc2VuZGVyIGZyb20gdGhlaXIgY29udGV4dCBncm91cC5cbiAgICAgKiByZW1vdmVGcm9tQ29udGV4dEdyb3VwIGlzIHJlc3BvbnNpYmxlIGZvciBjaGVja2luZyBjb25uZWN0aW9ucyBhdCB0aGUgaW5jb21pbmcgaWRlbnRpdHkuIEl0IGNhbGxzIHtAbGluayBJbnRlcm9wQnJva2VyI3JlbW92ZUNsaWVudEZyb21Db250ZXh0R3JvdXAgSW50ZXJvcEJyb2tlci5yZW1vdmVDbGllbnRGcm9tQ29udGV4dEdyb3VwfSB0byBhY3R1YWxseSB1bmdyb3VwIHRoZSBjbGllbnQuXG4gICAgICogVXNlZCBieSBQbGF0Zm9ybSBXaW5kb3dzLlxuICAgICAqIEByZXR1cm4geyBQcm9taXNlPHZvaWQ+IH1cbiAgICAgKiBAcGFyYW0geyBSZW1vdmVGcm9tQ29udGV4dEdyb3VwT3B0aW9ucyB9IHJlbW92ZUZyb21Db250ZXh0R3JvdXBPcHRpb25zIC0gQ29udGFpbnMgdGhlIHRhcmdldCBpZGVudGl0eSB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHsgQ2xpZW50SWRlbnRpdHkgfSBzZW5kZXJJZGVudGl0eSAtIElkZW50aXR5IG9mIHRoZSBjbGllbnQgc2VuZGVyLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVGcm9tQ29udGV4dEdyb3VwKHsgdGFyZ2V0IH0sIHNlbmRlcklkZW50aXR5KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWJyb2tlci1yZW1vdmUtZnJvbS1jb250ZXh0LWdyb3VwJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgLy8gSWYgYW4gZW5kcG9pbnRJZCBpcyBwcm92aWRlZCwgdXNlIHRoYXQuIFRoaXMgd2lsbCBsaWtlbHkgYmUgdXNlZCBieSBleHRlcm5hbCBhZGFwdGVycy5cbiAgICAgICAgICAgIGlmIChJbnRlcm9wQnJva2VyLmhhc0VuZHBvaW50SWQodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlQ2xpZW50RnJvbUNvbnRleHRHcm91cCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrIGhlcmUgaW4gY2FzZSBhIHNpbmdsZSBhcHAgaGFzIG11bHRpcGxlIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICBjb25zdCBhbGxDb25uZWN0aW9ucyA9IHRoaXMuY2hhbm5lbC5jb25uZWN0aW9ucy5maWx0ZXIoKHgpID0+IHgudXVpZCA9PT0gdGFyZ2V0LnV1aWQgJiYgeC5uYW1lID09PSB0YXJnZXQubmFtZSk7XG4gICAgICAgICAgICBpZiAoIWFsbENvbm5lY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29ubmVjdGlvbiBmb3VuZCBmb3IgZ2l2ZW4gSWRlbnRpdHkgJHt0YXJnZXQudXVpZH0gJHt0YXJnZXQubmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxDb25uZWN0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBNb3JlIHRoYW4gb25lIGNvbm5lY3Rpb24gZm91bmQgZm9yIGlkZW50aXR5ICR7dGFyZ2V0LnV1aWR9ICR7dGFyZ2V0Lm5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIGFsbENvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlbW92ZUNsaWVudEZyb21Db250ZXh0R3JvdXAoY29ubmVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gdGFyZ2V0IHByb3ZpZGVkLCByZW1vdmUgdGhlIHNlbmRlciBmcm9tIHRoZSBjb250ZXh0IGdyb3VwLlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW1vdmVDbGllbnRGcm9tQ29udGV4dEdyb3VwKHNlbmRlcklkZW50aXR5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByZW1vdmVDbGllbnRGcm9tQ29udGV4dEdyb3VwIGRvZXMgdGhlIGFjdHVhbCByZW1vdmUgb2YgdGhlIGNsaWVudCBmcm9tIHRoZSBDb250ZXh0IEdyb3VwXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciB7QGxpbmsgSW50ZXJvcEJyb2tlciNyZW1vdmVGcm9tQ29udGV4dEdyb3VwIEludGVyb3BCcm9rZXIucmVtb3ZlRnJvbUNvbnRleHRHcm91cH0uIERvZXMgdGhlIHdvcmsgb2YgYWN0dWFsbHkgcmVtb3ZpbmcgdGhlIGNsaWVudCBmcm9tIHRoZSBDb250ZXh0IEdyb3VwLlxuICAgICAqIFVzZWQgYnkgUGxhdGZvcm0gV2luZG93cy5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTx2b2lkPiB9XG4gICAgICogQHByb3BlcnR5IHsgQ2xpZW50SWRlbnRpdHkgfSBjbGllbnRJZGVudGl0eSAtIElkZW50aXR5IG9mIHRoZSBjbGllbnQgc2VuZGVyLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVDbGllbnRGcm9tQ29udGV4dEdyb3VwKGNsaWVudElkZW50aXR5KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWJyb2tlci1yZW1vdmUtY2xpZW50LWZyb20tY29udGV4dC1ncm91cCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gdGhpcy5nZXRDbGllbnRTdGF0ZShjbGllbnRJZGVudGl0eSk7XG4gICAgICAgIGlmIChjbGllbnRTdGF0ZSkge1xuICAgICAgICAgICAgY2xpZW50U3RhdGUuY29udGV4dEdyb3VwSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgSW50ZXJvcEJyb2tlci5zZXRDdXJyZW50Q29udGV4dEdyb3VwSW5DbGllbnRPcHRpb25zKGNsaWVudElkZW50aXR5LCBudWxsKTtcbiAgICB9XG4gICAgLy8gVXNlZCBieSBwbGF0Zm9ybSB3aW5kb3dzIHRvIGtub3cgd2hhdCBjbGllbnQgZ3JvdXBzIHRoZSBwcm92aWRlciBoYXMgZGVjbGFyZWQuIEFsc28gdXNlZCBpbnRlcm5hbGx5IHRvIGFjY2VzcyBjb250ZXh0IGdyb3Vwcy4gT3ZlcnJpZGVhYmxlIHNvIHRoYXQgdGhlIHBsYXRmb3JtIGRldmVsb3BlciBjYW4gbW9kaWZ5IGl0LlxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEludGVyb3AtQnJva2VyLWRlZmluZWQgY29udGV4dCBncm91cHMgYXZhaWxhYmxlIGZvciBhbiBlbnRpdHkgdG8gam9pbi4gQmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW4gdGhlIHJlc3Qgb2YgdGhlIEludGVyb3AgQnJva2VyIHRvIGZldGNoIHRoZSBDb250ZXh0IEdyb3Vwcywgb3ZlcnJpZGluZyB0aGlzIGFsbG93cyB5b3UgdG8gY3VzdG9taXplIHRoZSBDb250ZXh0IEdyb3VwcyBmb3IgdGhlIEludGVyb3AgQnJva2VyLiBIb3dldmVyLCB3ZSByZWNvbW1lbmQgY3VzdG9taXppbmcgdGhlIGNvbnRleHQgZ3JvdXBzIHRocm91Z2ggY29uZmlndXJhdGlvbiBpbnN0ZWFkLlxuICAgICAqIFVzZWQgYnkgUGxhdGZvcm0gV2luZG93cy5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTxDb250ZXh0R3JvdXBJbmZvW10+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGdldENvbnRleHRHcm91cHMoKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWJyb2tlci1nZXQtY29udGV4dC1ncm91cHMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDcmVhdGUgY29weSBmb3IgaW1tdXRhYmlsaXR5XG4gICAgICAgIHJldHVybiBjb250ZXh0R3JvdXBzLm1hcCgoY29udGV4dEdyb3VwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5jb250ZXh0R3JvdXAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldEluZm9Gb3JDb250ZXh0R3JvdXBPcHRpb25zIGludGVyZmFjZVxuICAgICAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gR2V0SW5mb0ZvckNvbnRleHRHcm91cE9wdGlvbnNcbiAgICAgKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBjb250ZXh0R3JvdXBJZCAtIE5hbWUgb2YgdGhlIGNvbnRleHQgZ3JvdXAgdG8gZ2V0IGluZm8gZm9yLlxuICAgICAqL1xuICAgIC8vIFVzZWQgdG8gYnkgcGxhdGZvcm0gd2luZG93cyB0byBnZXQgZGlzcGxheSBtZXRhZGF0YSBmb3IgYSBjb250ZXh0IGdyb3VwLlxuICAgIC8qKlxuICAgICAqIEdldHMgZGlzcGxheSBpbmZvIGZvciBhIGNvbnRleHQgZ3JvdXBcbiAgICAgKiBVc2VkIGJ5IFBsYXRmb3JtIFdpbmRvd3MuXG4gICAgICogQHBhcmFtIHsgR2V0SW5mb0ZvckNvbnRleHRHcm91cE9wdGlvbnMgfSBnZXRJbmZvRm9yQ29udGV4dEdyb3VwT3B0aW9ucyAtIENvbnRhaW5zIGNvbnRleHRHcm91cElkLCB0aGUgY29udGV4dCBncm91cCB5b3Ugd2lzaCB0byBnZXQgZGlzcGxheSBpbmZvIGZvci5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTxDb250ZXh0R3JvdXBJbmZvPn1cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZ2V0SW5mb0ZvckNvbnRleHRHcm91cCh7IGNvbnRleHRHcm91cElkIH0pIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtYnJva2VyLWdldC1pbmZvLWZvci1jb250ZXh0LWdyb3VwJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGV4dEdyb3VwcygpLmZpbmQoKGNvbnRleHRHcm91cCkgPT4gY29udGV4dEdyb3VwLmlkID09PSBjb250ZXh0R3JvdXBJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldEFsbENsaWVudHNJbkNvbnRleHRHcm91cE9wdGlvbnMgaW50ZXJmYWNlXG4gICAgICogQHR5cGVkZWYgeyBvYmplY3QgfSBHZXRBbGxDbGllbnRzSW5Db250ZXh0R3JvdXBPcHRpb25zXG4gICAgICogQHByb3BlcnR5IHsgc3RyaW5nIH0gY29udGV4dEdyb3VwSWQgLSBOYW1lIG9mIHRoZSBjb250ZXh0IGdyb3VwIHRvIGdldCBpbmZvIGZvci5cbiAgICAgKi9cbiAgICAvLyBVc2VkIGJ5IHBsYXRmb3JtIHdpbmRvd3MgdG8gZ2V0IGFsbCBjbGllbnRzIGZvciBhIGNvbnRleHQgZ3JvdXAuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgY2xpZW50cyBmb3IgYSBjb250ZXh0IGdyb3VwLlxuICAgICAqIFVzZWQgYnkgUGxhdGZvcm0gV2luZG93cy5cbiAgICAgKiBAcGFyYW0geyBHZXRBbGxDbGllbnRzSW5Db250ZXh0R3JvdXBPcHRpb25zIH0gZ2V0QWxsQ2xpZW50c0luQ29udGV4dEdyb3VwT3B0aW9ucyAtIENvbnRhaW5zIGNvbnRleHRHcm91cElkLCB0aGUgY29udGV4dCBncm91cCB5b3Ugd2lzaCB0byBnZXQgY2xpZW50cyBmb3IuXG4gICAgICogQHJldHVybiB7IFByb21pc2U8Q2xpZW50SWRlbnRpdHlbXT59XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGdldEFsbENsaWVudHNJbkNvbnRleHRHcm91cCh7IGNvbnRleHRHcm91cElkIH0pIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtYnJva2VyLWdldC1hbGwtY2xpZW50cy1pbi1jb250ZXh0LWdyb3VwJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50c0luQ29udGV4dEdyb3VwID0gQXJyYXkuZnJvbSh0aGlzLmludGVyb3BDbGllbnRzLnZhbHVlcygpKVxuICAgICAgICAgICAgLmZpbHRlcigoY29ubmVjdGVkQ2xpZW50KSA9PiBjb25uZWN0ZWRDbGllbnQuY29udGV4dEdyb3VwSWQgPT09IGNvbnRleHRHcm91cElkKVxuICAgICAgICAgICAgLm1hcCgoc3Vic2NyaXB0aW9uU3RhdGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb25TdGF0ZS5jbGllbnRJZGVudGl0eTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGllbnRzSW5Db250ZXh0R3JvdXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3BvbnNpYmxlIGZvciBsYXVuY2hpbmcgb2YgYXBwbGljYXRpb25zIHRoYXQgY2FuIGhhbmRsZSBhIGdpdmVuIGludGVudCwgYW5kIGRlbGVnYXRpb24gb2YgaW50ZW50cyB0byB0aG9zZSBhcHBsaWNhdGlvbnMuXG4gICAgICogTXVzdCBiZSBvdmVycmlkZGVuLlxuICAgICAqIEBwYXJhbSB7IEludGVudCB9IGludGVudCBUaGUgY29tYmluYXRpb24gb2YgYW4gYWN0aW9uIGFuZCBhIGNvbnRleHQgdGhhdCBpcyBwYXNzZWQgdG8gYW4gYXBwbGljYXRpb24gZm9yIHJlc29sdXRpb24uXG4gICAgICogQHJldHVybiB7IFByb21pc2U8dm9pZD4gfVxuICAgICAqIEB0dXRvcmlhbCBpbnRlcm9wLmhhbmRsZUZpcmVkSW50ZW50XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgYXN5bmMgaGFuZGxlRmlyZWRJbnRlbnQoaW50ZW50KSB7XG4gICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nLCB0aGlzIGlzIG1lYW50IHRvIGJlIG92ZXJpZGRlbiBieSB0aGUgcGxhdGZvcm0gcHJvdmlkZXJcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtYnJva2VyLWhhbmRsZS1maXJlZC1pbnRlbnQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCB0aGlzIGlzIG9ubHkgZm9yIGFwaSBhbmFseXRpY3MgcHVycG9zZXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IFVwZGF0ZSB0aGlzIHdhcm5pbmcgd2l0aCBhIGxpbmsgdG8gb3VyIGRvY3Mgb25jZSB0aGV5IGFyZSB3cml0dGVuLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGludGVudCBoYXMgYmVlbiBmaXJlZCBhbmQgaGFuZGxlRmlyZWRJbnRlbnQgaGFzIG5vdCBiZWVuIG92ZXJyaWRkZW4uIFBsZWFzZSBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgaW50ZW50LiBSZWZlciB0byBvdXIgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBpbmZvLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIGluIHtAbGluayBJbnRlcm9wQnJva2VyI2hhbmRsZUZpcmVkSW50ZW50IEludGVyb3BCcm9rZXIuaGFuZGxlRmlyZWRJbnRlbnR9LlxuICAgICAqIFdoaWxlIGhhbmRsZUZpcmVkSW50ZW50IGlzIHJlc3BvbnNpYmxlIGZvciBsYXVuY2hpbmcgYXBwbGljYXRpb25zLCBzZXRJbnRlbnRUYXJnZXQgaXMgdXNlZCB0byB0ZWxsIHRoZSBJbnRlcm9wQnJva2VyIHdoaWNoIGFwcGxpY2F0aW9uIHNob3VsZCByZWNlaXZlIHRoZSBpbnRlbnQgd2hlbiBpdCBpcyByZWFkeS5cbiAgICAgKiBAcGFyYW0geyBJbnRlbnQgfSBpbnRlbnQgVGhlIGNvbWJpbmF0aW9uIG9mIGFuIGFjdGlvbiBhbmQgYSBjb250ZXh0IHRoYXQgaXMgcGFzc2VkIHRvIGFuIGFwcGxpY2F0aW9uIGZvciByZXNvbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7IElkZW50aXR5IH0gdGFyZ2V0IC0gSWRlbnRpdHkgb2YgdGhlIHRhcmdldCB0aGF0IHdpbGwgaGFuZGxlIHRoZSBpbnRlbnQuXG4gICAgICogQHJldHVybiB7IFByb21pc2U8dm9pZD4gfVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyBzZXRJbnRlbnRUYXJnZXQoaW50ZW50LCB0YXJnZXQpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtYnJva2VyLXNldC1pbnRlbnQtdGFyZ2V0JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgdGhpcyBpcyBvbmx5IGZvciBhcGkgYW5hbHl0aWNzIHB1cnBvc2VzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0YXJnZXRJbmZvID0gdGhpcy5pbnRlbnRDbGllbnRNYXAuZ2V0KHRhcmdldC5uYW1lKTtcbiAgICAgICAgY29uc3QgaGFuZGxlcklkID0gYGludGVudC1oYW5kbGVyLSR7aW50ZW50Lm5hbWV9YDtcbiAgICAgICAgaWYgKCF0YXJnZXRJbmZvKSB7XG4gICAgICAgICAgICB0aGlzLmludGVudENsaWVudE1hcC5zZXQodGFyZ2V0Lm5hbWUsIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdIYW5kbGVySW5mb01hcCA9IHRoaXMuaW50ZW50Q2xpZW50TWFwLmdldCh0YXJnZXQubmFtZSk7XG4gICAgICAgICAgICBpZiAobmV3SGFuZGxlckluZm9NYXApIHtcbiAgICAgICAgICAgICAgICBuZXdIYW5kbGVySW5mb01hcC5zZXQoaGFuZGxlcklkLCB7IGlzUmVhZHk6IGZhbHNlLCBwZW5kaW5nSW50ZW50czogW2ludGVudF0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVySW5mbyA9IHRhcmdldEluZm8uZ2V0KGhhbmRsZXJJZCk7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXJJbmZvKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SW5mby5zZXQoaGFuZGxlcklkLCB7IGlzUmVhZHk6IGZhbHNlLCBwZW5kaW5nSW50ZW50czogW2ludGVudF0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVySW5mby5wZW5kaW5nSW50ZW50cy5wdXNoKGludGVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJJbmZvLmNsaWVudElkZW50aXR5ICYmIGhhbmRsZXJJbmZvLmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjbGllbnRJZGVudGl0eSwgcGVuZGluZ0ludGVudHMgfSA9IGhhbmRsZXJJbmZvO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZW50VG9TZW5kID0gcGVuZGluZ0ludGVudHNbcGVuZGluZ0ludGVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNoYW5uZWwuZGlzcGF0Y2goY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwgaW50ZW50VG9TZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJJbmZvLnBlbmRpbmdJbnRlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbnZva2luZyBpbnRlbnQgaGFuZGxlciBmb3IgY2xpZW50ICR7Y2xpZW50SWRlbnRpdHkudXVpZH0vJHtjbGllbnRJZGVudGl0eS5uYW1lfS8ke2NsaWVudElkZW50aXR5LmVuZHBvaW50SWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVySW5mby5pc1JlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICBTbmFwc2hvdCBBUElzXG4gICAgKi9cbiAgICAvLyBVc2VkIHRvIHNhdmUgaW50ZXJvcCBicm9rZXIgc3RhdGUgaW4gc25hcHNob3RzXG4gICAgZGVjb3JhdGVTbmFwc2hvdChzbmFwc2hvdCkge1xuICAgICAgICByZXR1cm4geyAuLi5zbmFwc2hvdCwgaW50ZXJvcFNuYXBzaG90RGV0YWlsczogeyBjb250ZXh0R3JvdXBTdGF0ZXM6IHRoaXMuZ2V0Q29udGV4dEdyb3VwU3RhdGVzKCkgfSB9O1xuICAgIH1cbiAgICAvLyBVc2VkIHRvIHJlc3RvcmUgaW50ZXJvcCBicm9rZXIgc3RhdGUgaW4gc25hcHNob3RzLlxuICAgIGFwcGx5U25hcHNob3Qoc25hcHNob3QsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250ZXh0R3JvdXBTdGF0ZXMgPSAoX2EgPSBzbmFwc2hvdCA9PT0gbnVsbCB8fCBzbmFwc2hvdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc25hcHNob3QuaW50ZXJvcFNuYXBzaG90RGV0YWlscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRleHRHcm91cFN0YXRlcztcbiAgICAgICAgaWYgKGNvbnRleHRHcm91cFN0YXRlcykge1xuICAgICAgICAgICAgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsb3NlRXhpc3RpbmdXaW5kb3dzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRXhpc3RpbmdDbGllbnRzKGNvbnRleHRHcm91cFN0YXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlaHlkcmF0ZUNvbnRleHRHcm91cFN0YXRlcyhjb250ZXh0R3JvdXBTdGF0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUV4aXN0aW5nQ2xpZW50cyhjb250ZXh0R3JvdXBTdGF0ZXMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50cyA9IHRoaXMuaW50ZXJvcENsaWVudHM7XG4gICAgICAgIGNsaWVudHMuZm9yRWFjaCgoc3ViU3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50SWRlbnRpdHksIGNvbnRleHRHcm91cElkLCBjb250ZXh0SGFuZGxlcnMgfSA9IHN1YlN0YXRlO1xuICAgICAgICAgICAgaWYgKGNvbnRleHRHcm91cElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBDb250ZXh0cyA9IGNvbnRleHRHcm91cFN0YXRlc1tjb250ZXh0R3JvdXBJZF07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbLCBjb250ZXh0XSBvZiBPYmplY3QuZW50cmllcyhncm91cENvbnRleHRzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0SGFuZGxlcnMuZm9yRWFjaCgoY29udGV4dEhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFuZGxlcklkLCBjb250ZXh0VHlwZSB9ID0gY29udGV4dEhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSW50ZXJvcEJyb2tlci5pc0NvbnRleHRUeXBlQ29tcGF0aWJsZShjb250ZXh0LnR5cGUsIGNvbnRleHRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlQ29udGV4dEhhbmRsZXIoY2xpZW50SWRlbnRpdHksIGhhbmRsZXJJZCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gc3RvcmUgY29udGV4dCBncm91cCBzdGF0ZSBpbiBzbmFwc2hvdHNcbiAgICBnZXRDb250ZXh0R3JvdXBTdGF0ZXMoKSB7XG4gICAgICAgIHJldHVybiBJbnRlcm9wQnJva2VyLnRvT2JqZWN0KHRoaXMuY29udGV4dEdyb3Vwc0J5SWQpO1xuICAgIH1cbiAgICAvLyBVc2VkIHRvIHJlaHlkcmF0ZSB0aGUgY29udGV4dCBzdGF0ZSBmcm9tIGEgc25hcHNob3RcbiAgICByZWh5ZHJhdGVDb250ZXh0R3JvdXBTdGF0ZXMoaW5jb21pbmdDb250ZXh0R3JvdXBTdGF0ZXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dEdyb3VwU3RhdGVzID0gT2JqZWN0LmVudHJpZXMoaW5jb21pbmdDb250ZXh0R3JvdXBTdGF0ZXMpO1xuICAgICAgICBmb3IgKGNvbnN0IFtjb250ZXh0R3JvdXBJZCwgY29udGV4dHNdIG9mIGNvbnRleHRHcm91cFN0YXRlcykge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dE9iamVjdHMgPSBPYmplY3QuZW50cmllcyhjb250ZXh0cyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjb250ZXh0VHlwZSwgY29udGV4dF0gb2YgY29udGV4dE9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0R3JvdXBzQnlJZC5oYXMoY29udGV4dEdyb3VwSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb250ZXh0R3JvdXBTdGF0ZSA9IHRoaXMuY29udGV4dEdyb3Vwc0J5SWQuZ2V0KGNvbnRleHRHcm91cElkKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRHcm91cFN0YXRlLnNldChjb250ZXh0VHlwZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGxvZ2ljIHdpbGwgY2hhbmdlIHdoZW4gZHluYW1pYyBjb250ZXh0IGdyb3VwIGNyZWF0aW9uIGNvbWVzIGluLlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEF0dGVtcHRpbmcgdG8gc2V0IGEgY29udGV4dCBncm91cCB0aGF0IGlzbid0IGluIHRoZSBjb250ZXh0IGdyb3VwIG1hcHBpbmcuIFNraXBwaW5nIGNvbnRleHQgZ3JvdXAgcmVoeWRyYXRpb24gZm9yOiAke2NvbnRleHRHcm91cElkfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAgIEludGVybmFsIENvbnRleHQgSGFuZGxlciBBUElzXG4gICAgKi9cbiAgICAvLyBVc2VkIHRvIGdpdmUgY29udGV4dCB0byBhIGNsaWVudCB0aGF0IGhhcyByZWdpc3RlcmVkIHRoZWlyIGNvbnRleHQgaGFuZGxlclxuICAgIGNvbnRleHRIYW5kbGVyUmVnaXN0ZXJlZCh7IGNvbnRleHRUeXBlLCBoYW5kbGVySWQgfSwgY2xpZW50SWRlbnRpdHkpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlckluZm8gPSB7IGNvbnRleHRUeXBlLCBoYW5kbGVySWQgfTtcbiAgICAgICAgY29uc3QgY2xpZW50U3RhdGUgPSB0aGlzLmdldENsaWVudFN0YXRlKGNsaWVudElkZW50aXR5KTtcbiAgICAgICAgY2xpZW50U3RhdGUgPT09IG51bGwgfHwgY2xpZW50U3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsaWVudFN0YXRlLmNvbnRleHRIYW5kbGVycy5zZXQoaGFuZGxlcklkLCBoYW5kbGVySW5mbyk7XG4gICAgICAgIGlmIChjbGllbnRTdGF0ZSAmJiBjbGllbnRTdGF0ZS5jb250ZXh0R3JvdXBJZCkge1xuICAgICAgICAgICAgY29uc3QgeyBjb250ZXh0R3JvdXBJZCB9ID0gY2xpZW50U3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0R3JvdXBNYXAgPSB0aGlzLmNvbnRleHRHcm91cHNCeUlkLmdldChjb250ZXh0R3JvdXBJZCk7XG4gICAgICAgICAgICBpZiAoY29udGV4dFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhpcyBzaW5nbGUgaGFuZGxlciBhbGwgb2YgdGhlIGNvbnRleHQsIGJlY2F1c2UgaXQgYWNjZXB0cyBhbGwuXG4gICAgICAgICAgICAgICAgY29udGV4dEdyb3VwTWFwLmZvckVhY2goKGNvbnRleHQsIF8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZva2VDb250ZXh0SGFuZGxlcihjbGllbnRJZGVudGl0eSwgaGFuZGxlcklkLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRleHRHcm91cE1hcC5oYXMoY29udGV4dFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dEZvclR5cGUgPSBjb250ZXh0R3JvdXBNYXAuZ2V0KGNvbnRleHRUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dEZvclR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZva2VDb250ZXh0SGFuZGxlcihjbGllbnRJZGVudGl0eSwgaGFuZGxlcklkLCBjb250ZXh0Rm9yVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgYXN5bmMgaW50ZW50SGFuZGxlclJlZ2lzdGVyZWQocGF5bG9hZCwgY2xpZW50SWRlbnRpdHkpIHtcbiAgICAgICAgY29uc3QgeyBoYW5kbGVySWQgfSA9IHBheWxvYWQ7XG4gICAgICAgIGNvbnN0IGNsaWVudEludGVudEluZm8gPSB0aGlzLmludGVudENsaWVudE1hcC5nZXQoY2xpZW50SWRlbnRpdHkubmFtZSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJJbmZvID0gY2xpZW50SW50ZW50SW5mbyA9PT0gbnVsbCB8fCBjbGllbnRJbnRlbnRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGllbnRJbnRlbnRJbmZvLmdldChoYW5kbGVySWQpO1xuICAgICAgICBpZiAoIWNsaWVudEludGVudEluZm8pIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZW50Q2xpZW50TWFwLnNldChjbGllbnRJZGVudGl0eS5uYW1lLCBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgY29uc3QgbmV3SGFuZGxlckluZm9NYXAgPSB0aGlzLmludGVudENsaWVudE1hcC5nZXQoY2xpZW50SWRlbnRpdHkubmFtZSk7XG4gICAgICAgICAgICBpZiAobmV3SGFuZGxlckluZm9NYXApIHtcbiAgICAgICAgICAgICAgICBuZXdIYW5kbGVySW5mb01hcC5zZXQoaGFuZGxlcklkLCB7IGlzUmVhZHk6IHRydWUsIHBlbmRpbmdJbnRlbnRzOiBbXSwgY2xpZW50SWRlbnRpdHkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWhhbmRsZXJJbmZvKSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlbnRJbmZvLnNldChoYW5kbGVySWQsIHsgaXNSZWFkeTogdHJ1ZSwgcGVuZGluZ0ludGVudHM6IFtdLCBjbGllbnRJZGVudGl0eSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGVuZGluZ0ludGVudHMgfSA9IGhhbmRsZXJJbmZvO1xuICAgICAgICAgICAgaGFuZGxlckluZm8uY2xpZW50SWRlbnRpdHkgPSBjbGllbnRJZGVudGl0eTtcbiAgICAgICAgICAgIGhhbmRsZXJJbmZvLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ0ludGVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlbnRUb1NlbmQgPSBwZW5kaW5nSW50ZW50c1twZW5kaW5nSW50ZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGFubmVsLmRpc3BhdGNoKGNsaWVudElkZW50aXR5LCBoYW5kbGVySWQsIGludGVudFRvU2VuZCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJJbmZvLnBlbmRpbmdJbnRlbnRzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW52b2tpbmcgaW50ZW50IGhhbmRsZXI6ICR7aGFuZGxlcklkfSBmb3IgY2xpZW50ICR7Y2xpZW50SWRlbnRpdHkudXVpZH0vJHtjbGllbnRJZGVudGl0eS5uYW1lfS8ke2NsaWVudElkZW50aXR5LmVuZHBvaW50SWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlZCB0byBpbnZva2UgYSBjbGllbnQncyBjb250ZXh0IGhhbmRsZXJcbiAgICBpbnZva2VDb250ZXh0SGFuZGxlcihjbGllbnRJZGVudGl0eSwgaGFuZGxlcklkLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5kaXNwYXRjaChjbGllbnRJZGVudGl0eSwgaGFuZGxlcklkLCBjb250ZXh0KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW52b2tpbmcgY29udGV4dCBoYW5kbGVyICR7aGFuZGxlcklkfSBmb3IgY29udGV4dCB0eXBlICR7Y29udGV4dC50eXBlfSBpbiBjbGllbnQgJHtjbGllbnRJZGVudGl0eS51dWlkfS8ke2NsaWVudElkZW50aXR5Lm5hbWV9LyR7Y2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZH1gLCBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gcmVtb3ZlIGEgY29udGV4dCBoYW5kbGVyIGZvciBhIGNsaWVudFxuICAgIHJlbW92ZUNvbnRleHRIYW5kbGVyKHsgaGFuZGxlcklkIH0sIGNsaWVudElkZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudFN0YXRlID0gdGhpcy5nZXRDbGllbnRTdGF0ZShjbGllbnRJZGVudGl0eSk7XG4gICAgICAgIGlmIChjbGllbnRTdGF0ZSkge1xuICAgICAgICAgICAgY2xpZW50U3RhdGUuY29udGV4dEhhbmRsZXJzLmRlbGV0ZShoYW5kbGVySWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgSW50ZXJuYWwgVXRpbHRpZXNcbiAgICAqL1xuICAgIC8vIEdldHRlciBmb3IgaW50ZXJvcCBpbmZvIGZvciBhIGNsaWVudC5cbiAgICBnZXRDbGllbnRTdGF0ZShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm9wQ2xpZW50cy5nZXQoaWQuZW5kcG9pbnRJZCk7XG4gICAgfVxuICAgIC8vIFV0aWwgZm9yIGdldENvbnRleHRHcm91cFN0YXRlcy4gU2VyaWFsaXplcyB0aGUgY29udGV4dEdyb3VwU3RhdGVzIG9iamVjdCBzbyB3ZSBjYW4gc3RvcmUgaXQuXG4gICAgc3RhdGljIHRvT2JqZWN0KG1hcCkge1xuICAgICAgICBjb25zdCBvYmplY3RGcm9tTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKG1hcCk7XG4gICAgICAgIGNvbnN0IG5ld09iamVjdCA9IHt9O1xuICAgICAgICBPYmplY3QuZW50cmllcyhvYmplY3RGcm9tTWFwKS5mb3JFYWNoKChbY29udGV4dEdyb3VwSWQsIGNvbnRleHRNYXBdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0T2JqZWN0ID0gT2JqZWN0LmZyb21FbnRyaWVzKGNvbnRleHRNYXApO1xuICAgICAgICAgICAgbmV3T2JqZWN0W2NvbnRleHRHcm91cElkXSA9IG5ld0NvbnRleHRPYmplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgIH1cbiAgICAvLyBVdGlsIHRvIGNoZWNrIGEgY2xpZW50IGlkZW50aXR5LlxuICAgIHN0YXRpYyBoYXNFbmRwb2ludElkKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmVuZHBvaW50SWQgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gVXRpbCB0byBjaGVjayBpZiB3ZSBzaG91bGQgc2VuZCBhIGNvbnRleHQgdG8gYSBoYW5kbGVyLlxuICAgIHN0YXRpYyBpc0NvbnRleHRUeXBlQ29tcGF0aWJsZShjb250ZXh0VHlwZSwgcmVnaXN0ZXJlZENvbnRleHRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVnaXN0ZXJlZENvbnRleHRUeXBlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0VHlwZSA9PT0gcmVnaXN0ZXJlZENvbnRleHRUeXBlO1xuICAgIH1cbiAgICAvLyBTZXR1cCBmdW5jdGlvbiBmb3Igc3RhdGUgbWFwcGluZ1xuICAgIHNldENvbnRleHRHcm91cE1hcCgpIHtcbiAgICAgICAgLy8gVGhpcyB3YXksIGlmIGEgdXNlciBvdmVycmlkZXMgdGhpcy5nZXRDb250ZXh0R3JvdXBzLCBpdCdzIHJlZmxlY3RlZCBpbiB0aGUgY29udGV4dEdyb3VwTWFwcGluZy5cbiAgICAgICAgZm9yIChjb25zdCBjb250ZXh0R3JvdXBJbmZvIG9mIHRoaXMuZ2V0Q29udGV4dEdyb3VwcygpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRHcm91cHNCeUlkLnNldChjb250ZXh0R3JvdXBJbmZvLmlkLCBuZXcgTWFwKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBzZXRDdXJyZW50Q29udGV4dEdyb3VwSW5DbGllbnRPcHRpb25zKGNsaWVudElkZW50aXR5LCBjb250ZXh0R3JvdXBJZCkge1xuICAgICAgICBjb25zdCBlbnRpdHlJbmZvID0gYXdhaXQgZmluLlN5c3RlbS5nZXRFbnRpdHlJbmZvKGNsaWVudElkZW50aXR5LnV1aWQsIGNsaWVudElkZW50aXR5Lm5hbWUpO1xuICAgICAgICBsZXQgZW50aXR5O1xuICAgICAgICBpZiAoZW50aXR5SW5mby5lbnRpdHlUeXBlID09PSAndmlldycpIHtcbiAgICAgICAgICAgIGVudGl0eSA9IGF3YWl0IGZpbi5WaWV3LndyYXAoY2xpZW50SWRlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVudGl0eUluZm8uZW50aXR5VHlwZSA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICAgIGVudGl0eSA9IGF3YWl0IGZpbi5XaW5kb3cud3JhcChjbGllbnRJZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudGl0eSkge1xuICAgICAgICAgICAgYXdhaXQgZW50aXR5LnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGludGVyb3A6IHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRHcm91cDogY29udGV4dEdyb3VwSWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2V0dGluZyBDdXJyZW50IENvbnRleHQgR3JvdXA6IEVudGl0eSB3aXRoIGlkZW50aXR5ICR7Y2xpZW50SWRlbnRpdHkudXVpZH0sICR7Y2xpZW50SWRlbnRpdHkubmFtZX0gaXMgbm90IGEgd2luZG93IG9yIHZpZXcuIEl0IGlzIGEgJHtlbnRpdHlJbmZvLmVudGl0eVR5cGV9IGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU2V0dXAgQ2hhbm5lbCBDb25uZWN0aW9uIExvZ2ljXG4gICAgd2lyZUNoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICBjaGFubmVsLm9uQ29ubmVjdGlvbigoY2xpZW50SWRlbnRpdHksIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3Rpb25BdXRob3JpemVkKGNsaWVudElkZW50aXR5LCBwYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiBub3QgYXV0aG9yaXplZCBmb3IgJHtjbGllbnRJZGVudGl0eS51dWlkfSwgJHtjbGllbnRJZGVudGl0eS5uYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjbGllbnRJZGVudGl0eS5lbmRwb2ludElkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uIHRvbyBvbGQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIEludGVyb3AuIFBsZWFzZSB1cGdyYWRlIHlvdXIgcnVudGltZSB0byBhIG1vcmUgcmVjZW50IHZlcnNpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0R3JvdXBJZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbnRleHRIYW5kbGVyczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgIGNsaWVudElkZW50aXR5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gT25seSBhbGxvdyB0aGUgY2xpZW50IHRvIGpvaW4gYSBjb250ZXh0R3JvdXAgdGhhdCBhY3R1YWxseSBleGlzdHMuXG4gICAgICAgICAgICBpZiAoKHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5jdXJyZW50Q29udGV4dEdyb3VwKSAmJiB0aGlzLmNvbnRleHRHcm91cHNCeUlkLmhhcyhwYXlsb2FkLmN1cnJlbnRDb250ZXh0R3JvdXApKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50U3Vic2NyaXB0aW9uU3RhdGUuY29udGV4dEdyb3VwSWQgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQuY3VycmVudENvbnRleHRHcm91cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJvcENsaWVudHMuc2V0KGNsaWVudElkZW50aXR5LmVuZHBvaW50SWQsIGNsaWVudFN1YnNjcmlwdGlvblN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYW5uZWwub25EaXNjb25uZWN0aW9uKChjbGllbnRJZGVudGl0eSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm9wQ2xpZW50cy5kZWxldGUoY2xpZW50SWRlbnRpdHkuZW5kcG9pbnRJZCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbmZvID0gdGhpcy5pbnRlbnRDbGllbnRNYXAuZ2V0KGNsaWVudElkZW50aXR5Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRhcmdldEluZm8gJiYgY2xpZW50SWRlbnRpdHkudXVpZCA9PT0gZmluLm1lLmlkZW50aXR5LnV1aWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRJbmZvLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5pc1JlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjaGFubmVsLmJlZm9yZUFjdGlvbigoYWN0aW9uLCBwYXlsb2FkLCBjbGllbnRJZGVudGl0eSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQWN0aW9uQXV0aG9yaXplZChhY3Rpb24sIHBheWxvYWQsIGNsaWVudElkZW50aXR5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWN0aW9uICgke2FjdGlvbn0pIG5vdCBhdXRob3JpemVkIGZvciAke2NsaWVudElkZW50aXR5LnV1aWR9LCAke2NsaWVudElkZW50aXR5Lm5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhhY3Rpb24sIHBheWxvYWQsIGNsaWVudElkZW50aXR5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYW5uZWwuYWZ0ZXJBY3Rpb24oY29uc29sZS5sb2cpO1xuICAgICAgICAvLyBDbGllbnQgZnVuY3Rpb25zXG4gICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ3NldENvbnRleHQnLCB0aGlzLnNldENvbnRleHQuYmluZCh0aGlzKSk7XG4gICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2ZpcmVJbnRlbnQnLCB0aGlzLmhhbmRsZUZpcmVkSW50ZW50LmJpbmQodGhpcykpO1xuICAgICAgICAvLyBQbGF0Zm9ybSB3aW5kb3cgZnVuY3Rpb25zXG4gICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2dldENvbnRleHRHcm91cHMnLCB0aGlzLmdldENvbnRleHRHcm91cHMuYmluZCh0aGlzKSk7XG4gICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2pvaW5Db250ZXh0R3JvdXAnLCB0aGlzLmpvaW5Db250ZXh0R3JvdXAuYmluZCh0aGlzKSk7XG4gICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ3JlbW92ZUZyb21Db250ZXh0R3JvdXAnLCB0aGlzLnJlbW92ZUZyb21Db250ZXh0R3JvdXAuYmluZCh0aGlzKSk7XG4gICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2dldEFsbENsaWVudHNJbkNvbnRleHRHcm91cCcsIHRoaXMuZ2V0QWxsQ2xpZW50c0luQ29udGV4dEdyb3VwLmJpbmQodGhpcykpO1xuICAgICAgICBjaGFubmVsLnJlZ2lzdGVyKCdnZXRJbmZvRm9yQ29udGV4dEdyb3VwJywgdGhpcy5nZXRJbmZvRm9yQ29udGV4dEdyb3VwLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBJbnRlcm5hbCBtZXRob2RzXG4gICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ2NvbnRleHRIYW5kbGVyUmVnaXN0ZXJlZCcsIHRoaXMuY29udGV4dEhhbmRsZXJSZWdpc3RlcmVkLmJpbmQodGhpcykpO1xuICAgICAgICBjaGFubmVsLnJlZ2lzdGVyKCdpbnRlbnRIYW5kbGVyUmVnaXN0ZXJlZCcsIHRoaXMuaW50ZW50SGFuZGxlclJlZ2lzdGVyZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoJ3JlbW92ZUNvbnRleHRIYW5kbGVyJywgdGhpcy5yZW1vdmVDb250ZXh0SGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gY29tcGxldGVseSBwcmV2ZW50IGEgY29ubmVjdGlvbi4gUmV0dXJuIGZhbHNlIHRvIHByZXZlbnQgY29ubmVjdGlvbnMuIEFsbG93cyBhbGwgY29ubmVjdGlvbnMgYnkgZGVmYXVsdC5cbiAgICAgKiBAcGFyYW0gX2lkIHRoZSBpZGVudGl0eSB0cnlpbmMgdG8gY29ubmVjdFxuICAgICAqIEBwYXJhbSBfY29ubmVjdGlvblBheWxvYWQgb3B0aW9uYWwgcGF5bG9hZCB0byB1c2UgaW4gY3VzdG9tIGltcGxlbWVudGF0aW9ucywgd2lsbCBiZSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGFzeW5jIGlzQ29ubmVjdGlvbkF1dGhvcml6ZWQoX2lkLCBfY29ubmVjdGlvblBheWxvYWQpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtYnJva2VyLWlzLWNvbm5lY3Rpb24tYXV0aG9yaXplZCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYmVmb3JlIGV2ZXJ5IGFjdGlvbiB0byBjaGVjayBpZiB0aGlzIGVudGl0eSBzaG91bGQgYmUgYWxsb3dlZCB0byB0YWtlIHRoZSBhY3Rpb24uXG4gICAgICogUmV0dXJuIGZhbHNlIHRvIHByZXZlbnQgdGhlIGFjdGlvblxuICAgICAqIEBwYXJhbSBfYWN0aW9uIHRoZSBzdHJpbmcgYWN0aW9uIHRvIGF1dGhvcml6ZSBpbiBjYW1lbCBjYXNlXG4gICAgICogQHBhcmFtIF9wYXlsb2FkIHRoZSBkYXRhIGJlaW5nIHNlbnQgZm9yIHRoaXMgYWN0aW9uXG4gICAgICogQHBhcmFtIF9pZGVudGl0eSB0aGUgY29ubmVjdGlvbiBhdHRlbXB0aW5nIHRvIGRpc3BhdGNoIHRoaXMgYWN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgaXNBY3Rpb25BdXRob3JpemVkKF9hY3Rpb24sIF9wYXlsb2FkLCBfaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtYnJva2VyLWlzLWFjdGlvbi1hdXRob3JpemVkJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcm9wQnJva2VyID0gSW50ZXJvcEJyb2tlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgICB9XG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfY2xpZW50UHJvbWlzZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJvcENsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IEludGVudFxuICogQHN1bW1hcnkgVGhlIGNvbWJpbmF0aW9uIG9mIGFuIGFjdGlvbiBhbmQgYSBjb250ZXh0IHRoYXQgaXMgcGFzc2VkIHRvIGFuIGFwcGxpY2F0aW9uIGZvciByZXNvbHV0aW9uLlxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gbmFtZSBOYW1lIG9mIHRoZSBpbnRlbnQuXG4gKiBAcHJvcGVydHkgeyBDb250ZXh0IH0gY29udGV4dCBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgaW50ZW50XG4gKi9cbi8qKlxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBTdWJzY3JpcHRpb25cbiAqIEBzdW1tYXJ5IE9iamVjdCByZXR1cm5lZCB3aGVuIHN1YnNjcmliaW5nIGEgaGFuZGxlci5cbiAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gdW5zdWJzY3JpYmUgRnVuY3Rpb24gdG8gdW5zdWJzY3JpYmUgdGhlIGhhbmRsZXIuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYgeyBmdW5jdGlvbiB9IENvbnRleHRIYW5kbGVyXG4gKiBAc3VtbWFyeSBTdWJzY3JpcHRpb24gZnVuY3Rpb24gZm9yIGFkZENvbnRleHRIYW5kbGVyLlxuICovXG4vKipcbiAqIEB0eXBlZGVmIHsgZnVuY3Rpb24gfSBJbnRlbnRIYW5kbGVyXG4gKiBAc3VtbWFyeSBTdWJzY3JpcHRpb24gZnVuY3Rpb24gZm9yIHJlZ2lzdGVySW50ZW50SGFuZGxlclxuICovXG4vKipcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gQ2xpZW50SWRlbnRpdHlcbiAqIEBzdW1tYXJ5IFRoZSBJZGVudGl0eSBmb3IgYSBDaGFubmVsIENsaWVudC4gSW5jbHVkZXMgZW5kcG9pbnRJZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gZGlmZmVyZW50IGNvbm5lY3Rpb25zIGZvciBhbiBlbnRpdHkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXVpZCBHVUlEIG9mIGFuIGFwcGxpY2F0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhbiBlbnRpdHkgaW4gYW4gYXBwbGljYXRpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZW5kcG9pbnRJZCBVbmlxdWUgZGlmZmVyZW50aWF0b3IgZm9yIGRpZmZlcmVudCBDaGFubmVsIGNvbm5lY3Rpb25zIGZvciBhbiBlbnRpdHkuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBDb250ZXh0R3JvdXBJbmZvXG4gKiBAc3VtbWFyeSBJbmZvcm1hdGlvbiBmb3IgYSBDb250ZXh0IEdyb3VwLiBDb250YWlucyBtZXRhZGF0YSBmb3IgZGlzcGxheWluZyB0aGUgZ3JvdXAgcHJvcGVybHkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgTmFtZSBvZiB0aGUgY29udGV4dCBncm91cFxuICogQHByb3BlcnR5IHtEaXNwbGF5TWV0YWRhdGF9IGRpc3BsYXlNZXRhZGF0YSBNZXRhZGF0YSBmb3IgdGhlIENvbnRleHQgR3JvdXAuIENvbnRhaW5zIHRoZSBncm91cCdzIGh1bWFuLXJlYWRhYmxlIG5hbWUsIGNvbG9yLCBhbmQgYW4gaW1hZ2UsIGFzIGRlZmluZWQgYnkgdGhlIEludGVyb3AgQnJva2VyLlxuICovXG4vKipcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gRGlzcGxheU1ldGFkYXRhXG4gKiBAc3VtbWFyeSBUaGUgZGlzcGxheSBkYXRhIGZvciBhIENvbnRleHQgR3JvdXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBBIHVzZXItcmVhZGFibGUgbmFtZSBmb3IgdGhpcyBjb250ZXh0IGdyb3VwLCBlLmc6IGBcIlJlZFwiYFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvcl0gVGhlIGNvbG9yIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aGluIHRoaXMgY29udGV4dCBncm91cCB3aGVuIGRpc3BsYXlpbmcgdGhpcyBjb250ZXh0IGdyb3VwIGluIGEgVUksIGUuZzogYDB4RkYwMDAwYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2x5cGhdIEEgVVJMIG9mIGFuIGltYWdlIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSB0aGlzIGNvbnRleHQgZ3JvdXBcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IENvbnRleHRcbiAqIEBzdW1tYXJ5IERhdGEgcGFzc2VkIGJldHdlZW4gZW50aXRpZXMgaW4gYSBjb250ZXh0IGdyb3VwLlxuICogQHByb3BlcnR5IHtvYmplY3R9IFtpZF0gQW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5LXZhbHVlIHBhaXJzIGZvciB0aGUgYnVsayBvZiB0aGUgZGF0YSBmb3IgdGhlIGNvbnRleHQuIERpZmZlcnMgYmV0d2VlbiBjb250ZXh0IHR5cGVzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSBVc2VyLXJlYWRhYmxlIG5hbWUgZm9yIHRoZSBpbmNvbWluZyBjb250ZXh0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgQ29uc2VydmVkIHR5cGUgZm9yIHRoZSBjb250ZXh0IChlLmcuIGBpbnN0cnVtZW50YCBvciBgY291bnRyeWApXG4gKi9cbi8qKlxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL29mLWRvY3MvZG9jcy9lbmFibGUtY29sb3ItbGlua2luZyAqKlRIRSBJTlRFUk9QIEFQSSBJUyBFWFBFUklNRU5UQUwuIElGIFlPVSBXT1VMRCBMSUtFIFRPIFVTRSBJVCwgUExFQVNFIFVTRSBPVVIgREVGQVVMVCBJTVBMRU1FTlRBVElPTiBJTiBCUk9XU0VSKip9XG4gKlxuICogVGhlIEludGVyb3AgQ2xpZW50IEFQSSBpcyBicm9rZW4gdXAgaW50byB0d28gZ3JvdXBzOlxuICpcbiAqICoqQ29udGVudCBGYWNpbmcgQVBJcyoqIC0gRm9yIEFwcGxpY2F0aW9uIERldmVsb3BlcnMgcHV0dGluZyBWaWV3cyBpbnRvIGEgUGxhdGZvcm0gV2luZG93LCB3aG8gY2FyZSBhYm91dCBDb250ZXh0LiBUaGVzZSBhcmUgQVBJcyB0aGF0IHNlbmQgb3V0IGFuZCByZWNlaXZlIHRoZSBDb250ZXh0IGRhdGEgdGhhdCBmbG93cyBiZXR3ZWVuIGFwcGxpY2F0aW9ucy4gVGhpbmsgb2YgdGhpcyBhcyB0aGUgV2F0ZXIgaW4gdGhlIEludGVyb3AgUGlwZXMuXG4gKlxuICogKipDb250ZXh0IEdyb3VwaW5nIEFQSXMqKiAtIEZvciBQbGF0Zm9ybSBEZXZlbG9wZXJzLCB0byBhZGQgYW5kIHJlbW92ZSBWaWV3cyB0byBhbmQgZnJvbSBDb250ZXh0IEdyb3Vwcy4gVGhlc2UgQVBJcyBhcmUgdXRpbGl6ZWQgdW5kZXItdGhlLWhvb2QgaW4gUGxhdGZvcm1zLCBzbyB0aGV5IGRvbid0IG5lZWQgdG8gYmUgdXNlZCB0byBwYXJ0aWNpcGF0ZSBpbiBJbnRlcm9wLiBUaGVzZSBhcmUgdGhlIEFQSXMgdGhhdCBkZWNpZGUgd2hpY2ggZW50aXRpZXMgdGhlIGNvbnRleHQgZGF0YSBmbG93cyBiZXR3ZWVuLiBUaGluayBvZiB0aGVzZSBhcyB0aGUgdmFsdmVzIG9yIHBpcGVzIHRoYXQgY29udHJvbCB0aGUgZmxvdyBvZiBDb250ZXh0IERhdGEgZm9yIEludGVyb3AuXG4gKlxuICogLS0tXG4gKlxuICogQWxsIEFQSXMgYXJlIGF2YWlsYWJsZSBhdCB0aGUgYGZpbi5tZS5pbnRlcm9wYCBuYW1lc3BhY2UuXG4gKlxuICogLS0tXG4gKlxuICogKipZb3Ugb25seSBuZWVkIDIgdGhpbmdzIHRvIHBhcnRpY2lwYXRlIGluIEludGVyb3AgQ29udGV4dCBHcm91cGluZzoqKlxuICogKiBBIENvbnRleHQgSGFuZGxlciBmb3IgaW5jb21pbmcgY29udGV4dDoge0BsaW5rIEludGVyb3BDbGllbnQjYWRkQ29udGV4dEhhbmRsZXIgYWRkQ29udGV4dEhhbmRsZXIoaGFuZGxlciwgY29udGV4dFR5cGU/KX1cbiAqICogQ2FsbCBzZXRDb250ZXh0IG9uIHlvdXIgY29udGV4dCBncm91cCB3aGVuIHlvdSB3YW50IHRvIHNoYXJlIGNvbnRleHQgd2l0aCBvdGhlciBncm91cCBtZW1iZXJzOiB7QGxpbmsgSW50ZXJvcENsaWVudCNzZXRDb250ZXh0IHNldENvbnRleHQoY29udGV4dCl9XG4gKlxuICogLS0tXG4gKlxuICogIyMjIyMgQ29uc3RydWN0b3JcbiAqIFJldHVybmVkIGJ5IHtAbGluayBJbnRlcm9wLmNvbm5lY3RTeW5jIEludGVyb3AuY29ubmVjdFN5bmN9LlxuICpcbiAqICMjIyMjIENvbnRlbnQgRmFjaW5nIEFQSXNcbiAqICAqIHtAbGluayBJbnRlcm9wQ2xpZW50I2FkZENvbnRleHRIYW5kbGVyIGFkZENvbnRleHRIYW5kbGVyKGhhbmRsZXIsIGNvbnRleHRUeXBlPyl9XG4gKiAgKiB7QGxpbmsgSW50ZXJvcENsaWVudCNzZXRDb250ZXh0IHNldENvbnRleHQoY29udGV4dCl9XG4gKlxuXG4gKiAjIyMjIyBDb250ZXh0IEdyb3VwaW5nIEFQSXMgLSBGb3IgUGxhdGZvcm0gV2luZG93IFVzZVxuICogICoge0BsaW5rIEludGVyb3BDbGllbnQjZ2V0Q29udGV4dEdyb3VwcyBnZXRDb250ZXh0R3JvdXBzKCl9XG4gKiAgKiB7QGxpbmsgSW50ZXJvcENsaWVudCNqb2luQ29udGV4dEdyb3VwIGpvaW5Db250ZXh0R3JvdXAoY29udGV4dEdyb3VwSWQsIHRhcmdldD8pfVxuICogICoge0BsaW5rIEludGVyb3BDbGllbnQjcmVtb3ZlRnJvbUNvbnRleHRHcm91cCByZW1vdmVGcm9tQ29udGV4dEdyb3VwKHRhcmdldD8pfVxuICogICoge0BsaW5rIEludGVyb3BDbGllbnQjZ2V0SW5mb0ZvckNvbnRleHRHcm91cCBnZXRJbmZvRm9yQ29udGV4dEdyb3VwKGNvbnRleHRHcm91cElkKX1cbiAqICAqIHtAbGluayBJbnRlcm9wQ2xpZW50I2dldEFsbENsaWVudHNJbkNvbnRleHRHcm91cCBnZXRBbGxDbGllbnRzSW5Db250ZXh0R3JvdXAoY29udGV4dEdyb3VwSWQpfVxuICpcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBJbnRlcm9wQ2xpZW50IGV4dGVuZHMgYmFzZV8xLkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHdpcmUsIG5hbWUsIGludGVyb3BDb25maWcpIHtcbiAgICAgICAgc3VwZXIod2lyZSk7XG4gICAgICAgIF9jbGllbnRQcm9taXNlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9jbGllbnRQcm9taXNlLCB0aGlzLmZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY29ubmVjdChgaW50ZXJvcC1icm9rZXItJHtuYW1lfWAsIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGludGVyb3BDb25maWdcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKlxuICAgIENsaWVudCBBUElzXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY29udGV4dCBmb3IgdGhlIGNvbnRleHQgZ3JvdXAgb2YgdGhlIGN1cnJlbnQgZW50aXR5LlxuICAgICAqIEBwYXJhbSB7IENvbnRleHQgfSBjb250ZXh0IC0gTmV3IGNvbnRleHQgdG8gc2V0LlxuICAgICAqIEByZXR1cm4geyBQcm9taXNlPHZvaWQ+IH1cbiAgICAgKiBAdHV0b3JpYWwgaW50ZXJvcC5zZXRDb250ZXh0XG4gICAgICovXG4gICAgYXN5bmMgc2V0Q29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1zZXQtY29udGV4dCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2NsaWVudFByb21pc2UpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKCdzZXRDb250ZXh0JywgeyBjb250ZXh0IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjb250ZXh0IGhhbmRsZXIgZm9yIGluY29taW5nIGNvbnRleHQuIElmIGFuIGVudGl0eSBpcyBwYXJ0IG9mIGEgY29udGV4dCBncm91cCwgYW5kIHRoZW4gc2V0cyBpdHMgY29udGV4dCBoYW5kbGVyLCBpdCB3aWxsIHJlY2VpdmUgYWxsIG9mIGl0cyBkZWNsYXJlZCBjb250ZXh0cy5cbiAgICAgKiBAcGFyYW0geyBDb250ZXh0SGFuZGxlciB9IGhhbmRsZXIgLSBIYW5kbGVyIGZvciBpbmNvbWluZyBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IFtjb250ZXh0VHlwZV0gLSBUaGUgdHlwZSBvZiBjb250ZXh0IHlvdSB3aXNoIHRvIGhhbmRsZS5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTxTdWJzY3JpcHRpb24+IH1cbiAgICAgKiBAdHV0b3JpYWwgaW50ZXJvcC5hZGRDb250ZXh0SGFuZGxlclxuICAgICAqL1xuICAgIGFzeW5jIGFkZENvbnRleHRIYW5kbGVyKGhhbmRsZXIsIGNvbnRleHRUeXBlKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1hZGQtY29udGV4dC1oYW5kbGVyJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfY2xpZW50UHJvbWlzZSk7XG4gICAgICAgIGxldCBoYW5kbGVySWQ7XG4gICAgICAgIGlmIChjb250ZXh0VHlwZSkge1xuICAgICAgICAgICAgaGFuZGxlcklkID0gYGludm9rZUNvbnRleHRIYW5kbGVyLSR7Y29udGV4dFR5cGV9LSR7dXRpbHNfMS5nZW5lcmF0ZUlkKCl9YDtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogQnkgcHJvdmlkaW5nIGEgY29udGV4dFR5cGUgKCR7Y29udGV4dFR5cGV9KSwgeW91IGFyZSB1c2luZyB0aGUgZXhwZXJpbWVudGFsIGFkZENvbnRleHRIYW5kbGVyLiBUbyBhdm9pZCBpc3N1ZXMsIG1ha2Ugc3VyZSB5b3UgYXJlIGFkZGluZyB5b3VyIGNvbnRleHQgaGFuZGxlcnMgYXQgdGhlIHRvcCBsZXZlbCBpbiB5b3VyIGFwcGxpY2F0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlcklkID0gJ2ludm9rZUNvbnRleHRIYW5kbGVyJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IHRoaXMud3JhcENvbnRleHRIYW5kbGVyKGhhbmRsZXIsIGhhbmRsZXJJZCk7XG4gICAgICAgIGNsaWVudC5yZWdpc3RlcihoYW5kbGVySWQsIHdyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgYXdhaXQgY2xpZW50LmRpc3BhdGNoKCdjb250ZXh0SGFuZGxlclJlZ2lzdGVyZWQnLCB7IGhhbmRsZXJJZCwgY29udGV4dFR5cGUgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsaWVudC5yZW1vdmUoaGFuZGxlcklkKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjbGllbnQuZGlzcGF0Y2goJ3JlbW92ZUNvbnRleHRIYW5kbGVyJywgeyBoYW5kbGVySWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qXG4gICAgUGxhdGZvcm0gV2luZG93IEFQSXNcbiAgICAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEludGVyb3AtQnJva2VyLWRlZmluZWQgY29udGV4dCBncm91cHMgYXZhaWxhYmxlIGZvciBhbiBlbnRpdHkgdG8gam9pbi5cbiAgICAgKiBVc2VkIGJ5IFBsYXRmb3JtIFdpbmRvd3MuXG4gICAgICogQHJldHVybiB7IFByb21pc2U8Q29udGV4dEdyb3VwSW5mb1tdPn1cbiAgICAgKiBAdHV0b3JpYWwgaW50ZXJvcC5nZXRDb250ZXh0R3JvdXBzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29udGV4dEdyb3VwcygpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtY2xpZW50LWdldC1jb250ZXh0LWdyb3VwcycpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2UsIGFuYWx5dGljcy1vbmx5IGNhbGxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2NsaWVudFByb21pc2UpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKCdnZXRDb250ZXh0R3JvdXBzJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW4gYWxsIEludGVyb3AgQ2xpZW50cyBhdCB0aGUgZ2l2ZW4gaWRlbnRpdHkgdG8gY29udGV4dCBncm91cCBgY29udGV4dEdyb3VwSWRgLlxuICAgICAqIElmIG5vIHRhcmdldCBpcyBzcGVjaWZpZWQsIGl0IGFkZHMgdGhlIHNlbmRlciB0byB0aGUgY29udGV4dCBncm91cC5cbiAgICAgKiBCZWNhdXNlIG11bHRpcGxlIENoYW5uZWwgY29ubmVjdGlvbnMvSW50ZXJvcCBDbGllbnRzIGNhbiBwb3RlbnRpYWxseSBleGlzdCBhdCBhIGB1dWlkYC9gbmFtZWAgY29tYm8sIHdlIGN1cnJlbnRseSBqb2luIGFsbCBDaGFubmVsIGNvbm5lY3Rpb25zL0ludGVyb3AgQ2xpZW50cyBhdCB0aGUgZ2l2ZW4gaWRlbnRpdHkgdG8gdGhlIGNvbnRleHQgZ3JvdXAuXG4gICAgICogSWYgYW4gYGVuZHBvaW50SWRgIGlzIHByb3ZpZGVkICh3aGljaCBpcyB1bmxpa2VseSwgdW5sZXNzIHRoZSBjYWxsIGlzIGNvbWluZyBmcm9tIGFuIGV4dGVybmFsIGFkYXB0ZXIpLCB0aGVuIHdlIG9ubHkgam9pbiB0aGF0IHNpbmdsZSBjb25uZWN0aW9uIHRvIHRoZSBjb250ZXh0IGdyb3VwLlxuICAgICAqIEZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXMsIHRoZXJlIHdpbGwgb25seSBiZSAxIGNvbm5lY3Rpb24gcHJlc2VudCBpbiBQbGF0Zm9ybSBhbmQgQnJvd3NlciBpbXBsbWVudGF0aW9ucywgc28gdGhpcyBwb2ludCBpcyBtb3JlLW9yLWxlc3MgbW9vdC5cbiAgICAgKiBVc2VkIGJ5IFBsYXRmb3JtIFdpbmRvd3MuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gY29udGV4dEdyb3VwSWQgLSBJZCBvZiB0aGUgY29udGV4dCBncm91cC5cbiAgICAgKiBAcGFyYW0geyBJZGVudGl0eSB9IFt0YXJnZXRdIC0gSWRlbnRpdHkgb2YgdGhlIGVudGl0eSB5b3Ugd2lzaCB0byBqb2luIHRvIGEgY29udGV4dCBncm91cC5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgaW50ZXJvcC5qb2luQ29udGV4dEdyb3VwXG4gICAgICovXG4gICAgYXN5bmMgam9pbkNvbnRleHRHcm91cChjb250ZXh0R3JvdXBJZCwgdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnRlcm9wLWNsaWVudC1qb2luLWNvbnRleHQtZ3JvdXAnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9jbGllbnRQcm9taXNlKTtcbiAgICAgICAgaWYgKCFjb250ZXh0R3JvdXBJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb250ZXh0R3JvdXBJZCBzcGVjaWZpZWQgZm9yIGpvaW5Db250ZXh0R3JvdXAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaCgnam9pbkNvbnRleHRHcm91cCcsIHsgY29udGV4dEdyb3VwSWQsIHRhcmdldCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIHRhcmdldCBmcm9tIGEgY29udGV4dCBncm91cC5cbiAgICAgKiBJZiBubyB0YXJnZXQgaXMgc3BlY2lmaWVkLCBpdCByZW1vdmVzIHRoZSBzZW5kZXIgZnJvbSB0aGVpciBjb250ZXh0IGdyb3VwLlxuICAgICAqIFVzZWQgYnkgUGxhdGZvcm0gV2luZG93cy5cbiAgICAgKiBAcGFyYW0geyBJZGVudGl0eSB9IFt0YXJnZXRdIC0gSWRlbnRpdHkgb2YgdGhlIGVudGl0eSB5b3Ugd2lzaCB0byBqb2luIHRvIGEgY29udGV4dCBncm91cC5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgaW50ZXJvcC5yZW1vdmVGcm9tQ29udGV4dEdyb3VwXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlRnJvbUNvbnRleHRHcm91cCh0YXJnZXQpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtY2xpZW50LXJlbW92ZS1mcm9tLWNvbnRleHQtZ3JvdXAnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9jbGllbnRQcm9taXNlKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaCgncmVtb3ZlRnJvbUNvbnRleHRHcm91cCcsIHsgdGFyZ2V0IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBjbGllbnRzIGZvciBhIGNvbnRleHQgZ3JvdXAuXG4gICAgICogVXNlZCBieSBQbGF0Zm9ybSBXaW5kb3dzLlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IGNvbnRleHRHcm91cElkIC0gVGhlIGlkIG9mIGNvbnRleHQgZ3JvdXAgeW91IHdpc2ggdG8gZ2V0IGNsaWVudHMgZm9yLlxuICAgICAqIEByZXR1cm4geyBQcm9taXNlPENsaWVudElkZW50aXR5W10+fVxuICAgICAqIEB0dXRvcmlhbCBpbnRlcm9wLmdldEFsbENsaWVudHNJbkNvbnRleHRHcm91cFxuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbENsaWVudHNJbkNvbnRleHRHcm91cChjb250ZXh0R3JvdXBJZCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignaW50ZXJvcC1jbGllbnQtZ2V0LWFsbC1jbGllbnRzLWluLWNvbnRleHQtZ3JvdXAnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9jbGllbnRQcm9taXNlKTtcbiAgICAgICAgaWYgKCFjb250ZXh0R3JvdXBJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb250ZXh0R3JvdXBJZCBzcGVjaWZpZWQgZm9yIGdldEFsbENsaWVudHNJbkNvbnRleHRHcm91cC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKCdnZXRBbGxDbGllbnRzSW5Db250ZXh0R3JvdXAnLCB7IGNvbnRleHRHcm91cElkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGRpc3BsYXkgaW5mbyBmb3IgYSBjb250ZXh0IGdyb3VwXG4gICAgICogVXNlZCBieSBQbGF0Zm9ybSBXaW5kb3dzLlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IGNvbnRleHRHcm91cElkIC0gVGhlIGlkIG9mIGNvbnRleHQgZ3JvdXAgeW91IHdpc2ggdG8gZ2V0IGRpc3BsYXkgaW5mbyBmb3IuXG4gICAgICogQHJldHVybiB7IFByb21pc2U8Q29udGV4dEdyb3VwSW5mbz59XG4gICAgICogQHR1dG9yaWFsIGludGVyb3AuZ2V0SW5mb0ZvckNvbnRleHRHcm91cFxuICAgICAqL1xuICAgIGFzeW5jIGdldEluZm9Gb3JDb250ZXh0R3JvdXAoY29udGV4dEdyb3VwSWQpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtY2xpZW50LWdldC1pbmZvLWZvci1jb250ZXh0LWdyb3VwJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfY2xpZW50UHJvbWlzZSk7XG4gICAgICAgIGlmICghY29udGV4dEdyb3VwSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udGV4dEdyb3VwSWQgc3BlY2lmaWVkIGZvciBnZXRJbmZvRm9yQ29udGV4dEdyb3VwLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGllbnQuZGlzcGF0Y2goJ2dldEluZm9Gb3JDb250ZXh0R3JvdXAnLCB7IGNvbnRleHRHcm91cElkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhbiBpbnRlbnQgdG8gdGhlIEludGVyb3AgQnJva2VyIHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHsgSW50ZW50IH0gaW50ZW50IC0gVGhlIGNvbWJpbmF0aW9uIG9mIGFuIGFjdGlvbiBhbmQgYSBjb250ZXh0IHRoYXQgaXMgcGFzc2VkIHRvIGFuIGFwcGxpY2F0aW9uIGZvciByZXNvbHV0aW9uLlxuICAgICAqIEByZXR1cm4geyBQcm9taXNlPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBpbnRlcm9wLmZpcmVJbnRlbnRcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgZmlyZUludGVudChpbnRlbnQpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtY2xpZW50LWZpcmUtaW50ZW50JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgdGhpcyBpcyBvbmx5IGZvciBhcGkgYW5hbHl0aWNzIHB1cnBvc2VzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9jbGllbnRQcm9taXNlKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaCgnZmlyZUludGVudCcsIGludGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaW50ZW50IGhhbmRsZXIgZm9yIGluY29taW5nIGludGVudHMuIFRoZSBsYXN0IGludGVudCBzZW50IG9mIHRoZSBuYW1lIHN1YnNjcmliZWQgdG8gd2lsbCBiZSByZWNlaXZlZC5cbiAgICAgKiBAcGFyYW0geyBJbnRlbnRIYW5kbGVyIH0gaGFuZGxlciAtIFJlZ2lzdGVyZWQgZnVuY3Rpb24gbWVhbnQgdG8gaGFuZGxlIGEgc3BlY2lmaWMgaW50ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gaW50ZW50TmFtZSAtIFRoZSBuYW1lIG9mIGFuIGludGVudC5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTxTdWJzY3JpcHRpb24+IH1cbiAgICAgKiBAdHV0b3JpYWwgaW50ZXJvcC5yZWdpc3RlckludGVudEhhbmRsZXJcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgcmVnaXN0ZXJJbnRlbnRIYW5kbGVyKGhhbmRsZXIsIGludGVudE5hbWUpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2ludGVyb3AtY2xpZW50LXJlZ2lzdGVyLWludGVudC1oYW5kbGVyJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgdGhpcyBpcyBvbmx5IGZvciBhcGkgYW5hbHl0aWNzIHB1cnBvc2VzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9jbGllbnRQcm9taXNlKTtcbiAgICAgICAgY29uc3QgaGFuZGxlcklkID0gYGludGVudC1oYW5kbGVyLSR7aW50ZW50TmFtZX1gO1xuICAgICAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IHRoaXMud3JhcEludGVudEhhbmRsZXIoaGFuZGxlciwgaGFuZGxlcklkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5yZWdpc3RlcihoYW5kbGVySWQsIHdyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5kaXNwYXRjaCgnaW50ZW50SGFuZGxlclJlZ2lzdGVyZWQnLCB7IGhhbmRsZXJJZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlZ2lzdGVyIGludGVudCBoYW5kbGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xpZW50LnJlbW92ZShoYW5kbGVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKlxuICAgIEludGVybmFsIFV0aWx0aWVzXG4gICAgKi9cbiAgICAvLyBVdGlsIGZvciBtb3JlIHVzZWZ1bCBlcnJvciBoYW5kbGluZ1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgd3JhcENvbnRleHRIYW5kbGVyKGhhbmRsZXIsIGhhbmRsZXJJZCkge1xuICAgICAgICByZXR1cm4gYXN5bmMgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlcihjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHRocm93biBieSBoYW5kbGVyICR7aGFuZGxlcklkfSBmb3IgY29udGV4dCB0eXBlICR7Y29udGV4dC50eXBlfTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICB3cmFwSW50ZW50SGFuZGxlcihoYW5kbGVyLCBoYW5kbGVySWQpIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jIChpbnRlbnQpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlcihpbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdGhyb3duIGJ5IGhhbmRsZXIgJHtoYW5kbGVySWR9OiAke2Vycm9yfWApO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJvcENsaWVudCA9IEludGVyb3BDbGllbnQ7XG5fY2xpZW50UHJvbWlzZSA9IG5ldyBXZWFrTWFwKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRmFjdG9yeV8xID0gcmVxdWlyZShcIi4vRmFjdG9yeVwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEZhY3RvcnlfMS5kZWZhdWx0O1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0ludGVyb3BDbGllbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0ludGVyb3BCcm9rZXJcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdlbmVyYXRlSWQgPSB2b2lkIDA7XG5leHBvcnRzLmdlbmVyYXRlSWQgPSAoKSA9PiBgJHtNYXRoLnJhbmRvbSgpfSR7RGF0ZS5ub3coKX1gO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldE1lID0gZXhwb3J0cy5nZXRCYXNlTWUgPSB2b2lkIDA7XG5jb25zdCBFbnRpdHlUeXBlXzEgPSByZXF1aXJlKFwiLi4vc2hhcGVzL0VudGl0eVR5cGVcIik7XG5jb25zdCB2aWV3XzEgPSByZXF1aXJlKFwiLi92aWV3XCIpO1xuY29uc3QgZnJhbWVfMSA9IHJlcXVpcmUoXCIuL2ZyYW1lXCIpO1xuY29uc3Qgd2luZG93XzEgPSByZXF1aXJlKFwiLi93aW5kb3dcIik7XG5mdW5jdGlvbiBnZXRCYXNlTWUoZW50aXR5VHlwZSwgdXVpZCwgbmFtZSkge1xuICAgIGNvbnN0IGVudGl0eVR5cGVIZWxwZXJzID0ge1xuICAgICAgICBpc1ZpZXc6IGVudGl0eVR5cGUgPT09ICd2aWV3JyxcbiAgICAgICAgaXNXaW5kb3c6IGVudGl0eVR5cGUgPT09ICd3aW5kb3cnLFxuICAgICAgICBpc0ZyYW1lOiBlbnRpdHlUeXBlID09PSAnaWZyYW1lJyxcbiAgICAgICAgaXNFeHRlcm5hbDogZW50aXR5VHlwZSA9PT0gJ2V4dGVybmFsIGNvbm5lY3Rpb24nXG4gICAgfTtcbiAgICByZXR1cm4geyAuLi5lbnRpdHlUeXBlSGVscGVycywgdXVpZCwgbmFtZSwgZW50aXR5VHlwZSB9O1xufVxuZXhwb3J0cy5nZXRCYXNlTWUgPSBnZXRCYXNlTWU7XG4vLyBXZSBuZWVkIHRvIGRvIGEgbG90IG9mIGNhc3RpbmcgYXMgdW5rbm93biBoZXJlIGJlY2F1c2UgdGhlIGNvbXBpbGVyIGdldCdzIGNvbmZ1c2VkIGFib3V0IG1hdGNoaW5nIHR5cGVzLiBXaGF0IG1hdHRlcnMgaXMgdGhhdCBpdCB3b3JrcyBvbiB0aGUgb3V0c2lkZVxuZnVuY3Rpb24gZ2V0TWUod2lyZSkge1xuICAgIGNvbnN0IHsgdXVpZCwgbmFtZSwgZW50aXR5VHlwZSB9ID0gd2lyZS5tZTtcbiAgICBjb25zdCBpbnRlcm9wT2JqZWN0ID0ge1xuICAgICAgICBzZXRDb250ZXh0KCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm9wIEFQSSBoYXMgbm90IGJlZW4gaW5zdGFudGlhdGVkLiBFaXRoZXIgY29ubmVjdGlvbiBoYXMgZmFpbGVkIG9yIHlvdSBoYXZlIG5vdCBkZWNsYXJlZCBpbnRlcm9wIGluIHlvdXIgY29uZmlnLicpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRDb250ZXh0SGFuZGxlcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJvcCBBUEkgaGFzIG5vdCBiZWVuIGluc3RhbnRpYXRlZC4gRWl0aGVyIGNvbm5lY3Rpb24gaGFzIGZhaWxlZCBvciB5b3UgaGF2ZSBub3QgZGVjbGFyZWQgaW50ZXJvcCBpbiB5b3VyIGNvbmZpZy4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29udGV4dEdyb3VwcygpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJvcCBBUEkgaGFzIG5vdCBiZWVuIGluc3RhbnRpYXRlZC4gRWl0aGVyIGNvbm5lY3Rpb24gaGFzIGZhaWxlZCBvciB5b3UgaGF2ZSBub3QgZGVjbGFyZWQgaW50ZXJvcCBpbiB5b3VyIGNvbmZpZy4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgam9pbkNvbnRleHRHcm91cCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJvcCBBUEkgaGFzIG5vdCBiZWVuIGluc3RhbnRpYXRlZC4gRWl0aGVyIGNvbm5lY3Rpb24gaGFzIGZhaWxlZCBvciB5b3UgaGF2ZSBub3QgZGVjbGFyZWQgaW50ZXJvcCBpbiB5b3VyIGNvbmZpZy4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlRnJvbUNvbnRleHRHcm91cCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJvcCBBUEkgaGFzIG5vdCBiZWVuIGluc3RhbnRpYXRlZC4gRWl0aGVyIGNvbm5lY3Rpb24gaGFzIGZhaWxlZCBvciB5b3UgaGF2ZSBub3QgZGVjbGFyZWQgaW50ZXJvcCBpbiB5b3VyIGNvbmZpZy4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QWxsQ2xpZW50c0luQ29udGV4dEdyb3VwKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm9wIEFQSSBoYXMgbm90IGJlZW4gaW5zdGFudGlhdGVkLiBFaXRoZXIgY29ubmVjdGlvbiBoYXMgZmFpbGVkIG9yIHlvdSBoYXZlIG5vdCBkZWNsYXJlZCBpbnRlcm9wIGluIHlvdXIgY29uZmlnLicpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbmZvRm9yQ29udGV4dEdyb3VwKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm9wIEFQSSBoYXMgbm90IGJlZW4gaW5zdGFudGlhdGVkLiBFaXRoZXIgY29ubmVjdGlvbiBoYXMgZmFpbGVkIG9yIHlvdSBoYXZlIG5vdCBkZWNsYXJlZCBpbnRlcm9wIGluIHlvdXIgY29uZmlnLicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzd2l0Y2ggKGVudGl0eVR5cGUpIHtcbiAgICAgICAgY2FzZSBFbnRpdHlUeXBlXzEuZGVmYXVsdC5WSUVXOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IHZpZXdfMS5WaWV3KHdpcmUsIHsgdXVpZCwgbmFtZSB9KSwgZ2V0QmFzZU1lKGVudGl0eVR5cGUsIHV1aWQsIG5hbWUpLCB7XG4gICAgICAgICAgICAgICAgaW50ZXJvcDogaW50ZXJvcE9iamVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgRW50aXR5VHlwZV8xLmRlZmF1bHQuV0lORE9XOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IHdpbmRvd18xLl9XaW5kb3cod2lyZSwgeyB1dWlkLCBuYW1lIH0pLCBnZXRCYXNlTWUoZW50aXR5VHlwZSwgdXVpZCwgbmFtZSksIHtcbiAgICAgICAgICAgICAgICBpbnRlcm9wOiBpbnRlcm9wT2JqZWN0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBFbnRpdHlUeXBlXzEuZGVmYXVsdC5JRlJBTUU6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgZnJhbWVfMS5fRnJhbWUod2lyZSwgeyB1dWlkLCBuYW1lIH0pLCBnZXRCYXNlTWUoZW50aXR5VHlwZSwgdXVpZCwgbmFtZSksIHtcbiAgICAgICAgICAgICAgICBpbnRlcm9wOiBpbnRlcm9wT2JqZWN0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmdldEJhc2VNZShlbnRpdHlUeXBlLCB1dWlkLCBuYW1lKSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0TWUgPSBnZXRNZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG5jb25zdCBzaGFwZXNfMSA9IHJlcXVpcmUoXCIuL3NoYXBlc1wiKTtcbmNvbnN0IEluc3RhbmNlXzEgPSByZXF1aXJlKFwiLi9JbnN0YW5jZVwiKTtcbi8qKlxuICogQGxlbmRzIE5vdGlmaWNhdGlvblxuICovXG5jbGFzcyBfTm90aWZpY2F0aW9uTW9kdWxlIGV4dGVuZHMgYmFzZV8xLkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5leHROb3RlSWQgPSAwO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHNoYXBlc18xLmV2ZW50cztcbiAgICB9XG4gICAgZ2VuTm90ZUlkKCkge1xuICAgICAgICB0aGlzLm5leHROb3RlSWQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dE5vdGVJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBOb3RpZmljYXRpb24uXG4gICAgICogQGRlcHJlY2F0ZWQgZmluLk5vdGlmaWNhdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBQbGVhc2UgbWlncmF0ZSB0byB0aGUgW05vdGlmaWNhdGlvbiBDZW50ZXIgQVBJXXtAbGluayBodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL25vdGlmaWNhdGlvbnMtYXBpfS5cbiAgICAgKiBAcGFyYW0geyBvYmplY3QgfSBvcHRpb25zXG4gICAgICogQHJldHVybiB7X05vdGlmaWNhdGlvbn1cbiAgICAgKiBAdHV0b3JpYWwgTm90aWZpY2F0aW9uLmNyZWF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBjcmVhdGUob3B0aW9ucykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oJ2Zpbi5Ob3RpZmljYXRpb24gaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuIFBsZWFzZSBtaWdyYXRlIHRvIHRoZSBOb3RpZmljYXRpb24gQ2VudGVyIEFQSTogaHR0cHM6Ly9kZXZlbG9wZXJzLm9wZW5maW4uY28vZG9jcy9ub3RpZmljYXRpb25zLWFwaS4nKTtcbiAgICAgICAgY29uc3Qgbm90ZU9wdGlvbnMgPSBuZXcgc2hhcGVzXzEuTm90aWZpY2F0aW9uT3B0aW9ucyhvcHRpb25zLCB0aGlzLm1lLCB0aGlzLmdlbk5vdGVJZCgpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW5jZV8xLl9Ob3RpZmljYXRpb24odGhpcy53aXJlLCBub3RlT3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gX05vdGlmaWNhdGlvbk1vZHVsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5fTm90aWZpY2F0aW9uID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG4vKipcbiAqIEBkZXByZWNhdGVkIGZpbi5Ob3RpZmljYXRpb24gaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gKiBQbGVhc2UgbWlncmF0ZSB0byB0aGUgW05vdGlmaWNhdGlvbiBDZW50ZXIgQVBJXXtAbGluayBodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL25vdGlmaWNhdGlvbnMtYXBpfS5cbiAqIEBjbGFzc2Rlc2MgQSBOb3RpZmljYXRpb24gb2JqZWN0IHJlcHJlc2VudHMgYSB3aW5kb3cgb24gT3BlbkZpbiBSdW50aW1lIHdoaWNoXG4gKiBpcyBzaG93biBicmllZmx5IHRvIHRoZSB1c2VyIG9uIHRoZSBib3R0b20tcmlnaHQgY29ybmVyIG9mIHRoZSBwcmltYXJ5IG1vbml0b3IuXG4gKiBBIG5vdGlmaWNhdGlvbiBpcyB0eXBpY2FsbHkgdXNlZCB0byBhbGVydCB0aGUgdXNlciBvZiBzb21lIGltcG9ydGFudCBldmVudCB3aGljaFxuICogcmVxdWlyZXMgaGlzIG9yIGhlciBhdHRlbnRpb24uIE5vdGlmaWNhdGlvbnMgYXJlIGEgY2hpbGQgb3IgeW91ciBhcHBsaWNhdGlvbiB0aGF0XG4gKiBhcmUgY29udHJvbGxlZCBieSB0aGUgcnVudGltZS5cbiAqIEBjbGFzc1xuICogQGFsaWFzIE5vdGlmaWNhdGlvblxuICogQGhpZGVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBfTm90aWZpY2F0aW9uIGV4dGVuZHMgYmFzZV8xLkVtaXR0ZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih3aXJlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHdpcmUsIFsnbm90aWZpY2F0aW9uJywgYCR7b3B0aW9ucy5ub3RpZmljYXRpb25JZH1gXSk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJMaXN0ID0gWyduZXdMaXN0ZW5lciddO1xuICAgICAgICB0aGlzLnVuaG9va0FsbExpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJMaXN0LmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25JZCA9IG9wdGlvbnMubm90aWZpY2F0aW9uSWQ7XG4gICAgICAgIHRoaXMub24oJ25ld0xpc3RlbmVyJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyTGlzdC5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGdpdmUgYW55IHVzZXIgYWRkZWQgbGlzdGVuZXJzIGEgY2hhbmNlIHRvIHJ1biB0aGVuIHVuaG9va1xuICAgICAgICB0aGlzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy51bmhvb2tBbGxMaXN0ZW5lcnMsIDEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBub3RpZmljYXRpb24gaXMgc2hvd25cbiAgICAgKiBAZGVwcmVjYXRlZCBmaW4uTm90aWZpY2F0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLlxuICAgICAqIFBsZWFzZSBtaWdyYXRlIHRvIHRoZSBbTm90aWZpY2F0aW9uIENlbnRlciBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3Mvbm90aWZpY2F0aW9ucy1hcGl9LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBOb3RpZmljYXRpb24uc2hvd1xuICAgICAqL1xuICAgIGFzeW5jIHNob3coKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybignZmluLk5vdGlmaWNhdGlvbiBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4gUGxlYXNlIG1pZ3JhdGUgdG8gdGhlIE5vdGlmaWNhdGlvbiBDZW50ZXIgQVBJOiBodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL25vdGlmaWNhdGlvbnMtYXBpLicpO1xuICAgICAgICBpZiAoIXRoaXMudXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdGlmaWNhdGlvbnMgcmVxdWlyZSBhIHVybCcpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZW5kLWFjdGlvbi10by1ub3RpZmljYXRpb25zLWNlbnRlcicsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2NyZWF0ZS1ub3RpZmljYXRpb24nLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSWQ6IHRoaXMub3B0aW9ucy5ub3RpZmljYXRpb25JZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAZGVwcmVjYXRlZCBmaW4uTm90aWZpY2F0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLlxuICAgICAqIFBsZWFzZSBtaWdyYXRlIHRvIHRoZSBbTm90aWZpY2F0aW9uIENlbnRlciBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3Mvbm90aWZpY2F0aW9ucy1hcGl9LlxuICAgICAqIEBwYXJhbSB7IGFueSB9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYmUgc2VudCB0byB0aGUgbm90aWZpY2F0aW9uLlxuICAgICAqIENhbiBiZSBlaXRoZXIgYSBwcmltaXRpdmUgZGF0YSB0eXBlIChzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbilcbiAgICAgKiBvciBjb21wb3NpdGUgZGF0YSB0eXBlIChvYmplY3QsIGFycmF5KSB0aGF0IGlzIGNvbXBvc2VkIG9mIG90aGVyXG4gICAgICogcHJpbWl0aXZlIG9yIGNvbXBvc2l0ZSBkYXRhIHR5cGVzXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIE5vdGlmaWNhdGlvbi5zZW5kTWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKCdmaW4uTm90aWZpY2F0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLiBQbGVhc2UgbWlncmF0ZSB0byB0aGUgTm90aWZpY2F0aW9uIENlbnRlciBBUEk6IGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3Mvbm90aWZpY2F0aW9ucy1hcGkuJyk7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZW5kLWFjdGlvbi10by1ub3RpZmljYXRpb25zLWNlbnRlcicsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ3NlbmQtbm90aWZpY2F0aW9uLW1lc3NhZ2UnLFxuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbklkOiB0aGlzLm9wdGlvbnMubm90aWZpY2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBub3RpZmljYXRpb25cbiAgICAgKiBAZGVwcmVjYXRlZCBmaW4uTm90aWZpY2F0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLlxuICAgICAqIFBsZWFzZSBtaWdyYXRlIHRvIHRoZSBbTm90aWZpY2F0aW9uIENlbnRlciBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3Mvbm90aWZpY2F0aW9ucy1hcGl9LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBOb3RpZmljYXRpb24uY2xvc2VcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKCdmaW4uTm90aWZpY2F0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLiBQbGVhc2UgbWlncmF0ZSB0byB0aGUgTm90aWZpY2F0aW9uIENlbnRlciBBUEk6IGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3Mvbm90aWZpY2F0aW9ucy1hcGkuJyk7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZW5kLWFjdGlvbi10by1ub3RpZmljYXRpb25zLWNlbnRlcicsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2Nsb3NlLW5vdGlmaWNhdGlvbicsXG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSWQ6IHRoaXMub3B0aW9ucy5ub3RpZmljYXRpb25JZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLl9Ob3RpZmljYXRpb24gPSBfTm90aWZpY2F0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL0ZhY3RvcnlcIik7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2hhcGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JbnN0YW5jZVwiKSwgZXhwb3J0cyk7XG5leHBvcnRzLmRlZmF1bHQgPSBGYWN0b3J5XzEuZGVmYXVsdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob3RpZmljYXRpb25PcHRpb25zID0gZXhwb3J0cy5ldmVudHMgPSB2b2lkIDA7XG5leHBvcnRzLmV2ZW50cyA9IHtcbiAgICBzaG93OiAnc2hvdycsXG4gICAgY2xvc2U6ICdjbG9zZScsXG4gICAgZXJyb3I6ICdlcnJvcicsXG4gICAgY2xpY2s6ICdjbGljaycsXG4gICAgbWVzc2FnZTogJ21lc3NhZ2UnXG59O1xuY2xhc3MgTm90aWZpY2F0aW9uT3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCBpZGVudGl0eSwgbm90aWZpY2F0aW9uSWQpIHtcbiAgICAgICAgY29uc3QgeyB1cmwsIG1lc3NhZ2UsIHRpbWVvdXQsIGlnbm9yZU1vdXNlT3ZlciB9ID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25JZCA9IG5vdGlmaWNhdGlvbklkO1xuICAgICAgICB0aGlzLnV1aWRPZlByb3hpZWRBcHAgPSBpZGVudGl0eS51dWlkO1xuICAgICAgICB0aGlzLmlnbm9yZU1vdXNlT3ZlciA9IGlnbm9yZU1vdXNlT3ZlcjtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvbk9wdGlvbnMgPSBOb3RpZmljYXRpb25PcHRpb25zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiwgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2xheW91dC9pbmRleFwiKTtcbmNvbnN0IEluc3RhbmNlXzEgPSByZXF1aXJlKFwiLi9JbnN0YW5jZVwiKTtcbi8qKlxuICogSW5pdFBsYXRmb3JtT3B0aW9ucyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gSW5pdFBsYXRmb3JtT3B0aW9uc1xuICogQHByb3BlcnR5IHsgT3ZlcnJpZGVDYWxsYmFjayB9IFtvdmVycmlkZUNhbGxiYWNrXSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZXh0ZW5kIG9yIHJlcGxhY2UgZGVmYXVsdCBQcm92aWRlciBiZWhhdmlvci5cbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7IHNhbWUgfCBkaWZmZXJlbnQgfSBQcm9jZXNzQWZmaW5pdHlTdHJhdGVneVxuICogQHN1bW1hcnkgU3RyYXRlZ3kgdG8gcGxhY2Ugdmlld3MgdGhhdCBzaGFyZSBhIGRvbWFpbiBpbnRvIGRpZmZlcmVudCBwcm9jZXNzIGFmZmluaXRpZXMgb3IgdGhlIHNhbWUgcHJvY2VzcyBhZmZpbml0eS5cbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHNhbWUgdmlld3MgaW4gdGhlIHNhbWUgZG9tYWluIHdpbGwgaGF2ZSB0aGUgc2FtZSBwcm9jZXNzIGFmZmluaXR5LlxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gZGlmZmVyZW50IHZpZXdzIGluIHRoZSBzYW1lIGRvbWFpbiB3aWxsIGhhdmUgZGlmZmVyZW50IHByb2Nlc3MgYWZmaW5pdGllcy5cbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFBsYXRmb3JtT3B0aW9uc1xuICogQHN1bW1hcnkgVGhlIG9wdGlvbnMgb2JqZWN0IHJlcXVpcmVkIGJ5IHtAbGluayBQbGF0Zm9ybSNzdGFydCBQbGF0Zm9ybS5zdGFydH1cbiAqIEFueSB7QGxpbmsgQXBwbGljYXRpb25PcHRpb24gQXBwbGljYXRpb24gb3B0aW9ufSBpcyBhbHNvIGEgdmFsaWQgcGxhdGZvcm0gb3B0aW9uXG4gKiBAcHJvcGVydHkge0FycmF5LjxPYmplY3Q+fSBbY29tbWFuZHNdIENvbmZpZ3VyYXRpb24gZm9yIGtleWJvYXJkIGNvbW1hbmRzLlxuICogRm9yIGRldGFpbHMgYW5kIHVzYWdlLCBzZWUgW1VzaW5nIEtleWJvYXJkIENvbW1hbmRzXXtAbGluayBodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL3BsYXRmb3JtLWFwaSNzZWN0aW9uLTUtMy11c2luZy1rZXlib2FyZC1jb21tYW5kc30uXG4gKiBAcHJvcGVydHkge0RlZmF1bHRXaW5kb3dPcHRpb25zfSBbZGVmYXVsdFdpbmRvd09wdGlvbnNdIERlZmF1bHQgd2luZG93IG9wdGlvbnMgYXBwbHkgdG8gYWxsIHBsYXRmb3JtIHdpbmRvd3MuXG4gKiBAcHJvcGVydHkge1ZpZXd+b3B0aW9uc30gW2RlZmF1bHRWaWV3T3B0aW9uc10gRGVmYXVsdCB2aWV3IG9wdGlvbnMgYXBwbHkgdG8gYWxsIHBsYXRmb3JtIHZpZXdzLlxuICogQHByb3BlcnR5IHtQcm9jZXNzQWZmaW5pdHlTdHJhdGVneX0gW3ZpZXdQcm9jZXNzQWZmaW5pdHlTdHJhdGVneV0gJ3NhbWUnIHwgJ2RpZmZlcmVudCcuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBEZWZhdWx0V2luZG93T3B0aW9uc1xuICogQHN1bW1hcnkgRGVmYXVsdCB3aW5kb3cgb3B0aW9ucyBhcHBseSB0byBhbGwgcGxhdGZvcm0gd2luZG93cy5cbiAqIEFueSB7QGxpbmsgV2luZG93fm9wdGlvbnMgV2luZG93IG9wdGlvbn0gaXMgYWxzbyBhIHZhbGlkIERlZmF1bHQgV2luZG93IG9wdGlvblxuICogdXNlZCBieSBkZWZhdWx0IGluIGFueSB3aW5kb3cgdGhhdCBpcyBjcmVhdGVkIGluIHRoZSBjdXJyZW50IHBsYXRmb3JtJ3Mgc2NvcGUuXG4gKiBJbmRpdmlkdWFsIHdpbmRvdyBvcHRpb25zIHdpbGwgb3ZlcnJpZGUgdGhlc2UgZGVmYXVsdHMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3N0eWxlc2hlZXRVcmxdXG4gKiBTcGVjaWZ5IGEgcGF0aCBvZiBhIGN1c3RvbSBDU1MgZmlsZSB0byBiZSBpbmplY3RlZCB0byBhbGwgb2YgdGhlIHBsYXRmb3JtJ3Mgd2luZG93cy5cbiAqIF9ub3RlXzogdGhpcyBvcHRpb24gaXMgb25seSBhcHBsaWVkIHRvIHdpbmRvd3MgdGhhdCB1c2UgdGhlIERlZmF1bHQgT3BlbkZpbiBXaW5kb3cuXG4gKiBXaW5kb3dzIHdpdGggYSBzcGVjaWZpZWQgdXJsIChDdXN0b20gV2luZG93cykgd2lsbCBub3QgYmUgYWZmZWN0ZWQgYnkgdGhpcyBvcHRpb24uXG4gKi9cbi8qKlxuICogU25hcHNob3QgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFNuYXBzaG90XG4gKiBAcHJvcGVydHkgeyBXaW5kb3dPcHRpb25bXSB9IHdpbmRvd3MgVGhlIGFycmF5IG9mIHdpbmRvdyBvcHRpb25zIG9iamVjdHNcbiAqL1xuLyoqXG4gKiBAbGVuZHMgUGxhdGZvcm1cbiAqL1xuY2xhc3MgUGxhdGZvcm1Nb2R1bGUgZXh0ZW5kcyBiYXNlXzEuQmFzZSB7XG4gICAgY29uc3RydWN0b3Iod2lyZSwgY2hhbm5lbCkge1xuICAgICAgICBzdXBlcih3aXJlKTtcbiAgICAgICAgdGhpcy5fY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVyID0gKC4uLmFyZ3MpID0+IHRoaXMud2lyZS5lbnZpcm9ubWVudFxuICAgICAgICAgICAgLmdldFByb3ZpZGVySW5pdGlhbGl6ZXIoKVxuICAgICAgICAgICAgLnRoZW4oKGluaXRDb25zdHJ1Y3RvcikgPT4gaW5pdENvbnN0cnVjdG9yKHRoaXMud2lyZS5lbnZpcm9ubWVudCkoLi4uYXJncykpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgKiBAZGVzYyBMYXlvdXRzIGdpdmUgYXBwIHByb3ZpZGVycyB0aGUgYWJpbGl0eSB0byBlbWJlZCBtdWx0aXBsZSB2aWV3cyBpbiBhIHNpbmdsZSB3aW5kb3cuICBUaGUgTGF5b3V0IG5hbWVzcGFjZVxuICAgICAgICAgKiBlbmFibGVzIHRoZSBpbml0aWFsaXphdGlvbiBhbmQgbWFuaXB1bGF0aW9uIG9mIGEgd2luZG93J3MgTGF5b3V0LiAgQSBMYXlvdXQgd2lsbFxuICAgICAgICAgKiA8YSBocmVmPVwidHV0b3JpYWwtTGF5b3V0LkRPTUV2ZW50cy5odG1sXCI+ZW1pdCBldmVudHMgbG9jYWxseTwvYT4gb24gdGhlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgbGF5b3V0LWNvbnRhaW5lci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuTGF5b3V0ID0gbmV3IGluZGV4XzEuTGF5b3V0TW9kdWxlKHRoaXMud2lyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgUGxhdGZvcm0uIE11c3QgYmUgY2FsbGVkIGZyb20gdGhlIFByb3ZpZGVyIHdoZW4gdXNpbmcgYSBjdXN0b20gcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIHsgSW5pdFBsYXRmb3JtT3B0aW9ucyB9IFtvcHRpb25zXSAtIHBsYXRmb3JtIG9wdGlvbnMgaW5jbHVkaW5nIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBleHRlbmQgb3IgcmVwbGFjZVxuICAgICAqIGRlZmF1bHQgUHJvdmlkZXIgYmVoYXZpb3IuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFBsYXRmb3JtLmluaXRcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGFzeW5jIGluaXQob3B0aW9ucykge1xuICAgICAgICBjb25zdCBvdmVycmlkZUNhbGxiYWNrID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm92ZXJyaWRlQ2FsbGJhY2s7XG4gICAgICAgIGNvbnN0IGludGVyb3BCcm9rZXIgPSBhd2FpdCB0aGlzLmZpbi5JbnRlcm9wLmluaXQodGhpcy5maW4ubWUudXVpZCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmludGVyb3BPdmVycmlkZSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAvLyBAdHMtaWdub3JlIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICB3aW5kb3cuaW50ZXJvcEJyb2tlciA9IGludGVyb3BCcm9rZXI7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0aWFsaXplcihvdmVycmlkZUNhbGxiYWNrLCBpbnRlcm9wQnJva2VyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFBsYXRmb3JtIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYW4gZXhpc3RpbmcgcGxhdGZvcm0uXG4gICAgICogQHBhcmFtIHsgSWRlbnRpdHkgfSBpZGVudGl0eVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPFBsYXRmb3JtPn1cbiAgICAgKiBAdHV0b3JpYWwgUGxhdGZvcm0ud3JhcFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBhc3luYyB3cmFwKGlkZW50aXR5KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdwbGF0Zm9ybS13cmFwJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW5jZV8xLlBsYXRmb3JtKHsgdXVpZDogaWRlbnRpdHkudXVpZCB9LCB0aGlzLl9jaGFubmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGEgUGxhdGZvcm0gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBleGlzdGluZyBwbGF0Zm9ybS5cbiAgICAgKiBAcGFyYW0geyBJZGVudGl0eSB9IGlkZW50aXR5XG4gICAgICogQHJldHVybiB7UGxhdGZvcm19XG4gICAgICogQHR1dG9yaWFsIFBsYXRmb3JtLndyYXBTeW5jXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHdyYXBTeW5jKGlkZW50aXR5KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdwbGF0Zm9ybS13cmFwLXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbmNlXzEuUGxhdGZvcm0oeyB1dWlkOiBpZGVudGl0eS51dWlkIH0sIHRoaXMuX2NoYW5uZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSByZXR1cm5zIGEgUGxhdGZvcm0gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBwbGF0Zm9ybS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxQbGF0Zm9ybT59XG4gICAgICogQHR1dG9yaWFsIFBsYXRmb3JtLmdldEN1cnJlbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3VycmVudCgpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLWdldC1jdXJyZW50JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh7IHV1aWQ6IHRoaXMud2lyZS5tZS51dWlkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IHJldHVybnMgYSBQbGF0Zm9ybSBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAqIEByZXR1cm4ge1BsYXRmb3JtfVxuICAgICAqIEB0dXRvcmlhbCBQbGF0Zm9ybS5nZXRDdXJyZW50U3luY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50U3luYygpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLWdldC1jdXJyZW50LXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwU3luYyh7IHV1aWQ6IHRoaXMud2lyZS5tZS51dWlkIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBzdGFydHMgYSBQbGF0Zm9ybSBhbmQgcmV0dXJucyBhIHdyYXBwZWQgYW5kIHJ1bm5pbmcgUGxhdGZvcm0gaW5zdGFuY2UuIFRoZSB3cmFwcGVkIFBsYXRmb3JtIG1ldGhvZHMgY2FuXG4gICAgICogYmUgdXNlZCB0byBsYXVuY2ggY29udGVudCBpbnRvIHRoZSBwbGF0Zm9ybS4gIFByb21pc2Ugd2lsbCByZWplY3QgaWYgdGhlIHBsYXRmb3JtIGlzIGFscmVhZHkgcnVubmluZy5cbiAgICAgKiBAcGFyYW0geyBQbGF0Zm9ybU9wdGlvbnMgfSBwbGF0Zm9ybU9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxQbGF0Zm9ybT59XG4gICAgICogQHR1dG9yaWFsIFBsYXRmb3JtLnN0YXJ0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXJ0KHBsYXRmb3JtT3B0aW9ucykge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tc3RhcnQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHV1aWQgfSA9IHBsYXRmb3JtT3B0aW9ucztcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHVzaW5nIHByaXZhdGUgdmFyaWFibGUuXG4gICAgICAgICAgICAgICAgY29uc3QgYXBwID0gYXdhaXQgdGhpcy5maW4uQXBwbGljYXRpb24uX2NyZWF0ZSh7IC4uLnBsYXRmb3JtT3B0aW9ucywgaXNQbGF0Zm9ybUNvbnRyb2xsZXI6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgYXBwLm9uY2UoJ3BsYXRmb3JtLWFwaS1yZWFkeScsICgpID0+IHJlc29sdmUodGhpcy53cmFwU3luYyh7IHV1aWQgfSkpKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHVzaW5nIHByaXZhdGUgdmFyaWFibGUuXG4gICAgICAgICAgICAgICAgYXBwLl9ydW4oeyB1dWlkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgcGxhdGZvcm1zJ3MgbWFuaWZlc3QgYW5kIHJldHVybnMgYSB3cmFwcGVkIGFuZCBydW5uaW5nIFBsYXRmb3JtLiAgSWYgdGhlcmUgaXMgYSBzbmFwc2hvdCBpbiB0aGUgbWFuaWZlc3QsXG4gICAgICogaXQgd2lsbCBiZSBsYXVuY2hlZCBpbnRvIHRoZSBwbGF0Zm9ybS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFuaWZlc3RVcmwgLSBUaGUgVVJMIG9mIHBsYXRmb3JtJ3MgbWFuaWZlc3QuXG4gICAgICogQHBhcmFtIHtSdm1MYXVuY2hPcHRpb25zfSBbb3B0c10gLSBQYXJhbWV0ZXJzIHRoYXQgdGhlIFJWTSB3aWxsIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxQbGF0Zm9ybT59XG4gICAgICogQHR1dG9yaWFsIFBsYXRmb3JtLnN0YXJ0RnJvbU1hbmlmZXN0XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXJ0RnJvbU1hbmlmZXN0KG1hbmlmZXN0VXJsLCBvcHRzKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdwbGF0Zm9ybS1zdGFydC1mcm9tLW1hbmlmZXN0JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWFzeW5jLXByb21pc2UtZXhlY3V0b3JcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB1c2luZyBwcml2YXRlIHZhcmlhYmxlLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFwcCA9IGF3YWl0IHRoaXMuZmluLkFwcGxpY2F0aW9uLl9jcmVhdGVGcm9tTWFuaWZlc3QobWFuaWZlc3RVcmwpO1xuICAgICAgICAgICAgICAgIGFwcC5vbmNlKCdwbGF0Zm9ybS1hcGktcmVhZHknLCAoKSA9PiByZXNvbHZlKHRoaXMud3JhcFN5bmMoeyB1dWlkOiBhcHAuaWRlbnRpdHkudXVpZCB9KSkpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdXNpbmcgcHJpdmF0ZSBtZXRob2Qgd2l0aG91dCB3YXJuaW5nLlxuICAgICAgICAgICAgICAgIGFwcC5fcnVuKG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBsYXRmb3JtTW9kdWxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG4gICAgfVxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9jb25uZWN0VG9Qcm92aWRlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGxhdGZvcm0gPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC92YWxpZGF0ZVwiKTtcbmNvbnN0IFBsYXRmb3JtXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcGVzL1BsYXRmb3JtXCIpO1xuLy8gUmV1c2UgY2xpZW50cyB0byBhdm9pZCBvdmVyd3JpdGluZyBhbHJlYWR5LXJlZ2lzdGVyZWQgY2xpZW50IGluIHByb3ZpZGVyXG5jb25zdCBjbGllbnRNYXAgPSBuZXcgTWFwKCk7XG4vKiogTWFuYWdlcyB0aGUgbGlmZSBjeWNsZSBvZiB3aW5kb3dzIGFuZCB2aWV3cyBpbiB0aGUgYXBwbGljYXRpb24uXG4gKlxuICogRW5hYmxlcyB0YWtpbmcgc25hcHNob3RzIG9mIGl0c2VsZiBhbmQgYXBwbHlpbmcgdGhlbSB0byByZXN0b3JlIGEgcHJldmlvdXMgY29uZmlndXJhdGlvblxuICogYXMgd2VsbCBhcyBsaXN0ZW4gdG8gPGEgaHJlZj1cInR1dG9yaWFsLVBsYXRmb3JtLkV2ZW50RW1pdHRlci5odG1sXCI+cGxhdGZvcm0gZXZlbnRzPC9hPi5cbiAqIEBuYW1lc3BhY2VcbiAqL1xuY2xhc3MgUGxhdGZvcm0gZXh0ZW5kcyBiYXNlXzEuRW1pdHRlckJhc2Uge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgICBjb25zdHJ1Y3RvcihpZGVudGl0eSwgY2hhbm5lbCkge1xuICAgICAgICAvLyB3ZSBwaWdneWJhY2sgb2ZmIG9mIGFwcGxpY2F0aW9uIGV2ZW50IGVtaXR0ZXIgYmVjYXVzZSBmcm9tIHRoZSBjb3JlJ3MgcGVyc3BlY3RpdmUgcGxhdGZvcm0gaXMganVzdCBhbiBhcHAuXG4gICAgICAgIHN1cGVyKGNoYW5uZWwud2lyZSwgWydhcHBsaWNhdGlvbicsIGlkZW50aXR5LnV1aWRdKTtcbiAgICAgICAgdGhpcy5nZXRDbGllbnQgPSAoaWRlbnRpdHkpID0+IHtcbiAgICAgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdwbGF0Zm9ybS1nZXQtY2xpZW50JywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gaWRlbnRpdHkgfHwgdGhpcy5pZGVudGl0eTtcbiAgICAgICAgICAgIGNvbnN0IHsgdXVpZCB9ID0gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCFjbGllbnRNYXAuaGFzKHV1aWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50UHJvbWlzZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2Nvbm5lY3RUb1Byb3ZpZGVyKS5jYWxsKHRoaXMsIHV1aWQpO1xuICAgICAgICAgICAgICAgIGNsaWVudE1hcC5zZXQodXVpZCwgY2xpZW50UHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBzZXQgaXQgYWJvdmVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50TWFwLmdldCh1dWlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgX2Nvbm5lY3RUb1Byb3ZpZGVyLnNldCh0aGlzLCBhc3luYyAodXVpZCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsTmFtZSA9IGBjdXN0b20tZnJhbWUtJHt1dWlkfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5fY2hhbm5lbC5jb25uZWN0KGNoYW5uZWxOYW1lLCB7IHdhaXQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIGNsaWVudC5vbkRpc2Nvbm5lY3Rpb24oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRNYXAuZGVsZXRlKHV1aWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNsaWVudE1hcC5kZWxldGUodXVpZCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdGFyZ2V0ZWQgUGxhdGZvcm0gaXMgbm90IGN1cnJlbnRseSBydW5uaW5nLiBMaXN0ZW4gZm9yIGFwcGxpY2F0aW9uLXN0YXJ0ZWQgZXZlbnQgZm9yIHRoZSBnaXZlbiBVdWlkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRGVwcmVjYXRlZCAocmVuYW1lZClcbiAgICAgICAgdGhpcy5sYXVuY2hMZWdhY3lNYW5pZmVzdCA9IHRoaXMubGF1bmNoQ29udGVudE1hbmlmZXN0O1xuICAgICAgICBjb25zdCBlcnJvck1zZyA9IHZhbGlkYXRlXzEudmFsaWRhdGVJZGVudGl0eShpZGVudGl0eSk7XG4gICAgICAgIGlmIChlcnJvck1zZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5pZGVudGl0eSA9IHsgdXVpZDogaWRlbnRpdHkudXVpZCB9O1xuICAgICAgICB0aGlzLnRvcGljID0gJ2FwcGxpY2F0aW9uJztcbiAgICAgICAgdGhpcy5MYXlvdXQgPSB0aGlzLmZpbi5QbGF0Zm9ybS5MYXlvdXQ7XG4gICAgICAgIHRoaXMuQXBwbGljYXRpb24gPSB0aGlzLmZpbi5BcHBsaWNhdGlvbi53cmFwU3luYyh0aGlzLmlkZW50aXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2aWV3IGFuZCBhdHRhY2hlcyBpdCB0byBhIHNwZWNpZmllZCB0YXJnZXQgd2luZG93LlxuICAgICAqIEBwYXJhbSB7IFZpZXd+b3B0aW9ucyB9IHZpZXdPcHRpb25zIFZpZXcgY3JlYXRpb24gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7IElkZW50aXR5IH0gW3RhcmdldF0gVGhlIHdpbmRvdyB0byB3aGljaCB0aGUgbmV3IHZpZXcgaXMgdG8gYmUgYXR0YWNoZWQuIElmIG5vIHRhcmdldCwgY3JlYXRlIGEgdmlldyBpbiBhIG5ldyB3aW5kb3cuXG4gICAgICogQHBhcmFtIHsgSWRlbnRpdHkgfSBbdGFyZ2V0Vmlld10gSWYgcHJvdmlkZWQsIHRoZSBuZXcgdmlldyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzYW1lIHRhYnN0cmlwIGFzIHRhcmdldFZpZXcuXG4gICAgICogQHJldHVybiB7IFByb21pc2U8Vmlldz4gfVxuICAgICAqIEB0dXRvcmlhbCBQbGF0Zm9ybS5jcmVhdGVWaWV3XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVmlldyh2aWV3T3B0aW9ucywgdGFyZ2V0LCB0YXJnZXRWaWV3KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdwbGF0Zm9ybS1jcmVhdGUtdmlldycsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LmRpc3BhdGNoKCdjcmVhdGUtdmlldycsIHtcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIG9wdHM6IHZpZXdPcHRpb25zLFxuICAgICAgICAgICAgdGFyZ2V0Vmlld1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSB8fCB2YWxpZGF0ZV8xLnZhbGlkYXRlSWRlbnRpdHkocmVzcG9uc2UuaWRlbnRpdHkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdoZW4gb3ZlcndyaXRpbmcgdGhlIGNyZWF0ZVZpZXcgY2FsbCwgcGxlYXNlIHJldHVybiBhbiBvYmplY3QgdGhhdCBoYXMgYSB2YWxpZCAnaWRlbnRpdHknIHByb3BlcnR5OiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW4uVmlldy53cmFwU3luYyhyZXNwb25zZS5pZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgV2luZG93LlxuICAgICAqIEBwYXJhbSB7IFdpbmRvd35vcHRpb25zIH0gb3B0aW9ucyBXaW5kb3cgY3JlYXRpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm4geyBQcm9taXNlPF9XaW5kb3c+IH1cbiAgICAgKiBAdHV0b3JpYWwgUGxhdGZvcm0uY3JlYXRlV2luZG93XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlV2luZG93KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLWNyZWF0ZS13aW5kb3cnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBpZiAoIW9wdGlvbnMucmVhc29uKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlYXNvbiA9IFBsYXRmb3JtXzEuV2luZG93Q3JlYXRpb25SZWFzb24uQVBJQ2FsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5kaXNwYXRjaCgnY3JlYXRlLXZpZXctY29udGFpbmVyJywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghcmVzcG9uc2UgfHwgdmFsaWRhdGVfMS52YWxpZGF0ZUlkZW50aXR5KHJlc3BvbnNlLmlkZW50aXR5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaGVuIG92ZXJ3cml0aW5nIHRoZSBjcmVhdGVXaW5kb3cgY2FsbCwgcGxlYXNlIHJldHVybiBhbiBvYmplY3QgdGhhdCBoYXMgYSB2YWxpZCAnaWRlbnRpdHknIHByb3BlcnR5OiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlkZW50aXR5IH0gPSByZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5maW4uV2luZG93LndyYXBTeW5jKGlkZW50aXR5KTtcbiAgICAgICAgLy8gd2UgYWRkIHRoZSBpZGVudGl0eSBhdCB0aGUgdG9wIGxldmVsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgcmVzLm5hbWUgPSBpZGVudGl0eS5uYW1lO1xuICAgICAgICByZXMudXVpZCA9IGlkZW50aXR5LnV1aWQ7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBjdXJyZW50IHBsYXRmb3JtLCBhbGwgaXRzIHdpbmRvd3MsIGFuZCB0aGVpciB2aWV3cy5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTx2b2lkPiB9XG4gICAgICogQHR1dG9yaWFsIFBsYXRmb3JtLnF1aXRcbiAgICAgKi9cbiAgICBhc3luYyBxdWl0KCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tcXVpdCcsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIHJldHVybiBjbGllbnQuZGlzcGF0Y2goJ3F1aXQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGEgc3BlY2lmaWVkIHZpZXcgaW4gYSB0YXJnZXQgd2luZG93LlxuICAgICAqIEBwYXJhbSB7IElkZW50aXR5IH0gdmlld0lkZW50aXR5IFZpZXcgaWRlbnRpdHlcbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTx2b2lkPiB9XG4gICAgICogQHR1dG9yaWFsIFBsYXRmb3JtLmNsb3NlVmlld1xuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlVmlldyh2aWV3SWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLWNsb3NlLXZpZXcnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBhd2FpdCBjbGllbnQuZGlzcGF0Y2goJ2Nsb3NlLXZpZXcnLCB7XG4gICAgICAgICAgICB2aWV3OiB2aWV3SWRlbnRpdHlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICoqKkRFUFJFQ0FURUQgLSBwbGVhc2UgdXNlIFBsYXRmb3JtLmNyZWF0ZVZpZXcuKioqXG4gICAgICogUmVwYXJlbnRzIGEgc3BlY2lmaWVkIHZpZXcgaW4gYSBuZXcgdGFyZ2V0IHdpbmRvdy5cbiAgICAgKiBAcGFyYW0geyBJZGVudGl0eSB9IHZpZXdJZGVudGl0eSBWaWV3IGlkZW50aXR5XG4gICAgICogQHBhcmFtIHsgSWRlbnRpdHkgfSB0YXJnZXQgbmV3IG93bmVyIHdpbmRvdyBpZGVudGl0eVxuICAgICAqIEByZXR1cm4geyBQcm9taXNlPFZpZXc+IH1cbiAgICAgKiBAdHV0b3JpYWwgUGxhdGZvcm0uY3JlYXRlVmlld1xuICAgICAqL1xuICAgIGFzeW5jIHJlcGFyZW50Vmlldyh2aWV3SWRlbnRpdHksIHRhcmdldCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybignUGxhdGZvcm0ucmVwYXJlbnRWaWV3IGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgUGxhdGZvcm0uY3JlYXRlVmlldycpO1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tcmVwYXJlbnQtdmlldycsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRWaWV3SWRlbnRpdHkgPSB7XG4gICAgICAgICAgICAuLi52aWV3SWRlbnRpdHksXG4gICAgICAgICAgICB1dWlkOiAoX2EgPSB2aWV3SWRlbnRpdHkudXVpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5pZGVudGl0eS51dWlkXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZpZXcgPSBhd2FpdCB0aGlzLmZpbi5WaWV3LndyYXAobm9ybWFsaXplZFZpZXdJZGVudGl0eSk7XG4gICAgICAgIGNvbnN0IHZpZXdPcHRpb25zID0gYXdhaXQgdmlldy5nZXRPcHRpb25zKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVZpZXcodmlld09wdGlvbnMsIHRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzbmFwc2hvdCBvZiB0aGUgcGxhdGZvcm0gaW4gaXRzIGN1cnJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBDYW4gYmUgdXNlZCB0byByZXN0b3JlIGFuIGFwcGxpY2F0aW9uIHRvIGEgcHJldmlvdXMgc3RhdGUuXG4gICAgICogQHJldHVybiB7IFByb21pc2U8U25hcHNob3Q+IH1cbiAgICAgKiBAdHV0b3JpYWwgUGxhdGZvcm0uZ2V0U25hcHNob3RcbiAgICAgKi9cbiAgICBhc3luYyBnZXRTbmFwc2hvdCgpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLWdldC1zbmFwc2hvdCcsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIHJldHVybiBjbGllbnQuZGlzcGF0Y2goJ2dldC1zbmFwc2hvdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc25hcHNob3QgdG8gYSBydW5uaW5nIFBsYXRmb3JtLlxuICAgICAqIFJlcXVlc3RlZCBzbmFwc2hvdCBtdXN0IGJlIGEgdmFsaWQgU25hcHNob3Qgb2JqZWN0LCBvciBhIHVybCBvciBmaWxlcGF0aCB0byBzdWNoIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIENhbiBvcHRpb25hbGx5IGNsb3NlIGV4aXN0aW5nIHdpbmRvd3MgYW5kIG92ZXJ3cml0ZSBjdXJyZW50IHBsYXRmb3JtIHN0YXRlIHdpdGggdGhhdCBvZiBhIHNuYXBzaG90LlxuICAgICAqXG4gICAgICogVGhlIGZ1bmN0aW9uIGFjY2VwdHMgZWl0aGVyIGEgc25hcHNob3QgdGFrZW4gdXNpbmcge0BsaW5rIFBsYXRmb3JtI2dldFNuYXBzaG90IGdldFNuYXBzaG90fSxcbiAgICAgKiBvciBhIHVybCBvciBmaWxlcGF0aCB0byBhIHNuYXBzaG90IEpTT04gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7IFNuYXBzaG90IHwgc3RyaW5nIH0gcmVxdWVzdGVkU25hcHNob3QgU25hcHNob3QgdG8gYXBwbHksIG9yIGEgdXJsIG9yIGZpbGVwYXRoLlxuICAgICAqIEBwYXJhbSB7IEFwcGx5U25hcHNob3RPcHRpb25zIH0gW29wdGlvbnNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gc3BlY2lmeSB3aGV0aGVyIGV4aXN0aW5nIHdpbmRvd3Mgc2hvdWxkIGJlIGNsb3NlZC5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTxQbGF0Zm9ybT4gfVxuICAgICAqIEB0dXRvcmlhbCBQbGF0Zm9ybS5hcHBseVNuYXBzaG90XG4gICAgICovXG4gICAgYXN5bmMgYXBwbHlTbmFwc2hvdChyZXF1ZXN0ZWRTbmFwc2hvdCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tYXBwbHktc25hcHNob3QnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlcnJNc2cgPSAnUmVxdWVzdGVkIHNuYXBzaG90IG11c3QgYmUgYSB2YWxpZCBTbmFwc2hvdCBvYmplY3QsIG9yIGEgdXJsIG9yIGZpbGVwYXRoIHRvIHN1Y2ggYW4gb2JqZWN0Lic7XG4gICAgICAgIGxldCBzbmFwc2hvdDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0ZWRTbmFwc2hvdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIEZldGNoIGFuZCBwYXJzZSBzbmFwc2hvdFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2NoYW5uZWwud2lyZS5zZW5kQWN0aW9uKCdnZXQtYXBwbGljYXRpb24tbWFuaWZlc3QnLCB7XG4gICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0VXJsOiByZXF1ZXN0ZWRTbmFwc2hvdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNuYXBzaG90ID0gcmVzcG9uc2UucGF5bG9hZC5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlcnJNc2d9OiAke2Vycn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNuYXBzaG90ID0gcmVxdWVzdGVkU25hcHNob3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzbmFwc2hvdC53aW5kb3dzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBhd2FpdCBjbGllbnQuZGlzcGF0Y2goJ2FwcGx5LXNuYXBzaG90Jywge1xuICAgICAgICAgICAgc25hcHNob3QsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIEpTT04gbWFuaWZlc3QgdXNpbmcgdGhlIGJyb3dzZXIgcHJvY2VzcyBhbmQgcmV0dXJucyBhIEphdmFzY3JpcHQgb2JqZWN0LlxuICAgICAqIENhbiBiZSBvdmVyd3JpdHRlbiB1c2luZyB7QGxpbmsgUGxhdGZvcm0jaW5pdCBQbGF0Zm9ybS5pbml0fS5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSBtYW5pZmVzdFVybCBUaGUgVVJMIG9mIHRoZSBtYW5pZmVzdCB0byBmZXRjaC5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTxhbnk+IH1cbiAgICAgKiBAdHV0b3JpYWwgUGxhdGZvcm0uZmV0Y2hNYW5pZmVzdFxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoTWFuaWZlc3QobWFuaWZlc3RVcmwpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaCgncGxhdGZvcm0tZmV0Y2gtbWFuaWZlc3QnLCB7IG1hbmlmZXN0VXJsIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBtYW5pZmVzdCBieSB1cmwgYW5kIGxhdW5jaGVzIGEgbGVnYWN5IGFwcGxpY2F0aW9uIG1hbmlmZXN0IG9yIHNuYXBzaG90IGludG8gdGhlIHBsYXRmb3JtLiAgUmV0dXJucyBhIHByb21pc2UgdGhhdFxuICAgICAqIHJlc29sdmVzIHRvIHRoZSB3cmFwcGVkIFBsYXRmb3JtLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYW5pZmVzdFVybCAtIFRoZSBVUkwgb2YgdGhlIG1hbmlmZXN0IHRoYXQgd2lsbCBiZSBsYXVuY2hlZCBpbnRvIHRoZSBwbGF0Zm9ybS4gIElmIHRoaXMgYXBwIG1hbmlmZXN0XG4gICAgICogY29udGFpbnMgYSBzbmFwc2hvdCwgdGhhdCB3aWxsIGJlIGxhdW5jaGVkIGludG8gdGhlIHBsYXRmb3JtLiAgSWYgbm90LCB0aGUgYXBwbGljYXRpb24gZGVzY3JpYmVkIGluIHN0YXJ0dXBfYXBwIG9wdGlvbnNcbiAgICAgKiB3aWxsIGJlIGxhdW5jaGVkIGludG8gdGhlIHBsYXRmb3JtLiBUaGUgYXBwbGljYWJsZSBzdGFydHVwX2FwcCBvcHRpb25zIHdpbGwgYmVjb21lIHtAbGluayBWaWV3fm9wdGlvbnMgVmlldyBPcHRpb25zfS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFBsYXRmb3JtPn1cbiAgICAgKiBAdHV0b3JpYWwgUGxhdGZvcm0ubGF1bmNoQ29udGVudE1hbmlmZXN0XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIGxhdW5jaENvbnRlbnRNYW5pZmVzdChtYW5pZmVzdFVybCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigncGxhdGZvcm0tbGF1bmNoLWNvbnRlbnQtbWFuaWZlc3QnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IHRoaXMuZmV0Y2hNYW5pZmVzdChtYW5pZmVzdFVybCk7XG4gICAgICAgIGNsaWVudC5kaXNwYXRjaCgnbGF1bmNoLWludG8tcGxhdGZvcm0nLCB7IG1hbmlmZXN0IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb250ZXh0IG9mIGEgaG9zdCB3aW5kb3cuIFRoZSBjb250ZXh0IHdpbGwgYmUgYXZhaWxhYmxlIHRvIHRoZSB3aW5kb3cgaXRzZWxmLCBhbmQgdG8gaXRzIGNoaWxkIFZpZXdzLiBJdCB3aWxsIGJlIHNhdmVkIGluIGFueSBwbGF0Zm9ybSBzbmFwc2hvdHMuXG4gICAgICogSXQgY2FuIGJlIHJldHJpZXZlZCB1c2luZyB7QGxpbmsgUGxhdGZvcm0jZ2V0V2luZG93Q29udGV4dCBnZXRXaW5kb3dDb250ZXh0fS5cbiAgICAgKiBAcGFyYW0ge2FueX0gY29udGV4dCAtIEEgZmllbGQgd2hlcmUgc2VyaWFsaXphYmxlIGNvbnRleHQgZGF0YSBjYW4gYmUgc3RvcmVkIHRvIGJlIHNhdmVkIGluIHBsYXRmb3JtIHNuYXBzaG90cy5cbiAgICAgKiBAcGFyYW0ge0lkZW50aXR5fSBbdGFyZ2V0XSAtIEEgdGFyZ2V0IHdpbmRvdyBvciB2aWV3IG1heSBvcHRpb25hbGx5IGJlIHByb3ZpZGVkLiBJZiBubyB0YXJnZXQgaXMgcHJvdmlkZWQsIHRoZSB1cGRhdGUgd2lsbCBiZSBhcHBsaWVkXG4gICAgICogdG8gdGhlIGN1cnJlbnQgd2luZG93IChpZiBjYWxsZWQgZnJvbSBhIFdpbmRvdykgb3IgdGhlIGN1cnJlbnQgaG9zdCB3aW5kb3cgKGlmIGNhbGxlZCBmcm9tIGEgVmlldykuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgUGxhdGZvcm0uc2V0V2luZG93Q29udGV4dFxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyBzZXRXaW5kb3dDb250ZXh0KGNvbnRleHQgPSB7fSwgdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdwbGF0Zm9ybS1zZXQtd2luZG93LWNvbnRleHQnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgYSBzZXJpYWxpemFibGUgb2JqZWN0IG9yIHN0cmluZyB0byBzZXQgdGhlIGNvbnRleHQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgY29uc3QgeyBlbnRpdHlUeXBlIH0gPSB0YXJnZXQgPyBhd2FpdCB0aGlzLmZpbi5TeXN0ZW0uZ2V0RW50aXR5SW5mbyh0YXJnZXQudXVpZCwgdGFyZ2V0Lm5hbWUpIDogdGhpcy5maW4ubWU7XG4gICAgICAgIGF3YWl0IGNsaWVudC5kaXNwYXRjaCgnc2V0LXdpbmRvdy1jb250ZXh0Jywge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGVudGl0eVR5cGUsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCB8fCB7IHV1aWQ6IHRoaXMuZmluLm1lLnV1aWQsIG5hbWU6IHRoaXMuZmluLm1lLm5hbWUgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb250ZXh0IGNvbnRleHQgb2YgYSBob3N0IHdpbmRvdyB0aGF0IHdhcyBwcmV2aW91c2x5IHNldCB1c2luZyB7QGxpbmsgUGxhdGZvcm0jc2V0V2luZG93Q29udGV4dCBzZXRXaW5kb3dDb250ZXh0fS5cbiAgICAgKiBUaGUgY29udGV4dCB3aWxsIGJlIHNhdmVkIGluIGFueSBwbGF0Zm9ybSBzbmFwc2hvdHMuICBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7SWRlbnRpdHl9IFt0YXJnZXRdIC0gQSB0YXJnZXQgd2luZG93IG9yIHZpZXcgbWF5IG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQuIElmIG5vIHRhcmdldCBpcyBwcm92aWRlZCwgdGFyZ2V0IHdpbGwgYmVcbiAgICAgKiB0aGUgY3VycmVudCB3aW5kb3cgKGlmIGNhbGxlZCBmcm9tIGEgV2luZG93KSBvciB0aGUgY3VycmVudCBob3N0IHdpbmRvdyAoaWYgY2FsbGVkIGZyb20gYSBWaWV3KS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gICAgICogQHR1dG9yaWFsIFBsYXRmb3JtLmdldFdpbmRvd0NvbnRleHRcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgZ2V0V2luZG93Q29udGV4dCh0YXJnZXQpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3BsYXRmb3JtLWdldC13aW5kb3ctY29udGV4dCcsIHRoaXMuaWRlbnRpdHkpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIGNvbnN0IHsgZW50aXR5VHlwZSB9ID0gdGFyZ2V0ID8gYXdhaXQgdGhpcy5maW4uU3lzdGVtLmdldEVudGl0eUluZm8odGFyZ2V0LnV1aWQsIHRhcmdldC5uYW1lKSA6IHRoaXMuZmluLm1lO1xuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKCdnZXQtd2luZG93LWNvbnRleHQnLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCB8fCB7IHV1aWQ6IHRoaXMuZmluLm1lLnV1aWQsIG5hbWU6IHRoaXMuZmluLm1lLm5hbWUgfSxcbiAgICAgICAgICAgIGVudGl0eVR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5QbGF0Zm9ybSA9IFBsYXRmb3JtO1xuX2Nvbm5lY3RUb1Byb3ZpZGVyID0gbmV3IFdlYWtNYXAoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkUHJlc2V0VHlwZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzVmFsaWRQcmVzZXRUeXBlKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImNvbHVtbnNcIiAvKiBjb2x1bW5zICovOlxuICAgICAgICBjYXNlIFwiZ3JpZFwiIC8qIGdyaWQgKi86XG4gICAgICAgIGNhc2UgXCJyb3dzXCIgLyogcm93cyAqLzpcbiAgICAgICAgY2FzZSBcInRhYnNcIiAvKiB0YWJzICovOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5pc1ZhbGlkUHJlc2V0VHlwZSA9IGlzVmFsaWRQcmVzZXRUeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0geyBpc1ZhbGlkUHJlc2V0VHlwZSB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL0ZhY3RvcnlcIik7XG5leHBvcnRzLmRlZmF1bHQgPSBGYWN0b3J5XzEuZGVmYXVsdDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JbnN0YW5jZVwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xuICAgIH1cbiAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX2xheW91dE1hbmFnZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxheW91dE1vZHVsZSA9IHZvaWQgMDtcbmNvbnN0IEluc3RhbmNlXzEgPSByZXF1aXJlKFwiLi9JbnN0YW5jZVwiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlXCIpO1xuLyoqXG4gKiBJbml0TGF5b3V0T3B0aW9ucyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gSW5pdExheW91dE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IFtjb250YWluZXJJZF0gVGhlIGlkIGF0dHJpYnV0ZSBvZiB0aGUgY29udGFpbmVyIHdoZXJlIHRoZSB3aW5kb3cncyBMYXlvdXQgc2hvdWxkIGJlIGluaXRpYWxpemVkLiAgSWYgbm90IHByb3ZpZGVkXG4gKiB0aGVuIGFuIGVsZW1lbnQgd2l0aCBpZCBgbGF5b3V0LWNvbnRhaW5lcmAgaXMgdXNlZC4gV2UgcmVjb21tZW5kIHVzaW5nIGEgZGl2IGVsZW1lbnQuXG4gKi9cbi8qKlxuICogUHJlc2V0TGF5b3V0T3B0aW9ucyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gUHJlc2V0TGF5b3V0T3B0aW9uc1xuICogQHByb3BlcnR5IHsgTGF5b3V0UHJlc2V0VHlwZXMgfSBwcmVzZXRUeXBlIFdoaWNoIHByZXNldCBsYXlvdXQgYXJyYW5nZW1lbnQgdG8gdXNlLlxuICogVGhlIHByZXNldCBvcHRpb25zIGFyZSBgY29sdW1uc2AsIGBncmlkYCwgYHJvd3NgLCBhbmQgYHRhYnNgLlxuICovXG4vKipcbiAqIExheW91dENvbmZpZyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gTGF5b3V0Q29uZmlnXG4gKiBAcHJvcGVydHkgeyBBcnJheTxMYXlvdXRJdGVtPiB9IGNvbnRlbnQgQ29udGVudCBvZiB0aGUgbGF5b3V0LiAgVGhlcmUgY2FuIG9ubHkgYmUgb25lIHRvcC1sZXZlbCBMYXlvdXRJdGVtIGluIHRoZSBjb250ZW50IGFycmF5LlxuICogV2UgZG8gbm90IHJlY29tbWVuZCB0cnlpbmcgdG8gYnVpbGQgTGF5b3V0cyBvciBMYXlvdXRJdGVtcyBieSBoYW5kIGFuZCBpbnN0ZWFkIHVzZSBjYWxscyBzdWNoIGFzIHtAbGluayBQbGF0Zm9ybSNnZXRTbmFwc2hvdCBnZXRTbmFwc2hvdH1cbiAqIG9yIG91ciB7QGxpbmsgaHR0cHM6Ly9vcGVuZmluLmdpdGh1Yi5pby9nb2xkZW4tcHJvdG90eXBlL2NvbmZpZy1nZW4gTGF5b3V0IENvbmZpZyBHZW5lcmF0aW9uIFRvb2wgfS5cbiAqIEBwcm9wZXJ0eSB7IExheW91dFNldHRpbmdzIH0gc2V0dGluZ3MgQ29uZmlndXJhdGlvbiBmb3IgY2VydGFpbiBMYXlvdXQgYmVoYXZpb3JzLiBTZWUgdGhlIExheW91dFNldHRpbmdzIGludGVyZmFjZS5cbiAqL1xuLyoqXG4gKiBMYXlvdXRJdGVtIEludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBMYXlvdXRJdGVtIFJlcHJlc2VudHMgdGhlIGFycmFuZ2VtZW50IG9mIFZpZXdzIHdpdGhpbiBhIFBsYXRmb3JtIHdpbmRvdydzIExheW91dC4gIFdlIGRvIG5vdCByZWNvbW1lbmQgdHJ5aW5nXG4gKiB0byBidWlsZCBMYXlvdXRzIG9yIExheW91dEl0ZW1zIGJ5IGhhbmQgYW5kIGluc3RlYWQgdXNlIGNhbGxzIHN1Y2ggYXMge0BsaW5rIFBsYXRmb3JtI2dldFNuYXBzaG90IGdldFNuYXBzaG90fSBvciBvdXJcbiAqIHtAbGluayBodHRwczovL29wZW5maW4uZ2l0aHViLmlvL2dvbGRlbi1wcm90b3R5cGUvY29uZmlnLWdlbiBMYXlvdXQgQ29uZmlnIEdlbmVyYXRpb24gVG9vbCB9LlxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgaXRlbS4gUG9zc2libGUgdmFsdWVzIGFyZSAncm93JywgJ2NvbHVtbicsICdzdGFjaycsIGFuZCAnY29tcG9uZW50Jy5cbiAqIEBwcm9wZXJ0eSB7IEFycmF5PExheW91dEl0ZW0+IH0gW2NvbnRlbnRdIEFuIGFycmF5IG9mIGNvbmZpZ3VyYXRpb25zIGZvciBpdGVtcyB0aGF0IHdpbGwgYmUgY3JlYXRlZCBhcyBjaGlsZHJlbiBvZiB0aGlzIGl0ZW0uXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBbY29tcG9uZW50TmFtZV0gT25seSBhIGBjb21wb25lbnRgIHR5cGUgd2lsbCBoYXZlIHRoaXMgcHJvcGVydHkgYW5kIGl0IHNob3VsZCBiZSBzZXQgdG8gYHZpZXdgLlxuICogQHByb3BlcnR5IHsgVmlld35vcHRpb25zIH0gW2NvbXBvbmVudFN0YXRlXSBPbmx5IGEgYGNvbXBvbmVudGAgdHlwZSB3aWxsIGhhdmUgdGhpcyBwcm9wZXJ0eSBhbmQgaXQgcmVwcmVzZW50cyB0aGUgdmlld1xuICogb3B0aW9ucyBvZiBhIGdpdmVuIGNvbXBvbmVudC5cbiAqL1xuLyoqXG4gKiBMYXlvdXRTZXR0aW5ncyBJbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gTGF5b3V0U2V0dGluZ3MgUmVwcmVzZW50cyBhIHBvdGVudGlhbCB3YXlzIHRvIGN1c3RvbWl6ZSBiZWhhdmlvciBvZiB5b3VyIExheW91dFxuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IFtjb25zdHJhaW5EcmFnVG9IZWFkZXJzPWZhbHNlXSBMaW1pdHMgdGhlIGFyZWEgdG8gd2hpY2ggdGFicyBjYW4gYmUgZHJhZ2dlZC5cbiAqIElmIHRydWUsIHN0YWNrIGhlYWRlcnMgYXJlIHRoZSBvbmx5IGFyZWFzIHdoZXJlIHRhYnMgY2FuIGJlIGRyb3BwZWQuXG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gW2hhc0hlYWRlcnM9dHJ1ZV0gVHVybnMgdGFiIGhlYWRlcnMgb24gb3Igb2ZmLlxuICogSWYgZmFsc2UsIHRoZSBsYXlvdXQgd2lsbCBiZSBkaXNwbGF5ZWQgd2l0aCBzcGxpdHRlcnMgb25seS5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbbmV3VGFiQnV0dG9uXVxuICogQ29uZmlndXJhdGlvbiBvZiB0aGUgUGx1cyBidXR0b24gdGhhdCBhcHBlYXJzIG9uIGVhY2ggdGFic3RyaXAuIFVwb24gcHJlc3NpbmcsIGEgbmV3IHRhYlxuICogd2lsbCBiZSBhZGRlZCB0byB0aGUgdGFic3RyaXAgd2l0aCB0aGUgc3BlY2lmaWVkIHVybC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmV3VGFiQnV0dG9uLnVybF0gU3BlY2lmaWVzIHRoZSB1cmwgdGhhdCBvcGVucyBpbiB0aGUgdGFiIGNyZWF0ZWQgdXBvbiBwcmVzc2luZyB0aGUgYnV0dG9uLlxuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IFtwb3BvdXRXaG9sZVN0YWNrPWZhbHNlXSBXaGV0aGVyIHRoZSBwb3BvdXQgYnV0dG9uIHdpbGwgb25seSBhY3Qgb24gdGhlIGVudGlyZSBzdGFjayxcbiAqIGFzIG9wcG9zZWQgdG8gb25seSB0aGUgYWN0aXZlIHRhYi5cbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBbcHJldmVudERyYWdJbj1mYWxzZV0gSWYgdHJ1ZSwgdGFicyBjYW4ndCBiZSBkcmFnZ2VkIGludG8gdGhlIHdpbmRvdy5cbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBbcHJldmVudERyYWdPdXQ9ZmFsc2VdIElmIHRydWUsIHRhYnMgY2FuJ3QgYmUgZHJhZ2dlZCBvdXQgb2YgdGhlIHdpbmRvdy5cbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBbcmVvcmRlckVuYWJsZWQ9dHJ1ZV0gSWYgdHJ1ZSwgdGhlIHVzZXIgY2FuIHJlLWFycmFuZ2UgdGhlIGxheW91dCBieVxuICogZHJhZ2dpbmcgaXRlbXMgYnkgdGhlaXIgdGFicyB0byB0aGUgZGVzaXJlZCBsb2NhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBbc2hvd0Nsb3NlSWNvbj1mYWxzZV0gV2hldGhlciB0byBzaG93IHRoZSBjbG9zZSBidXR0b24gb24gc3RhY2sgaGVhZGVyXG4gKiAobm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggY2xvc2UgYnV0dG9uIG9uIGV2ZXJ5IHRhYikuXG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gW3Nob3dNYXhpbWlzZUljb249ZmFsc2VdIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWF4aW1pemUgYnV0dG9uIG9uIHN0YWNrIGhlYWRlci5cbiAqIFRoZSBidXR0b24gd2lsbCBtYXhpbWl6ZSB0aGUgY3VycmVudCB0YWIgdG8gZmlsbCB0aGUgZW50aXJlIHdpbmRvdy5cbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBbc2hvd1BvcG91dEljb249ZmFsc2VdIFdoZXRoZXIgdG8gc2hvdyB0aGUgcG9wb3V0IGJ1dHRvbiBvbiBzdGFjayBoZWFkZXIuXG4gKiBUaGUgYnV0dG9uIHdpbGwgY3JlYXRlIGEgbmV3IHdpbmRvdyB3aXRoIGN1cnJlbnQgdGFiIGFzIGl0cyBjb250ZW50LlxuICogSW4gY2FzZSBgcG9wb3V0V2hvbGVTdGFja2AgaXMgc2V0IHRvIHRydWUsIGFsbCB0YWJzIGluIHRoZSBzdGFjayB3aWxsIGJlIGluIHRoZSBuZXcgd2luZG93LlxuICovXG4vKipcbiAqIEBsZW5kcyBQbGF0Zm9ybSNMYXlvdXRcbiAqL1xuY2xhc3MgTGF5b3V0TW9kdWxlIGV4dGVuZHMgYmFzZV8xLkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBfbGF5b3V0TWFuYWdlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIHdpbmRvdydzIExheW91dC4gIE11c3QgYmUgY2FsbGVkIGZyb20gYSBjdXN0b20gd2luZG93IHRoYXQgaGFzIGEgJ2xheW91dCcgb3B0aW9uIHNldCB1cG9uIGNyZWF0aW9uIG9mIHRoYXQgd2luZG93LlxuICAgICAgICAgKiBJZiBhIGNvbnRhaW5lcklkIGlzIG5vdCBwcm92aWRlZCwgdGhpcyBtZXRob2QgYXR0ZW1wdHMgdG8gZmluZCBhbiBlbGVtZW50IHdpdGggdGhlIGlkIGBsYXlvdXQtY29udGFpbmVyYC5cbiAgICAgICAgICogQSBMYXlvdXQgd2lsbCA8YSBocmVmPVwidHV0b3JpYWwtTGF5b3V0LkRPTUV2ZW50cy5odG1sXCI+ZW1pdCBldmVudHMgbG9jYWxseTwvYT4gb24gdGhlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgbGF5b3V0LWNvbnRhaW5lci5cbiAgICAgICAgICogSW4gb3JkZXIgdG8gY2FwdHVyZSB0aGUgcmVsZXZhbnQgZXZlbnRzIGR1cmluZyBMYXlvdXQgaW5pdGlhdGlvbiwgc2V0IHVwIHRoZSBsaXN0ZW5lcnMgb24gdGhlIERPTSBlbGVtZW50IHByaW9yIHRvIGNhbGxpbmcgYGluaXRgLlxuICAgICAgICAgKiBAcGFyYW0geyBJbml0TGF5b3V0T3B0aW9ucyB9IFtvcHRpb25zXSAtIExheW91dCBpbml0IG9wdGlvbnMuXG4gICAgICAgICAqIEByZXR1cm4geyBQcm9taXNlPExheW91dD4gfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICogQHR1dG9yaWFsIExheW91dC5pbml0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXQgPSBhc3luYyAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignbGF5b3V0LWluaXQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmluLm1lLmlzV2luZG93KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMYXlvdXQuaW5pdCBjYW4gb25seSBiZSBjYWxsZWQgZnJvbSBhIFdpbmRvdyBjb250ZXh0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfbGF5b3V0TWFuYWdlcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xheW91dCBmb3IgdGhpcyB3aW5kb3cgYWxyZWFkeSBpbml0aWFsaXplZCwgcGxlYXNlIHVzZSBMYXlvdXQucmVwbGFjZSBjYWxsIHRvIHJlcGxhY2UgdGhlIGxheW91dC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ28gdGhyb3VnaCBlbnZpcm9ubWVudCB0byBtYWtlIHN1cmUgaXQgaXMgb25seSBpbXBvcnRlZC9idW5kbGVkIGluIE9wZW5GaW4uXG4gICAgICAgICAgICBjb25zdCBNYW5hZ2VyQ29uc3RydWN0b3IgPSBhd2FpdCB0aGlzLndpcmUuZW52aXJvbm1lbnQuZ2V0TWFuYWdlckNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9sYXlvdXRNYW5hZ2VyLCBuZXcgTWFuYWdlckNvbnN0cnVjdG9yKCkpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtaWdub3JlXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbGF5b3V0IHdhcm5pbmcgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGNhbiByZW1vdmUgbGF5b3V0IGNoZWNrIGluIC41MlxuICAgICAgICAgICAgbGV0IHsgbGF5b3V0LCBjb250YWluZXJJZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFdlIHJlY29tbWVuZCB1c2luZyBhIGxheW91dCBpbiB3aW5kb3cgb3B0aW9ucy5cbiAgICAgICAgICAgICAgICBUaGlzIGxheW91dCBoYXMgbm90IGJlZW4gc2FuaXRpemVkIGFuZCB1bmV4cGVjdGVkIGJlaGF2aW9yIGNhbiBvY2N1ci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheW91dCA9IGxheW91dCB8fCAoYXdhaXQgdGhpcy5maW4uV2luZG93LmdldEN1cnJlbnRTeW5jKCkuZ2V0T3B0aW9ucygpKS5sYXlvdXQ7XG4gICAgICAgICAgICBjb250YWluZXJJZCA9IGNvbnRhaW5lcklkIHx8ICdsYXlvdXQtY29udGFpbmVyJztcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRhaW5lcklkKTtcbiAgICAgICAgICAgIC8vIFNob3VsZCB3ZSBlcnJvciBoZXJlIGlmIHRoZXJlIGlzIG5vIGNvbnRhaW5lcj8gR2V0dGluZyBhIHR5cGVzY3JpcHQgY29tcGxhaW50IG9uIGNyZWF0ZUxheW91dFxuICAgICAgICAgICAgLy8gb3ZlcnJpZGUgaGVyZVxuICAgICAgICAgICAgLy8gcHVsbCBjcmVhdGVDaGFubmVsQ29ubmVjdGlvbiBvdXQgb2YgTGF5b3V0TWFuYWdlciBhbmQgc2V0dXAgY2hhbm5lbCBjb25uZWN0aW9ucyBoZXJlIHVzaW5nIGxheW91dG1hbmFnZXIgaW5zdGFuY2UgbWV0aG9kcz9cbiAgICAgICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2xheW91dE1hbmFnZXIpLmluaXRNYW5hZ2VyKCk7XG4gICAgICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9sYXlvdXRNYW5hZ2VyKS5jcmVhdGVMYXlvdXQobGF5b3V0LCBjb250YWluZXIpO1xuICAgICAgICAgICAgLy8gQWRkaW5nIHRoaXMgdG8gdGhlIHJldHVybmVkIGluc3RhbmNlIHVuZG9jdW1lbnRlZC90eXBlZCBmb3IgQnJvd3Nlci5cbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMuZ2V0Q3VycmVudFN5bmMoKSwgeyBsYXlvdXRNYW5hZ2VyOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9sYXlvdXRNYW5hZ2VyKSB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhIExheW91dCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgV2luZG93J3MgbGF5b3V0LlxuICAgICAqIEBwYXJhbSB7IElkZW50aXR5IH0gaWRlbnRpdHlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxMYXlvdXQ+fVxuICAgICAqIEB0dXRvcmlhbCBMYXlvdXQud3JhcFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGFzeW5jIHdyYXAoaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2xheW91dC13cmFwJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW5jZV8xLkxheW91dChpZGVudGl0eSwgdGhpcy53aXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGEgTGF5b3V0IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBXaW5kb3cncyBsYXlvdXQuXG4gICAgICogQHBhcmFtIHsgSWRlbnRpdHkgfSBpZGVudGl0eVxuICAgICAqIEByZXR1cm4ge0xheW91dH1cbiAgICAgKiBAdHV0b3JpYWwgTGF5b3V0LndyYXBTeW5jXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgd3JhcFN5bmMoaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2xheW91dC13cmFwLXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbmNlXzEuTGF5b3V0KGlkZW50aXR5LCB0aGlzLndpcmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSByZXR1cm5zIGEgTGF5b3V0IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBXaW5kb3cncyBsYXlvdXQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48TGF5b3V0Pn1cbiAgICAgKiBAdHV0b3JpYWwgTGF5b3V0LmdldEN1cnJlbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3VycmVudCgpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2xheW91dC1nZXQtY3VycmVudCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5maW4ubWUuaXNXaW5kb3cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgaW4gYSBXaW5kb3cgY29udGV4dC4gIE9ubHkgV2luZG93cyBjYW4gaGF2ZSBhIExheW91dC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUgfSA9IHRoaXMuZmluLm1lO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwKHsgdXVpZCwgbmFtZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGEgTGF5b3V0IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBXaW5kb3cncyBsYXlvdXQuXG4gICAgICogQHJldHVybiB7TGF5b3V0fVxuICAgICAqIEB0dXRvcmlhbCBMYXlvdXQuZ2V0Q3VycmVudFN5bmNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZ2V0Q3VycmVudFN5bmMoKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdsYXlvdXQtZ2V0LWN1cnJlbnQtc3luYycpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5maW4ubWUuaXNXaW5kb3cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgaW4gYSBXaW5kb3cgY29udGV4dC4gIE9ubHkgV2luZG93cyBjYW4gaGF2ZSBhIExheW91dC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUgfSA9IHRoaXMuZmluLm1lO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwU3luYyh7IHV1aWQsIG5hbWUgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5MYXlvdXRNb2R1bGUgPSBMYXlvdXRNb2R1bGU7XG5fbGF5b3V0TWFuYWdlciA9IG5ldyBXZWFrTWFwKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmLCBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0ICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxheW91dCA9IHZvaWQgMDtcbmNvbnN0IHZhbGlkYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbC92YWxpZGF0ZVwiKTtcbmNvbnN0IGNvbW1vbl91dGlsc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi11dGlsc1wiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlXCIpO1xuLyoqXG4gKiBAbGVuZHMgUGxhdGZvcm0jTGF5b3V0XG4gKi9cbmNsYXNzIExheW91dCBleHRlbmRzIGJhc2VfMS5CYXNlIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG4gICAgY29uc3RydWN0b3IoaWRlbnRpdHksIHdpcmUpIHtcbiAgICAgICAgc3VwZXIod2lyZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBsYWNlcyBhIFBsYXRmb3JtIHdpbmRvdydzIGxheW91dCB3aXRoIGEgbmV3IGxheW91dC4gIEFueSB2aWV3cyB0aGF0IHdlcmUgaW4gdGhlIG9sZCBsYXlvdXQgYnV0IG5vdCB0aGUgbmV3IGxheW91dFxuICAgICAgICAgKiB3aWxsIGJlIGRlc3Ryb3llZC5cbiAgICAgICAgICogQHBhcmFtIHsgTGF5b3V0Q29uZmlnIH0gbGF5b3V0IE5ldyBsYXlvdXQgdG8gaW1wbGVtZW50IGluIHRoZSB0YXJnZXQgd2luZG93LlxuICAgICAgICAgKiBQbGVhc2Ugc2VlIGV4cGxhbmF0aW9uIG9mIGEgbGF5b3V0IHtAbGluayBodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL3BsYXRmb3JtLWFwaSNzZWN0aW9uLWxheW91dCBoZXJlfS5cbiAgICAgICAgICogQHJldHVybiB7IFByb21pc2U8dm9pZD4gfVxuICAgICAgICAgKiBAdHV0b3JpYWwgTGF5b3V0LnJlcGxhY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVwbGFjZSA9IGFzeW5jIChsYXlvdXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdsYXlvdXQtcmVwbGFjZScpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucGxhdGZvcm0uZ2V0Q2xpZW50KCk7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQuZGlzcGF0Y2goJ3JlcGxhY2UtbGF5b3V0Jywge1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5pZGVudGl0eSxcbiAgICAgICAgICAgICAgICBvcHRzOiB7IGxheW91dCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2VzIHRoZSBzcGVjaWZpZWQgdmlldyB3aXRoIGEgdmlldyB3aXRoIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBUaGUgb2xkIHZpZXcgaXMgc3RyaXBwZWQgb2YgaXRzIGxpc3RlbmVycyBhbmQgZWl0aGVyIGNsb3NlZCBvciBhdHRhY2hlZCB0byB0aGUgcHJvdmlkZXIgd2luZG93XG4gICAgICAgICAqIGRlcGVuZGluZyBvbiBgZGV0YWNoT25DbG9zZWAgdmlldyBvcHRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7IElkZW50aXR5IH0gdmlld1RvUmVwbGFjZSBJZGVudGl0eSBvZiB0aGUgdmlldyB0byBiZSByZXBsYWNlZFxuICAgICAgICAgKiBAcGFyYW0geyBWaWV3fm9wdGlvbnMgfSBuZXdWaWV3IENyZWF0aW9uIG9wdGlvbnMgb2YgdGhlIG5ldyB2aWV3LlxuICAgICAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTx2b2lkPiB9XG4gICAgICAgICAqIEB0dXRvcmlhbCBMYXlvdXQucmVwbGFjZVZpZXdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVwbGFjZVZpZXcgPSBhc3luYyAodmlld1RvUmVwbGFjZSwgbmV3VmlldykgPT4ge1xuICAgICAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2xheW91dC1yZXBsYWNlLXZpZXcnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnBsYXRmb3JtLmdldENsaWVudCgpO1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmRpc3BhdGNoKCdyZXBsYWNlLXZpZXcnLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmlkZW50aXR5LFxuICAgICAgICAgICAgICAgIG9wdHM6IHsgdmlld1RvUmVwbGFjZSwgbmV3VmlldyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2VzIGEgUGxhdGZvcm0gd2luZG93J3MgbGF5b3V0IHdpdGggYSBwcmVzZXQgbGF5b3V0IGFycmFuZ2VtZW50IHVzaW5nIHRoZSBleGlzdGluZyBWaWV3cyBhdHRhY2hlZCB0byB0aGUgd2luZG93LlxuICAgICAgICAgKiBUaGUgcHJlc2V0IG9wdGlvbnMgYXJlIGBjb2x1bW5zYCwgYGdyaWRgLCBgcm93c2AsIGFuZCBgdGFic2AuXG4gICAgICAgICAqIEBwYXJhbSB7IFByZXNldExheW91dE9wdGlvbnMgfSBvcHRpb25zIE1hbmRhdG9yeSBvYmplY3Qgd2l0aCBgcHJlc2V0VHlwZWAgcHJvcGVydHkgdGhhdCBzZXRzIHdoaWNoIHByZXNldCBsYXlvdXQgYXJyYW5nZW1lbnQgdG8gdXNlLlxuICAgICAgICAgKiBUaGUgcHJlc2V0IG9wdGlvbnMgYXJlIGBjb2x1bW5zYCwgYGdyaWRgLCBgcm93c2AsIGFuZCBgdGFic2AuXG4gICAgICAgICAqIEByZXR1cm4geyBQcm9taXNlPHZvaWQ+IH1cbiAgICAgICAgICogQHR1dG9yaWFsIExheW91dC5hcHBseVByZXNldFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcHBseVByZXNldCA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignbGF5b3V0LWFwcGx5LXByZXNldCcpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucGxhdGZvcm0uZ2V0Q2xpZW50KCk7XG4gICAgICAgICAgICBjb25zdCB7IHByZXNldFR5cGUgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoIXByZXNldFR5cGUgfHwgIWNvbW1vbl91dGlsc18xLmlzVmFsaWRQcmVzZXRUeXBlKHByZXNldFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgcHJlc2V0IGxheW91dCwgcGxlYXNlIGluY2x1ZGUgYW4gYXBwbGljYWJsZSBwcmVzZXRUeXBlIHByb3BlcnR5IGluIHRoZSBQcmVzZXRMYXlvdXRPcHRpb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmRpc3BhdGNoKCdhcHBseS1wcmVzZXQtbGF5b3V0Jywge1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5pZGVudGl0eSxcbiAgICAgICAgICAgICAgICBvcHRzOiB7IHByZXNldFR5cGUgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yTXNnID0gdmFsaWRhdGVfMS52YWxpZGF0ZUlkZW50aXR5KGlkZW50aXR5KTtcbiAgICAgICAgaWYgKGVycm9yTXNnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHRoaXMuZmluLlBsYXRmb3JtLndyYXBTeW5jKHsgdXVpZDogaWRlbnRpdHkudXVpZCB9KTtcbiAgICAgICAgaWYgKGlkZW50aXR5LnV1aWQgPT09IHRoaXMuZmluLm1lLnV1aWQgJiYgaWRlbnRpdHkubmFtZSA9PT0gdGhpcy5maW4ubWUubmFtZSkge1xuICAgICAgICAgICAgdGhpcy5pbml0ID0gdGhpcy5maW4uUGxhdGZvcm0uTGF5b3V0LmluaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgd2luZG93J3MgbGF5b3V0LiAgUmV0dXJucyB0aGUgc2FtZSBpbmZvcm1hdGlvbiB0aGF0IGlzIHJldHVybmVkIGZvciBhbGwgd2luZG93cyBpbiBnZXRTbmFwc2hvdC5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTxMYXlvdXRDb25maWc+IH1cbiAgICAgKiBAdHV0b3JpYWwgTGF5b3V0LmdldENvbmZpZ1xuICAgICAqL1xuICAgIGFzeW5jIGdldENvbmZpZygpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2xheW91dC1nZXQtY29uZmlnJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5wbGF0Zm9ybS5nZXRDbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5kaXNwYXRjaCgnZ2V0LWZyYW1lLXNuYXBzaG90Jywge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmlkZW50aXR5XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTGF5b3V0ID0gTGF5b3V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9GYWN0b3J5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JbnN0YW5jZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2hhcGVzXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi4vYmFzZVwiKTtcbmNvbnN0IEluc3RhbmNlXzEgPSByZXF1aXJlKFwiLi9JbnN0YW5jZVwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBTbmFwc2hvdFByb3ZpZGVyXG4gKiBAcHJvcGVydHkge2dldFNuYXBzaG90fSBbZ2V0U25hcHNob3RdXG4gKiBAcHJvcGVydHkge2FwcGx5U25hcHNob3R9IFthcHBseVNuYXBzaG90XVxuICovXG4vKipcbiAqIEBsZW5kcyBTbmFwc2hvdFNvdXJjZVxuICovXG5jbGFzcyBTbmFwc2hvdFNvdXJjZU1vZHVsZSBleHRlbmRzIGJhc2VfMS5CYXNlIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIFNuYXBzaG90U291cmNlIHdpdGggdGhlIGdldFNuYXBzaG90IGFuZCBhcHBseVNuYXBzaG90IG1ldGhvZHMgZGVmaW5lZC5cbiAgICAgKiBAcGFyYW0geyBTbmFwc2hvdFByb3ZpZGVyIH0gcHJvdmlkZXJcbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTx2b2lkPiB9XG4gICAgICogQHR1dG9yaWFsIFNuYXBzaG90U291cmNlLmluaXRcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYXN5bmMgaW5pdChwcm92aWRlcikge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignc25hcHNob3Qtc291cmNlLWluaXQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIHByb3ZpZGVyLmdldFNuYXBzaG90ICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvdmlkZXIuYXBwbHlTbmFwc2hvdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5b3UgbXVzdCBwYXNzIGluIGEgdmFsaWQgU25hcHNob3RQcm92aWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBhd2FpdCB0aGlzLmZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY3JlYXRlKHV0aWxzXzEuZ2V0U25hcHNob3RTb3VyY2VDaGFubmVsTmFtZShmaW4ubWUuaWRlbnRpdHkpKTtcbiAgICAgICAgY2hhbm5lbC5yZWdpc3RlcihcImdldC1zbmFwc2hvdFwiIC8qIEdFVF9TTkFQU0hPVCAqLywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBwcm92aWRlci5nZXRTbmFwc2hvdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc25hcHNob3QgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYW5uZWwucmVnaXN0ZXIoXCJhcHBseS1zbmFwc2hvdFwiIC8qIEFQUExZX1NOQVBTSE9UICovLCAoeyBzbmFwc2hvdCB9KSA9PiBwcm92aWRlci5hcHBseVNuYXBzaG90KHNuYXBzaG90KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFNuYXBzaG90U291cmNlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgU25hcHNob3RTb3VyY2UuXG4gICAgICogQHBhcmFtIHsgSWRlbnRpdHkgfSBpZGVudGl0eVxuICAgICAqIEByZXR1cm4geyBTbmFwc2hvdFNvdXJjZSB9XG4gICAgICogQHR1dG9yaWFsIFNuYXBzaG90U291cmNlLndyYXBTeW5jXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHdyYXBTeW5jKGlkZW50aXR5KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzbmFwc2hvdC1zb3VyY2Utd3JhcC1zeW5jJykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW5jZV8xLlNuYXBzaG90U291cmNlKHRoaXMud2lyZSwgaWRlbnRpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSByZXR1cm5zIGEgU25hcHNob3RTb3VyY2Ugb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBTbmFwc2hvdFNvdXJjZS5cbiAgICAgKiBAcGFyYW0geyBJZGVudGl0eSB9IGlkZW50aXR5XG4gICAgICogQHJldHVybiB7IFByb21pc2UuPFNuYXBzaG90U291cmNlPiB9XG4gICAgICogQHR1dG9yaWFsIFNuYXBzaG90U291cmNlLndyYXBcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYXN5bmMgd3JhcChpZGVudGl0eSkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignc25hcHNob3Qtc291cmNlLXdyYXAnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwU3luYyhpZGVudGl0eSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU25hcHNob3RTb3VyY2VNb2R1bGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG4gICAgfVxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX2lkZW50aXR5LCBfZ2V0Q29ubmVjdGlvbiwgX2dldENsaWVudCwgX3N0YXJ0Q29ubmVjdGlvbiwgX3NldFVwQ29ubmVjdGlvbkxpc3RlbmVyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TbmFwc2hvdFNvdXJjZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gKi9cbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgY29ubmVjdGlvbk1hcCA9IG5ldyBNYXAoKTtcbi8qKlxuICogRW5hYmxlcyBjb25maWd1cmluZyBhIFNuYXBzaG90U291cmNlIHdpdGggY3VzdG9tIGdldFNuYXBzaG90IGFuZCBhcHBseVNuYXBzaG90IG1ldGhvZHMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbmNsYXNzIFNuYXBzaG90U291cmNlIGV4dGVuZHMgYmFzZV8xLkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHdpcmUsIGlkKSB7XG4gICAgICAgIHN1cGVyKHdpcmUpO1xuICAgICAgICBfaWRlbnRpdHkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9nZXRDb25uZWN0aW9uLnNldCh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb25NYXAuaGFzKHRoaXMuaWRlbnRpdHkudXVpZCkpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFwLnNldCh0aGlzLmlkZW50aXR5LnV1aWQsIHsgZXZlbnRGaXJlZDogbnVsbCwgY2xpZW50UHJvbWlzZTogbnVsbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uTWFwLmdldCh0aGlzLmlkZW50aXR5LnV1aWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgX2dldENsaWVudC5zZXQodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9nZXRDb25uZWN0aW9uKS5jYWxsKHRoaXMpLmNsaWVudFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9nZXRDb25uZWN0aW9uKS5jYWxsKHRoaXMpLmNsaWVudFByb21pc2UgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9zdGFydENvbm5lY3Rpb24pLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZ2V0Q29ubmVjdGlvbikuY2FsbCh0aGlzKS5jbGllbnRQcm9taXNlO1xuICAgICAgICB9KTtcbiAgICAgICAgX3N0YXJ0Q29ubmVjdGlvbi5zZXQodGhpcywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbE5hbWUgPSB1dGlsc18xLmdldFNuYXBzaG90U291cmNlQ2hhbm5lbE5hbWUodGhpcy5pZGVudGl0eSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZ2V0Q29ubmVjdGlvbikuY2FsbCh0aGlzKS5ldmVudEZpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3NldFVwQ29ubmVjdGlvbkxpc3RlbmVyKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmZpbi5JbnRlckFwcGxpY2F0aW9uQnVzLkNoYW5uZWwuY29ubmVjdChjaGFubmVsTmFtZSwgeyB3YWl0OiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICBjbGllbnQub25EaXNjb25uZWN0aW9uKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZ2V0Q29ubmVjdGlvbikuY2FsbCh0aGlzKS5jbGllbnRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZ2V0Q29ubmVjdGlvbikuY2FsbCh0aGlzKS5ldmVudEZpcmVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9nZXRDb25uZWN0aW9uKS5jYWxsKHRoaXMpLmNsaWVudFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSB0YXJnZXRlZCBTbmFwc2hvdFNvdXJjZSBpcyBub3QgY3VycmVudGx5IGluaXRpYWxpemVkLiBBd2FpdCB0aGlzIG9iamVjdCdzIHJlYWR5KCkgbWV0aG9kLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF9zZXRVcENvbm5lY3Rpb25MaXN0ZW5lci5zZXQodGhpcywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbE5hbWUgPSB1dGlsc18xLmdldFNuYXBzaG90U291cmNlQ2hhbm5lbE5hbWUodGhpcy5pZGVudGl0eSk7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZTtcbiAgICAgICAgICAgIGxldCByZWplY3Q7XG4gICAgICAgICAgICBjb25zdCBldmVudEZpcmVkID0gbmV3IFByb21pc2UoKHksIG4pID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0geTtcbiAgICAgICAgICAgICAgICByZWplY3QgPSBuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9nZXRDb25uZWN0aW9uKS5jYWxsKHRoaXMpLmV2ZW50RmlyZWQgPSBldmVudEZpcmVkO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNoYW5uZWxOYW1lID09PSBjaGFubmVsTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5maW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0ZWQnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5maW4uSW50ZXJBcHBsaWNhdGlvbkJ1cy5DaGFubmVsLm9uKCdjb25uZWN0ZWQnLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9pZGVudGl0eSwgaWQpO1xuICAgIH1cbiAgICBnZXQgaWRlbnRpdHkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9pZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBkZXRlcm1pbmUgaWYgdGhlIFNuYXBzaG90U291cmNlIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICAgICAqXG4gICAgICogVXNlIHdoZW4gdGhlIHBhcmVudCBhcHBsaWNhdGlvbiBpcyBzdGFydGluZyB1cCB0byBlbnN1cmUgdGhlIFNuYXBzaG90U291cmNlIGlzIGFibGUgdG8gYWNjZXB0IGFuZFxuICAgICAqIGFwcGx5IGEgc25hcHNob3QgdXNpbmcgdGhlIHtAbGluayBTbmFwc2hvdFNvdXJjZSNhcHBseVNuYXBzaG90IGFwcGx5U25hcHNob3R9IG1ldGhvZC5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTx2b2lkPiB9XG4gICAgICogQHR1dG9yaWFsIFNuYXBzaG90U291cmNlLnJlYWR5XG4gICAgICovXG4gICAgYXN5bmMgcmVhZHkoKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzbmFwc2hvdC1zb3VyY2UtcmVhZHknKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlLCBhbmFseXRpY3Mtb25seSBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvclxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSWYgZ2V0Q2xpZW50IHdhcyBhbHJlYWR5IGNhbGxlZCBiZWZvcmUgdGhpcywgZG8gd2UgaGF2ZSBhIHRpbWluZyBpc3N1ZSB3aGVyZSB0aGUgY2hhbm5lbCBtaWdodCBoYXZlIGJlZW4gY3JlYXRlZCBidXQgd2UgbWlzc2VkIHRoZSBldmVudCBidXQgdGhpcyBzdGlsbCBmYWlscz9cbiAgICAgICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2dldENsaWVudCkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaXQgd2FzIG5vdCBydW5uaW5nLlxuICAgICAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZ2V0Q29ubmVjdGlvbikuY2FsbCh0aGlzKS5ldmVudEZpcmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIFNuYXBzaG90U291cmNlJ3MgZ2V0U25hcHNob3QgbWV0aG9kIGRlZmluZWQgYnkge0BsaW5rIFNuYXBzaG90U291cmNlI2luaXQgaW5pdH0uXG4gICAgICogQHJldHVybiB7IFByb21pc2U8YW55PiB9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0U25hcHNob3QoKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzbmFwc2hvdC1zb3VyY2UtZ2V0LXNuYXBzaG90JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZ2V0Q2xpZW50KS5jYWxsKHRoaXMpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IChhd2FpdCBjbGllbnQuZGlzcGF0Y2goXCJnZXQtc25hcHNob3RcIiAvKiBHRVRfU05BUFNIT1QgKi8pKTtcbiAgICAgICAgcmV0dXJuIChhd2FpdCByZXNwb25zZSkuc25hcHNob3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIFNuYXBzaG90U291cmNlJ3MgYXBwbHlTbmFwc2hvdCBtZXRob2QgZGVmaW5lZCBieSB7QGxpbmsgU25hcHNob3RTb3VyY2UjaW5pdCBpbml0fS5cbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZTx2b2lkPiB9XG4gICAgICovXG4gICAgYXN5bmMgYXBwbHlTbmFwc2hvdChzbmFwc2hvdCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignc25hcHNob3Qtc291cmNlLWFwcGx5LXNuYXBzaG90JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cG9zZSwgYW5hbHl0aWNzLW9ubHkgY2FsbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZ2V0Q2xpZW50KS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmRpc3BhdGNoKFwiYXBwbHktc25hcHNob3RcIiAvKiBBUFBMWV9TTkFQU0hPVCAqLywgeyBzbmFwc2hvdCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNuYXBzaG90U291cmNlID0gU25hcHNob3RTb3VyY2U7XG5faWRlbnRpdHkgPSBuZXcgV2Vha01hcCgpLCBfZ2V0Q29ubmVjdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9nZXRDbGllbnQgPSBuZXcgV2Vha01hcCgpLCBfc3RhcnRDb25uZWN0aW9uID0gbmV3IFdlYWtNYXAoKSwgX3NldFVwQ29ubmVjdGlvbkxpc3RlbmVyID0gbmV3IFdlYWtNYXAoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9GYWN0b3J5XCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRmFjdG9yeV8xLmRlZmF1bHQ7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSW5zdGFuY2VcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNuYXBzaG90U291cmNlQWN0aW9ucyA9IGV4cG9ydHMuZ2V0U25hcHNob3RTb3VyY2VDaGFubmVsTmFtZSA9IHZvaWQgMDtcbmNvbnN0IGNoYW5uZWxQcmVmaXggPSAnc25hcHNob3Qtc291cmNlLXByb3ZpZGVyLSc7XG5leHBvcnRzLmdldFNuYXBzaG90U291cmNlQ2hhbm5lbE5hbWUgPSAoaWQpID0+IGAke2NoYW5uZWxQcmVmaXh9JHtpZC51dWlkfWA7XG52YXIgU25hcHNob3RTb3VyY2VBY3Rpb25zO1xuKGZ1bmN0aW9uIChTbmFwc2hvdFNvdXJjZUFjdGlvbnMpIHtcbiAgICBTbmFwc2hvdFNvdXJjZUFjdGlvbnNbXCJHRVRfU05BUFNIT1RcIl0gPSBcImdldC1zbmFwc2hvdFwiO1xuICAgIFNuYXBzaG90U291cmNlQWN0aW9uc1tcIkFQUExZX1NOQVBTSE9UXCJdID0gXCJhcHBseS1zbmFwc2hvdFwiO1xufSkoU25hcHNob3RTb3VyY2VBY3Rpb25zID0gZXhwb3J0cy5TbmFwc2hvdFNvdXJjZUFjdGlvbnMgfHwgKGV4cG9ydHMuU25hcHNob3RTb3VyY2VBY3Rpb25zID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG5jb25zdCB0cmFuc3BvcnRfZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vLi4vdHJhbnNwb3J0L3RyYW5zcG9ydC1lcnJvcnNcIik7XG5jb25zdCB3aW5kb3dfMSA9IHJlcXVpcmUoXCIuLi93aW5kb3dcIik7XG4vKipcbiAqIEFwcEFzc2V0SW5mbyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gQXBwQXNzZXRJbmZvXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBzcmMgIFRoZSBVUkwgdG8gYSB6aXAgZmlsZSBjb250YWluaW5nIHRoZSBwYWNrYWdlIGZpbGVzIChleGVjdXRhYmxlcywgZGxscywgZXRj4oCmKVxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gYWxpYXMgVGhlIG5hbWUgb2YgdGhlIGFzc2V0XG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB2ZXJzaW9uIFRoZSB2ZXJzaW9uIG9mIHRoZSBwYWNrYWdlXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB0YXJnZXQgU3BlY2lmeSBkZWZhdWx0IGV4ZWN1dGFibGUgdG8gbGF1bmNoLiBUaGlzIG9wdGlvbiBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBsYXVuY2hFeHRlcm5hbFByb2Nlc3NcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IGFyZ3MgVGhlIGRlZmF1bHQgY29tbWFuZCBsaW5lIGFyZ3VtZW50cyBmb3IgdGhlIGFmb3JlbWVudGlvbmVkIHRhcmdldC5cbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBtYW5kYXRvcnkgV2hlbiBzZXQgdG8gdHJ1ZSwgdGhlIGFwcCB3aWxsIGZhaWwgdG8gbG9hZCBpZiB0aGUgYXNzZXQgY2Fubm90IGJlIGRvd25sb2FkZWQuXG4gKiBXaGVuIHNldCB0byBmYWxzZSwgdGhlIGFwcCB3aWxsIGNvbnRpbnVlIHRvIGxvYWQgaWYgdGhlIGFzc2V0IGNhbm5vdCBiZSBkb3dubG9hZGVkLiAoRGVmYXVsdDogdHJ1ZSlcbiAqL1xuLyoqXG4gKiBBcHBBc3NldFJlcXVlc3QgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IEFwcEFzc2V0UmVxdWVzdFxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gYWxpYXMgVGhlIG5hbWUgb2YgdGhlIGFzc2V0XG4gKi9cbi8qKlxuICogQXBwbGljYXRpb25JbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBBcHBsaWNhdGlvbkluZm9cbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBpc1BsYXRmb3JtIHRydWUgd2hlbiB0aGUgYXBwbGljYXRpb24gaXMgYSBQbGF0Zm9ybSBjb250cm9sbGVyXG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gaXNSdW5uaW5nICB0cnVlIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIHJ1bm5pbmdcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHV1aWQgdXVpZCBvZiB0aGUgYXBwbGljYXRpb25cbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHBhcmVudFV1aWQgdXVpZCBvZiB0aGUgYXBwbGljYXRpb24gdGhhdCBsYXVuY2hlcyB0aGlzIGFwcGxpY2F0aW9uXG4gKi9cbi8qKlxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBDbGVhckNhY2hlT3B0aW9uXG4gKiBAc3VtbWFyeSBDbGVhciBjYWNoZSBvcHRpb25zLlxuICogQGRlc2MgVGhlc2UgYXJlIHRoZSBvcHRpb25zIHJlcXVpcmVkIGJ5IHRoZSBjbGVhckNhY2hlIGZ1bmN0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYXBwY2FjaGUgaHRtbDUgYXBwbGljYXRpb24gY2FjaGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FjaGUgYnJvd3NlciBkYXRhIGNhY2hlIGZvciBodG1sIGZpbGVzIGFuZCBpbWFnZXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29va2llcyBicm93c2VyIGNvb2tpZXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbG9jYWxTdG9yYWdlIGJyb3dzZXIgZGF0YSB0aGF0IGNhbiBiZSB1c2VkIGFjcm9zcyBzZXNzaW9uc1xuICovXG4vKipcbiAqIENvb2tpZUluZm8gaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IENvb2tpZUluZm9cbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IG5hbWUgIFRoZSBuYW1lIG9mIHRoZSBjb29raWVcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IGRvbWFpbiBUaGUgZG9tYWluIG9mIHRoZSBjb29raWVcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHBhdGggVGhlIHBhdGggb2YgdGhlIGNvb2tpZVxuICovXG4vKipcbiAqIENvb2tpZU9wdGlvbiBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gQ29va2llT3B0aW9uXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb29raWVcbiAqL1xuLyoqXG4gKiBDcHVJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBDcHVJbmZvXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBtb2RlbCBUaGUgbW9kZWwgb2YgdGhlIGNwdVxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gc3BlZWQgVGhlIG51bWJlciBpbiBNSHpcbiAqIEBwcm9wZXJ0eSB7IFRpbWUgfSB0aW1lcyBUaGUgbnVtYmVycyBvZiBtaWxsaXNlY29uZHMgdGhlIENQVSBoYXMgc3BlbnQgaW4gZGlmZmVyZW50IG1vZGVzLlxuICovXG4vKipcbiAqIENyYXNoUmVwb3J0ZXJPcHRpb24gaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IENyYXNoUmVwb3J0ZXJPcHRpb25cbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBkaWFnbm9zdGljTW9kZSBJbiBkaWFnbm9zdGljIG1vZGUgdGhlIGNyYXNoIHJlcG9ydGVyIHdpbGwgc2VuZCBkaWFnbm9zdGljIGxvZ3MgdG9cbiAqICB0aGUgT3BlbkZpbiByZXBvcnRpbmcgc2VydmljZSBvbiBydW50aW1lIHNodXRkb3duXG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gaXNSdW5uaW5nIGNoZWNrIGlmIGl0J3MgcnVubmluZ1xuICovXG4vKipcbiAqIERpcFJlY3QgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IERpcFJlY3RcbiAqIEBwcm9wZXJ0eSB7IFJlY3QgfSBkaXBSZWN0IFRoZSBESVAgY29vcmRpbmF0ZXNcbiAqIEBwcm9wZXJ0eSB7IFJlY3QgfSBzY2FsZWRSZWN0IFRoZSBzY2FsZSBjb29yZGluYXRlc1xuICovXG4vKipcbiAqIERpcFNjYWxlUmVjdHMgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IERpcFNjYWxlUmVjdHNcbiAqIEBwcm9wZXJ0eSB7IFJlY3QgfSBkaXBSZWN0IFRoZSBESVAgY29vcmRpbmF0ZXNcbiAqIEBwcm9wZXJ0eSB7IFJlY3QgfSBzY2FsZWRSZWN0IFRoZSBzY2FsZSBjb29yZGluYXRlc1xuICovXG4vKipcbiAqIERvd25sb2FkUHJlbG9hZEluZm8gaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IERvd25sb2FkUHJlbG9hZEluZm9cbiAqIEBkZXNjIGRvd25sb2FkUHJlbG9hZFNjcmlwdHMgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB1cmwgdXJsIHRvIHRoZSBwcmVsb2FkIHNjcmlwdFxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gZXJyb3IgZXJyb3IgZHVyaW5nIHByZWxvYWQgc2NyaXB0IGFjcXVpc2l0aW9uXG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gc3VjY2Vlc3MgZG93bmxvYWQgb3BlcmF0aW9uIHN1Y2Nlc3NcbiAqL1xuLyoqXG4gKiBEb3dubG9hZFByZWxvYWRPcHRpb24gaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IERvd25sb2FkUHJlbG9hZE9wdGlvblxuICogQGRlc2MgVGhlc2UgYXJlIHRoZSBvcHRpb25zIG9iamVjdCByZXF1aXJlZCBieSB0aGUgZG93bmxvYWRQcmVsb2FkU2NyaXB0cyBmdW5jdGlvblxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gdXJsIHVybCB0byB0aGUgcHJlbG9hZCBzY3JpcHRcbiAqL1xuLyoqXG4gKiBFbnRpdHkgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IEVudGl0eVxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZW50aXR5XG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB1dWlkIFRoZSB1dWlkIG9mIHRoZSBlbnRpdHlcbiAqL1xuLyoqXG4gKiBFbnRpdHlJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBFbnRpdHlJbmZvXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBlbnRpdHlcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHV1aWQgVGhlIHV1aWQgb2YgdGhlIGVudGl0eVxuICogQHByb3BlcnR5IHsgSWRlbnRpdHkgfSBwYXJlbnQgVGhlIHBhcmVudCBvZiB0aGUgZW50aXR5XG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBlbnRpdHlUeXBlIFRoZSB0eXBlIG9mIHRoZSBlbnRpdHlcbiAqL1xuLyoqXG4gKiBFeHRlcm5hbEFwcGxpY2F0aW9uSW5mbyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gRXh0ZXJuYWxBcHBsaWNhdGlvbkluZm9cbiAqIEBwcm9wZXJ0eSB7IElkZW50aXR5IH0gcGFyZW50IFRoZSBwYXJlbnQgaWRlbnRpdHlcbiAqL1xuLyoqXG4gKiBFeHRlcm5hbENvbm5lY3Rpb24gaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IEV4dGVybmFsQ29ubmVjdGlvblxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gdG9rZW4gVGhlIHRva2VuIHRvIGJyb2tlciBhbiBleHRlcm5hbCBjb25uZWN0aW9uXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB1dWlkIFRoZSB1dWlkIG9mIHRoZSBleHRlcm5hbCBjb25uZWN0aW9uXG4gKi9cbi8qKlxuICogRXh0ZXJuYWxQcm9jZXNzUmVxdWVzdFR5cGUgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IEV4dGVybmFsUHJvY2Vzc1JlcXVlc3RUeXBlXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBwYXRoIFRoZSBmaWxlIHBhdGggdG8gd2hlcmUgdGhlIHJ1bm5pbmcgYXBwbGljYXRpb24gcmVzaWRlc1xuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gYXJndW1lbnRzIFRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIHJ1bm5pbmcgYXBwbGljYXRpb25cbiAqIEBwcm9wZXJ0eSB7IExhdW5jaEV4dGVybmFsUHJvY2Vzc0xpc3RlbmVyIH0gbGlzdGVuZXIgVGhpcyBpcyBkZXNjcmliZWQgaW4gdGhlIHtMYXVuY2hFeHRlcm5hbFByb2Nlc3NMaXN0bmVyfSB0eXBlIGRlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IGluaXRpYWxXaW5kb3dTdGF0ZSBJbml0aWFsIHdpbmRvdyBzdGF0ZSBhZnRlciBsYXVuY2hpbmc6ICdub3JtYWwnIChkZWZhdWx0KSwgJ21pbmltaXplZCcsICdtYXhpbWl6ZWQnXG4gKi9cbi8qKlxuICogRnJhbWVJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBGcmFtZUluZm9cbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZyYW1lXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB1dWlkIFRoZSB1dWlkIG9mIHRoZSBmcmFtZVxuICogQHByb3BlcnR5IHsgRW50aXR5VHlwZSB9IGVudGl0eVR5cGUgVGhlIGVudGl0eSB0eXBlLCBjb3VsZCBiZSAnd2luZG93JywgJ2lmcmFtZScsICdleHRlcm5hbCBjb25uZWN0aW9uJyBvciAndW5rbm93bidcbiAqIEBwcm9wZXJ0eSB7IElkZW50aXR5IH0gcGFyZW50IFRoZSBwYXJlbnQgaWRlbnRpdHlcbiAqL1xuLyoqXG4gKiBHZXRMb2dSZXF1ZXN0VHlwZSBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gR2V0TG9nUmVxdWVzdFR5cGVcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHJ1bm5pbmcgYXBwbGljYXRpb25cbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IGVuZEZpbGUgVGhlIGZpbGUgbGVuZ3RoIG9mIHRoZSBsb2cgZmlsZVxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gc2l6ZUxpbWl0IFRoZSBzZXQgc2l6ZSBsaW1pdCBvZiB0aGUgbG9nIGZpbGVcbiAqL1xuLyoqXG4gKiBHcHVJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBHcHVJbmZvXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBuYW1lIFRoZSBncmFwaGljcyBjYXJkIG5hbWVcbiAqL1xuLyoqXG4gKiBIb3N0U3BlY3MgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IEhvc3RTcGVjc1xuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IGFlcm9HbGFzc0VuYWJsZWQgVmFsdWUgdG8gY2hlY2sgaWYgQWVybyBHbGFzcyB0aGVtZSBpcyBzdXBwb3J0ZWQgb24gV2luZG93cyBwbGF0Zm9ybXNcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IGFyY2ggXCJ4ODZcIiBmb3IgMzItYml0IG9yIFwieDg2XzY0XCIgZm9yIDY0LWJpdFxuICogQHByb3BlcnR5IHsgQXJyYXk8Q3B1SW5mbz4gfSBjcHVzIFRoZSBzYW1lIHBheWxvYWQgYXMgTm9kZSdzIG9zLmNwdXMoKVxuICogQHByb3BlcnR5IHsgR3B1SW5mbyB9IGdwdSBUaGUgZ3JhcGhpY3MgY2FyZCBuYW1lXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBtZW1vcnkgVGhlIHNhbWUgcGF5bG9hZCBhcyBOb2RlJ3Mgb3MudG90YWxtZW0oKVxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gbmFtZSBUaGUgT1MgbmFtZSBhbmQgdmVyc2lvbi9lZGl0aW9uXG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gc2NyZWVuU2F2ZXIgVmFsdWUgdG8gY2hlY2sgaWYgc2NyZWVuc2F2ZXIgaXMgcnVubmluZy4gU3VwcG9ydGVkIG9uIFdpbmRvd3Mgb25seVxuICovXG4vKipcbiAqIElkZW50aXR5IGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBJZGVudGl0eVxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gbmFtZSBPcHRpb25hbCAtIHRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnRcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHV1aWQgVW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGFwcGxpY2F0aW9uXG4gKi9cbi8qKlxuICogTG9nSW5mbyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gTG9nSW5mb1xuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gbmFtZSBUaGUgZmlsZW5hbWUgb2YgdGhlIGxvZ1xuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgbG9nIGluIGJ5dGVzXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBkYXRlIFRoZSB1bml4IHRpbWUgYXQgd2hpY2ggdGhlIGxvZyB3YXMgY3JlYXRlZCBcIlRodSBKYW4gMDggMjAxNSAxNDo0MDozMCBHTVQtMDUwMCAoRWFzdGVybiBTdGFuZGFyZCBUaW1lKVwiXG4gKi9cbi8qKlxuICogTWFuaWZlc3RJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBNYW5pZmVzdEluZm9cbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHV1aWQgVGhlIHV1aWQgb2YgdGhlIGFwcGxpY2F0aW9uXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBtYW5pZmVzdFVybCBUaGUgcnVudGltZSBtYW5pZmVzdCBVUkxcbiAqL1xuLyoqXG4gKiBNb25pdG9yRGV0YWlscyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gTW9uaXRvckRldGFpbHNcbiAqIEBwcm9wZXJ0eSB7IERpcFNjYWxlUmVjdHMgfSBhdmFpbGFibGUgVGhlIGF2YWlsYWJsZSBESVAgc2NhbGUgY29vcmRpbmF0ZXNcbiAqIEBwcm9wZXJ0eSB7IFJlY3QgfSBhdmFpbGFibGVSZWN0IFRoZSBhdmFpbGFibGUgbW9uaXRvciBjb29yZGluYXRlc1xuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gZGV2aWNlSWQgVGhlIGRldmljZSBpZCBvZiB0aGUgZGlzcGxheVxuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IGRpc3BsYXlEZXZpY2VBY3RpdmUgdHJ1ZSBpZiB0aGUgZGlzcGxheSBpcyBhY3RpdmVcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IGRldmljZVNjYWxlRmFjdG9yIFRoZSBkZXZpY2Ugc2NhbGUgZmFjdG9yXG4gKiBAcHJvcGVydHkgeyBSZWN0IH0gbW9uaXRvclJlY3QgVGhlIG1vbml0b3IgY29vcmRpbmF0ZXNcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGRpc3BsYXlcbiAqIEBwcm9wZXJ0eSB7IFBvaW50IH0gZHBpIFRoZSBkb3RzIHBlciBpbmNoXG4gKiBAcHJvcGVydHkgeyBEaXBTY2FsZVJlY3RzIH0gbW9uaXRvciBUaGUgbW9uaXRvciBjb29yZGluYXRlc1xuICovXG4vKipcbiAqIE1vbml0b3JJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBNb25pdG9ySW5mb1xuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gZGV2aWNlU2NhbGVGYWN0b3IgVGhlIGRldmljZSBzY2FsZSBmYWN0b3JcbiAqIEBwcm9wZXJ0eSB7IFBvaW50IH0gZHBpIFRoZSBkb3RzIHBlciBpbmNoXG4gKiBAcHJvcGVydHkgeyBBcnJheTxNb25pdG9yRGV0YWlscz4gfSBub25QcmltYXJ5TW9uaXRvcnMgVGhlIGFycmF5IG9mIG1vbml0b3IgZGV0YWlsc1xuICogQHByb3BlcnR5IHsgTW9uaXRvckRldGFpbHMgfSBwcmltYXJ5TW9uaXRvciBUaGUgbW9uaXRvciBkZXRhaWxzXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSByZWFzb24gYWx3YXlzIFwiYXBpLXF1ZXJ5XCJcbiAqIEBwcm9wZXJ0eSB7IFRhc2tCYXIgfSB0YXNrQmFyIFRoZSB0YXNrYmFyIG9uIG1vbml0b3JcbiAqIEBwcm9wZXJ0eSB7IERpcFJlY3QgfSB2aXJ0dWFsU2NyZWVuIFRoZSB2aXJ0dWFsIGRpc3BsYXkgc2NyZWVuIGNvb3JkaW5hdGVzXG4gKi9cbi8qKlxuICogQHR5cGVkZWYgeyB2ZXJib3NlIHwgaW5mbyB8IHdhcm5pbmcgfCBlcnJvciB8IGZhdGFsIH0gTG9nTGV2ZWxcbiAqIEBzdW1tYXJ5IExvZyB2ZXJib3NpdHkgbGV2ZWxzLlxuICogQGRlc2MgRGVzY3JpYmVzIHRoZSBtaW5pbXVtIGxldmVsIChpbmNsdXNpdmUpIGFib3ZlIHdoaWNoIGxvZ3Mgd2lsbCBiZSB3cml0dGVuXG4gKlxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gdmVyYm9zZSBhbGwgbG9ncyB3cml0dGVuXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBpbmZvIGluZm8gYW5kIGFib3ZlXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB3YXJuaW5nIHdhcm5pbmcgYW5kIGFib3ZlXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBlcnJvciBlcnJvciBhbmQgYWJvdmVcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IGZhdGFsIGZhdGFsIG9ubHksIGluZGljYXRlcyBhIGNyYXNoIGlzIGltbWluZW50XG4gKi9cbi8qKlxuICogUG9pbnRUb3BMZWZ0IGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBQb2ludFRvcExlZnRcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHRvcCBUaGUgbW91c2UgdG9wIHBvc2l0aW9uIGluIHZpcnR1YWwgc2NyZWVuIGNvb3JkaW5hdGVzXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBsZWZ0IFRoZSBtb3VzZSBsZWZ0IHBvc2l0aW9uIGluIHZpcnR1YWwgc2NyZWVuIGNvb3JkaW5hdGVzXG4gKi9cbi8qKlxuICogUG9pbnQgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFBvaW50XG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSB4IFRoZSBtb3VzZSB4IHBvc2l0aW9uXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSB5IFRoZSBtb3VzZSB5IHBvc2l0aW9uXG4gKi9cbi8qKlxuICogUHJvY2Vzc0luZm8gaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFByb2Nlc3NJbmZvXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBjcHVVc2FnZSBUaGUgcGVyY2VudGFnZSBvZiB0b3RhbCBDUFUgdXNhZ2VcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IG5hbWUgVGhlIGFwcGxpY2F0aW9uIG5hbWVcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IG5vblBhZ2VkUG9vbFVzYWdlIFRoZSBjdXJyZW50IG5vbnBhZ2VkIHBvb2wgdXNhZ2UgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBhZ2VGYXVsdENvdW50IFRoZSBudW1iZXIgb2YgcGFnZSBmYXVsdHNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBhZ2VkUG9vbFVzYWdlIFRoZSBjdXJyZW50IHBhZ2VkIHBvb2wgdXNhZ2UgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBhZ2VmaWxlVXNhZ2UgVGhlIHRvdGFsIGFtb3VudCBvZiBtZW1vcnkgaW4gYnl0ZXMgdGhhdCB0aGUgbWVtb3J5IG1hbmFnZXIgaGFzIGNvbW1pdHRlZFxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gcGVha05vblBhZ2VkUG9vbFVzYWdlIFRoZSBwZWFrIG5vbnBhZ2VkIHBvb2wgdXNhZ2UgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBlYWtQYWdlZFBvb2xVc2FnZSBUaGUgcGVhayBwYWdlZCBwb29sIHVzYWdlIGluIGJ5dGVzXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBwZWFrUGFnZWZpbGVVc2FnZSBUaGUgcGVhayB2YWx1ZSBpbiBieXRlcyBvZiBwYWdlZmlsZVVzYWdlIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhpcyBwcm9jZXNzXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBwZWFrV29ya2luZ1NldFNpemUgVGhlIHBlYWsgd29ya2luZyBzZXQgc2l6ZSBpbiBieXRlc1xuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gcHJvY2Vzc0lkIFRoZSBuYXRpdmUgcHJvY2VzcyBpZGVudGlmaWVyXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB1dWlkIFRoZSBhcHBsaWNhdGlvbiBVVUlEXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSB3b3JraW5nU2V0U2l6ZSBUaGUgY3VycmVudCB3b3JraW5nIHNldCBzaXplIChib3RoIHNoYXJlZCBhbmQgcHJpdmF0ZSBkYXRhKSBpbiBieXRlc1xuICovXG4vKipcbiAqIFN5c3RlbVByb2Nlc3NJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBTeXN0ZW1Qcm9jZXNzSW5mb1xuICogQHByb3BlcnR5IHsgUHJvY2Vzc0RldGFpbHMgfSBicm93c2VyUHJvY2VzcyBJbmZvIG9uIGJyb3dzZXIgcHJvY2Vzc1xuICogQHByb3BlcnR5IHsgQXJyYXk8QXBwUHJvY2Vzc0luZm8+IH0gYXBwcyBBcnJheSBvZiBhcHBzIGFuZCB0aGVpciBwcm9jZXNzIGluZm9cbiAqL1xuLyoqXG4gKiBBcHBQcm9jZXNzSW5mbyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gQXBwUHJvY2Vzc0luZm9cbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHV1aWQgVGhlIHV1aWQgb2YgdGhlIGFwcGxpY2F0aW9uXG4gKiBAcHJvcGVydHkgeyBBcnJheTxFbnRpdHlQcm9jZXNzRGV0YWlscz4gfSBlbnRpdGllcyAgQXJyYXkgb2YgcHJvY2VzcyBpbmZvIGZvciBlYWNoIHdpbmRvdyBhbmQgdmlldyBmb3IgdGhlIGFwcGxpY2F0aW9uXG4gKi9cbi8qKlxuICogRW50aXR5UHJvY2Vzc0RldGFpbHMgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IEVudGl0eVByb2Nlc3NEZXRhaWxzXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB1dWlkIFRoZSB1dWlkIGZvciB0aGUgZW50aXR5XG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBuYW1lIFRoZSBuYW1lIGZvciB0aGUgZW50aXR5XG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB1cmwgVVJMIGFzc29jaWF0ZWQgd2l0aCB0aGUgZW50aXR5XG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBlbnRpdHlUeXBlIFR5cGUgZm9yIHRoZSBlbnRpdHk6IHdpbmRvdyBvciB2aWV3XG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBjcHVVc2FnZSBUaGUgcGVyY2VudGFnZSBvZiB0b3RhbCBDUFUgdXNhZ2VcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IG5vblBhZ2VkUG9vbFVzYWdlIFRoZSBjdXJyZW50IG5vbnBhZ2VkIHBvb2wgdXNhZ2UgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBhZ2VGYXVsdENvdW50IFRoZSBudW1iZXIgb2YgcGFnZSBmYXVsdHNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBhZ2VkUG9vbFVzYWdlIFRoZSBjdXJyZW50IHBhZ2VkIHBvb2wgdXNhZ2UgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBhZ2VmaWxlVXNhZ2UgVGhlIHRvdGFsIGFtb3VudCBvZiBtZW1vcnkgaW4gYnl0ZXMgdGhhdCB0aGUgbWVtb3J5IG1hbmFnZXIgaGFzIGNvbW1pdHRlZFxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gcGVha05vblBhZ2VkUG9vbFVzYWdlIFRoZSBwZWFrIG5vbnBhZ2VkIHBvb2wgdXNhZ2UgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBlYWtQYWdlZFBvb2xVc2FnZSBUaGUgcGVhayBwYWdlZCBwb29sIHVzYWdlIGluIGJ5dGVzXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBwZWFrUGFnZWZpbGVVc2FnZSBUaGUgcGVhayB2YWx1ZSBpbiBieXRlcyBvZiBwYWdlZmlsZVVzYWdlIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhpcyBwcm9jZXNzXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBwZWFrV29ya2luZ1NldFNpemUgVGhlIHBlYWsgd29ya2luZyBzZXQgc2l6ZSBpbiBieXRlc1xuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gd29ya2luZ1NldFNpemUgVGhlIGN1cnJlbnQgd29ya2luZyBzZXQgc2l6ZSAoYm90aCBzaGFyZWQgYW5kIHByaXZhdGUgZGF0YSkgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBpZCBUaGUgbmF0aXZlIHByb2Nlc3MgaWRlbnRpZmllclxuICogQHByb3BlcnR5IHsgQXJyYXk8RnJhbWVQcm9jZXNzRGV0YWlscz4gfSBmcmFtZXMgQXJyYXkgb2YgcHJvY2VzcyBpbmZvIGZvciBlYWNoIGlmcmFtZSBjb3JyZXNwb25lZGluZyB0byB0aGUgZW50aXR5XG4gKi9cbi8qKlxuICogRnJhbWVQcm9jZXNzRGV0YWlscyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gRnJhbWVQcm9jZXNzRGV0YWlsc1xuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gdXJsIEN1cnJlbnQgVVJMIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvY2Vzc1xuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gZW50aXR5VHlwZSBUeXBlIGZvciB0aGUgZnJhbWVcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IGNwdVVzYWdlIFRoZSBwZXJjZW50YWdlIG9mIHRvdGFsIENQVSB1c2FnZVxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gbm9uUGFnZWRQb29sVXNhZ2UgVGhlIGN1cnJlbnQgbm9ucGFnZWQgcG9vbCB1c2FnZSBpbiBieXRlc1xuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gcGFnZUZhdWx0Q291bnQgVGhlIG51bWJlciBvZiBwYWdlIGZhdWx0c1xuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gcGFnZWRQb29sVXNhZ2UgVGhlIGN1cnJlbnQgcGFnZWQgcG9vbCB1c2FnZSBpbiBieXRlc1xuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gcGFnZWZpbGVVc2FnZSBUaGUgdG90YWwgYW1vdW50IG9mIG1lbW9yeSBpbiBieXRlcyB0aGF0IHRoZSBtZW1vcnkgbWFuYWdlciBoYXMgY29tbWl0dGVkXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBwZWFrTm9uUGFnZWRQb29sVXNhZ2UgVGhlIHBlYWsgbm9ucGFnZWQgcG9vbCB1c2FnZSBpbiBieXRlc1xuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gcGVha1BhZ2VkUG9vbFVzYWdlIFRoZSBwZWFrIHBhZ2VkIHBvb2wgdXNhZ2UgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBlYWtQYWdlZmlsZVVzYWdlIFRoZSBwZWFrIHZhbHVlIGluIGJ5dGVzIG9mIHBhZ2VmaWxlVXNhZ2UgZHVyaW5nIHRoZSBsaWZldGltZSBvZiB0aGlzIHByb2Nlc3NcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBlYWtXb3JraW5nU2V0U2l6ZSBUaGUgcGVhayB3b3JraW5nIHNldCBzaXplIGluIGJ5dGVzXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSB3b3JraW5nU2V0U2l6ZSBUaGUgY3VycmVudCB3b3JraW5nIHNldCBzaXplIChib3RoIHNoYXJlZCBhbmQgcHJpdmF0ZSBkYXRhKSBpbiBieXRlc1xuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gcGlkIFRoZSBuYXRpdmUgcHJvY2VzcyBpZGVudGlmaWVyXG4gKi9cbi8qKlxuICogUHJvY2Vzc0RldGFpbHMgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFByb2Nlc3NEZXRhaWxzXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBjcHVVc2FnZSBUaGUgcGVyY2VudGFnZSBvZiB0b3RhbCBDUFUgdXNhZ2VcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IG5vblBhZ2VkUG9vbFVzYWdlIFRoZSBjdXJyZW50IG5vbnBhZ2VkIHBvb2wgdXNhZ2UgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBhZ2VGYXVsdENvdW50IFRoZSBudW1iZXIgb2YgcGFnZSBmYXVsdHNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBhZ2VkUG9vbFVzYWdlIFRoZSBjdXJyZW50IHBhZ2VkIHBvb2wgdXNhZ2UgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBhZ2VmaWxlVXNhZ2UgVGhlIHRvdGFsIGFtb3VudCBvZiBtZW1vcnkgaW4gYnl0ZXMgdGhhdCB0aGUgbWVtb3J5IG1hbmFnZXIgaGFzIGNvbW1pdHRlZFxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gcGVha05vblBhZ2VkUG9vbFVzYWdlIFRoZSBwZWFrIG5vbnBhZ2VkIHBvb2wgdXNhZ2UgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBlYWtQYWdlZFBvb2xVc2FnZSBUaGUgcGVhayBwYWdlZCBwb29sIHVzYWdlIGluIGJ5dGVzXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBwZWFrUGFnZWZpbGVVc2FnZSBUaGUgcGVhayB2YWx1ZSBpbiBieXRlcyBvZiBwYWdlZmlsZVVzYWdlIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhpcyBwcm9jZXNzXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBwZWFrV29ya2luZ1NldFNpemUgVGhlIHBlYWsgd29ya2luZyBzZXQgc2l6ZSBpbiBieXRlc1xuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gd29ya2luZ1NldFNpemUgVGhlIGN1cnJlbnQgd29ya2luZyBzZXQgc2l6ZSAoYm90aCBzaGFyZWQgYW5kIHByaXZhdGUgZGF0YSkgaW4gYnl0ZXNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHBpZCBUaGUgbmF0aXZlIHByb2Nlc3MgaWRlbnRpZmllclxuICovXG4vKipcbiAqIFByb3h5Q29uZmlnIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBQcm94eUNvbmZpZ1xuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gcHJveHlBZGRyZXNzIFRoZSBjb25maWd1cmVkIHByb3h5IGFkZHJlc3NcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHByb3h5UG9ydCBUaGUgY29uZmlndXJlZCBwcm94eSBwb3J0XG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB0eXBlIFRoZSBwcm94eSBUeXBlXG4gKi9cbi8qKlxuICogUHJveHlJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBQcm94eUluZm9cbiAqIEBwcm9wZXJ0eSB7IFByb3h5Q29uZmlnIH0gY29uZmlnIFRoZSBwcm94eSBjb25maWdcbiAqIEBwcm9wZXJ0eSB7IFByb3h5U3lzdGVtSW5mbyB9IHN5c3RlbSBUaGUgcHJveHkgc3lzdGVtIGluZm9cbiAqL1xuLyoqXG4gKiBRdWVyeVBlcm1pc3Npb25SZXN1bHQgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFF1ZXJ5UGVybWlzc2lvblJlc3VsdFxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gcGVybWlzc2lvbiBUaGUgZnVsbCBuYW1lIG9mIGEgc2VjdXJlZCBBUElcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHN0YXRlICdncmFudGVkJyB8ICdkZW5pZWQnIHwgJ3VuYXZhaWxhYmxlJ1xuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IGdyYW50ZWQgdHJ1ZSBpZiBwZXJtaXNzaW9uIGlzIGdyYW50ZWRcbiAqIEBwcm9wZXJ0eSB7IG9iamVjdCB9IFtyYXdWYWx1ZV0gVGhlIHZhbHVlIG9mIHBlcm1pc3Npb25cbiAqL1xuLyoqXG4gKiBQcm94eVN5c3RlbUluZm8gaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFByb3h5U3lzdGVtSW5mb1xuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gYXV0b0NvbmZpZ1VybCBUaGUgYXV0byBjb25maWd1cmF0aW9uIHVybFxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gYnlwYXNzIFRoZSBwcm94eSBieXBhc3MgaW5mb1xuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IGVuYWJsZWQgVmFsdWUgdG8gY2hlY2sgaWYgYSBwcm94eSBpcyBlbmFibGVkXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBwcm94eSBUaGUgcHJveHkgaW5mb1xuICovXG4vKipcbiAqIFJlY3QgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFJlY3RcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IGJvdHRvbSBUaGUgYm90dG9tLW1vc3QgY29vcmRpbmF0ZVxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gbGVmdCBUaGUgbGVmdC1tb3N0IGNvb3JkaW5hdGVcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHJpZ2h0IFRoZSByaWdodC1tb3N0IGNvb3JkaW5hdGVcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHRvcCBUaGUgdG9wLW1vc3QgY29vcmRpbmF0ZVxuICovXG4vKipcbiAqIFJlZ2lzdHJ5SW5mbyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gUmVnaXN0cnlJbmZvXG4gKiBAcHJvcGVydHkgeyBhbnkgfSBkYXRhIFRoZSByZWdpc3RyeSBkYXRhXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSByb290S2V5IFRoZSByZWdpc3RyeSByb290IGtleVxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gc3Via2V5IFRoZSByZWdpc3RyeSBrZXlcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHR5cGUgVGhlIHJlZ2lzdHJ5IHR5cGVcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHZhbHVlIFRoZSByZWdpc3RyeSB2YWx1ZSBuYW1lXG4gKi9cbi8qKlxuICogUnVudGltZURvd25sb2FkT3B0aW9ucyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gUnVudGltZURvd25sb2FkT3B0aW9uc1xuICogQGRlc2MgVGhlc2UgYXJlIHRoZSBvcHRpb25zIG9iamVjdCByZXF1aXJlZCBieSB0aGUgZG93bmxvYWRSdW50aW1lIGZ1bmN0aW9uLlxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gdmVyc2lvbiBUaGUgZ2l2ZW4gdmVyc2lvbiB0byBkb3dubG9hZFxuICovXG4vKipcbiAqIFJ1bnRpbWVJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBSdW50aW1lSW5mb1xuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gYXJjaGl0ZWN0dXJlIFRoZSBydW50aW1lIGJ1aWxkIGFyY2hpdGVjdHVyZVxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gbWFuaWZlc3RVcmwgVGhlIHJ1bnRpbWUgbWFuaWZlc3QgVVJMXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBwb3J0IFRoZSBydW50aW1lIHdlYnNvY2tldCBwb3J0XG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBzZWN1cml0eVJlYWxtIFRoZSBydW50aW1lIHNlY3VyaXR5IHJlYWxtXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSB2ZXJzaW9uIFRoZSBydW50aW1lIHZlcnNpb25cbiAqIEBwcm9wZXJ0eSB7IG9iamVjdCB9IGFyZ3MgdGhlIGNvbW1hbmQgbGluZSBhcmd1bWVudCB1c2VkIHRvIHN0YXJ0IHRoZSBSdW50aW1lXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBjaHJvbWVWZXJzaW9uIFRoZSBjaHJvbWUgdmVyc2lvblxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gZWxlY3Ryb25WZXJzaW9uIFRoZSBlbGVjdHJvbiB2ZXJzaW9uXG4gKi9cbi8qKlxuICogUlZNSW5mbyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gUlZNSW5mb1xuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gYWN0aW9uIFRoZSBuYW1lIG9mIGFjdGlvbjogXCJnZXQtcnZtLWluZm9cIlxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gYXBwTG9nRGlyZWN0b3J5IFRoZSBhcHAgbG9nIGRpcmVjdG9yeVxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gcGF0aCBUaGUgcGF0aCBvZiBPcGVuZmluUlZNLmV4ZVxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gJ3N0YXJ0LXRpbWUnIFRoZSBzdGFydCB0aW1lIG9mIFJWTVxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gdmVyc2lvbiBUaGUgdmVyc2lvbiBvZiBSVk1cbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9ICd3b3JraW5nLWRpcicgVGhlIHdvcmtpbmcgZGlyZWN0b3J5XG4gKi9cbi8qKlxuICogUnZtTGF1bmNoT3B0aW9ucyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gUnZtTGF1bmNoT3B0aW9uc1xuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IFtub1VpXSB0cnVlIGlmIG5vIFVJIHdoZW4gbGF1bmNoaW5nXG4gKiBAcHJvcGVydHkgeyBvYmplY3QgfSBbdXNlckFwcENvbmZpZ0FyZ3NdIFRoZSB1c2VyIGFwcCBjb25maWd1cmF0aW9uIGFyZ3NcbiAqL1xuLyoqXG4gKiBTZXJ2aWNlSWRlbnRpZmllciBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gU2VydmljZUlkZW50aWZpZXJcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2VcbiAqL1xuLyoqXG4gKiBTZXJ2aWNlQ29uZmlndXJhdGlvbiBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gU2VydmljZUNvbmZpZ3VyYXRpb25cbiAqIEBwcm9wZXJ0eSB7IG9iamVjdCB9IGNvbmZpZyBUaGUgc2VydmljZSBjb25maWd1cmF0aW9uXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzZXJ2aWNlXG4gKi9cbi8qKlxuICogU2hvcnRDdXRDb25maWcgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFNob3J0Q3V0Q29uZmlnXG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gZGVza3RvcCB0cnVlIGlmIGFwcGxpY2F0aW9uIGhhcyBhIHNob3J0Y3V0IG9uIHRoZSBkZXNrdG9wXG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gc3RhcnRNZW51IHRydWUgaWYgYXBwbGljYXRpb24gaGFzIHNob3J0Y3V0IGluIHRoZSBzdGFydCBtZW51XG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gc3lzdGVtU3RhcnR1cCB0cnVlIGlmIGFwcGxpY2F0aW9uIHdpbGwgYmUgbGF1bmNoZWQgb24gc3lzdGVtIHN0YXJ0dXBcbiAqL1xuLyoqXG4gKiBTdWJPcHRpb25zIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBPYmplY3QgfSBTdWJPcHRpb25zXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSB0aW1lc3RhbXAgVGhlIGV2ZW50IHRpbWVzdGFtcFxuICovXG4vKipcbiAqIFRhc2tCYXIgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFRhc2tCYXJcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IGVkZ2Ugd2hpY2ggZWRnZSBvZiBhIG1vbml0b3IgdGhlIHRhc2tiYXIgaXMgb25cbiAqIEBwcm9wZXJ0eSB7IFJlY3QgfSByZWN0IFRoZSB0YXNrYmFyIGNvb3JkaW5hdGVzXG4gKi9cbi8qKlxuICogVGVybWluYXRlRXh0ZXJuYWxSZXF1ZXN0VHlwZSBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gVGVybWluYXRlRXh0ZXJuYWxSZXF1ZXN0VHlwZVxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gdXVpZCBUaGUgdXVpZCBvZiB0aGUgcnVubmluZyBhcHBsaWNhdGlvblxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gdGltZW91dCBUaW1lIG91dCBwZXJpb2QgYmVmb3JlIHRoZSBydW5uaW5nIGFwcGxpY2F0aW9uIHRlcm1pbmF0ZXNcbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBraWxsdHJlZSBWYWx1ZSB0byB0ZXJtaW5hdGUgdGhlIHJ1bm5pbmcgYXBwbGljYXRpb25cbiAqL1xuLyoqXG4gKiBUaW1lIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBUaW1lXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSB1c2VyIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoZSBDUFUgaGFzIHNwZW50IGluIHVzZXIgbW9kZVxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gbmljZSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGUgQ1BVIGhhcyBzcGVudCBpbiBuaWNlIG1vZGVcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHN5cyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGUgQ1BVIGhhcyBzcGVudCBpbiBzeXMgbW9kZVxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gaWRsZSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGUgQ1BVIGhhcyBzcGVudCBpbiBpZGxlIG1vZGVcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IGlycSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGUgQ1BVIGhhcyBzcGVudCBpbiBpcnEgbW9kZVxuICovXG4vKipcbiAqIFRyYXlJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBUcmF5SW5mb1xuICogQHByb3BlcnR5IHsgQm91bmRzIH0gYm91bmRzIFRoZSBib3VuZCBvZiB0cmF5IGljb24gaW4gdmlydHVhbCBzY3JlZW4gcGl4ZWxzXG4gKiBAcHJvcGVydHkgeyBNb25pdG9ySW5mbyB9IG1vbml0b3JJbmZvIFBsZWFzZSBzZWUgZmluLlN5c3RlbS5nZXRNb25pdG9ySW5mbyBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0geCBjb3B5IG9mIGJvdW5kcy54XG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSB5IGNvcHkgb2YgYm91bmRzLnlcbiAqL1xuLyoqXG4gKiBXaW5kb3dEZXRhaWwgaW50ZXJmYWNlXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IFdpbmRvd0RldGFpbFxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gYm90dG9tIFRoZSBib3R0b20tbW9zdCBjb29yZGluYXRlIG9mIHRoZSB3aW5kb3dcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSB3aW5kb3dcbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBpc1Nob3dpbmcgVmFsdWUgdG8gY2hlY2sgaWYgdGhlIHdpbmRvdyBpcyBzaG93aW5nXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBsZWZ0IFRoZSBsZWZ0LW1vc3QgY29vcmRpbmF0ZSBvZiB0aGUgd2luZG93XG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB3aW5kb3dcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHJpZ2h0IFRoZSByaWdodC1tb3N0IGNvb3JkaW5hdGUgb2YgdGhlIHdpbmRvd1xuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gc3RhdGUgVGhlIHdpbmRvdyBzdGF0ZVxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gdG9wIFRoZSB0b3AtbW9zdCBjb29yZGluYXRlIG9mIHRoZSB3aW5kb3dcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgd2luZG93XG4gKi9cbi8qKlxuICogV2luZG93SW5mbyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gV2luZG93SW5mb1xuICogQHByb3BlcnR5IHsgQXJyYXk8V2luZG93RGV0YWlsPiB9IGNoaWxkV2luZG93cyBUaGUgYXJyYXkgb2YgY2hpbGQgd2luZG93cyBkZXRhaWxzXG4gKiBAcHJvcGVydHkgeyBXaW5kb3dEZXRhaWwgfSBtYWluV2luZG93IFRoZSBtYWluIHdpbmRvdyBkZXRhaWxcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHV1aWQgVGhlIHV1aWQgb2YgdGhlIGFwcGxpY2F0aW9uXG4gKi9cbi8qKlxuICogQ2VydGlmaWVkQXBwSW5mbyBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gQ2VydGlmaWVkQXBwSW5mb1xuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IGlzUnVubmluZyB0cnVlIGlmIHRoZSBhcHAgaXMgcnVubmluZ1xuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IFtpc09wdGVkSW50b0NlcnRmaWVkQXBwXSB0cnVlIGlmIHRoZSBhcHAgaGFzIG9wdGVkIGludG8gY2VydGlmaWNhdGlvblxuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IFtpc0NlcnRpZmllZF0gdHJ1ZSBpZiB0aGUgYXBwIGlzIGNlcnRpZmllZFxuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IFtpc1NTTENlcnRpZmllZF0gdHJ1ZSBpZiB0aGUgYXBwIG1hbmlmZXN0J3MgU1NMIGNlcnRpZmljYXRlIGlzIHZhbGlkXG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gW2lzUHJlc2VudEluQXBwRGlyZWN0b3J5XSB0cnVlIGlmIHRoZSBhcHAgaXMgcHJlc2VudCBpbiB0aGUgT3BlbkZpbiBhcHAgZGlyZWN0b3J5XG4gKi9cbi8qKlxuICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY29yZSBvZiBPcGVuRmluIFJ1bnRpbWUuIEFsbG93cyB0aGUgZGV2ZWxvcGVyXG4gKiB0byBwZXJmb3JtIHN5c3RlbS1sZXZlbCBhY3Rpb25zLCBzdWNoIGFzIGFjY2Vzc2luZyBsb2dzLCB2aWV3aW5nIHByb2Nlc3NlcyxcbiAqIGNsZWFyaW5nIHRoZSBjYWNoZSBhbmQgZXhpdGluZyB0aGUgcnVudGltZSBhcyB3ZWxsIGFzIGxpc3RlbiB0byA8YSBocmVmPVwidHV0b3JpYWwtU3lzdGVtLkV2ZW50RW1pdHRlci5odG1sXCI+c3lzdGVtIGV2ZW50czwvYT4uXG4gKiBAbmFtZXNwYWNlXG4gKi9cbmNsYXNzIFN5c3RlbSBleHRlbmRzIGJhc2VfMS5FbWl0dGVyQmFzZSB7XG4gICAgY29uc3RydWN0b3Iod2lyZSkge1xuICAgICAgICBzdXBlcih3aXJlLCBbJ3N5c3RlbSddKTtcbiAgICB9XG4gICAgc2VuZEV4dGVybmFsUHJvY2Vzc1JlcXVlc3QoYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGl0RXZlbnRLZXkgPSAnZXh0ZXJuYWwtcHJvY2Vzcy1leGl0ZWQnO1xuICAgICAgICAgICAgbGV0IHByb2Nlc3NVdWlkO1xuICAgICAgICAgICAgbGV0IGV4aXRQYXlsb2FkO1xuICAgICAgICAgICAgbGV0IGV4dGVybmFsUHJvY2Vzc0V4aXRIYW5kbGVyO1xuICAgICAgICAgICAgbGV0IG9mV2luZG93O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxQcm9jZXNzRXhpdEhhbmRsZXIgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcGF5bG9hZCB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZXhpdFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpYzogJ2V4aXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB1dWlkOiBkYXRhLnByb2Nlc3NVdWlkIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdENvZGU6IGRhdGEuZXhpdENvZGUgfHwgMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc1V1aWQgPT09IHBheWxvYWQucHJvY2Vzc1V1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubGlzdGVuZXIoZXhpdFBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2ZXaW5kb3cucmVtb3ZlTGlzdGVuZXIoZXhpdEV2ZW50S2V5LCBleHRlcm5hbFByb2Nlc3NFeGl0SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHdpbmRvdyBjb25zdHJ1Y3RvciBleHBlY3RzIHRoZSBuYW1lIGlzIG5vdCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2lyZS5tZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2lyZS5tZS5uYW1lID0gdGhpcy53aXJlLm1lLnV1aWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mV2luZG93ID0gbmV3IHdpbmRvd18xLl9XaW5kb3codGhpcy53aXJlLCB0aGlzLndpcmUubWUpO1xuICAgICAgICAgICAgICAgIG9mV2luZG93Lm9uKGV4aXRFdmVudEtleSwgZXh0ZXJuYWxQcm9jZXNzRXhpdEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53aXJlXG4gICAgICAgICAgICAgICAgLnNlbmRBY3Rpb24oYWN0aW9uLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIC50aGVuKCh7IHBheWxvYWQgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NVdWlkID0gcGF5bG9hZC5kYXRhLnV1aWQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkLmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChleGl0UGF5bG9hZCAmJiBwcm9jZXNzVXVpZCA9PT0gZXhpdFBheWxvYWQudXVpZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxpc3RlbmVyKGV4aXRQYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgb2ZXaW5kb3cucmVtb3ZlTGlzdGVuZXIoZXhpdEV2ZW50S2V5LCBleHRlcm5hbFByb2Nlc3NFeGl0SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvZldpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICBvZldpbmRvdy5yZW1vdmVMaXN0ZW5lcihleGl0RXZlbnRLZXksIGV4dGVybmFsUHJvY2Vzc0V4aXRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIHwgc3ltYm9sIH0gZXZlbnRUeXBlICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB9IGxpc3RlbmVyIC0gQ2FsbGVkIHdoZW5ldmVyIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIGFkZExpc3RlbmVyXG4gICAgICogQG1lbWJlcm9mIFN5c3RlbVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBDYWxsZWQgd2hlbmV2ZXIgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gb25cbiAgICAgKiBAbWVtYmVyb2YgU3lzdGVtXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5FdmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgb25lIHRpbWUgbGlzdGVuZXIgZm9yIHRoZSBldmVudC4gVGhlIGxpc3RlbmVyIGlzIGludm9rZWQgb25seSB0aGUgZmlyc3QgdGltZSB0aGUgZXZlbnQgaXMgZmlyZWQsIGFmdGVyIHdoaWNoIGl0IGlzIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIHwgc3ltYm9sIH0gZXZlbnRUeXBlICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB9IGxpc3RlbmVyIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7IFN1Yk9wdGlvbnMgfSBbb3B0aW9uc10gLSBPcHRpb24gdG8gc3VwcG9ydCBldmVudCB0aW1lc3RhbXBzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fVxuICAgICAqIEBmdW5jdGlvbiBvbmNlXG4gICAgICogQG1lbWJlcm9mIFN5c3RlbVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lclxuICAgICAqIEBtZW1iZXJvZiBTeXN0ZW1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLkV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBvbmUgdGltZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50LiBUaGUgbGlzdGVuZXIgaXMgaW52b2tlZCBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBldmVudCBpcyBmaXJlZCwgYWZ0ZXIgd2hpY2ggaXQgaXMgcmVtb3ZlZC5cbiAgICAgKiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdGVuZXJzIGFycmF5LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB8IHN5bWJvbCB9IGV2ZW50VHlwZSAgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgRnVuY3Rpb24gfSBsaXN0ZW5lciAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lclxuICAgICAqIEBtZW1iZXJvZiBTeXN0ZW1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLkV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZyb20gdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIENhdXRpb246IENhbGxpbmcgdGhpcyBtZXRob2QgY2hhbmdlcyB0aGUgYXJyYXkgaW5kaWNlcyBpbiB0aGUgbGlzdGVuZXIgYXJyYXkgYmVoaW5kIHRoZSBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyXG4gICAgICogQG1lbWJlcm9mIFN5c3RlbVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB8IHN5bWJvbCB9IFtldmVudFR5cGVdICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzXG4gICAgICogQG1lbWJlcm9mIFN5c3RlbVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGUgcnVudGltZS4gVGhlIHZlcnNpb24gY29udGFpbnMgdGhlIG1ham9yLCBtaW5vcixcbiAgICAgKiBidWlsZCBhbmQgcmV2aXNpb24gbnVtYmVycy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxzdHJpbmc+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0VmVyc2lvblxuICAgICAqL1xuICAgIGdldFZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXZlcnNpb24nKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGNhY2hlZCBkYXRhIGNvbnRhaW5pbmcgYXBwbGljYXRpb24gcmVzb3VyY2VcbiAgICAgKiBmaWxlcyAoaW1hZ2VzLCBIVE1MLCBKYXZhU2NyaXB0IGZpbGVzKSwgY29va2llcywgYW5kIGl0ZW1zIHN0b3JlZCBpbiB0aGVcbiAgICAgKiBMb2NhbCBTdG9yYWdlLlxuICAgICAqIEBwYXJhbSB7IENsZWFyQ2FjaGVPcHRpb24gfSBvcHRpb25zIC0gU2VlIHR1dG9yaWFsIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5jbGVhckNhY2hlXG4gICAgICovXG4gICAgY2xlYXJDYWNoZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignY2xlYXItY2FjaGUnLCBvcHRpb25zKS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY2FjaGVkIGRhdGEgd2hlbiBPcGVuRmluIFJ1bnRpbWUgZXhpdHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5kZWxldGVDYWNoZU9uRXhpdFxuICAgICAqL1xuICAgIGRlbGV0ZUNhY2hlT25FeGl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2RlbGV0ZS1jYWNoZS1yZXF1ZXN0JykudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGl0cyB0aGUgUnVudGltZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLmV4aXRcbiAgICAgKi9cbiAgICBleGl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2V4aXQtZGVza3RvcCcpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIEpTT04gbWFuaWZlc3QgdXNpbmcgdGhlIGJyb3dzZXIgcHJvY2VzcyBhbmQgcmV0dXJucyBhIEphdmFzY3JpcHQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IG1hbmlmZXN0VXJsIFRoZSBVUkwgb2YgdGhlIG1hbmlmZXN0IHRvIGZldGNoLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPGFueT59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5mZXRjaE1hbmlmZXN0XG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hNYW5pZmVzdChtYW5pZmVzdFVybCkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YSB9IH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZmV0Y2gtbWFuaWZlc3QnLCB7IG1hbmlmZXN0VXJsIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFueSB1bndyaXR0ZW4gY29va2llcyBkYXRhIHRvIGRpc2suXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5mbHVzaENvb2tpZVN0b3JlXG4gICAgICovXG4gICAgZmx1c2hDb29raWVTdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdmbHVzaC1jb29raWUtc3RvcmUnKS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhcnJheSBvZiBkYXRhIChuYW1lLCBpZHMsIGJvdW5kcykgZm9yIGFsbCBhcHBsaWNhdGlvbiB3aW5kb3dzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuQXJyYXkuPFdpbmRvd0luZm8+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0QWxsV2luZG93c1xuICAgICAqL1xuICAgIGdldEFsbFdpbmRvd3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWFsbC13aW5kb3dzJykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBhcnJheSBvZiBkYXRhIGZvciBhbGwgYXBwbGljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuQXJyYXkuPEFwcGxpY2F0aW9uSW5mbz59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5nZXRBbGxBcHBsaWNhdGlvbnNcbiAgICAgKi9cbiAgICBnZXRBbGxBcHBsaWNhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWFsbC1hcHBsaWNhdGlvbnMnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjb21tYW5kIGxpbmUgYXJndW1lbnQgc3RyaW5nIHRoYXQgc3RhcnRlZCBPcGVuRmluIFJ1bnRpbWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48c3RyaW5nPn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLmdldENvbW1hbmRMaW5lQXJndW1lbnRzXG4gICAgICovXG4gICAgZ2V0Q29tbWFuZExpbmVBcmd1bWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWNvbW1hbmQtbGluZS1hcmd1bWVudHMnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjcmFzaCByZXBvcnRlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxDcmFzaFJlcG9ydGVyT3B0aW9uPn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLmdldENyYXNoUmVwb3J0ZXJTdGF0ZVxuICAgICAqL1xuICAgIGdldENyYXNoUmVwb3J0ZXJTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtY3Jhc2gtcmVwb3J0ZXItc3RhdGUnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyogPC0tIE5vdGUgdGhlIG9uZSBhc3RlcmlzayB0byBoaWRlIGZyb20ganNkb2MgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIHB1Ymxpc2ggdGhpcyBtZXRob2QgYW55bW9yZS5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFN5c3RlbS5nZXRNYWNoaW5lSWR9IGluc3RlYWQuXG4gICAgICovXG4gICAgZ2V0RGV2aWNlSWQoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRnVuY3Rpb24gaXMgZGVwcmVjYXRlZDsgdXNlIGdldE1hY2hpbmVJZCBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1kZXZpY2UtaWQnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIGNyYXNoIHJlcG9ydGVyIGZvciB0aGUgYnJvd3NlciBwcm9jZXNzIGlmIG5vdCBhbHJlYWR5IHJ1bm5pbmcuXG4gICAgICogWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgYGRpYWdub3N0aWNNb2RlYCB0byBoYXZlIHRoZSBsb2dzIHNlbnQgdG9cbiAgICAgKiBPcGVuRmluIG9uIHJ1bnRpbWUgY2xvc2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IENyYXNoUmVwb3J0ZXJPcHRpb24gfSBvcHRpb25zIC0gY29uZmlndXJlIGNyYXNoIHJlcG9ydGVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48Q3Jhc2hSZXBvcnRlck9wdGlvbj59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5zdGFydENyYXNoUmVwb3J0ZXJcbiAgICAgKi9cbiAgICBzdGFydENyYXNoUmVwb3J0ZXIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRpYWdub3N0aWNNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ2RpYWdub3N0aWNNb2RlIG5vdCBmb3VuZCBpbiBvcHRpb25zJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgICAgIC5zZW5kQWN0aW9uKCdzdGFydC1jcmFzaC1yZXBvcnRlcicsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiByZXNvbHZlKHBheWxvYWQuZGF0YSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGhleCBlbmNvZGVkIGhhc2ggb2YgdGhlIG1hYyBhZGRyZXNzIGFuZCB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxzdHJpbmc+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0RGV2aWNlVXNlcklkXG4gICAgICovXG4gICAgZ2V0RGV2aWNlVXNlcklkKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IGdldERldmljZVVzZXJJZCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFN5c3RlbS5nZXRVbmlxdWVVc2VySWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtZGV2aWNlLXVzZXItaWQnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGhleCBlbmNvZGVkIGhhc2ggb2YgdGhlIG1hY2hpbmUgaWQgYW5kIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIgbmFtZS5cbiAgICAgKiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYSB1c2VyIC8gbWFjaGluZSBjb21iaW5hdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxzdHJpbmc+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0VW5pcXVlVXNlcklkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGdldFVuaXF1ZVVzZXJJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtdW5pcXVlLXVzZXItaWQnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgZnJhbWUgaW5mbyBvYmplY3QgZm9yIHRoZSB1dWlkIGFuZCBuYW1lIHBhc3NlZCBpblxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHV1aWQgLSBUaGUgVVVJRCBvZiB0aGUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGFyZ2V0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPEVudGl0eUluZm8+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0RW50aXR5SW5mb1xuICAgICAqL1xuICAgIGdldEVudGl0eUluZm8odXVpZCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1lbnRpdHktaW5mbycsIHsgdXVpZCwgbmFtZSB9KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBvbiB0aGUgY29tcHV0ZXIgb24gd2hpY2ggdGhlIHJ1bnRpbWUgaXMgaW5zdGFsbGVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48c3RyaW5nPn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLmdldEVudmlyb25tZW50VmFyaWFibGVcbiAgICAgKi9cbiAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGVudk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ2dldC1lbnZpcm9ubWVudC12YXJpYWJsZScsIHtcbiAgICAgICAgICAgIGVudmlyb25tZW50VmFyaWFibGVzOiBlbnZOYW1lXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGZvY3VzZWQgd2luZG93LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPFdpbmRvd0luZm8+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0Rm9jdXNlZFdpbmRvd1xuICAgICAqL1xuICAgIGdldEZvY3VzZWRXaW5kb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWZvY3VzZWQtd2luZG93JykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50bHkgZm9jdXNlZCBleHRlcm5hbCB3aW5kb3cuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48SWRlbnRpdHk+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBTeXN0ZW0uZ2V0Rm9jdXNlZEV4dGVybmFsV2luZG93IHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEZvY3VzZWRFeHRlcm5hbFdpbmRvdygpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBTeXN0ZW0uZ2V0Rm9jdXNlZEV4dGVybmFsV2luZG93IHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLicpO1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YSB9IH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWZvY3VzZWQtZXh0ZXJuYWwtd2luZG93Jyk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBnaXZlbiBhcHAncyBjZXJ0aWZpY2F0aW9uIHN0YXR1c1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPENlcnRpZmllZEFwcEluZm8+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uaXNBcHBDZXJ0aWZpZWRcbiAgICAgKi9cbiAgICBhc3luYyBpc0FwcENlcnRpZmllZChtYW5pZmVzdFVybCkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQ6IHsgZGF0YTogeyBjZXJ0aWZpZWRJbmZvIH0gfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2lzLWFwcC1jZXJ0aWZpZWQnLCB7IG1hbmlmZXN0VXJsIH0pO1xuICAgICAgICByZXR1cm4gY2VydGlmaWVkSW5mbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGluc3RhbGxlZCBydW50aW1lIHZlcnNpb25zIGluIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxzdHJpbmdbXT59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5nZXRJbnN0YWxsZWRSdW50aW1lc1xuICAgICAqL1xuICAgIC8vIGluY29tcGF0aWJsZSB3aXRoIHN0YW5kYWxvbmUgbm9kZSBwcm9jZXNzLlxuICAgIGdldEluc3RhbGxlZFJ1bnRpbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1pbnN0YWxsZWQtcnVudGltZXMnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhLnJ1bnRpbWVzKTtcbiAgICB9XG4gICAgLy8gaW5jb21wYXRpYmxlIHdpdGggc3RhbmRhbG9uZSBub2RlIHByb2Nlc3MuXG4gICAgYXN5bmMgZ2V0SW5zdGFsbGVkQXBwcygpIHtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IGRhdGE6IHsgaW5zdGFsbGVkQXBwcyB9IH0gfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtaW5zdGFsbGVkLWFwcHMnKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbGxlZEFwcHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY29udGVudHMgb2YgdGhlIGxvZyB3aXRoIHRoZSBzcGVjaWZpZWQgZmlsZW5hbWUuXG4gICAgICogQHBhcmFtIHsgR2V0TG9nUmVxdWVzdFR5cGUgfSBvcHRpb25zIEEgb2JqZWN0IHRoYXQgaWQgZGVmaW5lZCBieSB0aGUgR2V0TG9nUmVxdWVzdFR5cGUgaW50ZXJmYWNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48c3RyaW5nPn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLmdldExvZ1xuICAgICAqL1xuICAgIGdldExvZyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigndmlldy1sb2cnLCBvcHRpb25zKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEKSBwcm92aWRlZCBieSB0aGUgbWFjaGluZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxzdHJpbmc+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0TWFjaGluZUlkXG4gICAgICovXG4gICAgZ2V0TWFjaGluZUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1tYWNoaW5lLWlkJykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1pbmltdW0gKGluY2x1c2l2ZSkgbG9nZ2luZyBsZXZlbCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyB3cml0dGVuIHRvIHRoZSBsb2cuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48TG9nTGV2ZWw+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0TWluTG9nTGV2ZWxcbiAgICAgKi9cbiAgICBnZXRNaW5Mb2dMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtbWluLWxvZy1sZXZlbCcpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYXJyYXkgY29udGFpbmluZyBpbmZvcm1hdGlvbiBmb3IgZWFjaCBsb2cgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLkFycmF5PExvZ0luZm8+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0TG9nTGlzdFxuICAgICAqL1xuICAgIGdldExvZ0xpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignbGlzdC1sb2dzJykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBkYXRhIGFib3V0IHRoZSBtb25pdG9yIHNldHVwIG9mIHRoZVxuICAgICAqIGNvbXB1dGVyIHRoYXQgdGhlIHJ1bnRpbWUgaXMgcnVubmluZyBvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxNb25pdG9ySW5mbz59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5nZXRNb25pdG9ySW5mb1xuICAgICAqL1xuICAgIGdldE1vbml0b3JJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1tb25pdG9yLWluZm8nKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW91c2UgaW4gdmlydHVhbCBzY3JlZW4gY29vcmRpbmF0ZXMgKGxlZnQsIHRvcCkuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48UG9pbnRUb3BMZWZ0Pn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLmdldE1vdXNlUG9zaXRpb25cbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1tb3VzZS1wb3NpdGlvbicpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBydW50aW1lIHByb2Nlc3NlcyB0aGF0IGFyZSBjdXJyZW50bHlcbiAgICAgKiBydW5uaW5nLiBFYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB1dWlkXG4gICAgICogYW5kIHRoZSBuYW1lIG9mIHRoZSBhcHBsaWNhdGlvbiB0byB3aGljaCB0aGUgcHJvY2VzcyBiZWxvbmdzLlxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2Ugb3VyIG5ldyBzZXQgb2YgcHJvY2VzcyBBUElzOlxuICAgICAqIFtXaW5kb3cuZ2V0UHJvY2Vzc0luZm9de0BsaW5rIFdpbmRvdyNnZXRQcm9jZXNzSW5mb31cbiAgICAgKiBbVmlldy5nZXRQcm9jZXNzSW5mb117QGxpbmsgVmlldyNnZXRQcm9jZXNzSW5mb31cbiAgICAgKiBbQXBwbGljYXRpb24uZ2V0UHJvY2Vzc0luZm9de0BsaW5rIEFwcGxpY2F0aW9uI2dldFByb2Nlc3NJbmZvfVxuICAgICAqIFtTeXN0ZW0uZ2V0QWxsUHJvY2Vzc0luZm9de0BsaW5rIFN5c3RlbSNnZXRBbGxQcm9jZXNzSW5mb31cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLkFycmF5LjxQcm9jZXNzSW5mbz59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5nZXRQcm9jZXNzTGlzdFxuICAgICAqL1xuICAgIGdldFByb2Nlc3NMaXN0KCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oJ1N5c3RlbS5nZXRQcm9jZXNzTGlzdCBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgY29uc2lkZXIgdXNpbmcgb3VyIG5ldyBwcm9jZXNzIEFQSXM6IFdpbmRvdy5nZXRQcm9jZXNzSW5mbywgVmlldy5nZXRQcm9jZXNzSW5mbywgQXBwbGljYXRpb24uZ2V0UHJvY2Vzc0luZm8sIFN5c3RlbS5nZXRBbGxQcm9jZXNzSW5mbycpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Byb2Nlc3Mtc25hcHNob3QnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBwcm9jZXNzIGluZm9ybWF0aW9uLiBUaGlzIGluY2x1ZGVzIHRoZSBicm93c2VyIHByb2Nlc3MgYW5kIGV2ZXJ5IHByb2Nlc3MgYXNzb2NpYXRlZCB0byBhbGwgZW50aXRpZXMgKHdpbmRvd3MgYW5kIHZpZXdzKS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxTeXN0ZW1Qcm9jZXNzSW5mbz59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5nZXRBbGxQcm9jZXNzSW5mb1xuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyBnZXRBbGxQcm9jZXNzSW5mbygpIHtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkOiB7IGRhdGEgfSB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1hbGwtcHJvY2Vzcy1pbmZvJywgdGhpcy5pZGVudGl0eSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIFByb3h5IHNldHRpbmdzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPFByb3h5SW5mbz59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5nZXRQcm94eVNldHRpbmdzXG4gICAgICovXG4gICAgZ2V0UHJveHlTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtcHJveHktc2V0dGluZ3MnKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVubmluZyBSdW50aW1lIGluIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxSdW50aW1lSW5mbz59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5nZXRSdW50aW1lSW5mb1xuICAgICAqL1xuICAgIGdldFJ1bnRpbWVJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1ydW50aW1lLWluZm8nKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVubmluZyBSVk0gaW4gYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPFJWTUluZm8+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0UnZtSW5mb1xuICAgICAqL1xuICAgIC8vIGluY29tcGF0aWJsZSB3aXRoIHN0YW5kYWxvbmUgbm9kZSBwcm9jZXNzLlxuICAgIGdldFJ2bUluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXJ2bS1pbmZvJykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBzeXN0ZW0gaW5mb3JtYXRpb24uXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48SG9zdFNwZWNzPn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLmdldEhvc3RTcGVjc1xuICAgICAqL1xuICAgIGdldEhvc3RTcGVjcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtaG9zdC1zcGVjcycpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGFuIGV4ZWN1dGFibGUgb3IgYmF0Y2ggZmlsZS4gQSBwYXRoIHRvIHRoZSBmaWxlIG11c3QgYmUgaW5jbHVkZWQgaW4gb3B0aW9ucy5cbiAgICAgKiA8YnI+IEEgdXVpZCBtYXkgYmUgb3B0aW9uYWxseSBwcm92aWRlZC4gSWYgbm90IHByb3ZpZGVkLCBPcGVuRmluIHdpbGwgY3JlYXRlIGEgdXVpZCBmb3IgdGhlIG5ldyBwcm9jZXNzLlxuICAgICAqIDxicj4gTm90ZTogVGhpcyBtZXRob2QgaXMgcmVzdHJpY3RlZCBieSBkZWZhdWx0IGFuZCBtdXN0IGJlIGVuYWJsZWQgdmlhXG4gICAgICogPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3MvYXBpLXNlY3VyaXR5XCI+QVBJIHNlY3VyaXR5IHNldHRpbmdzPC9hPi5cbiAgICAgKiBAcGFyYW0geyBFeHRlcm5hbFByb2Nlc3NSZXF1ZXN0VHlwZSB9IG9wdGlvbnMgQSBvYmplY3QgdGhhdCBpcyBkZWZpbmVkIGluIHRoZSBFeHRlcm5hbFByb2Nlc3NSZXF1ZXN0VHlwZSBpbnRlcmZhY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxJZGVudGl0eT59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5sYXVuY2hFeHRlcm5hbFByb2Nlc3NcbiAgICAgKi9cbiAgICBsYXVuY2hFeHRlcm5hbFByb2Nlc3Mob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kRXh0ZXJuYWxQcm9jZXNzUmVxdWVzdCgnbGF1bmNoLWV4dGVybmFsLXByb2Nlc3MnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9uaXRvcnMgYSBydW5uaW5nIHByb2Nlc3MuIEEgcGlkIGZvciB0aGUgcHJvY2VzcyBtdXN0IGJlIGluY2x1ZGVkIGluIG9wdGlvbnMuXG4gICAgICogPGJyPiBBIHV1aWQgbWF5IGJlIG9wdGlvbmFsbHkgcHJvdmlkZWQuIElmIG5vdCBwcm92aWRlZCwgT3BlbkZpbiB3aWxsIGNyZWF0ZSBhIHV1aWQgZm9yIHRoZSBuZXcgcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0geyBFeHRlcm5hbFByb2Nlc3NJbmZvIH0gb3B0aW9ucyBTZWUgdHV0b3JpYWwgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPElkZW50aXR5Pn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLm1vbml0b3JFeHRlcm5hbFByb2Nlc3NcbiAgICAgKi9cbiAgICBtb25pdG9yRXh0ZXJuYWxQcm9jZXNzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEV4dGVybmFsUHJvY2Vzc1JlcXVlc3QoJ21vbml0b3ItZXh0ZXJuYWwtcHJvY2VzcycsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdGhlIHBhc3NlZCBtZXNzYWdlIGludG8gYm90aCB0aGUgbG9nIGZpbGUgYW5kIHRoZSBjb25zb2xlLlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IGxldmVsIFRoZSBsb2cgbGV2ZWwgZm9yIHRoZSBlbnRyeS4gQ2FuIGJlIGVpdGhlciBcImluZm9cIiwgXCJ3YXJuaW5nXCIgb3IgXCJlcnJvclwiXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gbWVzc2FnZSBUaGUgbG9nIG1lc3NhZ2UgdGV4dFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0ubG9nXG4gICAgICovXG4gICAgbG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignd3JpdGUtdG8tbG9nJywgeyBsZXZlbCwgbWVzc2FnZSB9KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBwYXNzZWQgVVJMIGluIHRoZSBkZWZhdWx0IHdlYiBicm93c2VyLiBJdCBvbmx5IHN1cHBvcnRzIGh0dHAocykgYW5kIGZpbihzKSBwcm90b2NvbHMgYnkgZGVmYXVsdC5cbiAgICAgKiBJbiBvcmRlciB0byB1c2Ugb3RoZXIgY3VzdG9tIHByb3RvY29scywgdGhleSBoYXZlIHRvIGJlIGVuYWJsZWQgdmlhXG4gICAgICogPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3MvYXBpLXNlY3VyaXR5XCI+QVBJIHNlY3VyaXR5IHNldHRpbmdzPC9hPi5cbiAgICAgKiBGaWxlIHByb3RvY29sIGFuZCBmaWxlIHBhdGggYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gdXJsIFRoZSBVUkwgdG8gb3BlblxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0ub3BlblVybFdpdGhCcm93c2VyXG4gICAgICovXG4gICAgb3BlblVybFdpdGhCcm93c2VyKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ29wZW4tdXJsLXdpdGgtYnJvd3NlcicsIHsgdXJsIH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvY2VzcyBlbnRyeSBmb3IgdGhlIHBhc3NlZCBVVUlEIG9idGFpbmVkIGZyb20gYSBwcmlvciBjYWxsXG4gICAgICogb2YgZmluLlN5c3RlbS5sYXVuY2hFeHRlcm5hbFByb2Nlc3MoKS5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSB1dWlkIFRoZSBVVUlEIGZvciBhIHByb2Nlc3Mgb2J0YWluZWQgZnJvbSBhIHByaW9yIGNhbGwgdG8gZmluLmRlc2t0b3AuU3lzdGVtLmxhdW5jaEV4dGVybmFsUHJvY2VzcygpXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5yZWxlYXNlRXh0ZXJuYWxQcm9jZXNzXG4gICAgICovXG4gICAgcmVsZWFzZUV4dGVybmFsUHJvY2Vzcyh1dWlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigncmVsZWFzZS1leHRlcm5hbC1wcm9jZXNzJywgeyB1dWlkIH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIENocm9taXVtIERldmVsb3BlciBUb29scyBmb3IgdGhlIHNwZWNpZmllZCB3aW5kb3dcbiAgICAgKiBAcGFyYW0geyBJZGVudGl0eSB9IGlkZW50aXR5IFRoaXMgaXMgYSBvYmplY3QgdGhhdCBpcyBkZWZpbmVkIGJ5IHRoZSBJZGVudGl0eSBpbnRlcmZhY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLnNob3dEZXZlbG9wZXJUb29sc1xuICAgICAqL1xuICAgIHNob3dEZXZlbG9wZXJUb29scyhpZGVudGl0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3Nob3ctZGV2ZWxvcGVyLXRvb2xzJywgaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBjbG9zZSBhbiBleHRlcm5hbCBwcm9jZXNzLiBUaGUgcHJvY2VzcyB3aWxsIGJlIHRlcm1pbmF0ZWQgaWYgaXRcbiAgICAgKiBoYXMgbm90IGNsb3NlZCBhZnRlciB0aGUgZWxhcHNlZCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy48YnI+XG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgcmVzdHJpY3RlZCBieSBkZWZhdWx0IGFuZCBtdXN0IGJlIGVuYWJsZWQgdmlhXG4gICAgICogPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3MvYXBpLXNlY3VyaXR5XCI+QVBJIHNlY3VyaXR5IHNldHRpbmdzPC9hPi5cbiAgICAgKiBAcGFyYW0geyBUZXJtaW5hdGVFeHRlcm5hbFJlcXVlc3RUeXBlIH0gb3B0aW9ucyBBIG9iamVjdCBkZWZpbmVkIGluIHRoZSBUZXJtaW5hdGVFeHRlcm5hbFJlcXVlc3RUeXBlIGludGVyZmFjZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0udGVybWluYXRlRXh0ZXJuYWxQcm9jZXNzXG4gICAgICovXG4gICAgdGVybWluYXRlRXh0ZXJuYWxQcm9jZXNzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd0ZXJtaW5hdGUtZXh0ZXJuYWwtcHJvY2VzcycsIG9wdGlvbnMpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBPcGVuRmluIFJ1bnRpbWUgUHJveHkgc2V0dGluZ3MuXG4gICAgICogQHBhcmFtIHsgUHJveHlDb25maWcgfSBvcHRpb25zIEEgY29uZmlnIG9iamVjdCBkZWZpbmVkIGluIHRoZSBQcm94eUNvbmZpZyBpbnRlcmZhY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLnVwZGF0ZVByb3h5U2V0dGluZ3NcbiAgICAgKi9cbiAgICB1cGRhdGVQcm94eVNldHRpbmdzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd1cGRhdGUtcHJveHknLCBvcHRpb25zKS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyB0aGUgZ2l2ZW4gYXBwbGljYXRpb24gYXNzZXQ8YnI+XG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgcmVzdHJpY3RlZCBieSBkZWZhdWx0IGFuZCBtdXN0IGJlIGVuYWJsZWQgdmlhXG4gICAgICogPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3MvYXBpLXNlY3VyaXR5XCI+QVBJIHNlY3VyaXR5IHNldHRpbmdzPC9hPi5cbiAgICAgKiBAcGFyYW0geyBBcHBBc3NldEluZm8gfSBhcHBBc3NldCBBcHAgYXNzZXQgb2JqZWN0XG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5kb3dubG9hZEFzc2V0XG4gICAgICovXG4gICAgLy8gaW5jb21wYXRpYmxlIHdpdGggc3RhbmRhbG9uZSBub2RlIHByb2Nlc3MuXG4gICAgZG93bmxvYWRBc3NldChhcHBBc3NldCwgcHJvZ3Jlc3NMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gbm9kZS5qcyBlbnZpcm9ubWVudCBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICBpZiAodGhpcy53aXJlLmVudmlyb25tZW50LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdOb2RlRW52aXJvbm1lbnQnKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyB0cmFuc3BvcnRfZXJyb3JzXzEuTm90U3VwcG9ydGVkRXJyb3IoJ2Rvd25sb2FkQXNzZXQgb25seSBzdXBwb3J0ZWQgaW4gYW4gT3BlbkZpbiBSZW5kZXIgcHJvY2VzcycpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZElkID0gdGhpcy53aXJlLmVudmlyb25tZW50LmdldE5leHRNZXNzYWdlSWQoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgZGxQcm9ncmVzc0tleSA9IGBhc3NldC1kb3dubG9hZC1wcm9ncmVzcy0ke2Rvd25sb2FkSWR9YDtcbiAgICAgICAgICAgIGNvbnN0IGRsRXJyb3JLZXkgPSBgYXNzZXQtZG93bmxvYWQtZXJyb3ItJHtkb3dubG9hZElkfWA7XG4gICAgICAgICAgICBjb25zdCBkbENvbXBsZXRlS2V5ID0gYGFzc2V0LWRvd25sb2FkLWNvbXBsZXRlLSR7ZG93bmxvYWRJZH1gO1xuICAgICAgICAgICAgY29uc3QgZGxQcm9ncmVzcyA9IChwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkZWRCeXRlczogcHJvZ3Jlc3MuZG93bmxvYWRlZEJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbEJ5dGVzOiBwcm9ncmVzcy50b3RhbEJ5dGVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVyKHApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFuTGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZGxQcm9ncmVzc0tleSwgZGxQcm9ncmVzcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZGxFcnJvciA9IChyLCBlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGVyciB8fCByO1xuICAgICAgICAgICAgICAgIGNsZWFuTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyB0cmFuc3BvcnRfZXJyb3JzXzEuUnVudGltZUVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZGxDb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhbkxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uKGRsUHJvZ3Jlc3NLZXksIGRsUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgdGhpcy5vbmNlKGRsRXJyb3JLZXksIGRsRXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5vbmNlKGRsQ29tcGxldGVLZXksIGRsQ29tcGxldGUpO1xuICAgICAgICAgICAgY29uc3QgZG93bmxvYWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihhcHBBc3NldCwgeyBkb3dubG9hZElkIH0pO1xuICAgICAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2Rvd25sb2FkLWFzc2V0JywgZG93bmxvYWRPcHRpb25zKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYW5MaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgdmVyc2lvbiBvZiB0aGUgcnVudGltZS5cbiAgICAgKiBAcGFyYW0geyBSdW50aW1lRG93bmxvYWRPcHRpb25zIH0gb3B0aW9ucyAtIERvd25sb2FkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb2dyZXNzTGlzdGVuZXJdIC0gY2FsbGVkIGFzIHRoZSBydW50aW1lIGlzIGRvd25sb2FkZWQgd2l0aCBwcm9ncmVzcyBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLmRvd25sb2FkUnVudGltZVxuICAgICAqL1xuICAgIGRvd25sb2FkUnVudGltZShvcHRpb25zLCBwcm9ncmVzc0xpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBub2RlLmpzIGVudmlyb25tZW50IG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGlmICh0aGlzLndpcmUuZW52aXJvbm1lbnQuY29uc3RydWN0b3IubmFtZSA9PT0gJ05vZGVFbnZpcm9ubWVudCcpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHRyYW5zcG9ydF9lcnJvcnNfMS5Ob3RTdXBwb3J0ZWRFcnJvcignZG93bmxvYWRSdW50aW1lIG9ubHkgc3VwcG9ydGVkIGluIGFuIE9wZW5GaW4gUmVuZGVyIHByb2Nlc3MnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZG93bmxvYWRJZCA9IHRoaXMud2lyZS5lbnZpcm9ubWVudC5nZXROZXh0TWVzc2FnZUlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IGRsUHJvZ3Jlc3NLZXkgPSBgcnVudGltZS1kb3dubG9hZC1wcm9ncmVzcy0ke2Rvd25sb2FkSWR9YDtcbiAgICAgICAgICAgIGNvbnN0IGRsRXJyb3JLZXkgPSBgcnVudGltZS1kb3dubG9hZC1lcnJvci0ke2Rvd25sb2FkSWR9YDtcbiAgICAgICAgICAgIGNvbnN0IGRsQ29tcGxldGVLZXkgPSBgcnVudGltZS1kb3dubG9hZC1jb21wbGV0ZS0ke2Rvd25sb2FkSWR9YDtcbiAgICAgICAgICAgIGNvbnN0IGRsUHJvZ3Jlc3MgPSAocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0ge1xuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZGVkQnl0ZXM6IHByb2dyZXNzLmRvd25sb2FkZWRCeXRlcyxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxCeXRlczogcHJvZ3Jlc3MudG90YWxCeXRlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcihwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjbGVhbkxpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGRsUHJvZ3Jlc3NLZXksIGRsUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRsRXJyb3IgPSAociwgZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnIgfHwgcjtcbiAgICAgICAgICAgICAgICBjbGVhbkxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgdHJhbnNwb3J0X2Vycm9yc18xLlJ1bnRpbWVFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRsQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYW5MaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbihkbFByb2dyZXNzS2V5LCBkbFByb2dyZXNzKTtcbiAgICAgICAgICAgIHRoaXMub25jZShkbEVycm9yS2V5LCBkbEVycm9yKTtcbiAgICAgICAgICAgIHRoaXMub25jZShkbENvbXBsZXRlS2V5LCBkbENvbXBsZXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywgeyBkb3dubG9hZElkIH0pO1xuICAgICAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2Rvd25sb2FkLXJ1bnRpbWUnLCBkb3dubG9hZE9wdGlvbnMpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhbkxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBwcmVsb2FkIHNjcmlwdHMgZnJvbSBnaXZlbiBVUkxzXG4gICAgICogQHBhcmFtIHtEb3dubG9hZFByZWxvYWRPcHRpb25bXX0gc2NyaXB0cyAtIFVSTHMgb2YgcHJlbG9hZCBzY3JpcHRzLiBTZWUgdHV0b3JpYWwgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLkFycmF5PERvd25sb2FkUHJlbG9hZEluZm8+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZG93bmxvYWRQcmVsb2FkU2NyaXB0c1xuICAgICAqL1xuICAgIGRvd25sb2FkUHJlbG9hZFNjcmlwdHMoc2NyaXB0cykge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2Rvd25sb2FkLXByZWxvYWQtc2NyaXB0cycsIHsgc2NyaXB0cyB9KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGFycmF5IG9mIGRhdGEgKG5hbWUsIGlkcywgYm91bmRzKSBmb3IgYWxsIGFwcGxpY2F0aW9uIHdpbmRvd3MuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS5BcnJheS48SWRlbnRpdHk+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0QWxsRXh0ZXJuYWxBcHBsaWNhdGlvbnNcbiAgICAgKi9cbiAgICBnZXRBbGxFeHRlcm5hbEFwcGxpY2F0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtYWxsLWV4dGVybmFsLWFwcGxpY2F0aW9ucycpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgaW5mb3JtYXRpb24gYWJvdXQgY3VycmVudGx5XG4gICAgICogcnVubmluZyB1c2VyLWZyaWVuZGx5IG5hdGl2ZSB3aW5kb3dzIG9uIHRoZSBzeXN0ZW0uPGJyPlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIHJlc3RyaWN0ZWQgYnkgZGVmYXVsdCBhbmQgbXVzdCBiZSBlbmFibGVkIHZpYVxuICAgICAqIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL2FwaS1zZWN1cml0eVwiPkFQSSBzZWN1cml0eSBzZXR0aW5nczwvYT4uXG4gICAgICogQHJldHVybiB7UHJvbWlzZS5BcnJheS48SWRlbnRpdHk+fVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAZGVwcmVjYXRlZCBTeXN0ZW0uZ2V0QWxsRXh0ZXJuYWxXaW5kb3dzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLlxuICAgICAqL1xuICAgIGdldEFsbEV4dGVybmFsV2luZG93cygpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBTeXN0ZW0uZ2V0QWxsRXh0ZXJuYWxXaW5kb3dzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLicpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1hbGwtZXh0ZXJuYWwtd2luZG93cycpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYXBwIGFzc2V0IGluZm9ybWF0aW9uLlxuICAgICAqIEBwYXJhbSB7IEFwcEFzc2V0UmVxdWVzdCB9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxBcHBBc3NldEluZm8+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0uZ2V0QXBwQXNzZXRJbmZvXG4gICAgICovXG4gICAgZ2V0QXBwQXNzZXRJbmZvKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtYXBwLWFzc2V0LWluZm8nLCBvcHRpb25zKS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFkZGl0aW9uYWwgaW5mbyBvZiBjb29raWVzLlxuICAgICAqIEBwYXJhbSB7IENvb2tpZU9wdGlvbiB9IG9wdGlvbnMgLSBTZWUgdHV0b3JpYWwgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLkFycmF5LjxDb29raWVJbmZvPn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLmdldENvb2tpZXNcbiAgICAgKi9cbiAgICBnZXRDb29raWVzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy53aXJlLmVudmlyb25tZW50LmdldFVybCgpO1xuICAgICAgICBjb25zdCBuZXdPcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7IHVybCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtY29va2llcycsIG5ld09wdGlvbnMpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG1pbmltdW0gbG9nIGxldmVsIGFib3ZlIHdoaWNoIGxvZ3Mgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBPcGVuRmluIGxvZ1xuICAgICAqIEBwYXJhbSB7IExvZ0xldmVsIH0gVGhlIG1pbmltdW0gbGV2ZWwgKGluY2x1c2l2ZSkgYWJvdmUgd2hpY2ggYWxsIGNhbGxzIHRvIGxvZyB3aWxsIGJlIHdyaXR0ZW5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLnNldE1pbkxvZ0xldmVsXG4gICAgICovXG4gICAgc2V0TWluTG9nTGV2ZWwobGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzZXQtbWluLWxvZy1sZXZlbCcsIHsgbGV2ZWwgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIFVVSUQgb2YgdGhlIGNvbXB1dGVyIG9uIHdoaWNoIHRoZSBydW50aW1lIGlzIGluc3RhbGxlZFxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHV1aWQgVGhlIHV1aWQgb2YgdGhlIHJ1bm5pbmcgYXBwbGljYXRpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxFbnRpdHk+fVxuICAgICAqIEB0dXRvcmlhbCBTeXN0ZW0ucmVzb2x2ZVV1aWRcbiAgICAgKi9cbiAgICByZXNvbHZlVXVpZCh1dWlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmVcbiAgICAgICAgICAgIC5zZW5kQWN0aW9uKCdyZXNvbHZlLXV1aWQnLCB7XG4gICAgICAgICAgICBlbnRpdHlLZXk6IHV1aWRcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGFycmF5IG9mIGRhdGEgZm9yIGFsbCBleHRlcm5hbCBhcHBsaWNhdGlvbnNcbiAgICAgKiBAcGFyYW0geyBJZGVudGl0eSB9IHJlcXVlc3RpbmdJZGVudGl0eSBUaGlzIG9iamVjdCBpcyBkZXNjcmliZWQgaW4gdGhlIElkZW50aXR5IHR5cGVkZWZcbiAgICAgKiBAcGFyYW0geyBhbnkgfSBkYXRhIEFueSBkYXRhIHR5cGUgdG8gcGFzcyB0byB0aGUgbWV0aG9kXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48YW55Pn1cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgZXhlY3V0ZU9uUmVtb3RlKHJlcXVlc3RpbmdJZGVudGl0eSwgZGF0YSkge1xuICAgICAgICBkYXRhLnJlcXVlc3RpbmdJZGVudGl0eSA9IHJlcXVlc3RpbmdJZGVudGl0eTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5mZXJyeUFjdGlvbihkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIHNwZWNpZmVkIHZhbHVlIGZyb20gdGhlIHJlZ2lzdHJ5Ljxicj5cbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyByZXN0cmljdGVkIGJ5IGRlZmF1bHQgYW5kIG11c3QgYmUgZW5hYmxlZCB2aWFcbiAgICAgKiA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXJzLm9wZW5maW4uY28vZG9jcy9hcGktc2VjdXJpdHlcIj5BUEkgc2VjdXJpdHkgc2V0dGluZ3M8L2E+LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHJvb3RLZXkgLSBUaGUgcmVnaXN0cnkgcm9vdCBrZXkuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gc3Via2V5IC0gVGhlIHJlZ2lzdHJ5IGtleS5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSB2YWx1ZSAtIFRoZSByZWdpc3RyeSB2YWx1ZSBuYW1lLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPFJlZ2lzdHJ5SW5mbz59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5yZWFkUmVnaXN0cnlWYWx1ZVxuICAgICAqL1xuICAgIHJlYWRSZWdpc3RyeVZhbHVlKHJvb3RLZXksIHN1YmtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ3JlYWQtcmVnaXN0cnktdmFsdWUnLCB7XG4gICAgICAgICAgICByb290S2V5LFxuICAgICAgICAgICAgc3Via2V5LFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYWxsIHdpbGwgcmVnaXN0ZXIgYSB1bmlxdWUgaWQgYW5kIHByb2R1Y2UgYSB0b2tlbi5cbiAgICAgKiBUaGUgdG9rZW4gY2FuIGJlIHVzZWQgdG8gYnJva2VyIGFuIGV4dGVybmFsIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gdXVpZCAtIEEgVVVJRCBmb3IgdGhlIHJlbW90ZSBjb25uZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPEV4dGVybmFsQ29ubmVjdGlvbj59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5yZWdpc3RlckV4dGVybmFsQ29ubmVjdGlvblxuICAgICAqL1xuICAgIHJlZ2lzdGVyRXh0ZXJuYWxDb25uZWN0aW9uKHV1aWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdyZWdpc3Rlci1leHRlcm5hbC1jb25uZWN0aW9uJywgeyB1dWlkIH0pLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBqc29uIGJsb2IgZm91bmQgaW4gdGhlIFtkZXNrdG9wIG93bmVyIHNldHRpbmdzXShodHRwczovL29wZW5maW4uY28vZG9jdW1lbnRhdGlvbi9kZXNrdG9wLW93bmVyLXNldHRpbmdzLylcbiAgICAgKiBmb3IgdGhlIHNwZWNpZmllZCBzZXJ2aWNlLlxuICAgICAqIE1vcmUgaW5mb3JtYXRpb24gYWJvdXQgZGVza3RvcCBzZXJ2aWNlcyBjYW4gYmUgZm91bmQgW2hlcmVdKGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3MvZGVza3RvcC1zZXJ2aWNlcykuXG4gICAgICogQHBhcmFtIHsgU2VydmljZUlkZW50aWZpZXIgfSBzZXJ2aWNlSWRlbnRpZmllciBBbiBvYmplY3QgY29udGFpbmluZyBhIG5hbWUga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgc2VydmljZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxTZXJ2aWNlQ29uZmlndXJhdGlvbj59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5nZXRTZXJ2aWNlQ29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGdldFNlcnZpY2VDb25maWd1cmF0aW9uKHNlcnZpY2VJZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VydmljZUlkZW50aWZpZXIubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGFuIG9iamVjdCB3aXRoIGEgYG5hbWVgIHByb3BlcnR5IGhhdmluZyBhIHN0cmluZyB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gc2VydmljZUlkZW50aWZpZXI7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXNlcnZpY2UtY29uZmlndXJhdGlvbicsIHsgbmFtZSB9KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U3lzdGVtQXBwQ29uZmlnKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBzdHJpbmcgdmFsdWUgZm9yIG5hbWUgb2Ygc3lzdGVtIGFwcCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXN5c3RlbS1hcHAtY29uZmlndXJhdGlvbicsIHsgbmFtZSB9KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbmFscyB0aGUgUlZNIHRvIHBlcmZvcm0gYSBoZWFsdGggY2hlY2sgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMgYXMganNvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxzdHJpbmdbXT59XG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5ydW5Sdm1IZWFsdGhDaGVja1xuICAgICAqL1xuICAgIHJ1blJ2bUhlYWx0aENoZWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3J1bi1ydm0taGVhbHRoLWNoZWNrJykudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExhdW5jaCBhcHBsaWNhdGlvbiB1c2luZyBhIG1hbmlmZXN0IFVSTC9wYXRoLiBJdCBkaWZmZXJzIGZyb20gQXBwbGljYXRpb24uc3RhcnRGcm9tTWFuaWZlc3QgaW4gdGhhdCB0aGlzIEFQSSBjYW4gYWNjZXB0IGEgbWFuaWZlc3QgdXNpbmcgdGhlIGZpbiBwcm90b2NvbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFuaWZlc3RVcmwgLSBUaGUgbWFuaWZlc3QncyBVUkwgb3IgcGF0aC5cbiAgICAgKiBAcGFyYW0ge1J2bUxhdW5jaE9wdGlvbnN9IFtvcHRzXSAtIFBhcmFtZXRlcnMgdGhhdCB0aGUgUlZNIHdpbGwgdXNlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPE1hbmlmZXN0Pn1cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICogQHR1dG9yaWFsIFN5c3RlbS5sYXVuY2hNYW5pZmVzdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBhc3luYyBsYXVuY2hNYW5pZmVzdChtYW5pZmVzdFVybCwgb3B0cykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdsYXVuY2gtbWFuaWZlc3QnLCB7XG4gICAgICAgICAgICBtYW5pZmVzdFVybCxcbiAgICAgICAgICAgIG9wdHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5wYXlsb2FkLmRhdGEubWFuaWZlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IHBlcm1pc3Npb24gb2YgYSBzZWN1cmVkIGFwaSBpbiBjdXJyZW50IGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaU5hbWUgLSBUaGUgZnVsbCBuYW1lIG9mIGEgc2VjdXJlZCBBUEkuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48UXVlcnlQZXJtaXNzaW9uUmVzdWx0Pn1cbiAgICAgKiBAdHV0b3JpYWwgU3lzdGVtLnF1ZXJ5UGVybWlzc2lvbkZvckN1cnJlbnRDb250ZXh0XG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlQZXJtaXNzaW9uRm9yQ3VycmVudENvbnRleHQoYXBpTmFtZSkge1xuICAgICAgICBjb25zdCBpZGVudGl0eSA9IHsgdXVpZDogdGhpcy53aXJlLm1lLnV1aWQsIG5hbWU6IHRoaXMud2lyZS5tZS5uYW1lIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3F1ZXJ5LXBlcm1pc3Npb24tZm9yLWN1cnJlbnQtY29udGV4dCcsIHtcbiAgICAgICAgICAgIGFwaU5hbWUsXG4gICAgICAgICAgICBpZGVudGl0eVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnBheWxvYWQuZGF0YTtcbiAgICB9XG4gICAgLy8gTm90IGRvY3VtZW50aW5nLCBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICBhc3luYyBlbmFibGVOYXRpdmVXaW5kb3dJbnRlZ3JhdGlvblByb3ZpZGVyKHBlcm1pc3Npb25zKSB7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2VuYWJsZS1uYXRpdmUtd2luZG93LWludGVncmF0aW9uLXByb3ZpZGVyJywgeyBwZXJtaXNzaW9ucyB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQuZGF0YTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3ZhbGlkYXRlXCIpO1xuY29uc3QgRW50aXR5VHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXBlcy9FbnRpdHlUeXBlXCIpO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xuLyoqXG4gKiBAbGVuZHMgVmlld1xuICovXG5jbGFzcyBWaWV3TW9kdWxlIGV4dGVuZHMgYmFzZV8xLkJhc2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmlldy5cbiAgICAgKiBAcGFyYW0geyBWaWV3fm9wdGlvbnMgfSBvcHRpb25zIC0gVmlldyBjcmVhdGlvbiBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48Vmlldz59XG4gICAgICogQHR1dG9yaWFsIFZpZXcuY3JlYXRlXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHV1aWQgfSA9IHRoaXMud2lyZS5tZTtcbiAgICAgICAgaWYgKCFvcHRpb25zLm5hbWUgfHwgdHlwZW9mIG9wdGlvbnMubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgYSBuYW1lIHByb3BlcnR5IGFzIGEgc3RyaW5nIGluIG9yZGVyIHRvIGNyZWF0ZSBhIFZpZXcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2lyZS5lbnZpcm9ubWVudC5jaGlsZFZpZXdzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndpcmUuZW52aXJvbm1lbnQuY3JlYXRlQ2hpbGRDb250ZW50KHtcbiAgICAgICAgICAgICAgICBlbnRpdHlUeXBlOiBFbnRpdHlUeXBlXzEuZGVmYXVsdC5WSUVXLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHsgLi4ub3B0aW9ucywgdXVpZCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjcmVhdGUtdmlldycsIHsgLi4ub3B0aW9ucywgdXVpZCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53cmFwU3luYyh7IHV1aWQsIG5hbWU6IG9wdGlvbnMubmFtZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFZpZXcgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBleGlzdGluZyB2aWV3LlxuICAgICAqIEBwYXJhbSB7IElkZW50aXR5IH0gaWRlbnRpdHlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxWaWV3Pn1cbiAgICAgKiBAdHV0b3JpYWwgVmlldy53cmFwXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBhc3luYyB3cmFwKGlkZW50aXR5KSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd2aWV3LXdyYXAnKTtcbiAgICAgICAgY29uc3QgZXJyb3JNc2cgPSB2YWxpZGF0ZV8xLnZhbGlkYXRlSWRlbnRpdHkoaWRlbnRpdHkpO1xuICAgICAgICBpZiAoZXJyb3JNc2cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBpbmRleF8xLlZpZXcodGhpcy53aXJlLCBpZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFZpZXcgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbiBleGlzdGluZyB2aWV3LlxuICAgICAqIEBwYXJhbSB7IElkZW50aXR5IH0gaWRlbnRpdHlcbiAgICAgKiBAcmV0dXJuIHtWaWV3fVxuICAgICAqIEB0dXRvcmlhbCBWaWV3LndyYXBTeW5jXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB3cmFwU3luYyhpZGVudGl0eSkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbigndmlldy13cmFwLXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlcnJvck1zZyA9IHZhbGlkYXRlXzEudmFsaWRhdGVJZGVudGl0eShpZGVudGl0eSk7XG4gICAgICAgIGlmIChlcnJvck1zZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGluZGV4XzEuVmlldyh0aGlzLndpcmUsIGlkZW50aXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFZpZXcgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCB2aWV3XG4gICAgICogQHJldHVybiB7UHJvbWlzZS48Vmlldz59XG4gICAgICogQHR1dG9yaWFsIFZpZXcuZ2V0Q3VycmVudFxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZ2V0Q3VycmVudCgpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3ZpZXctZ2V0LWN1cnJlbnQnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMud2lyZS5tZS5pc1ZpZXcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgaW4gYSBWaWV3IGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUgfSA9IHRoaXMud2lyZS5tZTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh7IHV1aWQsIG5hbWUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFZpZXcgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCB2aWV3XG4gICAgICogQHJldHVybiB7Vmlld31cbiAgICAgKiBAdHV0b3JpYWwgVmlldy5nZXRDdXJyZW50U3luY1xuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZ2V0Q3VycmVudFN5bmMoKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd2aWV3LWdldC1jdXJyZW50LXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMud2lyZS5tZS5pc1ZpZXcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgaW4gYSBWaWV3IGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUgfSA9IHRoaXMud2lyZS5tZTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcFN5bmMoeyB1dWlkLCBuYW1lIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZpZXdNb2R1bGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmlldyA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnQgKi9cbmNvbnN0IHdlYmNvbnRlbnRzXzEgPSByZXF1aXJlKFwiLi4vd2ViY29udGVudHNcIik7XG5jb25zdCB3aW5kb3dfMSA9IHJlcXVpcmUoXCIuLi93aW5kb3dcIik7XG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFZpZXd+b3B0aW9uc1xuICogQHN1bW1hcnkgVmlldyBjcmVhdGlvbiBvcHRpb25zLlxuICogQGRlc2MgVGhpcyBpcyB0aGUgb3B0aW9ucyBvYmplY3QgcmVxdWlyZWQgYnkge0BsaW5rIFZpZXcuY3JlYXRlIFZpZXcuY3JlYXRlfS5cbiAqXG4gKiBOb3RlIHRoYXQgYG5hbWVgIGFuZCBgdGFyZ2V0YCBhcmUgdGhlIG9ubHkgcmVxdWlyZWQgcHJvcGVydGllcyDigJQgYWxiZWl0IHRoZSBgdXJsYCBwcm9wZXJ0eSBpcyB1c3VhbGx5IHByb3ZpZGVkIGFzIHdlbGxcbiAqIChkZWZhdWx0cyB0byBgXCJhYm91dDpibGFua1wiYCB3aGVuIG9taXR0ZWQpLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZXhwZXJpbWVudGFsXVxuICogQ29uZmlndXJhdGlvbnMgZm9yIEFQSSBpbmplY3Rpb24uXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZXhwZXJpbWVudGFsLmNoaWxkV2luZG93c10gQ29uZmlndXJlIGlmIHRoZSBydW50aW1lIHNob3VsZCBlbmFibGUgY2hpbGQgd2luZG93cyBmb3Igdmlld3MuXG4gKlxuICogQHByb3BlcnR5IHtvYmplY3R9IFthcGldXG4gKiBDb25maWd1cmF0aW9ucyBmb3IgQVBJIGluamVjdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdH0gW2FwaS5pZnJhbWVdIENvbmZpZ3VyZSBpZiB0aGUgdGhlIEFQSSBzaG91bGQgYmUgaW5qZWN0ZWQgaW50byBpZnJhbWVzIGJhc2VkIG9uIGRvbWFpbi5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcGkuaWZyYW1lLmNyb3NzT3JpZ2luSW5qZWN0aW9uPWZhbHNlXSBDb250cm9scyBpZiB0aGUgYGZpbmAgQVBJIG9iamVjdCBpcyBwcmVzZW50IGZvciBjcm9zcyBvcmlnaW4gaWZyYW1lcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FwaS5pZnJhbWUuc2FtZU9yaWdpbkluamVjdGlvbj10cnVlXSBDb250cm9scyBpZiB0aGUgYGZpbmAgQVBJIG9iamVjdCBpcyBwcmVzZW50IGZvciBzYW1lIG9yaWdpbiBpZnJhbWVzLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbYXV0b1Jlc2l6ZV0gQXV0b1Jlc2l6ZSBvcHRpb25zXG4gKlxuICogQHByb3BlcnR5IHtvYmplY3R9IFtib3VuZHNdIGluaXRpYWwgYm91bmRzIGdpdmVuIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtiYWNrZ3JvdW5kQ29sb3I9XCIjRkZGXCJdIC0gX1VwZGF0YWJsZS5fXG4gKiBUaGUgdmlld+KAmXMgX2JhY2tmaWxsXyBjb2xvciBhcyBhIGhleGFkZWNpbWFsIHZhbHVlLiBOb3QgdG8gYmUgY29uZnVzZWQgd2l0aCB0aGUgY29udGVudCBiYWNrZ3JvdW5kIGNvbG9yXG4gKiAoYGRvY3VtZW50LmJvZHkuc3R5bGUuYmFja2dyb3VuZENvbG9yYCksXG4gKiB0aGlzIGNvbG9yIGJyaWVmbHkgZmlsbHMgYSB2aWV34oCZcyAoYSkgY29udGVudCBhcmVhIGJlZm9yZSBpdHMgY29udGVudCBpcyBsb2FkZWQgYXMgd2VsbCBhcyAoYikgbmV3bHkgZXhwb3NlZFxuICogYXJlYXMgd2hlbiBncm93aW5nIGEgd2luZG93LiBTZXR0aW5nXG4gKiB0aGlzIHZhbHVlIHRvIHRoZSBhbnRpY2lwYXRlZCBjb250ZW50IGJhY2tncm91bmQgY29sb3IgY2FuIGhlbHAgaW1wcm92ZSB1c2VyIGV4cGVyaWVuY2UuXG4gKiBEZWZhdWx0IGlzIHdoaXRlLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbY29udGVudE5hdmlnYXRpb25dXG4gKiBSZXN0cmljdCBuYXZpZ2F0aW9uIHRvIFVSTHMgdGhhdCBtYXRjaCBhIHdoaXRlbGlzdGVkIHBhdHRlcm4uXG4gKiBJbiB0aGUgbGFjayBvZiBhIHdoaXRlbGlzdCwgbmF2aWdhdGlvbiB0byBVUkxzIHRoYXQgbWF0Y2ggYSBibGFja2xpc3RlZCBwYXR0ZXJuIHdvdWxkIGJlIHByb2hpYml0ZWQuXG4gKiBTZWUgW2hlcmVdKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9tYXRjaF9wYXR0ZXJucykgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtjb250ZW50TmF2aWdhdGlvbi53aGl0ZWxpc3Q9W11dIExpc3Qgb2Ygd2hpdGVsaXN0ZWQgVVJMcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtjb250ZW50TmF2aWdhdGlvbi5ibGFja2xpc3Q9W11dIExpc3Qgb2YgYmxhY2tsaXN0ZWQgVVJMcy5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdH0gW2NvbnRleHRNZW51U2V0dGluZ3NdIC0gX1VwZGF0YWJsZS5fXG4gKiBDb25maWd1cmUgdGhlIGNvbnRleHQgbWVudSB3aGVuIHJpZ2h0LWNsaWNraW5nIG9uIGEgdmlldy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbnRleHRNZW51U2V0dGluZ3MuZW5hYmxlPXRydWVdIFNob3VsZCB0aGUgY29udGV4dCBtZW51IGRpc3BsYXkgb24gcmlnaHQgY2xpY2suXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb250ZXh0TWVudVNldHRpbmdzLmRldnRvb2xzPXRydWVdIFNob3VsZCB0aGUgY29udGV4dCBtZW51IGNvbnRhaW4gYSBidXR0b24gZm9yIG9wZW5pbmcgZGV2dG9vbHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb250ZXh0TWVudVNldHRpbmdzLnJlbG9hZD10cnVlXSBTaG91bGQgdGhlIGNvbnRleHQgbWVudSBjb250YWluIGEgYnV0dG9uIGZvciByZWxvYWRpbmcgdGhlIHBhZ2UuXG4gKlxuICogQHByb3BlcnR5IHthbnl9IFtjdXN0b21EYXRhPVwiXCJdIC0gX1VwZGF0YWJsZS5fXG4gKiBBIGZpZWxkIHRoYXQgdGhlIHVzZXIgY2FuIGF0dGFjaCBzZXJpYWxpemFibGUgZGF0YSB0byB0byBiZSBmZXJyaWVkIGFyb3VuZCB3aXRoIHRoZSB2aWV3IG9wdGlvbnMuXG4gKiBfV2hlbiBvbWl0dGVkLCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IGlzIHRoZSBlbXB0eSBzdHJpbmcgKGBcIlwiYCkuX1xuICpcbiAqIFdoZW4gb21pdHRlZCwgdGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBpcyB0aGUgZW1wdHkgc3RyaW5nIChgXCJcImApLlxuICogQXMgb3Bwb3NlZCB0byBjdXN0b21EYXRhIHRoaXMgaXMgbWVhbnQgZm9yIGZyZXF1ZW50IHVwZGF0ZXMgYW5kIHNoYXJpbmcgd2l0aCBvdGhlciBjb250ZXh0cy4gW0V4YW1wbGVde0B0dXRvcmlhbCBjdXN0b21Db250ZXh0fVxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0W119IFtob3RrZXlzPVtdXSAtIF9VcGRhdGFibGUuX1xuICogRGVmaW5lcyB0aGUgbGlzdCBvZiBob3RrZXlzIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGFzIGEgYGhvdGtleWAgZXZlbnQgb24gdGhlIHZpZXcuIEZvciB1c2FnZSBleGFtcGxlIHNlZSBbZXhhbXBsZV17QHR1dG9yaWFsIGhvdGtleXN9LlxuICogV2l0aGluIFBsYXRmb3JtLCBPcGVuRmluIGFsc28gaW1wbGVtZW50cyBhIHNldCBvZiBwcmUtZGVmaW5lZCBhY3Rpb25zIGNhbGxlZFxuICogW2tleWJvYXJkIGNvbW1hbmRzXXtAbGluayBodHRwczovL2RldmVsb3BlcnMub3BlbmZpbi5jby9kb2NzL3BsYXRmb3JtLWFwaSNzZWN0aW9uLTUtMy11c2luZy1rZXlib2FyZC1jb21tYW5kc31cbiAqIHRoYXQgY2FuIGJlIGFzc2lnbmVkIHRvIGEgc3BlY2lmaWMgaG90a2V5IGluIHRoZSBwbGF0Zm9ybSBtYW5pZmVzdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBob3RrZXlzLmtleXMgVGhlIGtleSBjb21iaW5hdGlvbiBvZiB0aGUgaG90a2V5LCBpLmUuIFwiQ3RybCtUXCJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hvdGtleXMucHJldmVudERlZmF1bHQ9ZmFsc2VdIHByZXZlbnREZWZhdWx0IHdpbGwgcHJldmVudCB0aGUgcGFnZSBrZXlkb3duL2tleXVwIGV2ZW50cyBmcm9tIGJlaW5nIGVtaXR0ZWQuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaXNDbG9zYWJsZT10cnVlXSAqKlBsYXRmb3JtcyBPbmx5LioqIElmIGZhbHNlLCB0aGUgdmlldyB3aWxsIGJlIHBlcnNpc3RlbnQgYW5kIGNhbid0IGJlIGNsb3NlZCB0aHJvdWdoXG4gKiBlaXRoZXIgVUkgb3IgYFBsYXRmb3JtLmNsb3NlVmlld2AuIE5vdGUgdGhhdCB0aGUgdmlldyB3aWxsIHN0aWxsIGJlIGNsb3NlZCBpZiB0aGUgaG9zdCB3aW5kb3cgaXMgY2xvc2VkIG9yXG4gKiBpZiB0aGUgdmlldyBpc24ndCBwYXJ0IG9mIHRoZSBuZXcgbGF5b3V0IHdoZW4gcnVubmluZyBgTGF5b3V0LnJlcGxhY2VgLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBUaGUgbmFtZSBvZiB0aGUgdmlldy5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZXRhY2hPbkNsb3NlPWZhbHNlXSAtIF9VcGRhdGFibGUuX1xuICogUGxhdGZvcm1zIE9ubHkuICBJZiB0cnVlLCB3aWxsIGhpZGUgYW5kIGRldGFjaCB0aGUgVmlldyBmcm9tIHRoZSB3aW5kb3cgZm9yIGxhdGVyIHVzZSBpbnN0ZWFkIG9mIGNsb3NpbmcsXG4gKiBhbGxvd2luZyB0aGUgc3RhdGUgb2YgdGhlIFZpZXcgdG8gYmUgc2F2ZWQgYW5kIHRoZSBWaWV3IHRvIGJlIGltbWVkaWF0ZWx5IHNob3duIGluIGEgbmV3IExheW91dC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21hbmlmZXN0VXJsXSAqKlBsYXRmb3JtcyBPbmx5LioqIFVybCB0byBhIG1hbmlmZXN0IHRoYXQgY29udGFpbnMgVmlldyBPcHRpb25zLiBQcm9wZXJ0aWVzIG90aGVyIHRoYW4gbWFuaWZlc3RVcmwgY2FuIHN0aWxsIGJlIHVzZWRcbiAqIGJ1dCB0aGUgcHJvcGVydGllcyBpbiB0aGUgbWFuaWZlc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UgaWYgdGhlcmUgaXMgYW55IGNvbGxpc2lvbi5cbiAqXG4gKiBAcHJvcGVydHkge3ByZWxvYWRTY3JpcHRbXX0gW3ByZWxvYWRTY3JpcHRzXSAtIF9Jbmhlcml0YWJsZV9cbiAqIEEgbGlzdCBvZiBzY3JpcHRzIHRoYXQgYXJlIGV2YWwnZWQgYmVmb3JlIG90aGVyIHNjcmlwdHMgaW4gdGhlIHBhZ2UuIFdoZW4gb21pdHRlZCwgX2luaGVyaXRzX1xuICogZnJvbSB0aGUgcGFyZW50IGFwcGxpY2F0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ByZXZlbnREcmFnT3V0PWZhbHNlXSAqKlBsYXRmb3JtcyBPbmx5LioqIElmIHRydWUsIHRoZSB0YWIgb2YgdGhlIHZpZXcgY2FuJ3QgYmUgZHJhZ2dlZCBvdXQgb2YgaXRzIGhvc3Qgd2luZG93LlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcHJvY2Vzc0FmZmluaXR5PTxhcHBsaWNhdGlvbiB1dWlkPl1cbiAqIEEgc3RyaW5nIHRvIGF0dGVtcHQgdG8gZ3JvdXAgcmVuZGVyZXJzIHRvZ2V0aGVyLiBXaWxsIG9ubHkgYmUgdXNlZCBpZiBwYWdlcyBhcmUgb24gdGhlIHNhbWUgb3JpZ2luLlxuICpcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpdHl9IFt0YXJnZXRdXG4gKiBUaGUgaWRlbnRpdHkgb2YgdGhlIHdpbmRvdyB0aGlzIHZpZXcgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsPVwiYWJvdXQ6YmxhbmtcIl1cbiAqIFRoZSBVUkwgb2YgdGhlIHZpZXcuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1dWlkPTxhcHBsaWNhdGlvbiB1dWlkPl1cbiAqIFRoZSBgdXVpZGAgb2YgdGhlIGFwcGxpY2F0aW9uLCB1bmlxdWUgd2l0aGluIHRoZSBzZXQgb2YgYWxsIGBBcHBsaWNhdGlvbmBzIHJ1bm5pbmcgaW4gT3BlbkZpbiBSdW50aW1lLlxuICogSWYgb21pdHRlZCwgZGVmYXVsdHMgdG8gdGhlIGB1dWlkYCBvZiB0aGUgYXBwbGljYXRpb24gc3Bhd25pbmcgdGhlIHZpZXcuXG4gKiBJZiBnaXZlbiwgbXVzdCBtYXRjaCB0aGUgYHV1aWRgIG9mIHRoZSBhcHBsaWNhdGlvbiBzcGF3bmluZyB0aGUgdmlldy5cbiAqIEluIG90aGVyIHdvcmRzLCB0aGUgYXBwbGljYXRpb24ncyBgdXVpZGAgaXMgdGhlIG9ubHkgYWNjZXB0YWJsZSB2YWx1ZSwgYnV0IGlzIHRoZSBkZWZhdWx0LCBzbyB0aGVyZSdzXG4gKiByZWFsbHkgbm8gbmVlZCB0byBwcm92aWRlIGl0LlxuICovXG4vKipcbiAqIEBjbGFzc2Rlc2MgYSBWaWV3IGNhbiBiZSB1c2VkIHRvIGVtYmVkIGFkZGl0aW9uYWwgd2ViIGNvbnRlbnQgaW50byBhIFdpbmRvdy5cbiAqIEl0IGlzIGxpa2UgYSBjaGlsZCB3aW5kb3csIGV4Y2VwdCBpdCBpcyBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIGl0cyBvd25pbmcgd2luZG93LlxuICogSXQgaGFzIHRoZSBhYmlsaXR5IHRvIGxpc3RlbiBmb3IgPGEgaHJlZj1cInR1dG9yaWFsLVZpZXcuRXZlbnRFbWl0dGVyLmh0bWxcIj5WaWV3LXNwZWNpZmljIGV2ZW50czwvYT4uXG4gKlxuICogQnkgZGVmYXVsdCwgYSBWaWV3IHdpbGwgdHJ5IHRvIHNoYXJlIHRoZSBzYW1lIHJlbmRlcmVyIHByb2Nlc3MgYXMgb3RoZXIgVmlld3Mgb3duZWQgYnkgaXRzIHBhcmVudCBBcHBsaWNhdGlvbi5cbiAqIFRvIGNoYW5nZSB0aGF0IGJlaGF2aW9yLCBzZWUgdGhlIHByb2Nlc3NBZmZpbml0eSB7QGxpbmsgVmlld35vcHRpb25zIHZpZXcgb3B0aW9ufS5cbiAqXG4gKiBBIFZpZXcncyBsaWZlY3ljbGUgaXMgdGllZCB0byBpdHMgb3duaW5nIHdpbmRvdyBhbmQgY2FuIGJlIHJlLWF0dGFjaGVkIHRvIGEgZGlmZmVyZW50IHdpbmRvdyBhdCBhbnkgcG9pbnQgZHVyaW5nIGl0cyBsaWZlY3ljbGUuXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBWaWV3XG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFZpZXcgZXh0ZW5kcyB3ZWJjb250ZW50c18xLldlYkNvbnRlbnRzIHtcbiAgICBjb25zdHJ1Y3Rvcih3aXJlLCBpZGVudGl0eSkge1xuICAgICAgICBzdXBlcih3aXJlLCBpZGVudGl0eSwgJ3ZpZXcnKTtcbiAgICAgICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgdmlldy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGdldFpvb21MZXZlbFxuICAgICAgICAgKiBAbWVtYmVyT2YgVmlld1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48bnVtYmVyPn1cbiAgICAgICAgICogQHR1dG9yaWFsIFZpZXcuZ2V0Wm9vbUxldmVsXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgdmlldy5cbiAgICAgICAgICogQHBhcmFtIHsgbnVtYmVyIH0gbGV2ZWwgVGhlIHpvb20gbGV2ZWxcbiAgICAgICAgICogQGZ1bmN0aW9uIHNldFpvb21MZXZlbFxuICAgICAgICAgKiBAbWVtYmVyT2YgVmlld1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICAgICAqIEB0dXRvcmlhbCBWaWV3LnNldFpvb21MZXZlbFxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgYW5kIGhpZ2hsaWdodCB0ZXh0IG9uIGEgcGFnZS5cbiAgICAgICAgICogQHBhcmFtIHsgc3RyaW5nIH0gc2VhcmNoVGVybSBUZXJtIHRvIGZpbmQgaW4gcGFnZVxuICAgICAgICAgKiBAcGFyYW0geyBGaW5kSW5QYWdlT3B0aW9ucyB9IG9wdGlvbnMgU2VhcmNoIG9wdGlvbnNcbiAgICAgICAgICogQGZ1bmN0aW9uIGZpbmRJblBhZ2VcbiAgICAgICAgICogQG1lbWJlck9mIFZpZXdcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2UuPG51bWJlcj59XG4gICAgICAgICAqIEB0dXRvcmlhbCBWaWV3LmZpbmRJblBhZ2VcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wcyBhbnkgZmluZEluUGFnZSBjYWxsIHdpdGggdGhlIHByb3ZpZGVkIGFjdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAgICAgKiBBY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHN0b3BwaW5nIGEgZmluZCBpbiBwYWdlOjxicj5cbiAgICAgICAgICogXCJjbGVhclNlbGVjdGlvblwiIC0gQ2xlYXIgdGhlIHNlbGVjdGlvbi48YnI+XG4gICAgICAgICAqIFwia2VlcFNlbGVjdGlvblwiIC0gVHJhbnNsYXRlIHRoZSBzZWxlY3Rpb24gaW50byBhIG5vcm1hbCBzZWxlY3Rpb24uPGJyPlxuICAgICAgICAgKiBcImFjdGl2YXRlU2VsZWN0aW9uXCIgLSBGb2N1cyBhbmQgY2xpY2sgdGhlIHNlbGVjdGlvbiBub2RlLjxicj5cbiAgICAgICAgICogQGZ1bmN0aW9uIHN0b3BGaW5kSW5QYWdlXG4gICAgICAgICAqIEBtZW1iZXJPZiBWaWV3XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgICAgICogQHR1dG9yaWFsIFZpZXcuc3RvcEZpbmRJblBhZ2VcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYXZpZ2F0ZXMgdGhlIHZpZXcgdG8gYSBzcGVjaWZpZWQgVVJMLiBUaGUgdXJsIG11c3QgY29udGFpbiB0aGUgcHJvdG9jb2wgcHJlZml4IHN1Y2ggYXMgaHR0cDovLyBvciBodHRwczovLy5cbiAgICAgICAgICogQHBhcmFtIHsgc3RyaW5nIH0gdXJsIC0gVGhlIFVSTCB0byBuYXZpZ2F0ZSB0aGUgdmlldyB0by5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICAgICAqIEBmdW5jdGlvbiBuYXZpZ2F0ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgVmlld1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR1dG9yaWFsIFZpZXcubmF2aWdhdGVcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hdmlnYXRlcyB0aGUgdmlldyBiYWNrIG9uZSBwYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gbmF2aWdhdGVCYWNrXG4gICAgICAgICAqIEBtZW1iZXJPZiBWaWV3XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgICAgICogQHR1dG9yaWFsIFZpZXcubmF2aWdhdGVCYWNrXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogTmF2aWdhdGVzIHRoZSB2aWV3IGZvcndhcmQgb25lIHBhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiBuYXZpZ2F0ZUZvcndhcmRcbiAgICAgICAgICogQG1lbWJlck9mIFZpZXdcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAgICAgKiBAdHV0b3JpYWwgVmlldy5uYXZpZ2F0ZUZvcndhcmRcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wcyBhbnkgY3VycmVudCBuYXZpZ2F0aW9uIHRoZSB2aWV3IGlzIHBlcmZvcm1pbmcuXG4gICAgICAgICAqIEBmdW5jdGlvbiBzdG9wTmF2aWdhdGlvblxuICAgICAgICAgKiBAbWVtYmVyT2YgVmlld1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICAgICAqIEB0dXRvcmlhbCBWaWV3LnN0b3BOYXZpZ2F0aW9uXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVsb2FkcyB0aGUgdmlldyBjdXJyZW50IHBhZ2VcbiAgICAgICAgICogQGZ1bmN0aW9uIHJlbG9hZFxuICAgICAgICAgKiBAbWVtYmVyT2YgVmlld1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICAgICAqIEB0dXRvcmlhbCBWaWV3LnJlbG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaW50cyB0aGUgdmlldydzIHdlYiBwYWdlXG4gICAgICAgICAqIEBwYXJhbSB7IFByaW50T3B0aW9ucyB9IFtvcHRpb25zXSBQcmludGVyIE9wdGlvbnNcbiAgICAgICAgICogQGZ1bmN0aW9uIHByaW50XG4gICAgICAgICAqIEBtZW1iZXJPZiBWaWV3XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgICAgICogQHR1dG9yaWFsIFZpZXcucHJpbnRcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggYWxsIHN5c3RlbSBwcmludGVyc1xuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0UHJpbnRlcnNcbiAgICAgICAgICogQG1lbWJlck9mIFZpZXdcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm4geyBQcm9taXNlLkFycmF5LjxQcmludGVySW5mbz4gfVxuICAgICAgICAgKiBAdHV0b3JpYWwgVmlldy5nZXRQcmludGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3dzIHRoZSBDaHJvbWl1bSBEZXZlbG9wZXIgVG9vbHNcbiAgICAgICAgICogQGZ1bmN0aW9uIHNob3dEZXZlbG9wZXJUb29sc1xuICAgICAgICAgKiBAbWVtYmVyT2YgVmlld1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICAgICAqIEB0dXRvcmlhbCBWaWV3LnNob3dEZXZlbG9wZXJUb29sc1xuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgcHJvY2VzcyBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggYSB2aWV3LlxuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0UHJvY2Vzc0luZm9cbiAgICAgICAgICogQG1lbWJlck9mIFZpZXdcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2UuPEVudGl0eVByb2Nlc3NEZXRhaWxzPn1cbiAgICAgICAgICogQHR1dG9yaWFsIFZpZXcuZ2V0UHJvY2Vzc0luZm9cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gb24gYWxsIFNoYXJlZCBXb3JrZXJzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0U2hhcmVkV29ya2Vyc1xuICAgICAgICAgKiBAbWVtYmVyT2YgVmlld1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS5BcnJheS48U2hhcmVkV29ya2VySW5mbz59XG4gICAgICAgICAqIEB0dXRvcmlhbCBWaWV3LmdldFNoYXJlZFdvcmtlcnNcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVucyB0aGUgZGV2ZWxvcGVyIHRvb2xzIGZvciB0aGUgc2hhcmVkIHdvcmtlciBjb250ZXh0LlxuICAgICAgICAgKiBAZnVuY3Rpb24gaW5zcGVjdFNoYXJlZFdvcmtlclxuICAgICAgICAgKiBAbWVtYmVyT2YgVmlld1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICAgICAqIEB0dXRvcmlhbCBWaWV3Lmluc3BlY3RTaGFyZWRXb3JrZXJcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNwZWN0cyB0aGUgc2hhcmVkIHdvcmtlciBiYXNlZCBvbiBpdHMgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHdvcmtlcklkIC0gVGhlIGlkIG9mIHRoZSBzaGFyZWQgd29ya2VyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gaW5zcGVjdFNoYXJlZFdvcmtlckJ5SWRcbiAgICAgICAgICogQG1lbWJlck9mIFZpZXdcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAgICAgKiBAdHV0b3JpYWwgVmlldy5pbnNwZWN0U2hhcmVkV29ya2VyQnlJZFxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZW5zIHRoZSBkZXZlbG9wZXIgdG9vbHMgZm9yIHRoZSBzZXJ2aWNlIHdvcmtlciBjb250ZXh0LlxuICAgICAgICAgKiBAZnVuY3Rpb24gaW5zcGVjdFNlcnZpY2VXb3JrZXJcbiAgICAgICAgICogQG1lbWJlck9mIFZpZXdcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAgICAgKiBAdHV0b3JpYWwgVmlldy5pbnNwZWN0U2VydmljZVdvcmtlclxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGFjaGVzIHRoZSBjdXJyZW50IHZpZXcgdG8gYSB0aGUgZ2l2ZW4gd2luZG93IGlkZW50aXR5LlxuICAgICAgICAgKiBJZGVudGl0eSBtdXN0IGJlIHRoZSBpZGVudGl0eSBvZiBhIHdpbmRvdyBpbiB0aGUgc2FtZSBhcHBsaWNhdGlvbi5cbiAgICAgICAgICogVGhpcyBkZXRhY2hlcyB0aGUgdmlldyBmcm9tIGl0cyBjdXJyZW50IHdpbmRvdywgYW5kIHNldHMgdGhlIHZpZXcgdG8gYmUgZGVzdHJveWVkIHdoZW4gaXRzIG5ldyB3aW5kb3cgY2xvc2VzLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IHtJZGVudGl0eX1cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICAgICAqIEB0dXRvcmlhbCBWaWV3LmF0dGFjaFxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0dGFjaCA9IGFzeW5jICh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdhdHRhY2gtdmlldycsIHsgdGFyZ2V0LCAuLi50aGlzLmlkZW50aXR5IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveXMgdGhlIGN1cnJlbnQgdmlld1xuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgICAgICogQHR1dG9yaWFsIFZpZXcuZGVzdHJveVxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZGVzdHJveS12aWV3JywgeyAuLi50aGlzLmlkZW50aXR5IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvd3MgdGhlIGN1cnJlbnQgdmlldyBpZiBpdCBpcyBjdXJyZW50bHkgaGlkZGVuLlxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgICAgICogQHR1dG9yaWFsIFZpZXcuc2hvd1xuICAgICAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3cgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignc2hvdy12aWV3JywgeyAuLi50aGlzLmlkZW50aXR5IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZXMgdGhlIGN1cnJlbnQgdmlldyBpZiBpdCBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICAgICAqIEB0dXRvcmlhbCBWaWV3LmhpZGVcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaWRlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2hpZGUtdmlldycsIHsgLi4udGhpcy5pZGVudGl0eSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGJvdW5kcyAodG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KSBvZiB0aGUgdmlldyByZWxhdGl2ZSB0byBpdHMgd2luZG93LlxuICAgICAgICAgKiBAcGFyYW0gYm91bmRzIHtWaWV3Qm91bmRzfVxuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgICAgICogQHR1dG9yaWFsIFZpZXcuc2V0Qm91bmRzXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Qm91bmRzID0gYXN5bmMgKGJvdW5kcykgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3NldC12aWV3LWJvdW5kcycsIHsgYm91bmRzLCAuLi50aGlzLmlkZW50aXR5IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgYm91bmRzICh0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQpIG9mIHRoZSB2aWV3IHJlbGF0aXZlIHRvIGl0cyB3aW5kb3cuXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2UuPFZpZXdCb3VuZHM+fVxuICAgICAgICAgKiBAdHV0b3JpYWwgVmlldy5nZXRCb3VuZHNcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRCb3VuZHMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY2sgPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXZpZXctYm91bmRzJywgeyAuLi50aGlzLmlkZW50aXR5IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFjay5wYXlsb2FkLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBWaWV3J3MgaW5mby5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48Vmlld0luZm8+fVxuICAgICAgICAgKiBAdHV0b3JpYWwgVmlldy5nZXRJbmZvXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0SW5mbyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjayA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtdmlldy1pbmZvJywgeyAuLi50aGlzLmlkZW50aXR5IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFjay5wYXlsb2FkLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIGxheW91dCBmb3IgdGhlIHdpbmRvdyB0aGUgdmlldyBpcyBhdHRhY2hlZCB0by5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48TGF5b3V0Pn1cbiAgICAgICAgICogQHR1dG9yaWFsIFZpZXcuZ2V0UGFyZW50TGF5b3V0XG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UGFyZW50TGF5b3V0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3ZpZXctZ2V0LXBhcmVudC1sYXlvdXQnLCB7IC4uLnRoaXMuaWRlbnRpdHkgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBleHBvc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFdpbmRvdyA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudFdpbmRvdygpO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRXaW5kb3cuZ2V0TGF5b3V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBWaWV3J3Mgb3B0aW9ucy5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZTxWaWV3T3B0aW9ucz59XG4gICAgICAgICAqIEB0dXRvcmlhbCBWaWV3LmdldE9wdGlvbnNcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRPcHRpb25zID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtdmlldy1vcHRpb25zJywgeyAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdmlldydzIG9wdGlvbnMuXG4gICAgICAgICAqIEBwYXJhbSB7IFBhcnRpYWw8Vmlld09wdGlvbnM+IH0gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgICAgICogQHR1dG9yaWFsIFZpZXcudXBkYXRlT3B0aW9uc1xuICAgICAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd1cGRhdGUtdmlldy1vcHRpb25zJywgeyBvcHRpb25zLCAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgd2luZG93IHRoZSB2aWV3IGlzIGN1cnJlbnRseSBhdHRhY2hlZCB0by5cbiAgICAgICAgICogQHJldHVybiB7UHJvbWlzZS48X1dpbmRvdz59XG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFdpbmRvdyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF5bG9hZDogeyBkYXRhIH0gfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtdmlldy13aW5kb3cnLCB7IC4uLnRoaXMuaWRlbnRpdHkgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvd18xLl9XaW5kb3codGhpcy53aXJlLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b3BpYyA9ICd2aWV3JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJhc2U2NCBlbmNvZGVkIGltYWdlIG9mIHRoZSB2aWV3IG9yIGEgcGFydCBvZiBpdC5cbiAgICAgKiBAZnVuY3Rpb24gY2FwdHVyZVBhZ2VcbiAgICAgKiBAcGFyYW0geyBDYXB0dXJlUGFnZU9wdGlvbnMgfSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIGNhcHR1cmVQYWdlIGNhbGwuXG4gICAgICogQG1lbWJlck9mIFZpZXdcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxzdHJpbmc+fVxuICAgICAqIEB0dXRvcmlhbCBWaWV3LmNhcHR1cmVQYWdlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgSmF2YXNjcmlwdCBvbiB0aGUgdmlldywgcmVzdHJpY3RlZCB0byBjb250ZW50cyB5b3Ugb3duIG9yIGNvbnRlbnRzIG93bmVkIGJ5XG4gICAgICogYXBwbGljYXRpb25zIHlvdSBoYXZlIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gY29kZSBKYXZhU2NyaXB0IGNvZGUgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIHZpZXcuXG4gICAgICogQGZ1bmN0aW9uIGV4ZWN1dGVKYXZhU2NyaXB0XG4gICAgICogQG1lbWJlck9mIFZpZXdcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgVmlldy5leGVjdXRlSmF2YVNjcmlwdFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIHZpZXdcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAZnVuY3Rpb24gZm9jdXNcbiAgICAgKiBAbWVtYmVyb2YgVmlld1xuICAgICAqIEBlbWl0cyBmb2N1c2VkXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHR1dG9yaWFsIFZpZXcuZm9jdXNcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgZm9jdXMoeyBlbWl0U3ludGhGb2N1c2VkIH0gPSB7IGVtaXRTeW50aEZvY3VzZWQ6IHRydWUgfSkge1xuICAgICAgICBjb25zdCB3aW4gPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRXaW5kb3coKTtcbiAgICAgICAgYXdhaXQgd2luLmZvY3VzZWRXZWJWaWV3V2FzQ2hhbmdlZCgpO1xuICAgICAgICBhd2FpdCBzdXBlci5mb2N1cyh7IGVtaXRTeW50aEZvY3VzZWQgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5WaWV3ID0gVmlldztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9GYWN0b3J5XCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRmFjdG9yeV8xLmRlZmF1bHQ7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSW5zdGFuY2VcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYkNvbnRlbnRzID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG5jbGFzcyBXZWJDb250ZW50cyBleHRlbmRzIGJhc2VfMS5FbWl0dGVyQmFzZSB7XG4gICAgY29uc3RydWN0b3Iod2lyZSwgaWRlbnRpdHksIGVudGl0eVR5cGUpIHtcbiAgICAgICAgc3VwZXIod2lyZSwgW2VudGl0eVR5cGUsIGlkZW50aXR5LnV1aWQsIGlkZW50aXR5Lm5hbWVdKTtcbiAgICAgICAgdGhpcy5lbnRpdHlUeXBlID0gZW50aXR5VHlwZTtcbiAgICB9XG4gICAgY2FwdHVyZVBhZ2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2NhcHR1cmUtcGFnZScsIHsgb3B0aW9ucywgLi4udGhpcy5pZGVudGl0eSB9KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgZXhlY3V0ZUphdmFTY3JpcHQoY29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlXG4gICAgICAgICAgICAuc2VuZEFjdGlvbignZXhlY3V0ZS1qYXZhc2NyaXB0LWluLXdpbmRvdycsIHsgLi4udGhpcy5pZGVudGl0eSwgY29kZSB9KVxuICAgICAgICAgICAgLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICBnZXRab29tTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXpvb20tbGV2ZWwnLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgc2V0Wm9vbUxldmVsKGxldmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignc2V0LXpvb20tbGV2ZWwnLCB7IC4uLnRoaXMuaWRlbnRpdHksIGxldmVsIH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgbmF2aWdhdGUodXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignbmF2aWdhdGUtd2luZG93JywgeyAuLi50aGlzLmlkZW50aXR5LCB1cmwgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBuYXZpZ2F0ZUJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignbmF2aWdhdGUtd2luZG93LWJhY2snLCB7IC4uLnRoaXMuaWRlbnRpdHkgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBhc3luYyBuYXZpZ2F0ZUZvcndhcmQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCduYXZpZ2F0ZS13aW5kb3ctZm9yd2FyZCcsIHsgLi4udGhpcy5pZGVudGl0eSB9KTtcbiAgICB9XG4gICAgc3RvcE5hdmlnYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignc3RvcC13aW5kb3ctbmF2aWdhdGlvbicsIHsgLi4udGhpcy5pZGVudGl0eSB9KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJlbG9hZChpZ25vcmVDYWNoZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmVcbiAgICAgICAgICAgIC5zZW5kQWN0aW9uKCdyZWxvYWQtd2luZG93Jywge1xuICAgICAgICAgICAgaWdub3JlQ2FjaGUsXG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBwcmludChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbigncHJpbnQnLCB7IC4uLnRoaXMuaWRlbnRpdHksIG9wdGlvbnMgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBmaW5kSW5QYWdlKHNlYXJjaFRlcm0sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ2ZpbmQtaW4tcGFnZScsIHsgLi4udGhpcy5pZGVudGl0eSwgc2VhcmNoVGVybSwgb3B0aW9ucyB9KVxuICAgICAgICAgICAgLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICBzdG9wRmluZEluUGFnZShhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzdG9wLWZpbmQtaW4tcGFnZScsIHsgLi4udGhpcy5pZGVudGl0eSwgYWN0aW9uIH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZ2V0UHJpbnRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXByaW50ZXJzJywgeyAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICBhc3luYyBmb2N1cyh7IGVtaXRTeW50aEZvY3VzZWQgfSA9IHsgZW1pdFN5bnRoRm9jdXNlZDogdHJ1ZSB9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdmb2N1cy13aW5kb3cnLCB7IGVtaXRTeW50aEZvY3VzZWQsIC4uLnRoaXMuaWRlbnRpdHkgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNob3dEZXZlbG9wZXJUb29scygpIHtcbiAgICAgICAgLy8gTm90ZSB0aGlzIGhpdHMgdGhlIHN5c3RlbSBhY3Rpb24gbWFwIGluIGNvcmUgc3RhdGUgZm9yIGxlZ2FjeSByZWFzb25zLlxuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignc2hvdy1kZXZlbG9wZXItdG9vbHMnLCB0aGlzLmlkZW50aXR5KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvY2Vzc0luZm8oKSB7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZDogeyBkYXRhIH0gfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtcHJvY2Vzcy1pbmZvJywgdGhpcy5pZGVudGl0eSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBhc3luYyBnZXRTaGFyZWRXb3JrZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC1zaGFyZWQtd29ya2VycycsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICBhc3luYyBpbnNwZWN0U2hhcmVkV29ya2VyKCkge1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignaW5zcGVjdC1zaGFyZWQtd29ya2VyJywgeyAuLi50aGlzLmlkZW50aXR5IH0pO1xuICAgIH1cbiAgICBhc3luYyBpbnNwZWN0U2hhcmVkV29ya2VyQnlJZCh3b3JrZXJJZCkge1xuICAgICAgICBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignaW5zcGVjdC1zaGFyZWQtd29ya2VyLWJ5LWlkJywgeyAuLi50aGlzLmlkZW50aXR5LCB3b3JrZXJJZCB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW5zcGVjdFNlcnZpY2VXb3JrZXIoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpbnNwZWN0LXNlcnZpY2Utd29ya2VyJywgeyAuLi50aGlzLmlkZW50aXR5IH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViQ29udGVudHMgPSBXZWJDb250ZW50cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4uL2Jhc2VcIik7XG5jb25zdCB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvdmFsaWRhdGVcIik7XG5jb25zdCBJbnN0YW5jZV8xID0gcmVxdWlyZShcIi4vSW5zdGFuY2VcIik7XG4vKipcbiAqIEBsZW5kcyBXaW5kb3dcbiAqL1xuY2xhc3MgX1dpbmRvd01vZHVsZSBleHRlbmRzIGJhc2VfMS5CYXNlIHtcbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSByZXR1cm5zIGEgV2luZG93IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYW4gZXhpc3Rpbmcgd2luZG93LlxuICAgICAqIEBwYXJhbSB7IElkZW50aXR5IH0gaWRlbnRpdHlcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxfV2luZG93Pn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LndyYXBcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgYXN5bmMgd3JhcChpZGVudGl0eSkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignd2luZG93LXdyYXAnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlcnJvck1zZyA9IHZhbGlkYXRlXzEudmFsaWRhdGVJZGVudGl0eShpZGVudGl0eSk7XG4gICAgICAgIGlmIChlcnJvck1zZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEluc3RhbmNlXzEuX1dpbmRvdyh0aGlzLndpcmUsIGlkZW50aXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGEgV2luZG93IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYW4gZXhpc3Rpbmcgd2luZG93LlxuICAgICAqIEBwYXJhbSB7IElkZW50aXR5IH0gaWRlbnRpdHlcbiAgICAgKiBAcmV0dXJuIHtfV2luZG93fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cud3JhcFN5bmNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgd3JhcFN5bmMoaWRlbnRpdHkpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3dpbmRvdy13cmFwLXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlcnJvck1zZyA9IHZhbGlkYXRlXzEudmFsaWRhdGVJZGVudGl0eShpZGVudGl0eSk7XG4gICAgICAgIGlmIChlcnJvck1zZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEluc3RhbmNlXzEuX1dpbmRvdyh0aGlzLndpcmUsIGlkZW50aXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBXaW5kb3cuXG4gICAgICogQHBhcmFtIHsgV2luZG93fm9wdGlvbnMgfSBvcHRpb25zIC0gV2luZG93IGNyZWF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxfV2luZG93Pn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmNyZWF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBjcmVhdGUob3B0aW9ucykge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignY3JlYXRlLXdpbmRvdycpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhpcyBlcnJvciwganVzdCBjb250aW51ZSBpZiB0aGlzIGFuYWx5dGljcy1vbmx5IGNhbGwgZmFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHdpbiA9IG5ldyBJbnN0YW5jZV8xLl9XaW5kb3codGhpcy53aXJlLCB7IHV1aWQ6IHRoaXMubWUudXVpZCwgbmFtZTogb3B0aW9ucy5uYW1lIH0pO1xuICAgICAgICByZXR1cm4gd2luLmNyZWF0ZVdpbmRvdyhvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgcmV0dXJucyBhIFdpbmRvdyBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHdpbmRvd1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPF9XaW5kb3c+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZ2V0Q3VycmVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50KCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWN1cnJlbnQtd2luZG93JykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLndpcmUubWUuaXNXaW5kb3cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgaW4gYSBXaW5kb3cgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdXVpZCwgbmFtZSB9ID0gdGhpcy53aXJlLm1lO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwKHsgdXVpZCwgbmFtZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSByZXR1cm5zIGEgV2luZG93IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgd2luZG93XG4gICAgICogQHJldHVybiB7X1dpbmRvd31cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmdldEN1cnJlbnRTeW5jXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGdldEN1cnJlbnRTeW5jKCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWN1cnJlbnQtd2luZG93LXN5bmMnKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMud2lyZS5tZS5pc1dpbmRvdykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIG5vdCBpbiBhIFdpbmRvdyBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB1dWlkLCBuYW1lIH0gPSB0aGlzLndpcmUubWU7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBTeW5jKHsgdXVpZCwgbmFtZSB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBfV2luZG93TW9kdWxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLl9XaW5kb3cgPSB2b2lkIDA7XG5jb25zdCBhcHBsaWNhdGlvbl8xID0gcmVxdWlyZShcIi4uL2FwcGxpY2F0aW9uXCIpO1xuY29uc3QgZXh0ZXJuYWxfd2luZG93XzEgPSByZXF1aXJlKFwiLi4vZXh0ZXJuYWwtd2luZG93XCIpO1xuY29uc3Qgd2ViY29udGVudHNfMSA9IHJlcXVpcmUoXCIuLi93ZWJjb250ZW50c1wiKTtcbmNvbnN0IHZpZXdfMSA9IHJlcXVpcmUoXCIuLi92aWV3XCIpO1xuY29uc3QgRW50aXR5VHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL3NoYXBlcy9FbnRpdHlUeXBlXCIpO1xuLyoqXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IE1hcmdpbnNcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IFttYXJnaW5UeXBlXVxuICogQ2FuIGJlIGBkZWZhdWx0YCwgYG5vbmVgLCBgcHJpbnRhYmxlQXJlYWAsIG9yIGBjdXN0b21gLiBJZiBgY3VzdG9tYCBpcyBjaG9zZW4sXG4gKiB5b3Ugd2lsbCBhbHNvIG5lZWQgdG8gc3BlY2lmeSBgdG9wYCwgYGJvdHRvbWAsIGBsZWZ0YCwgYW5kIGByaWdodGAuXG4gKlxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gW3RvcF0gVGhlIHRvcCBtYXJnaW4gb2YgdGhlIHByaW50ZWQgd2ViIHBhZ2UsIGluIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IFtib3R0b21dIFRoZSBib3R0b20gbWFyZ2luIG9mIHRoZSBwcmludGVkIHdlYiBwYWdlLCBpbiBwaXhlbHMuXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBbbGVmdF0gVGhlIGxlZnQgbWFyZ2luIG9mIHRoZSBwcmludGVkIHdlYiBwYWdlLCBpbiBwaXhlbHMuXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBbcmlnaHRdIFRoZSByaWdodCBtYXJnaW4gb2YgdGhlIHByaW50ZWQgd2ViIHBhZ2UsIGluIHBpeGVscy5cbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7IG9iamVjdCB9IERwaVxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gW2hvcml6b250YWxdIFRoZSBob3Jpem9udGFsIGRwaVxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gW3ZlcnRpY2FsXSBUaGUgdmVydGljYWwgZHBpXG4gKi9cbi8qKlxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBQcmludE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBbc2lsZW50PWZhbHNlXSBEb24ndCBhc2sgdXNlciBmb3IgcHJpbnQgc2V0dGluZ3MuXG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gW3ByaW50QmFja2dyb3VuZD1mYWxzZV0gUHJpbnRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFuZCBpbWFnZSBvZiB0aGUgd2ViIHBhZ2UuXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBbZGV2aWNlTmFtZT0nJ10gU2V0IHRoZSBwcmludGVyIGRldmljZSBuYW1lIHRvIHVzZS5cbiAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gfSBbY29sb3I9dHJ1ZV0gU2V0IHdoZXRoZXIgdGhlIHByaW50ZWQgd2ViIHBhZ2Ugd2lsbCBiZSBpbiBjb2xvciBvciBncmF5c2NhbGUuXG4gKiBAcHJvcGVydHkgeyBNYXJnaW5zIH0gW21hcmdpbnNdIFNldCBtYXJnaW5zIGZvciB0aGUgcHJpbnRlZCB3ZWIgcGFnZVxuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IFtsYW5kc2NhcGU9ZmFsc2VdIFdoZXRoZXIgdGhlIHdlYiBwYWdlIHNob3VsZCBiZSBwcmludGVkIGluIGxhbmRzY2FwZSBtb2RlLlxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gW3NjYWxlRmFjdG9yXSBUaGUgc2NhbGUgZmFjdG9yIG9mIHRoZSB3ZWIgcGFnZS5cbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IFtwYWdlc1BlclNoZWV0XSBUaGUgbnVtYmVyIG9mIHBhZ2VzIHRvIHByaW50IHBlciBwYWdlIHNoZWV0LlxuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IFtjb2xsYXRlXSBXaGV0aGVyIHRoZSB3ZWIgcGFnZSBzaG91bGQgYmUgY29sbGF0ZWQuXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBbY29waWVzXSBUaGUgbnVtYmVyIG9mIGNvcGllcyBvZiB0aGUgd2ViIHBhZ2UgdG8gcHJpbnQuXG4gKiBAcHJvcGVydHkgeyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IH0gW3BhZ2VSYW5nZXNdIFRoZSBwYWdlIHJhbmdlIHRvIHByaW50LiBTaG91bGQgaGF2ZSB0d28ga2V5czogZnJvbSBhbmQgdG8uXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBbZHVwbGV4TW9kZV0gU2V0IHRoZSBkdXBsZXggbW9kZSBvZiB0aGUgcHJpbnRlZCB3ZWIgcGFnZS4gQ2FuIGJlIHNpbXBsZXgsIHNob3J0RWRnZSwgb3IgbG9uZ0VkZ2UuXG4gKiBAcHJvcGVydHkgeyBEcGkgfSBbZHBpXSBTZXQgZHBpIGZvciB0aGUgcHJpbnRlZCB3ZWIgcGFnZVxuICovXG4vKipcbiAqIFByaW50ZXJJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBQcmludGVySW5mb1xuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gbmFtZSBQcmludGVyIE5hbWVcbiAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IGRlc2NyaXB0aW9uIFByaW50ZXIgRGVzY3JpcHRpb25cbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHN0YXR1cyBQcmludGVyIFN0YXR1c1xuICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IGlzRGVmYXVsdCBJbmRpY2F0ZXMgdGhhdCBzeXN0ZW0ncyBkZWZhdWx0IHByaW50ZXJcbiAqL1xuLyoqXG4gKiBTaGFyZWRXb3JrZXJJbmZvIGludGVyZmFjZVxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBTaGFyZWRXb3JrZXJJbmZvXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBpZCBUaGUgdW5pcXVlIGlkIG9mIHRoZSBzaGFyZWQgd29ya2VyLlxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gdXJsIFRoZSB1cmwgb2YgdGhlIHNoYXJlZCB3b3JrZXIuXG4gKi9cbi8qKlxuICogQ29udGVudENyZWF0aW9uUnVsZSBpbnRlcmZhY2VcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gQ29udGVudENyZWF0aW9uUnVsZVxuICogQHByb3BlcnR5IHsgc3RyaW5nIH0gYmVoYXZpb3IgJ3ZpZXcnIHwgJ3dpbmRvdycgfCAnYnJvd3NlcicgfCAnYmxvY2snXG4gKiBAcHJvcGVydHkgeyBzdHJpbmdbXSB9IG1hdGNoIExpc3Qgb2YgW21hdGNoIHBhdHRlcm5zXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvbWF0Y2hfcGF0dGVybnMpLlxuICogQHByb3BlcnR5IHsgb2JqZWN0IH0gb3B0aW9ucyBXaW5kb3cgY3JlYXRpb24gb3B0aW9ucyBvciBWaWV3IGNyZWF0aW9uIG9wdGlvbnMuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gV2luZG93fm9wdGlvbnNcbiAqIEBzdW1tYXJ5IFdpbmRvdyBjcmVhdGlvbiBvcHRpb25zLlxuICogQGRlc2MgVGhpcyBpcyB0aGUgb3B0aW9ucyBvYmplY3QgcmVxdWlyZWQgYnkge0BsaW5rIFdpbmRvdy5jcmVhdGUgV2luZG93LmNyZWF0ZX0uXG4gKlxuICogTm90ZSB0aGF0IGBuYW1lYCBpcyB0aGUgb25seSByZXF1aXJlZCBwcm9wZXJ0eSDigJQgYWxiZWl0IHRoZSBgdXJsYCBwcm9wZXJ0eSBpcyB1c3VhbGx5IHByb3ZpZGVkIGFzIHdlbGxcbiAqIChkZWZhdWx0cyB0byBgXCJhYm91dDpibGFua1wiYCB3aGVuIG9taXR0ZWQpLlxuICpcbiAqIF9UaGlzIGpzZG9jIHR5cGVkZWYgbWlycm9ycyB0aGUgYFdpbmRvd09wdGlvbnNgIFR5cGVTY3JpcHQgaW50ZXJmYWNlIGluIGBAdHlwZXMvb3BlbmZpbmAuX1xuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbYWNjZWxlcmF0b3JdXG4gKiBFbmFibGUga2V5Ym9hcmQgc2hvcnRjdXRzIGZvciBkZXZ0b29scywgem9vbSwgcmVsb2FkLCBhbmQgcmVsb2FkIGlnbm9yaW5nIGNhY2hlLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FjY2VsZXJhdG9yLmRldnRvb2xzPWZhbHNlXVxuICogSWYgYHRydWVgLCBlbmFibGVzIHRoZSBkZXZ0b29scyBrZXlib2FyZCBzaG9ydGN1dDo8YnI+XG4gKiBgQ3RybGAgKyBgU2hpZnRgICsgYElgIF8oVG9nZ2xlcyBEZXZ0b29scylfXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWNjZWxlcmF0b3IucmVsb2FkPWZhbHNlXVxuICogSWYgYHRydWVgLCBlbmFibGVzIHRoZSByZWxvYWQga2V5Ym9hcmQgc2hvcnRjdXRzOjxicj5cbiAqIGBDdHJsYCArIGBSYCBfKFdpbmRvd3MpXzxicj5cbiAqIGBGNWAgXyhXaW5kb3dzKV88YnI+XG4gKiBgQ29tbWFuZGAgKyBgUmAgXyhNYWMpX1xuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FjY2VsZXJhdG9yLnJlbG9hZElnbm9yaW5nQ2FjaGU9ZmFsc2VdXG4gKiBJZiBgdHJ1ZWAsIGVuYWJsZXMgdGhlIHJlbG9hZC1mcm9tLXNvdXJjZSBrZXlib2FyZCBzaG9ydGN1dHM6PGJyPlxuICogYEN0cmxgICsgYFNoaWZ0YCArIGBSYCBfKFdpbmRvd3MpXzxicj5cbiAqIGBTaGlmdGAgKyBgRjVgIF8oV2luZG93cylfPGJyPlxuICogYENvbW1hbmRgICsgYFNoaWZ0YCArIGBSYCBfKE1hYylfXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWNjZWxlcmF0b3Iuem9vbT1mYWxzZV1cbiAqIElmIGB0cnVlYCwgZW5hYmxlcyB0aGUgem9vbSBrZXlib2FyZCBzaG9ydGN1dHM6PGJyPlxuICogYEN0cmxgICsgYCtgIF8oWm9vbSBJbilfPGJyPlxuICogYEN0cmxgICsgYFNoaWZ0YCArIGArYCBfKFpvb20gSW4pXzxicj5cbiAqIGBDdHJsYCArIGBOdW1QYWQrYCBfKFpvb20gSW4pXzxicj5cbiAqIGBDdHJsYCArIGAtYCBfKFpvb20gT3V0KV88YnI+XG4gKiBgQ3RybGAgKyBgU2hpZnRgICsgYC1gIF8oWm9vbSBPdXQpXzxicj5cbiAqIGBDdHJsYCArIGBOdW1QYWQtYCBfKFpvb20gT3V0KV88YnI+XG4gKiBgQ3RybGAgKyBgU2Nyb2xsYCBfKFpvb20gSW4gJiBPdXQpXzxicj5cbiAqIGBDdHJsYCArIGAwYCBfKFJlc3RvcmUgdG8gMTAwJSlfXG4gKlxuICogQHByb3BlcnR5IHtvYmplY3R9IFthbHBoYU1hc2tdIC0gX0V4cGVyaW1lbnRhbC5fICBfVXBkYXRhYmxlLl9cbiAqIDxicj5cbiAqIGFscGhhTWFzayB0dXJucyBhbnl0aGluZyBvZiBtYXRjaGluZyBSR0IgdmFsdWUgdHJhbnNwYXJlbnQuXG4gKiA8YnI+XG4gKiBDYXZlYXRzOlxuICogKiBydW50aW1lIGtleSAtLWRpc2FibGUtZ3B1IGlzIHJlcXVpcmVkLiBOb3RlOiBVbmNsZWFyIGJlaGF2aW9yIG9uIHJlbW90ZSBEZXNrdG9wIHN1cHBvcnRcbiAqICogVXNlciBjYW5ub3QgY2xpY2stdGhyb3VnaCB0cmFuc3BhcmVudCByZWdpb25zXG4gKiAqIE5vdCBzdXBwb3J0ZWQgb24gTWFjXG4gKiAqIFdpbmRvd3MgQWVybyBtdXN0IGJlIGVuYWJsZWRcbiAqICogV29uJ3QgbWFrZSB2aXN1YWwgc2Vuc2Ugb24gUGl4ZWwtcHVzaGVkIGVudmlyb25tZW50cyBzdWNoIGFzIENpdHJpeFxuICogKiBOb3Qgc3VwcG9ydGVkIG9uIHJvdW5kZWQgY29ybmVyIHdpbmRvd3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYWxwaGFNYXNrLnJlZD0tMV0gMC0yNTVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYWxwaGFNYXNrLmdyZWVuPS0xXSAwLTI1NVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthbHBoYU1hc2suYmx1ZT0tMV0gMC0yNTVcbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthbHdheXNPblRvcD1mYWxzZV0gLSBfVXBkYXRhYmxlLl9cbiAqIEEgZmxhZyB0byBhbHdheXMgcG9zaXRpb24gdGhlIHdpbmRvdyBhdCB0aGUgdG9wIG9mIHRoZSB3aW5kb3cgc3RhY2suXG4gKlxuICogQHByb3BlcnR5IHtvYmplY3R9IFthcGldXG4gKiBDb25maWd1cmF0aW9ucyBmb3IgQVBJIGluamVjdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdH0gW2FwaS5pZnJhbWVdIENvbmZpZ3VyZSBpZiB0aGUgdGhlIEFQSSBzaG91bGQgYmUgaW5qZWN0ZWQgaW50byBpZnJhbWVzIGJhc2VkIG9uIGRvbWFpbi5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcGkuaWZyYW1lLmNyb3NzT3JpZ2luSW5qZWN0aW9uPWZhbHNlXSBDb250cm9scyBpZiB0aGUgYGZpbmAgQVBJIG9iamVjdCBpcyBwcmVzZW50IGZvciBjcm9zcyBvcmlnaW4gaWZyYW1lcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FwaS5pZnJhbWUuc2FtZU9yaWdpbkluamVjdGlvbj10cnVlXSBDb250cm9scyBpZiB0aGUgYGZpbmAgQVBJIG9iamVjdCBpcyBwcmVzZW50IGZvciBzYW1lIG9yaWdpbiBpZnJhbWVzLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXBwbGljYXRpb25JY29uID0gXCJcIl0gLSBfRGVwcmVjYXRlZF8gLSB1c2UgYGljb25gIGluc3RlYWQuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthc3BlY3RSYXRpbz0wXSAtIF9VcGRhdGFibGUuX1xuICogVGhlIGFzcGVjdCByYXRpbyBvZiB3aWR0aCB0byBoZWlnaHQgdG8gZW5mb3JjZSBmb3IgdGhlIHdpbmRvdy4gSWYgdGhpcyB2YWx1ZSBpcyBlcXVhbCB0byBvciBsZXNzIHRoYW4gemVybyxcbiAqIGFuIGFzcGVjdCByYXRpbyB3aWxsIG5vdCBiZSBlbmZvcmNlZC5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdXRvU2hvdz10cnVlXVxuICogQSBmbGFnIHRvIGF1dG9tYXRpY2FsbHkgc2hvdyB0aGUgd2luZG93IHdoZW4gaXQgaXMgY3JlYXRlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2JhY2tncm91bmRDb2xvcj1cIiNGRkZcIl1cbiAqIFRoZSB3aW5kb3figJlzIF9iYWNrZmlsbF8gY29sb3IgYXMgYSBoZXhhZGVjaW1hbCB2YWx1ZS4gTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggdGhlIGNvbnRlbnQgYmFja2dyb3VuZCBjb2xvclxuICogKGBkb2N1bWVudC5ib2R5LnN0eWxlLmJhY2tncm91bmRDb2xvcmApLFxuICogdGhpcyBjb2xvciBicmllZmx5IGZpbGxzIGEgd2luZG934oCZcyAoYSkgY29udGVudCBhcmVhIGJlZm9yZSBpdHMgY29udGVudCBpcyBsb2FkZWQgYXMgd2VsbCBhcyAoYikgbmV3bHkgZXhwb3NlZFxuICogYXJlYXMgd2hlbiBncm93aW5nIGEgd2luZG93LiBTZXR0aW5nXG4gKiB0aGlzIHZhbHVlIHRvIHRoZSBhbnRpY2lwYXRlZCBjb250ZW50IGJhY2tncm91bmQgY29sb3IgY2FuIGhlbHAgaW1wcm92ZSB1c2VyIGV4cGVyaWVuY2UuXG4gKiBEZWZhdWx0IGlzIHdoaXRlLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbY29udGVudENyZWF0aW9uXVxuICogQXBwbHkgcnVsZXMgdGhhdCBkZXRlcm1pbmUgaG93IHVzZXIgaW50ZXJhY3Rpb24gKGB3aW5kb3cub3BlbmAgYW5kIGxpbmtzKSBjcmVhdGVzIGNvbnRlbnQuXG4gKiBAcHJvcGVydHkge0NvbnRlbnRDcmVhdGlvblJ1bGVbXX0gW2NvbnRlbnRDcmVhdGlvbi5ydWxlcyA9IFtdXSBMaXN0IG9mIGNvbnRlbnQgY3JlYXRpb24gcnVsZXMuXG4gKlxuICogQHByb3BlcnR5IHtvYmplY3R9IFtjb250ZW50TmF2aWdhdGlvbl1cbiAqIFJlc3RyaWN0IG5hdmlnYXRpb24gdG8gVVJMcyB0aGF0IG1hdGNoIGEgd2hpdGVsaXN0ZWQgcGF0dGVybi5cbiAqIEluIHRoZSBsYWNrIG9mIGEgd2hpdGVsaXN0LCBuYXZpZ2F0aW9uIHRvIFVSTHMgdGhhdCBtYXRjaCBhIGJsYWNrbGlzdGVkIHBhdHRlcm4gd291bGQgYmUgcHJvaGliaXRlZC5cbiAqIFNlZSBbaGVyZV0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL21hdGNoX3BhdHRlcm5zKSBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW2NvbnRlbnROYXZpZ2F0aW9uLndoaXRlbGlzdD1bXV0gTGlzdCBvZiB3aGl0ZWxpc3RlZCBVUkxzLlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW2NvbnRlbnROYXZpZ2F0aW9uLmJsYWNrbGlzdD1bXV0gTGlzdCBvZiBibGFja2xpc3RlZCBVUkxzLlxuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb250ZXh0TWVudT10cnVlXSAtIF9VcGRhdGFibGUuX1xuICogQSBmbGFnIHRvIHNob3cgdGhlIGNvbnRleHQgbWVudSB3aGVuIHJpZ2h0LWNsaWNraW5nIG9uIGEgd2luZG93LlxuICogR2l2ZXMgYWNjZXNzIHRvIHRoZSBkZXZ0b29scyBmb3IgdGhlIHdpbmRvdy5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdH0gW2NvbnRleHRNZW51U2V0dGluZ3NdIC0gX1VwZGF0YWJsZS5fXG4gKiBDb25maWd1cmUgdGhlIGNvbnRleHQgbWVudSB3aGVuIHJpZ2h0LWNsaWNraW5nIG9uIGEgd2luZG93LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29udGV4dE1lbnVTZXR0aW5ncy5lbmFibGU9dHJ1ZV0gU2hvdWxkIHRoZSBjb250ZXh0IG1lbnUgZGlzcGxheSBvbiByaWdodCBjbGljay5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbnRleHRNZW51U2V0dGluZ3MuZGV2dG9vbHM9dHJ1ZV0gU2hvdWxkIHRoZSBjb250ZXh0IG1lbnUgY29udGFpbiBhIGJ1dHRvbiBmb3Igb3BlbmluZyBkZXZ0b29scy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbnRleHRNZW51U2V0dGluZ3MucmVsb2FkPXRydWVdIFNob3VsZCB0aGUgY29udGV4dCBtZW51IGNvbnRhaW4gYSBidXR0b24gZm9yIHJlbG9hZGluZyB0aGUgcGFnZS5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdH0gW2Nvcm5lclJvdW5kaW5nXSAtIF9VcGRhdGFibGUuX1xuICogRGVmaW5lcyBhbmQgYXBwbGllcyByb3VuZGVkIGNvcm5lcnMgZm9yIGEgZnJhbWVsZXNzIHdpbmRvdy4gKipOT1RFOioqIE9uIG1hY09TIGNvcm5lciBpcyBub3QgZWxsaXBzZSBidXQgY2lyY2xlIHJvdW5kZWQgYnkgdGhlXG4gKiAgYXZlcmFnZSBvZiBfaGVpZ2h0XyBhbmQgX3dpZHRoXy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY29ybmVyUm91bmRpbmcuaGVpZ2h0PTBdIFRoZSBoZWlnaHQgaW4gcGl4ZWxzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjb3JuZXJSb3VuZGluZy53aWR0aD0wXSBUaGUgd2lkdGggaW4gcGl4ZWxzLlxuICpcbiAqIEBwcm9wZXJ0eSB7YW55fSBbY3VzdG9tQ29udGV4dD1cIlwiXSAtIF9VcGRhdGFibGUuX1xuICogQSBmaWVsZCB0aGF0IHRoZSB1c2VyIGNhbiB1c2UgdG8gYXR0YWNoIHNlcmlhbGl6YWJsZSBkYXRhIHRoYXQgd2lsbCBiZSBzYXZlZCB3aGVuIHtAbGluayBQbGF0Zm9ybSNnZXRTbmFwc2hvdCBQbGF0Zm9ybS5nZXRTbmFwc2hvdH1cbiAqIGlzIGNhbGxlZC4gIElmIGEgd2luZG93IGluIGEgUGxhdGZvcm0gaXMgdHJ5aW5nIHRvIHVwZGF0ZSBvciByZXRyaWV2ZSBpdHMgb3duIGNvbnRleHQsIGl0IGNhbiB1c2UgdGhlXG4gKiB7QGxpbmsgUGxhdGZvcm0jc2V0V2luZG93Q29udGV4dCBQbGF0Zm9ybS5zZXRXaW5kb3dDb250ZXh0fSBhbmQge0BsaW5rIFBsYXRmb3JtI2dldFdpbmRvd0NvbnRleHQgUGxhdGZvcm0uZ2V0V2luZG93Q29udGV4dH0gY2FsbHMuXG4gKiBXaGVuIG9taXR0ZWQsIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgaXMgdGhlIGVtcHR5IHN0cmluZyAoYFwiXCJgKS5cbiAqIEFzIG9wcG9zZWQgdG8gY3VzdG9tRGF0YSB0aGlzIGlzIG1lYW50IGZvciBmcmVxdWVudCB1cGRhdGVzIGFuZCBzaGFyaW5nIHdpdGggb3RoZXIgY29udGV4dHMuIFtFeGFtcGxlXXtAdHV0b3JpYWwgY3VzdG9tQ29udGV4dH1cbiAqXG4gKiBAcHJvcGVydHkge2FueX0gW2N1c3RvbURhdGE9XCJcIl0gLSBfVXBkYXRhYmxlLl9cbiAqIEEgZmllbGQgdGhhdCB0aGUgdXNlciBjYW4gYXR0YWNoIHNlcmlhbGl6YWJsZSBkYXRhIHRvIHRvIGJlIGZlcnJpZWQgYXJvdW5kIHdpdGggdGhlIHdpbmRvdyBvcHRpb25zLlxuICogX1doZW4gb21pdHRlZCwgdGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBpcyB0aGUgZW1wdHkgc3RyaW5nIChgXCJcImApLl9cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdFtdfSBbY3VzdG9tUmVxdWVzdEhlYWRlcnNdXG4gKiBEZWZpbmVzIGxpc3Qgb2YgY3VzdG9tIGhlYWRlcnMgZm9yIHJlcXVlc3RzIHNlbnQgYnkgdGhlIHdpbmRvdy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtjdXN0b21SZXF1ZXN0SGVhZGVycy51cmxQYXR0ZXJucz1bXV0gVGhlIFVSTCBwYXR0ZXJucyBmb3Igd2hpY2ggdGhlIGhlYWRlcnMgd2lsbCBiZSBhcHBsaWVkXG4gKiBAcHJvcGVydHkge29iamVjdFtdfSBbY3VzdG9tUmVxdWVzdEhlYWRlcnMuaGVhZGVycz1bXV0gT2JqZWN0cyByZXByZXNlbnRpbmcgaGVhZGVycyBhbmQgdGhlaXIgdmFsdWVzLFxuICogd2hlcmUgdGhlIG9iamVjdCBrZXkgaXMgdGhlIG5hbWUgb2YgaGVhZGVyIGFuZCB2YWx1ZSBhdCBrZXkgaXMgdGhlIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjbG9zZU9uTGFzdFZpZXdSZW1vdmVkPXRydWVdIC0gX0V4cGVyaW1lbnRhbC5fICBfVXBkYXRhYmxlLl9cbiAqIFRvZ2dsaW5nIG9mZiB3b3VsZCBrZWVwIHRoZSBXaW5kb3cgYWxpdmUgZXZlbiBpZiBhbGwgaXRzIFZpZXdzIHdlcmUgY2xvc2VkLlxuICogVGhpcyBpcyBtZWFudCBmb3IgYWR2YW5jZWQgdXNlcnMgYW5kIHNob3VsZCBiZSB1c2VkIHdpdGggY2F1dGlvbi5cbiAqIExpbWl0YXRpb25zIC0gT25jZSBhIExheW91dCBoYXMgYmVlbiBlbXB0aWVkIG91dCBvZiBhbGwgdmlld3MgaXQncyBub3QgdXNhYmxlIGFueW1vcmUsIGFuZCBjZXJ0YWluIEFQSSBjYWxscyB3aWxsIGZhaWwuXG4gKiBVc2UgYGxheW91dC5yZXBsYWNlYCB0byBjcmVhdGUgYSBmcmVzaCBMYXlvdXQgaW5zdGFuY2UgaW4gY2FzZSB5b3Ugd2FudCB0byBwb3B1bGF0ZSBpdCB3aXRoIFZpZXdzIGFnYWluLlxuICogKiogbm90ZSAqKiAtIFRoaXMgb3B0aW9uIGlzIGlnbm9yZWQgaW4gbm9uLVBsYXRmb3JtcyBhcHBzLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlZmF1bHRDZW50ZXJlZD1mYWxzZV1cbiAqIENlbnRlcnMgdGhlIHdpbmRvdyBpbiB0aGUgcHJpbWFyeSBtb25pdG9yLiBUaGlzIG9wdGlvbiBvdmVycmlkZXMgYGRlZmF1bHRMZWZ0YCBhbmQgYGRlZmF1bHRUb3BgLiBXaGVuIGBzYXZlV2luZG93U3RhdGVgIGlzIGB0cnVlYCxcbiAqIHRoaXMgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGZvciBzdWJzZXF1ZW50IGxhdW5jaGVzIGluIGZhdm9yIG9mIHRoZSBjYWNoZWQgdmFsdWUuICoqTk9URToqKiBPbiBtYWNPUyBfZGVmYXVsdENlbnRlcl8gaXNcbiAqIHNvbWV3aGF0IGFib3ZlIGNlbnRlciB2ZXJ0aWNhbGx5LlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVmYXVsdEhlaWdodD01MDBdXG4gKiBUaGUgZGVmYXVsdCBoZWlnaHQgb2YgdGhlIHdpbmRvdy4gV2hlbiBgc2F2ZVdpbmRvd1N0YXRlYCBpcyBgdHJ1ZWAsIHRoaXMgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGZvciBzdWJzZXF1ZW50IGxhdW5jaGVzXG4gKiBpbiBmYXZvciBvZiB0aGUgY2FjaGVkIHZhbHVlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVmYXVsdExlZnQ9MTAwXVxuICogVGhlIGRlZmF1bHQgbGVmdCBwb3NpdGlvbiBvZiB0aGUgd2luZG93LiBXaGVuIGBzYXZlV2luZG93U3RhdGVgIGlzIGB0cnVlYCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgZm9yIHN1YnNlcXVlbnRcbiAqIGxhdW5jaGVzIGluIGZhdm9yIG9mIHRoZSBjYWNoZWQgdmFsdWUuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWZhdWx0VG9wPTEwMF1cbiAqIFRoZSBkZWZhdWx0IHRvcCBwb3NpdGlvbiBvZiB0aGUgd2luZG93LiBXaGVuIGBzYXZlV2luZG93U3RhdGVgIGlzIGB0cnVlYCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgZm9yIHN1YnNlcXVlbnRcbiAqIGxhdW5jaGVzIGluIGZhdm9yIG9mIHRoZSBjYWNoZWQgdmFsdWUuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWZhdWx0V2lkdGg9ODAwXVxuICogVGhlIGRlZmF1bHQgd2lkdGggb2YgdGhlIHdpbmRvdy4gV2hlbiBgc2F2ZVdpbmRvd1N0YXRlYCBpcyBgdHJ1ZWAsIHRoaXMgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGZvciBzdWJzZXF1ZW50XG4gKiBsYXVuY2hlcyBpbiBmYXZvciBvZiB0aGUgY2FjaGVkIHZhbHVlLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2luY2x1ZGVJblNuYXBzaG90cz10cnVlXSAtIF9VcGRhdGFibGUuX1xuICogV2hlbiB0cnVlLCB0aGUgd2luZG93IHdpbGwgYmUgYmUgaW5jbHVkZWQgaW4gc25hcHNob3RzIHJldHVybmVkIGJ5IFBsYXRmb3JtLmdldFNuYXBzaG90KCkuIFR1cm5pbmcgdGhpcyBvZmYgbWF5IGJlIGRlc2lyYWJsZSB3aGVuIGRlYWxpbmcgd2l0aFxuICogaW5oZXJlbnRseSB0ZW1wb3Jhcnkgd2luZG93cyB3aG9zZSBzdGF0ZSBzaG91bGRuJ3QgYmUgcHJlc2VydmVkLCBzdWNoIGFzIG1vZGFscywgbWVudXMsIG9yIHBvcHVwcy5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmcmFtZT10cnVlXSAtIF9VcGRhdGFibGUuX1xuICogQSBmbGFnIHRvIHNob3cgdGhlIGZyYW1lLlxuICpcbiAqIEBoaWRkZW4tcHJvcGVydHkge2Jvb2xlYW59IFtoaWRlT25DbG9zZT1mYWxzZV0gLSBBIGZsYWcgdG8gYWxsb3cgYSB3aW5kb3cgdG8gYmUgaGlkZGVuIHdoZW4gdGhlIGNsb3NlIGJ1dHRvbiBpcyBjbGlja2VkLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0W119IFtob3RrZXlzPVtdXSAtIF9VcGRhdGFibGUuX1xuICogRGVmaW5lcyB0aGUgbGlzdCBvZiBob3RrZXlzIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGFzIGEgYGhvdGtleWAgZXZlbnQgb24gdGhlIHdpbmRvdy4gRm9yIHVzYWdlIGV4YW1wbGUgc2VlIFtleGFtcGxlXXtAdHV0b3JpYWwgaG90a2V5c30uXG4gKiBXaXRoaW4gUGxhdGZvcm0sIE9wZW5GaW4gYWxzbyBpbXBsZW1lbnRzIGEgc2V0IG9mIHByZS1kZWZpbmVkIGFjdGlvbnMgY2FsbGVkXG4gKiBba2V5Ym9hcmQgY29tbWFuZHNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5vcGVuZmluLmNvL2RvY3MvcGxhdGZvcm0tYXBpI3NlY3Rpb24tNS0zLXVzaW5nLWtleWJvYXJkLWNvbW1hbmRzfVxuICogdGhhdCBjYW4gYmUgYXNzaWduZWQgdG8gYSBzcGVjaWZpYyBob3RrZXkgaW4gdGhlIHBsYXRmb3JtIG1hbmlmZXN0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvdGtleXMua2V5cyBUaGUga2V5IGNvbWJpbmF0aW9uIG9mIHRoZSBob3RrZXksIGkuZS4gXCJDdHJsK1RcIlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaG90a2V5cy5wcmV2ZW50RGVmYXVsdD1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gcHJldmVudCBkZWZhdWx0IGtleSBoYW5kbGluZyBiZWZvcmUgZW1pdHRpbmcgdGhlIGV2ZW50XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uXSAtIF9VcGRhdGFibGUuIEluaGVyaXRhYmxlLl9cbiAqIEEgVVJMIGZvciB0aGUgaWNvbiB0byBiZSBzaG93biBpbiB0aGUgd2luZG93IHRpdGxlIGJhciBhbmQgdGhlIHRhc2tiYXIuXG4gKiBfV2hlbiBvbWl0dGVkLCBpbmhlcml0cyBmcm9tIHRoZSBwYXJlbnQgYXBwbGljYXRpb24uX1xuICogIG5vdGU6IFdpbmRvdyBPUyBjYWNoZXMgdGFza2JhciBpY29ucywgdGhlcmVmb3JlIGFuIGljb24gY2hhbmdlIG1pZ2h0IG9ubHkgYmUgdmlzaWJsZSBhZnRlciB0aGUgY2FjaGUgaXMgcmVtb3ZlZCBvciB0aGUgdXVpZCBpcyBjaGFuZ2VkLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4SGVpZ2h0PS0xXSAtIF9VcGRhdGFibGUuX1xuICogVGhlIG1heGltdW0gaGVpZ2h0IG9mIGEgd2luZG93LiBXaWxsIGRlZmF1bHQgdG8gdGhlIE9TIGRlZmluZWQgdmFsdWUgaWYgc2V0IHRvIC0xLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21heGltaXphYmxlPXRydWVdIC0gX1VwZGF0YWJsZS5fXG4gKiBBIGZsYWcgdGhhdCBsZXRzIHRoZSB3aW5kb3cgYmUgbWF4aW1pemVkLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4V2lkdGg9LTFdIC0gX1VwZGF0YWJsZS5fXG4gKiBUaGUgbWF4aW11bSB3aWR0aCBvZiBhIHdpbmRvdy4gV2lsbCBkZWZhdWx0IHRvIHRoZSBPUyBkZWZpbmVkIHZhbHVlIGlmIHNldCB0byAtMS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pbkhlaWdodD0wXSAtIF9VcGRhdGFibGUuX1xuICogVGhlIG1pbmltdW0gaGVpZ2h0IG9mIGEgd2luZG93LlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21pbmltaXphYmxlPXRydWVdIC0gX1VwZGF0YWJsZS5fXG4gKiBBIGZsYWcgdGhhdCBsZXRzIHRoZSB3aW5kb3cgYmUgbWluaW1pemVkLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluV2lkdGg9MF0gLSBfVXBkYXRhYmxlLl9cbiAqIFRoZSBtaW5pbXVtIHdpZHRoIG9mIGEgd2luZG93LlxuICpcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpdHl9IFttb2RhbFBhcmVudElkZW50aXR5XVxuICogUGFyZW50IGlkZW50aXR5IG9mIGEgbW9kYWwgd2luZG93LiBJdCB3aWxsIGNyZWF0ZSBhIG1vZGFsIGNoaWxkIHdpbmRvdyB3aGVuIHRoaXMgb3B0aW9uIGlzIHNldC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogVGhlIG5hbWUgb2YgdGhlIHdpbmRvdy5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MS4wXSAtIF9VcGRhdGFibGUuX1xuICogQSBmbGFnIHRoYXQgc3BlY2lmaWVzIGhvdyB0cmFuc3BhcmVudCB0aGUgd2luZG93IHdpbGwgYmUuXG4gKiBDaGFuZ2luZyBvcGFjaXR5IGRvZXNuJ3Qgd29yayBvbiBXaW5kb3dzIDcgd2l0aG91dCBBZXJvIHNvIHNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGhhdmUgbm8gZWZmZWN0IHRoZXJlLlxuICogVGhpcyB2YWx1ZSBpcyBjbGFtcGVkIGJldHdlZW4gYDAuMGAgYW5kIGAxLjBgLlxuICpcbiAqIEBwcm9wZXJ0eSB7cHJlbG9hZFNjcmlwdFtdfSBbcHJlbG9hZFNjcmlwdHNdIC0gX0luaGVyaXRhYmxlX1xuICogQSBsaXN0IG9mIHNjcmlwdHMgdGhhdCBhcmUgZXZhbCdlZCBiZWZvcmUgb3RoZXIgc2NyaXB0cyBpbiB0aGUgcGFnZS4gV2hlbiBvbWl0dGVkLCBfaW5oZXJpdHNfXG4gKiBmcm9tIHRoZSBwYXJlbnQgYXBwbGljYXRpb24uXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwcm9jZXNzQWZmaW5pdHldXG4gKiBBIHN0cmluZyB0byBhdHRlbXB0IHRvIGdyb3VwIHJlbmRlcmVycyB0b2dldGhlci4gV2lsbCBvbmx5IGJlIHVzZWQgaWYgcGFnZXMgYXJlIG9uIHRoZSBzYW1lIG9yaWdpbi5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXNpemFibGU9dHJ1ZV0gLSBfVXBkYXRhYmxlLl9cbiAqIEEgZmxhZyB0byBhbGxvdyB0aGUgdXNlciB0byByZXNpemUgdGhlIHdpbmRvdy5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3Jlc2l6ZVJlZ2lvbl0gLSBfVXBkYXRhYmxlLl9cbiAqIERlZmluZXMgYSByZWdpb24gaW4gcGl4ZWxzIHRoYXQgd2lsbCByZXNwb25kIHRvIHVzZXIgbW91c2UgaW50ZXJhY3Rpb24gZm9yIHJlc2l6aW5nIGEgZnJhbWVsZXNzIHdpbmRvdy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVzaXplUmVnaW9uLmJvdHRvbVJpZ2h0Q29ybmVyPTldXG4gKiBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgYW4gYWRkaXRpb25hbCBzcXVhcmUgcmVzaXphYmxlIHJlZ2lvbiBsb2NhdGVkIGF0IHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIGEgZnJhbWVsZXNzIHdpbmRvdy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVzaXplUmVnaW9uLnNpemU9N11cbiAqIFRoZSBzaXplIGluIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbcmVzaXplUmVnaW9uLnNpZGVzPXt0b3A6dHJ1ZSxyaWdodDp0cnVlLGJvdHRvbTp0cnVlLGxlZnQ6dHJ1ZX1dXG4gKiBTaWRlcyB0aGF0IGEgd2luZG93IGNhbiBiZSByZXNpemVkIGZyb20uXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc2F2ZVdpbmRvd1N0YXRlPXRydWVdXG4gKiBBIGZsYWcgdG8gY2FjaGUgdGhlIGxvY2F0aW9uIG9mIHRoZSB3aW5kb3cuXG4gKiAqKiBub3RlICoqIC0gVGhpcyBvcHRpb24gaXMgaWdub3JlZCBpbiBQbGF0Zm9ybXMgYXMgaXQgd291bGQgY2F1c2UgaW5jb25zaXN0ZW50IHtAbGluayBQbGF0Zm9ybSNhcHBseVNuYXBzaG90IGFwcGx5U25hcHNob3R9IGJlaGF2aW9yLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NoYWRvdz1mYWxzZV1cbiAqIEEgZmxhZyB0byBkaXNwbGF5IGEgc2hhZG93IG9uIGZyYW1lbGVzcyB3aW5kb3dzLlxuICogYHNoYWRvd2AgYW5kIGBjb3JuZXJSb3VuZGluZ2AgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS5cbiAqIE9uIFdpbmRvd3MgNywgQWVybyB0aGVtZSBpcyByZXF1aXJlZC5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93QmFja2dyb3VuZEltYWdlcz1mYWxzZV0gLSBfVXBkYXRhYmxlLl9cbiAqIFBsYXRmb3JtcyBPbmx5LiAgSWYgdHJ1ZSwgd2lsbCBzaG93IGJhY2tncm91bmQgaW1hZ2VzIGluIHRoZSBsYXlvdXQgd2hlbiB0aGUgVmlld3MgYXJlIGhpZGRlbi5cbiAqIFRoaXMgb2NjdXJzIHdoZW4gdGhlIHdpbmRvdyBpcyByZXNpemluZyBvciBhIHRhYiBpcyBiZWluZyBkcmFnZ2VkIHdpdGhpbiB0aGUgbGF5b3V0LlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dUYXNrYmFySWNvbj10cnVlXSAtIF9VcGRhdGFibGUuXyBfV2luZG93c18uXG4gKiBBIGZsYWcgdG8gc2hvdyB0aGUgd2luZG93J3MgaWNvbiBpbiB0aGUgdGFza2Jhci5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzbWFsbFdpbmRvdz1mYWxzZV1cbiAqIEEgZmxhZyB0byBzcGVjaWZ5IGEgZnJhbWVsZXNzIHdpbmRvdyB0aGF0IGNhbiBiZSBiZSBjcmVhdGVkIGFuZCByZXNpemVkIHRvIGxlc3MgdGhhbiA0MXgzNnB4ICh3aWR0aCB4IGhlaWdodCkuXG4gKiBfTm90ZTogQ2F2ZWF0cyBvZiBzbWFsbCB3aW5kb3dzIGFyZSBubyBBZXJvIFNuYXAgYW5kIGRyYWcgdG8vZnJvbSBtYXhpbWl6ZS5fXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdGF0ZT1cIm5vcm1hbFwiXVxuICogVGhlIHZpc2libGUgc3RhdGUgb2YgdGhlIHdpbmRvdyBvbiBjcmVhdGlvbi5cbiAqIE9uZSBvZjpcbiAqICogYFwibWF4aW1pemVkXCJgXG4gKiAqIGBcIm1pbmltaXplZFwiYFxuICogKiBgXCJub3JtYWxcImBcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Rhc2tiYXJJY29uPXN0cmluZ10gLSBEZXByZWNhdGVkIC0gdXNlIGBpY29uYCBpbnN0ZWFkLl9XaW5kb3dzXy5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Rhc2tiYXJJY29uR3JvdXA9PGFwcGxpY2F0aW9uIHV1aWQ+XSAtIF9XaW5kb3dzXy5cbiAqIFNwZWNpZnkgYSB0YXNrYmFyIGdyb3VwIGZvciB0aGUgd2luZG93LlxuICogX0lmIG9taXR0ZWQsIGRlZmF1bHRzIHRvIGFwcCdzIHV1aWQgKGBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudFN5bmMoKS5pZGVudGl0eS51dWlkYCkuX1xuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsPVwiYWJvdXQ6YmxhbmtcIl1cbiAqIFRoZSBVUkwgb2YgdGhlIHdpbmRvdy5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3V1aWQ9PGFwcGxpY2F0aW9uIHV1aWQ+XVxuICogVGhlIGB1dWlkYCBvZiB0aGUgYXBwbGljYXRpb24sIHVuaXF1ZSB3aXRoaW4gdGhlIHNldCBvZiBhbGwgYEFwcGxpY2F0aW9uYHMgcnVubmluZyBpbiBPcGVuRmluIFJ1bnRpbWUuXG4gKiBJZiBvbWl0dGVkLCBkZWZhdWx0cyB0byB0aGUgYHV1aWRgIG9mIHRoZSBhcHBsaWNhdGlvbiBzcGF3bmluZyB0aGUgd2luZG93LlxuICogSWYgZ2l2ZW4sIG11c3QgbWF0Y2ggdGhlIGB1dWlkYCBvZiB0aGUgIGFwcGxpY2F0aW9uIHNwYXduaW5nIHRoZSB3aW5kb3cuXG4gKiBJbiBvdGhlciB3b3JkcywgdGhlIGFwcGxpY2F0aW9uJ3MgYHV1aWRgIGlzIHRoZSBvbmx5IGFjY2VwdGFibGUgdmFsdWUsIGJ1dCBpcyB0aGUgZGVmYXVsdCwgc28gdGhlcmUnc1xuICogcmVhbGx5IG5vIG5lZWQgdG8gcHJvdmlkZSBpdC5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3YWl0Rm9yUGFnZUxvYWQ9ZmFsc2VdXG4gKiBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSB3aW5kb3cgd2lsbCBub3QgYXBwZWFyIHVudGlsIHRoZSBgd2luZG93YCBvYmplY3QncyBgbG9hZGAgZXZlbnQgZmlyZXMuXG4gKiBXaGVuIHNldCB0byBgZmFsc2VgLCB0aGUgd2luZG93IHdpbGwgYXBwZWFyIGltbWVkaWF0ZWx5IHdpdGhvdXQgd2FpdGluZyBmb3IgY29udGVudCB0byBiZSBsb2FkZWQuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gQ2FwdHVyZVBhZ2VPcHRpb25zXG4gKiBAcHJvcGVydHkgeyBBcmVhIH0gW2FyZWFdIFRoZSBhcmVhIG9mIHRoZSB3aW5kb3cgdG8gYmUgY2FwdHVyZWQuXG4gKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBbZm9ybWF0PSdwbmcnXSBUaGUgZm9ybWF0IG9mIHRoZSBjYXB0dXJlZCBpbWFnZS4gIENhbiBiZSAncG5nJywgJ2pwZycsIG9yICdibXAnLlxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gW3F1YWxpdHk9MTAwXSBOdW1iZXIgcmVwcmVzZW50aW5nIHF1YWxpdHkgb2YgSlBFRyBpbWFnZSBvbmx5LiBCZXR3ZWVuIDAgLSAxMDAuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYgeyBvYmplY3QgfSBBcmVhXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBoZWlnaHQgQXJlYSdzIGhlaWdodFxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gd2lkdGggQXJlYSdzIHdpZHRoXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSB4IFggY29vcmRpbmF0ZSBvZiBhcmVhJ3Mgc3RhcnRpbmcgcG9pbnRcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IHkgWSBjb29yZGluYXRlIG9mIGFyZWEncyBzdGFydGluZyBwb2ludFxuICovXG4vKipcbiAqIEB0eXBlZGVmIHsgb2JqZWN0IH0gV2luZG93TW92ZW1lbnRPcHRpb25zXG4gKiBAcHJvcGVydHkgeyBib29sZWFuIH0gbW92ZUluZGVwZW5kZW50bHkgLSBNb3ZlIGEgd2luZG93IGluZGVwZW5kZW50bHkgb2YgaXRzIGdyb3VwIG9yIGFsb25nIHdpdGggaXRzIGdyb3VwLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBGaW5kSW5QYWdlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbZm9yd2FyZD10cnVlXSBXaGV0aGVyIHRvIHNlYXJjaCBmb3J3YXJkIG9yIGJhY2t3YXJkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZmluZE5leHQ9ZmFsc2VdIFdoZXRoZXIgdGhlIG9wZXJhdGlvbiBpcyBmaXJzdCByZXF1ZXN0IG9yIGEgZm9sbG93IHVwLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbWF0Y2hDYXNlPWZhbHNlXSBXaGV0aGVyIHNlYXJjaCBzaG91bGQgYmUgY2FzZS1zZW5zaXRpdmUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3b3JkU3RhcnQ9ZmFsc2VdIFdoZXRoZXIgdG8gbG9vayBvbmx5IGF0IHRoZSBzdGFydCBvZiB3b3Jkcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21lZGlhbENhcGl0YWxBc1dvcmRTdGFydD1mYWxzZV1cbiAqIFdoZW4gY29tYmluZWQgd2l0aCB3b3JkU3RhcnQsIGFjY2VwdHMgYSBtYXRjaCBpbiB0aGUgbWlkZGxlIG9mIGEgd29yZCBpZiB0aGUgbWF0Y2ggYmVnaW5zIHdpdGggYW4gdXBwZXJjYXNlIGxldHRlciBmb2xsb3dlZCBieSBhPGJyPlxuICogbG93ZXJjYXNlIG9yIG5vbi1sZXR0ZXIuIEFjY2VwdHMgc2V2ZXJhbCBvdGhlciBpbnRyYS13b3JkIG1hdGNoZXMuXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVHJhbnNpdGlvblxuICogQHByb3BlcnR5IHtPcGFjaXR5fSBvcGFjaXR5IC0gVGhlIE9wYWNpdHkgdHJhbnNpdGlvblxuICogQHByb3BlcnR5IHtQb3NpdGlvbn0gcG9zaXRpb24gLSBUaGUgUG9zaXRpb24gdHJhbnNpdGlvblxuICogQHByb3BlcnR5IHtTaXplfSBzaXplIC0gVGhlIFNpemUgdHJhbnNpdGlvblxuICovXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRyYW5zaXRpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGludGVycnVwdCAtIFRoaXMgb3B0aW9uIGludGVycnVwdHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLiBXaGVuIGZhbHNlIGl0IHB1c2hlc1xudGhpcyBhbmltYXRpb24gb250byB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24gcXVldWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlbGF0aXZlIC0gVHJlYXQgJ29wYWNpdHknIGFzIGFic29sdXRlIG9yIGFzIGEgZGVsdGEuIERlZmF1bHRzIHRvIGZhbHNlLlxuICovXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNpemVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSB0b3RhbCB0aW1lIGluIG1pbGxpc2Vjb25kcyB0aGlzIHRyYW5zaXRpb24gc2hvdWxkIHRha2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlbGF0aXZlIC0gVHJlYXQgJ29wYWNpdHknIGFzIGFic29sdXRlIG9yIGFzIGEgZGVsdGEuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gT3B0aW9uYWwgaWYgaGVpZ2h0IGlzIHByZXNlbnQuIERlZmF1bHRzIHRvIHRoZSB3aW5kb3cncyBjdXJyZW50IHdpZHRoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIE9wdGlvbmFsIGlmIHdpZHRoIGlzIHByZXNlbnQuIERlZmF1bHRzIHRvIHRoZSB3aW5kb3cncyBjdXJyZW50IGhlaWdodC5cbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQb3NpdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIHRvdGFsIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRoaXMgdHJhbnNpdGlvbiBzaG91bGQgdGFrZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVsYXRpdmUgLSBUcmVhdCAnb3BhY2l0eScgYXMgYWJzb2x1dGUgb3IgYXMgYSBkZWx0YS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVmdCAtIERlZmF1bHRzIHRvIHRoZSB3aW5kb3cncyBjdXJyZW50IGxlZnQgcG9zaXRpb24gaW4gdmlydHVhbCBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9wIC0gRGVmYXVsdHMgdG8gdGhlIHdpbmRvdydzIGN1cnJlbnQgdG9wIHBvc2l0aW9uIGluIHZpcnR1YWwgc2NyZWVuIGNvb3JkaW5hdGVzLlxuICovXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IE9wYWNpdHlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSB0b3RhbCB0aW1lIGluIG1pbGxpc2Vjb25kcyB0aGlzIHRyYW5zaXRpb24gc2hvdWxkIHRha2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlbGF0aXZlIC0gVHJlYXQgJ29wYWNpdHknIGFzIGFic29sdXRlIG9yIGFzIGEgZGVsdGEuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9wYWNpdHkgLSBUaGlzIHZhbHVlIGlzIGNsYW1wZWQgZnJvbSAwLjAgdG8gMS4wLlxuICovXG4vKipcbiAqIEJvdW5kcyBpcyBhIGludGVyZmFjZSB0aGF0IGhhcyB0aGUgcHJvcGVydGllcyBvZiBoZWlnaHQsXG4gKiB3aWR0aCwgbGVmdCwgdG9wIHdoaWNoIGFyZSBhbGwgbnVtYmVyc1xuICogQHR5cGVkZWYgeyBvYmplY3QgfSBCb3VuZHNcbiAqIEBwcm9wZXJ0eSB7IG51bWJlciB9IGhlaWdodCBHZXQgdGhlIGFwcGxpY2F0aW9uIGhlaWdodCBib3VuZFxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gd2lkdGggR2V0IHRoZSBhcHBsaWNhdGlvbiB3aWR0aCBib3VuZFxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gdG9wIEdldCB0aGUgYXBwbGljYXRpb24gdG9wIGJvdW5kXG4gKiBAcHJvcGVydHkgeyBudW1iZXIgfSBsZWZ0IEdldCB0aGUgYXBwbGljYXRpb24gbGVmdCBib3VuZFxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gcmlnaHQgR2V0IHRoZSBhcHBsaWNhdGlvbiByaWdodCBib3VuZFxuICogQHByb3BlcnR5IHsgbnVtYmVyIH0gYm90dG9tIEdldCB0aGUgYXBwbGljYXRpb24gYm90dG9tIGJvdW5kXG4gKi9cbi8qKlxuICogQGNsYXNzZGVzYyBBIGJhc2ljIHdpbmRvdyB0aGF0IHdyYXBzIGEgbmF0aXZlIEhUTUwgd2luZG93LiBQcm92aWRlcyBtb3JlIGZpbmUtZ3JhaW5lZFxuICogY29udHJvbCBvdmVyIHRoZSB3aW5kb3cgc3RhdGUgc3VjaCBhcyB0aGUgYWJpbGl0eSB0byBtaW5pbWl6ZSwgbWF4aW1pemUsIHJlc3RvcmUsIGV0Yy5cbiAqIEJ5IGRlZmF1bHQgYSB3aW5kb3cgZG9lcyBub3Qgc2hvdyB1cG9uIGluc3RhbnRpYXRpb247IGluc3RlYWQgdGhlIHdpbmRvdydzIHNob3coKSBtZXRob2RcbiAqIG11c3QgYmUgaW52b2tlZCBtYW51YWxseS4gVGhlIG5ldyB3aW5kb3cgYXBwZWFycyBpbiB0aGUgc2FtZSBwcm9jZXNzIGFzIHRoZSBwYXJlbnQgd2luZG93LlxuICogSXQgaGFzIHRoZSBhYmlsaXR5IHRvIGxpc3RlbiBmb3IgPGEgaHJlZj1cInR1dG9yaWFsLVdpbmRvdy5FdmVudEVtaXR0ZXIuaHRtbFwiPndpbmRvdyBzcGVjaWZpYyBldmVudHM8L2E+LlxuICogQGNsYXNzXG4gKiBAYWxpYXMgV2luZG93XG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbi8vIFRoZSB3aW5kb3cuV2luZG93IG5hbWUgaXMgdGFrZW5cbmNsYXNzIF9XaW5kb3cgZXh0ZW5kcyB3ZWJjb250ZW50c18xLldlYkNvbnRlbnRzIHtcbiAgICBjb25zdHJ1Y3Rvcih3aXJlLCBpZGVudGl0eSkge1xuICAgICAgICBzdXBlcih3aXJlLCBpZGVudGl0eSwgJ3dpbmRvdycpO1xuICAgICAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIHwgc3ltYm9sIH0gZXZlbnRUeXBlICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB9IGxpc3RlbmVyIC0gQ2FsbGVkIHdoZW5ldmVyIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIGFkZExpc3RlbmVyXG4gICAgICogQG1lbWJlcm9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBDYWxsZWQgd2hlbmV2ZXIgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gb25cbiAgICAgKiBAbWVtYmVyb2YgV2luZG93XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5FdmVudEVtaXR0ZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgb25lIHRpbWUgbGlzdGVuZXIgZm9yIHRoZSBldmVudC4gVGhlIGxpc3RlbmVyIGlzIGludm9rZWQgb25seSB0aGUgZmlyc3QgdGltZSB0aGUgZXZlbnQgaXMgZmlyZWQsIGFmdGVyIHdoaWNoIGl0IGlzIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIHwgc3ltYm9sIH0gZXZlbnRUeXBlICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcGFyYW0geyBGdW5jdGlvbiB9IGxpc3RlbmVyIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7IFN1Yk9wdGlvbnMgfSBbb3B0aW9uc10gLSBPcHRpb24gdG8gc3VwcG9ydCBldmVudCB0aW1lc3RhbXBzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fVxuICAgICAqIEBmdW5jdGlvbiBvbmNlXG4gICAgICogQG1lbWJlcm9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lclxuICAgICAqIEBtZW1iZXJvZiBXaW5kb3dcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LkV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBvbmUgdGltZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50LiBUaGUgbGlzdGVuZXIgaXMgaW52b2tlZCBvbmx5IHRoZSBmaXJzdCB0aW1lIHRoZSBldmVudCBpcyBmaXJlZCwgYWZ0ZXIgd2hpY2ggaXQgaXMgcmVtb3ZlZC5cbiAgICAgKiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdGVuZXJzIGFycmF5LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB8IHN5bWJvbCB9IGV2ZW50VHlwZSAgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHsgRnVuY3Rpb24gfSBsaXN0ZW5lciAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyBTdWJPcHRpb25zIH0gW29wdGlvbnNdIC0gT3B0aW9uIHRvIHN1cHBvcnQgZXZlbnQgdGltZXN0YW1wcy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lclxuICAgICAqIEBtZW1iZXJvZiBXaW5kb3dcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LkV2ZW50RW1pdHRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZyb20gdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIENhdXRpb246IENhbGxpbmcgdGhpcyBtZXRob2QgY2hhbmdlcyB0aGUgYXJyYXkgaW5kaWNlcyBpbiB0aGUgbGlzdGVuZXIgYXJyYXkgYmVoaW5kIHRoZSBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfCBzeW1ib2wgfSBldmVudFR5cGUgIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsgU3ViT3B0aW9ucyB9IFtvcHRpb25zXSAtIE9wdGlvbiB0byBzdXBwb3J0IGV2ZW50IHRpbWVzdGFtcHMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59XG4gICAgICogQGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyXG4gICAgICogQG1lbWJlcm9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB8IHN5bWJvbCB9IFtldmVudFR5cGVdICAtIFRoZSB0eXBlIG9mIHRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn1cbiAgICAgKiBAZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzXG4gICAgICogQG1lbWJlcm9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuRXZlbnRFbWl0dGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJhc2U2NCBlbmNvZGVkIGltYWdlIG9mIHRoZSB3aW5kb3cgb3IgYSBwYXJ0IG9mIGl0LlxuICAgICAqIEBmdW5jdGlvbiBjYXB0dXJlUGFnZVxuICAgICAqIEBwYXJhbSB7IENhcHR1cmVQYWdlT3B0aW9ucyB9IFtvcHRpb25zXSBvcHRpb25zIGZvciBjYXB0dXJlUGFnZSBjYWxsLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHN0cmluZz59XG4gICAgICogQG1lbWJlcm9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuY2FwdHVyZVBhZ2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBKYXZhc2NyaXB0IG9uIHRoZSB3aW5kb3csIHJlc3RyaWN0ZWQgdG8gd2luZG93cyB5b3Ugb3duIG9yIHdpbmRvd3Mgb3duZWQgYnlcbiAgICAgKiBhcHBsaWNhdGlvbnMgeW91IGhhdmUgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSBjb2RlIEphdmFTY3JpcHQgY29kZSB0byBiZSBleGVjdXRlZCBvbiB0aGUgd2luZG93LlxuICAgICAqIEBmdW5jdGlvbiBleGVjdXRlSmF2YVNjcmlwdFxuICAgICAqIEBtZW1iZXJPZiBXaW5kb3dcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmV4ZWN1dGVKYXZhU2NyaXB0XG4gICAgICovXG4gICAgLyoqXG4gICAgICogR2l2ZXMgZm9jdXMgdG8gdGhlIHdpbmRvdy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAZnVuY3Rpb24gZm9jdXNcbiAgICAgKiBAZW1pdHMgZm9jdXNlZFxuICAgICAqIEBtZW1iZXJPZiBXaW5kb3dcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmZvY3VzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgd2luZG93LlxuICAgICAqIEBmdW5jdGlvbiBnZXRab29tTGV2ZWxcbiAgICAgKiBAbWVtYmVyT2YgV2luZG93XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48bnVtYmVyPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmdldFpvb21MZXZlbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHdpbmRvdy5cbiAgICAgKiBAcGFyYW0geyBudW1iZXIgfSBsZXZlbCBUaGUgem9vbSBsZXZlbFxuICAgICAqIEBmdW5jdGlvbiBzZXRab29tTGV2ZWxcbiAgICAgKiBAbWVtYmVyT2YgV2luZG93XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5zZXRab29tTGV2ZWxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBoaWdobGlnaHQgdGV4dCBvbiBhIHBhZ2UuXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gc2VhcmNoVGVybSBUZXJtIHRvIGZpbmQgaW4gcGFnZVxuICAgICAqIEBwYXJhbSB7IEZpbmRJblBhZ2VPcHRpb25zIH0gb3B0aW9ucyBTZWFyY2ggb3B0aW9uc1xuICAgICAqIEBmdW5jdGlvbiBmaW5kSW5QYWdlXG4gICAgICogQG1lbWJlck9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPG51bWJlcj59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5maW5kSW5QYWdlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU3RvcHMgYW55IGZpbmRJblBhZ2UgY2FsbCB3aXRoIHRoZSBwcm92aWRlZCBhY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqIEFjdGlvbiB0byBleGVjdXRlIHdoZW4gc3RvcHBpbmcgYSBmaW5kIGluIHBhZ2U6PGJyPlxuICAgICAqIFwiY2xlYXJTZWxlY3Rpb25cIiAtIENsZWFyIHRoZSBzZWxlY3Rpb24uPGJyPlxuICAgICAqIFwia2VlcFNlbGVjdGlvblwiIC0gVHJhbnNsYXRlIHRoZSBzZWxlY3Rpb24gaW50byBhIG5vcm1hbCBzZWxlY3Rpb24uPGJyPlxuICAgICAqIFwiYWN0aXZhdGVTZWxlY3Rpb25cIiAtIEZvY3VzIGFuZCBjbGljayB0aGUgc2VsZWN0aW9uIG5vZGUuPGJyPlxuICAgICAqIEBmdW5jdGlvbiBzdG9wRmluZEluUGFnZVxuICAgICAqIEBtZW1iZXJPZiBXaW5kb3dcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LnN0b3BGaW5kSW5QYWdlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRoZSB3aW5kb3cgdG8gYSBzcGVjaWZpZWQgVVJMLiBUaGUgdXJsIG11c3QgY29udGFpbiB0aGUgcHJvdG9jb2wgcHJlZml4IHN1Y2ggYXMgaHR0cDovLyBvciBodHRwczovLy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byBuYXZpZ2F0ZSB0aGUgd2luZG93IHRvLlxuICAgICAqIEBmdW5jdGlvbiBuYXZpZ2F0ZVxuICAgICAqIEBtZW1iZXJPZiBXaW5kb3dcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93Lm5hdmlnYXRlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRoZSB3aW5kb3cgYmFjayBvbmUgcGFnZS5cbiAgICAgKiBAZnVuY3Rpb24gbmF2aWdhdGVCYWNrXG4gICAgICogQG1lbWJlck9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cubmF2aWdhdGVCYWNrXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRoZSB3aW5kb3cgZm9yd2FyZCBvbmUgcGFnZS5cbiAgICAgKiBAZnVuY3Rpb24gbmF2aWdhdGVGb3J3YXJkXG4gICAgICogQG1lbWJlck9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cubmF2aWdhdGVGb3J3YXJkXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU3RvcHMgYW55IGN1cnJlbnQgbmF2aWdhdGlvbiB0aGUgd2luZG93IGlzIHBlcmZvcm1pbmcuXG4gICAgICogQGZ1bmN0aW9uIHN0b3BOYXZpZ2F0aW9uXG4gICAgICogQG1lbWJlck9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuc3RvcE5hdmlnYXRpb25cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSB3aW5kb3cgY3VycmVudCBwYWdlXG4gICAgICogQGZ1bmN0aW9uIHJlbG9hZFxuICAgICAqIEBtZW1iZXJPZiBXaW5kb3dcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LnJlbG9hZFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFByaW50cyB0aGUgd2luZG93J3Mgd2ViIHBhZ2VcbiAgICAgKiBAcGFyYW0geyBQcmludE9wdGlvbnMgfSBbb3B0aW9uc10gUHJpbnRlciBPcHRpb25zXG4gICAgICogQGZ1bmN0aW9uIHByaW50XG4gICAgICogQG1lbWJlck9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cucHJpbnRcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggYWxsIHN5c3RlbSBwcmludGVyc1xuICAgICAqIEBmdW5jdGlvbiBnZXRQcmludGVyc1xuICAgICAqIEBtZW1iZXJPZiBXaW5kb3dcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHsgUHJvbWlzZS5BcnJheS48UHJpbnRlckluZm8+IH1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmdldFByaW50ZXJzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBwcm9jZXNzIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCBhIHdpbmRvdy5cbiAgICAgKiBAZnVuY3Rpb24gZ2V0UHJvY2Vzc0luZm9cbiAgICAgKiBAbWVtYmVyT2YgV2luZG93XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48RW50aXR5UHJvY2Vzc0RldGFpbHM+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZ2V0UHJvY2Vzc0luZm9cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gb24gYWxsIFNoYXJlZCBXb3JrZXJzLlxuICAgICAqIEBmdW5jdGlvbiBnZXRTaGFyZWRXb3JrZXJzXG4gICAgICogQG1lbWJlck9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuQXJyYXkuPFNoYXJlZFdvcmtlckluZm8+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZ2V0U2hhcmVkV29ya2Vyc1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBkZXZlbG9wZXIgdG9vbHMgZm9yIHRoZSBzaGFyZWQgd29ya2VyIGNvbnRleHQuXG4gICAgICogQGZ1bmN0aW9uIGluc3BlY3RTaGFyZWRXb3JrZXJcbiAgICAgKiBAbWVtYmVyT2YgV2luZG93XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5pbnNwZWN0U2hhcmVkV29ya2VyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogSW5zcGVjdHMgdGhlIHNoYXJlZCB3b3JrZXIgYmFzZWQgb24gaXRzIElELlxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHdvcmtlcklkIC0gVGhlIGlkIG9mIHRoZSBzaGFyZWQgd29ya2VyLlxuICAgICAqIEBmdW5jdGlvbiBpbnNwZWN0U2hhcmVkV29ya2VyQnlJZFxuICAgICAqIEBtZW1iZXJPZiBXaW5kb3dcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93Lmluc3BlY3RTaGFyZWRXb3JrZXJCeUlkXG4gICAgICovXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGRldmVsb3BlciB0b29scyBmb3IgdGhlIHNlcnZpY2Ugd29ya2VyIGNvbnRleHQuXG4gICAgICogQGZ1bmN0aW9uIGluc3BlY3RTZXJ2aWNlV29ya2VyXG4gICAgICogQG1lbWJlck9mIFdpbmRvd1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuaW5zcGVjdFNlcnZpY2VXb3JrZXJcbiAgICAgKi9cbiAgICAvLyBjcmVhdGUgYSBuZXcgd2luZG93XG4gICAgY3JlYXRlV2luZG93KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3dpbmRvdy1jcmVhdGUtd2luZG93JywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IENPTlNUUlVDVE9SX0NCX1RPUElDID0gJ2ZpcmUtY29uc3RydWN0b3ItY2FsbGJhY2snO1xuICAgICAgICAgICAgLy8gbmVlZCB0byBjYWxsIHBhZ2VSZXNwb25zZSwgb3RoZXJ3aXNlIHdoZW4gYSBjaGlsZCB3aW5kb3cgaXMgY3JlYXRlZCwgcGFnZSBpcyBub3QgbG9hZGVkXG4gICAgICAgICAgICBjb25zdCBwYWdlUmVzcG9uc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub24oQ09OU1RSVUNUT1JfQ0JfVE9QSUMsIGZ1bmN0aW9uIGZpcmVDb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2JQYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN1Y2Nlc3MgfSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHJlc3BvbnNlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwUmVzcG9uc2VDb2RlOiByZXNwb25zZURhdGEuaHR0cFJlc3BvbnNlQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlJbmplY3RlZDogcmVzcG9uc2VEYXRhLmFwaUluamVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2JQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlRGF0YS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtFcnJvckNvZGU6IHJlc3BvbnNlRGF0YS5uZXR3b3JrRXJyb3JDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiByZXNwb25zZURhdGEuc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihDT05TVFJVQ1RPUl9DQl9UT1BJQywgZmlyZUNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2JQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHRzOlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMud2FpdEZvclBhZ2VMb2FkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLndhaXRGb3JQYWdlTG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXV0b1Nob3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYXV0b1Nob3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2luZG93Q3JlYXRpb24gPSB0aGlzLndpcmUuZW52aXJvbm1lbnQuY3JlYXRlQ2hpbGRDb250ZW50KHsgZW50aXR5VHlwZTogRW50aXR5VHlwZV8xLmRlZmF1bHQuV0lORE9XLCBvcHRpb25zIH0pO1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoW3BhZ2VSZXNwb25zZSwgd2luZG93Q3JlYXRpb25dKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNvbHZlZEFycikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VSZXNvbHZlID0gcmVzb2x2ZWRBcnJbMF07XG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VSZXNvbHZlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChwYWdlUmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gZW5mb3JjZSBhIDUuMCBjb250cmFjdCB0aGF0IHRoZSBjaGlsZCdzIG1haW4gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBub3QgZmlyZSBiZWZvcmUgdGhlIHBhcmVudCdzIHN1Y2Nlc3MgY2FsbGJhY2sgb24gY3JlYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjaGlsZCB3aW5kb3cgaXMgbm90IGFjY2Vzc2libGUgKENPUlMpIHRoaXMgY29udHJhY3QgZG9lc1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgaG9sZC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2ViV2luZG93ID0gdGhpcy5nZXRXZWJXaW5kb3coKTtcbiAgICAgICAgICAgICAgICAgICAgd2ViV2luZG93LmZpbi5fX2ludGVybmFsXy5vcGVuZXJTdWNjZXNzQ0JDYWxsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tbW9uIGZvciBtYWluIHdpbmRvd3MsIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLiBoZXJlIGp1c3QgdG8gaGF2ZSBhIGRlYnVnIHRhcmdldC5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2luZG93TGlzdEZyb21OYW1lTGlzdChpZGVudGl0eUxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5TGlzdC5tYXAoKHsgdXVpZCwgbmFtZSwgaXNFeHRlcm5hbFdpbmRvdyB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNFeHRlcm5hbFdpbmRvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZXh0ZXJuYWxfd2luZG93XzEuRXh0ZXJuYWxXaW5kb3codGhpcy53aXJlLCB7IHV1aWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9XaW5kb3codGhpcy53aXJlLCB7IHV1aWQsIG5hbWUgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gYXJyYXkgb2YgZnJhbWUgaW5mbyBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgbWFpbiBmcmFtZSBhbmQgYW55XG4gICAgICogaWZyYW1lcyB0aGF0IGFyZSBjdXJyZW50bHkgb24gdGhlIHBhZ2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48QXJyYXk8RnJhbWVJbmZvPj59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5nZXRBbGxGcmFtZXNcbiAgICAgKi9cbiAgICBnZXRBbGxGcmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LWFsbC1mcmFtZXMnLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBib3VuZHMgKHRvcCwgYm90dG9tLCByaWdodCwgbGVmdCwgd2lkdGgsIGhlaWdodCkgb2YgdGhlIHdpbmRvdy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxCb3VuZHM+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZ2V0Qm91bmRzXG4gICAgICovXG4gICAgZ2V0Qm91bmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlXG4gICAgICAgICAgICAuc2VuZEFjdGlvbignZ2V0LXdpbmRvdy1ib3VuZHMnLCB0aGlzLmlkZW50aXR5KVxuICAgICAgICAgICAgLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIHRoZSB3aW5kb3cgb24gaXRzIGN1cnJlbnQgc2NyZWVuLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuY2VudGVyXG4gICAgICovXG4gICAgY2VudGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2NlbnRlci13aW5kb3cnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZm9jdXMgZnJvbSB0aGUgd2luZG93LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuYmx1clxuICAgICAqL1xuICAgIGJsdXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignYmx1ci13aW5kb3cnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyaW5ncyB0aGUgd2luZG93IHRvIHRoZSBmcm9udCBvZiB0aGUgd2luZG93IHN0YWNrLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuYnJpbmdUb0Zyb250XG4gICAgICovXG4gICAgYnJpbmdUb0Zyb250KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2JyaW5nLXdpbmRvdy10by1mcm9udCcsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHNwZWNpZmllZCB3aW5kb3cgdHJhbnNpdGlvbnMuXG4gICAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9ucyAtIERlc2NyaWJlcyB0aGUgYW5pbWF0aW9ucyB0byBwZXJmb3JtLiBTZWUgdGhlIHR1dG9yaWFsLlxuICAgICAqIEBwYXJhbSB7VHJhbnNpdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgYW5pbWF0aW9uLiBTZWUgdGhlIHR1dG9yaWFsLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuYW5pbWF0ZVxuICAgICAqL1xuICAgIGFuaW1hdGUodHJhbnNpdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ2FuaW1hdGUtd2luZG93Jywge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgLi4udGhpcy5pZGVudGl0eVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIHdpbmRvdy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmhpZGVcbiAgICAgKi9cbiAgICBoaWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2hpZGUtd2luZG93JywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjbG9zZXMgdGhlIHdpbmRvdyBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSB7IGJvb2xlYW4gfSBbZm9yY2UgPSBmYWxzZV0gQ2xvc2Ugd2lsbCBiZSBwcmV2ZW50ZWQgZnJvbSBjbG9zaW5nIHdoZW4gZm9yY2UgaXMgZmFsc2UgYW5kXG4gICAgICogIOKAmGNsb3NlLXJlcXVlc3RlZOKAmSBoYXMgYmVlbiBzdWJzY3JpYmVkIHRvIGZvciBhcHBsaWNhdGlvbuKAmXMgbWFpbiB3aW5kb3cuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5jbG9zZVxuICAgICAqL1xuICAgIGNsb3NlKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdjbG9zZS13aW5kb3cnLCB7IGZvcmNlLCAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvY3VzZWRXZWJWaWV3V2FzQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdmb2N1c2VkLXdlYnZpZXctY2hhbmdlZCcsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmF0aXZlIE9TIGxldmVsIElkLlxuICAgICAqIEluIFdpbmRvd3MsIGl0IHdpbGwgcmV0dXJuIHRoZSBXaW5kb3dzIFtoYW5kbGVdKGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3dpbmRvd3MvZGVza3RvcC9XaW5Qcm9nL3dpbmRvd3MtZGF0YS10eXBlcyNIV05EKS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxzdHJpbmc+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZ2V0TmF0aXZlSWRcbiAgICAgKi9cbiAgICBnZXROYXRpdmVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdnZXQtd2luZG93LW5hdGl2ZS1pZCcsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgd2luZG93J3MgYXR0YWNoZWQgdmlld3MuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuQXJyYXkuPFZpZXc+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZ2V0Q3VycmVudFZpZXdzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q3VycmVudFZpZXdzKCkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGF3YWl0IHRoaXMud2lyZS5zZW5kQWN0aW9uKCd3aW5kb3ctZ2V0LXZpZXdzJywgdGhpcy5pZGVudGl0eSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkLmRhdGEubWFwKChpZCkgPT4gbmV3IHZpZXdfMS5WaWV3KHRoaXMud2lyZSwgaWQpKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFdpbmRvdy5kaXNhYmxlVXNlck1vdmVtZW50fSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGRpc2FibGVGcmFtZSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGdW5jdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgZGlzYWJsZVVzZXJNb3ZlbWVudCBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2Rpc2FibGUtd2luZG93LWZyYW1lJywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyBhIHVzZXIgZnJvbSBjaGFuZ2luZyBhIHdpbmRvdydzIHNpemUvcG9zaXRpb24gd2hlbiB1c2luZyB0aGUgd2luZG93J3MgZnJhbWUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5kaXNhYmxlVXNlck1vdmVtZW50XG4gICAgICovXG4gICAgZGlzYWJsZVVzZXJNb3ZlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdkaXNhYmxlLXdpbmRvdy1mcmFtZScsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFdpbmRvdy5lbmFibGVVc2VyTW92ZW1lbnR9IGluc3RlYWQuXG4gICAgICovXG4gICAgZW5hYmxlRnJhbWUoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRnVuY3Rpb24gaXMgZGVwcmVjYXRlZDsgdXNlIGVuYWJsZVVzZXJNb3ZlbWVudCBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2VuYWJsZS13aW5kb3ctZnJhbWUnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlLWVuYWJsZXMgdXNlciBjaGFuZ2VzIHRvIGEgd2luZG93J3Mgc2l6ZS9wb3NpdGlvbiB3aGVuIHVzaW5nIHRoZSB3aW5kb3cncyBmcmFtZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmVuYWJsZVVzZXJNb3ZlbWVudFxuICAgICAqL1xuICAgIGVuYWJsZVVzZXJNb3ZlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdlbmFibGUtd2luZG93LWZyYW1lJywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbGFzaGVzIHRoZSB3aW5kb3figJlzIGZyYW1lIGFuZCB0YXNrYmFyIGljb24gdW50aWwgc3RvcEZsYXNoaW5nIGlzIGNhbGxlZCBvciB1bnRpbCBhIGZvY3VzIGV2ZW50IGlzIGZpcmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZmxhc2hcbiAgICAgKi9cbiAgICBmbGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdmbGFzaC13aW5kb3cnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSB0YXNrYmFyIGljb24gZnJvbSBmbGFzaGluZy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LnN0b3BGbGFzaGluZ1xuICAgICAqL1xuICAgIHN0b3BGbGFzaGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdzdG9wLWZsYXNoLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGFycmF5IGNvbnRhaW5pbmcgd3JhcHBlZCBmaW4uV2luZG93cyB0aGF0IGFyZSBncm91cGVkIHdpdGggdGhpcyB3aW5kb3cuXG4gICAgICogSWYgYSB3aW5kb3cgaXMgbm90IGluIGEgZ3JvdXAgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuIFBsZWFzZSBub3RlIHRoYXRcbiAgICAgKiBjYWxsaW5nIHdpbmRvdyBpcyBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IGFycmF5LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPEFycmF5PF9XaW5kb3d8RXh0ZXJuYWxXaW5kb3c+Pn1cbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgV2luZG93IEdyb3VwIEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5nZXRHcm91cFxuICAgICAqL1xuICAgIGdldEdyb3VwKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBXaW5kb3cgR3JvdXAgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ2dldC13aW5kb3ctZ3JvdXAnLCB7XG4gICAgICAgICAgICBjcm9zc0FwcDogdHJ1ZSxcbiAgICAgICAgICAgIC4uLnRoaXMuaWRlbnRpdHlcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCh7IHBheWxvYWQgfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHdpbkdyb3VwID0gW107XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdpbkdyb3VwID0gdGhpcy53aW5kb3dMaXN0RnJvbU5hbWVMaXN0KHBheWxvYWQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2luR3JvdXA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuIGluZm9ybWF0aW9uIG9iamVjdCBmb3IgdGhlIHdpbmRvdy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxXaW5kb3dJbmZvPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmdldEluZm9cbiAgICAgKi9cbiAgICBnZXRJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC13aW5kb3ctaW5mbycsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHdpbmRvdydzIExheW91dFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPExheW91dD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5nZXRMYXlvdXRcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgZ2V0TGF5b3V0KCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignd2luZG93LWdldC1sYXlvdXQnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvcHRzID0gYXdhaXQgdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICAgIGlmICghb3B0cy5sYXlvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2luZG93IGRvZXMgbm90IGhhdmUgYSBMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW4uUGxhdGZvcm0uTGF5b3V0LndyYXAodGhpcy5pZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc2V0dGluZ3Mgb2YgdGhlIHdpbmRvdy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxhbnk+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZ2V0T3B0aW9uc1xuICAgICAqL1xuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignZ2V0LXdpbmRvdy1vcHRpb25zJywgdGhpcy5pZGVudGl0eSkudGhlbigoeyBwYXlsb2FkIH0pID0+IHBheWxvYWQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxBcHBsaWNhdGlvbj59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5nZXRQYXJlbnRBcHBsaWNhdGlvblxuICAgICAqL1xuICAgIGdldFBhcmVudEFwcGxpY2F0aW9uKCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignd2luZG93LWdldC1wYXJlbnQtYXBwbGljYXRpb24nLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBhcHBsaWNhdGlvbl8xLkFwcGxpY2F0aW9uKHRoaXMud2lyZSwgdGhpcy5pZGVudGl0eSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJlbnQgd2luZG93LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPF9XaW5kb3c+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZ2V0UGFyZW50V2luZG93XG4gICAgICovXG4gICAgZ2V0UGFyZW50V2luZG93KCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignd2luZG93LWdldC1wYXJlbnQtd2luZG93JywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgYXBwbGljYXRpb25fMS5BcHBsaWNhdGlvbih0aGlzLndpcmUsIHRoaXMuaWRlbnRpdHkpKS50aGVuKChhcHApID0+IGFwcC5nZXRXaW5kb3coKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICoqKkRFUFJFQ0FURUQgLSBwbGVhc2UgdXNlIFdpbmRvdy5jYXB0dXJlUGFnZS4qKipcbiAgICAgKiBHZXRzIGEgYmFzZTY0IGVuY29kZWQgUE5HIGltYWdlIG9mIHRoZSB3aW5kb3cgb3IganVzdCBwYXJ0IGEgb2YgaXQuXG4gICAgICogQHBhcmFtIHsgQXJlYSB9IFthcmVhXSBUaGUgYXJlYSBvZiB0aGUgd2luZG93IHRvIGJlIGNhcHR1cmVkLlxuICAgICAqIE9taXR0aW5nIGl0IHdpbGwgY2FwdHVyZSB0aGUgd2hvbGUgdmlzaWJsZSB3aW5kb3cuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48c3RyaW5nPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmNhcHR1cmVQYWdlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U25hcHNob3QoYXJlYSkge1xuICAgICAgICBjb25zdCByZXEgPSB7IGFyZWEsIC4uLnRoaXMuaWRlbnRpdHkgfTtcbiAgICAgICAgY29uc29sZS53YXJuKCdXaW5kb3cuZ2V0U25hcHNob3QgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBXaW5kb3cuY2FwdHVyZVBhZ2UnKTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC13aW5kb3ctc25hcHNob3QnLCByZXEpO1xuICAgICAgICByZXR1cm4gcmVzLnBheWxvYWQuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBzdGF0ZSAoXCJtaW5pbWl6ZWRcIiwgXCJtYXhpbWl6ZWRcIiwgb3IgXCJyZXN0b3JlZFwiKSBvZiB0aGUgd2luZG93LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHN0cmluZz59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5nZXRTdGF0ZVxuICAgICAqL1xuICAgIGdldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2dldC13aW5kb3ctc3RhdGUnLCB0aGlzLmlkZW50aXR5KS50aGVuKCh7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmlvdXNseSBjYWxsZWQgZ2V0TmF0aXZlV2luZG93LlxuICAgICAqIFJldHVybnMgdGhlIFtXaW5kb3cgT2JqZWN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93KVxuICAgICAqIHRoYXQgcmVwcmVzZW50cyB0aGUgd2ViIGNvbnRleHQgb2YgdGhlIHRhcmdldCB3aW5kb3cuIFRoaXMgaXMgdGhlIHNhbWUgb2JqZWN0IHRoYXRcbiAgICAgKiB5b3Ugd291bGQgZ2V0IGZyb20gY2FsbGluZyBbd2luZG93Lm9wZW4oKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9vcGVuKSBpbiBhIHN0YW5kYXJkIHdlYiBjb250ZXh0LlxuICAgICAqIFRoZSB0YXJnZXQgd2luZG93IG5lZWRzIHRvIGJlIGluIHRoZSBzYW1lIGFwcGxpY2F0aW9uIGFzIHRoZSByZXF1ZXN0aW5nIHdpbmRvd1xuICAgICAqIGFzIHdlbGwgYXMgY29tcGx5IHdpdGggW3NhbWUtb3JpZ2luXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TZWN1cml0eS9TYW1lLW9yaWdpbl9wb2xpY3kpIHBvbGljeSByZXF1aXJlbWVudHMuXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuZ2V0V2ViV2luZG93XG4gICAgICovXG4gICAgZ2V0V2ViV2luZG93KCkge1xuICAgICAgICB0aGlzLndpcmUuc2VuZEFjdGlvbignd2luZG93LWdldC13ZWItd2luZG93JywgdGhpcy5pZGVudGl0eSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGlzIGVycm9yLCBqdXN0IGNvbnRpbnVlIGlmIHRoaXMgYW5hbHl0aWNzLW9ubHkgY2FsbCBmYWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5lbnZpcm9ubWVudC5nZXRXZWJXaW5kb3codGhpcy5pZGVudGl0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIHdpbmRvdyBpcyBhIG1haW4gd2luZG93LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5pc01haW5XaW5kb3dcbiAgICAgKi9cbiAgICBpc01haW5XaW5kb3coKSB7XG4gICAgICAgIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd3aW5kb3ctaXMtbWFpbi13aW5kb3cnLCB0aGlzLmlkZW50aXR5KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoaXMgZXJyb3IsIGp1c3QgY29udGludWUgaWYgdGhpcyBhbmFseXRpY3Mtb25seSBjYWxsIGZhaWxzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5tZS51dWlkID09PSB0aGlzLm1lLm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIHdpbmRvdyBpcyBjdXJyZW50bHkgc2hvd2luZy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxib29sZWFuPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LmlzU2hvd2luZ1xuICAgICAqL1xuICAgIGlzU2hvd2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdpcy13aW5kb3ctc2hvd2luZycsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKb2lucyB0aGUgc2FtZSB3aW5kb3cgZ3JvdXAgYXMgdGhlIHNwZWNpZmllZCB3aW5kb3cuXG4gICAgICogSm9pbmluZyBhIGdyb3VwIHdpdGggbmF0aXZlIHdpbmRvd3MgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQobWV0aG9kIHdpbGwgbmFjaykuXG4gICAgICogQHBhcmFtIHsgX1dpbmRvdyB8IEV4dGVybmFsV2luZG93IH0gdGFyZ2V0IFRoZSB3aW5kb3cgd2hvc2UgZ3JvdXAgaXMgdG8gYmUgam9pbmVkXG4gICAgICogQGRlcHJlY2F0ZWQgQWxsIFdpbmRvdyBHcm91cCBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuam9pbkdyb3VwXG4gICAgICovXG4gICAgam9pbkdyb3VwKHRhcmdldCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIFdhcm5pbmc6IEFsbCBXaW5kb3cgR3JvdXAgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ2pvaW4td2luZG93LWdyb3VwJywge1xuICAgICAgICAgICAgZ3JvdXBpbmdVdWlkOiB0YXJnZXQuaWRlbnRpdHkudXVpZCxcbiAgICAgICAgICAgIGdyb3VwaW5nV2luZG93TmFtZTogdGFyZ2V0LmlkZW50aXR5Lm5hbWUsXG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZXMgdGhlIGN1cnJlbnQgd2luZG93IGdyb3VwIHNvIHRoYXQgdGhlIHdpbmRvdyBjYW4gYmUgbW92ZSBpbmRlcGVuZGVudGx5IG9mIHRob3NlIGluIHRoZSBncm91cC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAZGVwcmVjYXRlZCBBbGwgV2luZG93IEdyb3VwIEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuXG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5sZWF2ZUdyb3VwXG4gICAgICovXG4gICAgbGVhdmVHcm91cCgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiBXYXJuaW5nOiBBbGwgV2luZG93IEdyb3VwIEFQSXMgd2lsbCBiZSByZW1vdmVkIGJ5IG1ham9yIHZlcnNpb24gMjIuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignbGVhdmUtd2luZG93LWdyb3VwJywgdGhpcy5pZGVudGl0eSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXhpbWl6ZXMgdGhlIHdpbmRvd1xuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cubWF4aW1pemVcbiAgICAgKi9cbiAgICBtYXhpbWl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdtYXhpbWl6ZS13aW5kb3cnLCB0aGlzLmlkZW50aXR5KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgaW5zdGFuY2UncyB3aW5kb3cgZ3JvdXAgd2l0aCB0aGUgc2FtZSB3aW5kb3cgZ3JvdXAgYXMgdGhlIHNwZWNpZmllZCB3aW5kb3dcbiAgICAgKiBAcGFyYW0geyBfV2luZG93IHwgRXh0ZXJuYWxXaW5kb3cgfSB0YXJnZXQgVGhlIHdpbmRvdyB3aG9zZSBncm91cCBpcyB0byBiZSBtZXJnZWQgd2l0aFxuICAgICAqIEBkZXByZWNhdGVkIEFsbCBXaW5kb3cgR3JvdXAgQVBJcyB3aWxsIGJlIHJlbW92ZWQgYnkgbWFqb3IgdmVyc2lvbiAyMi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93Lm1lcmdlR3JvdXBzXG4gICAgICovXG4gICAgbWVyZ2VHcm91cHModGFyZ2V0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gV2FybmluZzogQWxsIFdpbmRvdyBHcm91cCBBUElzIHdpbGwgYmUgcmVtb3ZlZCBieSBtYWpvciB2ZXJzaW9uIDIyLicpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlXG4gICAgICAgICAgICAuc2VuZEFjdGlvbignbWVyZ2Utd2luZG93LWdyb3VwcycsIHtcbiAgICAgICAgICAgIGdyb3VwaW5nVXVpZDogdGFyZ2V0LmlkZW50aXR5LnV1aWQsXG4gICAgICAgICAgICBncm91cGluZ1dpbmRvd05hbWU6IHRhcmdldC5pZGVudGl0eS5uYW1lLFxuICAgICAgICAgICAgLi4udGhpcy5pZGVudGl0eVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWluaW1pemVzIHRoZSB3aW5kb3cuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5taW5pbWl6ZVxuICAgICAqL1xuICAgIG1pbmltaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ21pbmltaXplLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHdpbmRvdyBieSBhIHNwZWNpZmllZCBhbW91bnQuXG4gICAgICogQHBhcmFtIHsgbnVtYmVyIH0gZGVsdGFMZWZ0IFRoZSBjaGFuZ2UgaW4gdGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7IG51bWJlciB9IGRlbHRhVG9wIFRoZSBjaGFuZ2UgaW4gdGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgd2luZG93XG4gICAgICogQHBhcmFtIHsgV2luZG93TW92ZW1lbnRPcHRpb25zIH0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIG1vZGlmeSB3aW5kb3cgbW92ZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93Lm1vdmVCeVxuICAgICAqL1xuICAgIG1vdmVCeShkZWx0YUxlZnQsIGRlbHRhVG9wLCBvcHRpb25zID0geyBtb3ZlSW5kZXBlbmRlbnRseTogZmFsc2UgfSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlXG4gICAgICAgICAgICAuc2VuZEFjdGlvbignbW92ZS13aW5kb3ctYnknLCB7XG4gICAgICAgICAgICBkZWx0YUxlZnQsXG4gICAgICAgICAgICBkZWx0YVRvcCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgd2luZG93IHRvIGEgc3BlY2lmaWVkIGxvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7IG51bWJlciB9IGxlZnQgVGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7IG51bWJlciB9IHRvcCBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSB3aW5kb3dcbiAgICAgKiBAcGFyYW0geyBXaW5kb3dNb3ZlbWVudE9wdGlvbnMgfSBvcHRpb25zIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gbW9kaWZ5IHdpbmRvdyBtb3ZlbWVudFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cubW92ZVRvXG4gICAgICovXG4gICAgbW92ZVRvKGxlZnQsIHRvcCwgb3B0aW9ucyA9IHsgbW92ZUluZGVwZW5kZW50bHk6IGZhbHNlIH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ21vdmUtd2luZG93Jywge1xuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSB3aW5kb3cgYnkgYSBzcGVjaWZpZWQgYW1vdW50LlxuICAgICAqIEBwYXJhbSB7IG51bWJlciB9IGRlbHRhV2lkdGggVGhlIGNoYW5nZSBpbiB0aGUgd2lkdGggb2YgdGhlIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7IG51bWJlciB9IGRlbHRhSGVpZ2h0IFRoZSBjaGFuZ2UgaW4gdGhlIGhlaWdodCBvZiB0aGUgd2luZG93XG4gICAgICogQHBhcmFtIHsgQW5jaG9yVHlwZSB9IGFuY2hvciBTcGVjaWZpZXMgYSBjb3JuZXIgdG8gcmVtYWluIGZpeGVkIGR1cmluZyB0aGUgcmVzaXplLlxuICAgICAqIENhbiB0YWtlIHRoZSB2YWx1ZXM6IFwidG9wLWxlZnRcIiwgXCJ0b3AtcmlnaHRcIiwgXCJib3R0b20tbGVmdFwiLCBvciBcImJvdHRvbS1yaWdodFwiLlxuICAgICAqIElmIHVuZGVmaW5lZCwgdGhlIGRlZmF1bHQgaXMgXCJ0b3AtbGVmdFwiXG4gICAgICogQHBhcmFtIHsgV2luZG93TW92ZW1lbnRPcHRpb25zIH0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIHRvIG1vZGlmeSB3aW5kb3cgbW92ZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LnJlc2l6ZUJ5XG4gICAgICovXG4gICAgcmVzaXplQnkoZGVsdGFXaWR0aCwgZGVsdGFIZWlnaHQsIGFuY2hvciwgb3B0aW9ucyA9IHsgbW92ZUluZGVwZW5kZW50bHk6IGZhbHNlIH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ3Jlc2l6ZS13aW5kb3ctYnknLCB7XG4gICAgICAgICAgICBkZWx0YVdpZHRoOiBNYXRoLmZsb29yKGRlbHRhV2lkdGgpLFxuICAgICAgICAgICAgZGVsdGFIZWlnaHQ6IE1hdGguZmxvb3IoZGVsdGFIZWlnaHQpLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIC4uLnRoaXMuaWRlbnRpdHlcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIHdpbmRvdyB0byB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvbnMuXG4gICAgICogQHBhcmFtIHsgbnVtYmVyIH0gd2lkdGggVGhlIGNoYW5nZSBpbiB0aGUgd2lkdGggb2YgdGhlIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7IG51bWJlciB9IGhlaWdodCBUaGUgY2hhbmdlIGluIHRoZSBoZWlnaHQgb2YgdGhlIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7IEFuY2hvclR5cGUgfSBhbmNob3IgU3BlY2lmaWVzIGEgY29ybmVyIHRvIHJlbWFpbiBmaXhlZCBkdXJpbmcgdGhlIHJlc2l6ZS5cbiAgICAgKiBDYW4gdGFrZSB0aGUgdmFsdWVzOiBcInRvcC1sZWZ0XCIsIFwidG9wLXJpZ2h0XCIsIFwiYm90dG9tLWxlZnRcIiwgb3IgXCJib3R0b20tcmlnaHRcIi5cbiAgICAgKiBJZiB1bmRlZmluZWQsIHRoZSBkZWZhdWx0IGlzIFwidG9wLWxlZnRcIlxuICAgICAqIEBwYXJhbSB7IFdpbmRvd01vdmVtZW50T3B0aW9ucyB9IG9wdGlvbnMgT3B0aW9uYWwgcGFyYW1ldGVycyB0byBtb2RpZnkgd2luZG93IG1vdmVtZW50XG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5yZXNpemVUb1xuICAgICAqL1xuICAgIHJlc2l6ZVRvKHdpZHRoLCBoZWlnaHQsIGFuY2hvciwgb3B0aW9ucyA9IHsgbW92ZUluZGVwZW5kZW50bHk6IGZhbHNlIH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZVxuICAgICAgICAgICAgLnNlbmRBY3Rpb24oJ3Jlc2l6ZS13aW5kb3cnLCB7XG4gICAgICAgICAgICB3aWR0aDogTWF0aC5mbG9vcih3aWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguZmxvb3IoaGVpZ2h0KSxcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyB0aGUgd2luZG93IHRvIGl0cyBub3JtYWwgc3RhdGUgKGkuZS4sIHVubWluaW1pemVkLCB1bm1heGltaXplZCkuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5yZXN0b3JlXG4gICAgICovXG4gICAgcmVzdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCdyZXN0b3JlLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBicmluZyB0aGUgd2luZG93IHRvIHRoZSBmcm9udCBvZiB0aGUgZW50aXJlIHN0YWNrIGFuZCBnaXZlIGl0IGZvY3VzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuc2V0QXNGb3JlZ3JvdW5kXG4gICAgICovXG4gICAgc2V0QXNGb3JlZ3JvdW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ3NldC1mb3JlZ3JvdW5kLXdpbmRvdycsIHRoaXMuaWRlbnRpdHkpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd2luZG93J3Mgc2l6ZSBhbmQgcG9zaXRpb24uXG4gICAgICogQHByb3BlcnR5IHsgQm91bmRzIH0gYm91bmRzIFRoaXMgaXMgYSAqIEB0eXBlIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSB3aW5kb3cub2JqZWN0IHRoYXQgaG9sZHMgdGhlIHByb3BlcnR5cyBvZlxuICAgICAqIEBwYXJhbSB7IFdpbmRvd01vdmVtZW50T3B0aW9ucyB9IG9wdGlvbnMgT3B0aW9uYWwgcGFyYW1ldGVycyB0byBtb2RpZnkgd2luZG93IG1vdmVtZW50XG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5zZXRCb3VuZHNcbiAgICAgKi9cbiAgICBzZXRCb3VuZHMoYm91bmRzLCBvcHRpb25zID0geyBtb3ZlSW5kZXBlbmRlbnRseTogZmFsc2UgfSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlXG4gICAgICAgICAgICAuc2VuZEFjdGlvbignc2V0LXdpbmRvdy1ib3VuZHMnLCB7IC4uLmJvdW5kcywgb3B0aW9ucywgLi4udGhpcy5pZGVudGl0eSB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHdpbmRvdyBpZiBpdCBpcyBoaWRkZW4uXG4gICAgICogQHBhcmFtIHsgYm9vbGVhbiB9IFtmb3JjZSA9IGZhbHNlXSBTaG93IHdpbGwgYmUgcHJldmVudGVkIGZyb20gc2hvd2luZyB3aGVuIGZvcmNlIGlzIGZhbHNlIGFuZFxuICAgICAqICDigJhzaG93LXJlcXVlc3RlZOKAmSBoYXMgYmVlbiBzdWJzY3JpYmVkIHRvIGZvciBhcHBsaWNhdGlvbuKAmXMgbWFpbiB3aW5kb3cuXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5zaG93XG4gICAgICovXG4gICAgc2hvdyhmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpcmUuc2VuZEFjdGlvbignc2hvdy13aW5kb3cnLCB7IGZvcmNlLCAuLi50aGlzLmlkZW50aXR5IH0pLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHdpbmRvdyBpZiBpdCBpcyBoaWRkZW4gYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cbiAgICAgKiBJZiB0aGUgdG9nZ2xlIHBhcmFtZXRlciBpcyBzZXQgdG8gdHJ1ZSwgdGhlIHdpbmRvdyB3aWxsXG4gICAgICogYWx0ZXJuYXRlIGJldHdlZW4gc2hvd2luZyBhbmQgaGlkaW5nLlxuICAgICAqIEBwYXJhbSB7IG51bWJlciB9IGxlZnQgVGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7IG51bWJlciB9IHRvcCBUaGUgcmlnaHQgcG9zaXRpb24gb2YgdGhlIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7IGJvb2xlYW4gfSBmb3JjZSBTaG93IHdpbGwgYmUgcHJldmVudGVkIGZyb20gY2xvc2luZyB3aGVuIGZvcmNlIGlzIGZhbHNlIGFuZFxuICAgICAqIOKAmHNob3ctcmVxdWVzdGVk4oCZIGhhcyBiZWVuIHN1YnNjcmliZWQgdG8gZm9yIGFwcGxpY2F0aW9u4oCZcyBtYWluIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7IFdpbmRvd01vdmVtZW50T3B0aW9ucyB9IG9wdGlvbnMgT3B0aW9uYWwgcGFyYW1ldGVycyB0byBtb2RpZnkgd2luZG93IG1vdmVtZW50XG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5zaG93QXRcbiAgICAgKi9cbiAgICBzaG93QXQobGVmdCwgdG9wLCBmb3JjZSA9IGZhbHNlLCBvcHRpb25zID0geyBtb3ZlSW5kZXBlbmRlbnRseTogZmFsc2UgfSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlXG4gICAgICAgICAgICAuc2VuZEFjdGlvbignc2hvdy1hdC13aW5kb3cnLCB7XG4gICAgICAgICAgICBmb3JjZSxcbiAgICAgICAgICAgIGxlZnQ6IE1hdGguZmxvb3IobGVmdCksXG4gICAgICAgICAgICB0b3A6IE1hdGguZmxvb3IodG9wKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAuLi50aGlzLmlkZW50aXR5XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgQ2hyb21pdW0gRGV2ZWxvcGVyIFRvb2xzXG4gICAgICogQHJldHVybiB7UHJvbWlzZS48dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5zaG93RGV2ZWxvcGVyVG9vbHNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB3aW5kb3cgdXNpbmcgdGhlIHBhc3NlZCBvcHRpb25zLlxuICAgICAqIFZhbHVlcyB0aGF0IGFyZSBvYmplY3RzIGFyZSBkZWVwLW1lcmdlZCwgb3ZlcndyaXRpbmcgb25seSB0aGUgdmFsdWVzIHRoYXQgYXJlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7Kn0gb3B0aW9ucyBDaGFuZ2VzIGEgd2luZG93J3Mgb3B0aW9ucyB0aGF0IHdlcmUgZGVmaW5lZCB1cG9uIGNyZWF0aW9uLiBTZWUgdHV0b3JpYWxcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjx2b2lkPn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LnVwZGF0ZU9wdGlvbnNcbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lyZS5zZW5kQWN0aW9uKCd1cGRhdGUtd2luZG93LW9wdGlvbnMnLCB7IG9wdGlvbnMsIC4uLnRoaXMuaWRlbnRpdHkgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBjcmVkZW50aWFscyB0byBhdXRoZW50aWNhdGlvbiByZXF1ZXN0c1xuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHVzZXJOYW1lIHVzZXJOYW1lIHRvIHByb3ZpZGUgdG8gdGhlIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZVxuICAgICAqIEBwYXJhbSB7IHN0cmluZyB9IHBhc3N3b3JkIHBhc3N3b3JkIHRvIHByb3ZpZGUgdG8gdGhlIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UuPHZvaWQ+fVxuICAgICAqIEB0dXRvcmlhbCBXaW5kb3cuYXV0aGVudGljYXRlXG4gICAgICovXG4gICAgYXV0aGVudGljYXRlKHVzZXJOYW1lLCBwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlXG4gICAgICAgICAgICAuc2VuZEFjdGlvbignd2luZG93LWF1dGhlbnRpY2F0ZScsIHsgdXNlck5hbWUsIHBhc3N3b3JkLCAuLi50aGlzLmlkZW50aXR5IH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBTaG93UG9wdXBNZW51T3B0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWVudUl0ZW1UZW1wbGF0ZT59IHRlbXBsYXRlIC0gQW4gYXJyYXkgZGVzY3JpYmluZyB0aGUgbWVudSB0byBzaG93LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeF0gLSBUaGUgd2luZG93IHggY29vcmRpbmF0ZSB3aGVyZSB0byBzaG93IHRoZSBtZW51LiBEZWZhdWx0cyB0byBtb3VzZSBwb3NpdGlvbi4gSWYgdXNpbmcgbXVzdCBhbHNvIHVzZSBgeWAuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt5XSAtIFRoZSB3aW5kb3cgeSBjb29yZGluYXRlIHdoZXJlIHRvIHNob3cgdGhlIG1lbnUuIERlZmF1bHRzIHRvIG1vdXNlIHBvc2l0aW9uLiBJZiB1c2luZyBtdXN0IGFsc28gdXNlIGB4YFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtvYmplY3R9IE1lbnVJdGVtVGVtcGxhdGVcbiAgICAgKiBAcHJvcGVydHkgeyp9IGRhdGEgRGF0YSB0byBiZSByZXR1cm5lZCBpZiB0aGUgdXNlciBzZWxlY3RzIHRoZSBlbGVtZW50LiBNdXN0IGJlIHNlcmlhbGl6YWJsZS4gTGFyZ2Ugb2JqZWN0cyBjYW4gaGF2ZSBhIHBlcmZvcm1hbmNlIGltcGFjdC5cbiAgICAgKiBAcHJvcGVydHkgeydub3JtYWwnIHwgJ3NlcGFyYXRvcicgfCAnc3VibWVudScgfCAnY2hlY2tib3gnfSBbdHlwZV0gLSBEZWZhdWx0cyB0byAnbm9ybWFsJyB1bmxlc3MgYSAnc3VibWVudScga2V5IGV4aXN0c1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFiZWxdIC0gVGhlIHRleHQgdG8gc2hvdyBvbiB0aGUgbWVudSBpdGVtLiBTaG91bGQgYmUgbGVmdCB1bmRlZmluZWQgZm9yIGB0eXBlOiAnc2VwYXJhdG9yJ2BcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlbmFibGVkXSAtIElmIGZhbHNlLCB0aGUgbWVudSBpdGVtIHdpbGwgYmUgZ3JleWVkIG91dCBhbmQgdW5jbGlja2FibGUuXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZV0gLSBJZiBmYWxzZSwgdGhlIG1lbnUgaXRlbSB3aWxsIGJlIGVudGlyZWx5IGhpZGRlbi5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjaGVja2VkXSAtIFNob3VsZCBvbmx5IGJlIHNwZWNpZmllZCBmb3IgYGNoZWNrYm94YCB0eXBlIG1lbnUgaXRlbXMuXG4gICAgICogQHByb3BlcnR5IHtBcnJheTxNZW51SXRlbVRlbXBsYXRlPn0gW3N1Ym1lbnVdIFNob3VsZCBiZSBzcGVjaWZpZWQgZm9yIGBzdWJtZW51YCB0eXBlIG1lbnUgaXRlbXMuIElmIGBzdWJtZW51YCBpcyBzcGVjaWZpZWQsIHRoZSBgdHlwZTogJ3N1Ym1lbnUnYCBjYW4gYmUgb21pdHRlZC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBNZW51UmVzdWx0XG4gICAgICogQHByb3BlcnR5IHsnY2xpY2tlZCcgfCAnY2xvc2VkJ30gcmVzdWx0IC0gV2hldGhlciB0aGUgdXNlciBjbGlja2VkIG9uIGEgbWVudSBpdGVtIG9yIHRoZSBtZW51IHdhcyBjbG9zZWQgKHVzZXIgY2xpY2tlZCBlbHNld2hlcmUpLlxuICAgICAqIEBwcm9wZXJ0eSB7KiB8IHVuZGVmaW5lZH0gW2RhdGFdIC0gVGhlIGRhdGEgcHJvcGVydHkgb2YgdGhlIG1lbnUgaXRlbSBjbGlja2VkIGJ5IHRoZSB1c2VyLiBPbmx5IGRlZmluZWQgaWYgcmVzdWx0IHdhcyBgY2xpY2tlZGAuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU2hvd3MgYSBtZW51IG9uIHRoZSB3aW5kb3cuIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgdXNlciBoYXMgZWl0aGVyIHNlbGVjdGVkIGFuIGl0ZW0gb3IgY2xvc2VkIHRoZSBtZW51LiAoVGhpcyBtYXkgdGFrZSBsb25nZXIgdGhhbiBvdGhlciBhcGlzKS5cbiAgICAgKiBSZXNvbHZlcyB0byBhbiBvYmplY3Qgd2l0aCBge3Jlc3VsdDogJ2NsaWNrZWQnLCBkYXRhIH1gIHdoZXJlIGRhdGEgaXMgdGhlIGRhdGEgZmllbGQgb24gdGhlIG1lbnUgaXRlbSBjbGlja2VkLCBvciBge3Jlc3VsdCAnY2xvc2VkJ31gIHdoZW4gdGhlIHVzZXIgZG9lc24ndCBzZWxlY3QgYW55dGhpbmcuXG4gICAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aWxsIGNsb3NlIHByZXZpb3VzbHkgb3BlbmVkIG1lbnVzLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKiBAcGFyYW0ge1Nob3dQb3B1cE1lbnVPcHRpb25zfSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxNZW51UmVzdWx0Pn1cbiAgICAgKiBAdHV0b3JpYWwgV2luZG93LnNob3dQb3B1cE1lbnVcbiAgICAgKi9cbiAgICBhc3luYyBzaG93UG9wdXBNZW51KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBhd2FpdCB0aGlzLndpcmUuc2VuZEFjdGlvbignc2hvdy1wb3B1cC1tZW51JywgeyBvcHRpb25zLCAuLi50aGlzLmlkZW50aXR5IH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHdpbmRvdydzIHBvcHVwIG1lbnUsIGlmIG9uZSBleGlzdHMuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gICAgICogQHR1dG9yaWFsIFdpbmRvdy5jbG9zZVBvcHVwTWVudVxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlUG9wdXBNZW51KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXJlLnNlbmRBY3Rpb24oJ2Nsb3NlLXBvcHVwLW1lbnUnLCB7IC4uLnRoaXMuaWRlbnRpdHkgfSkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuX1dpbmRvdyA9IF9XaW5kb3c7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQm91bmRzQ2hhbmdlVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpO1xuY2xhc3MgQm91bmRzQ2hhbmdlZFJlcGx5IGV4dGVuZHMgYmFzZV8xLlJlcGx5IHtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEJvdW5kc0NoYW5nZWRSZXBseTtcbnZhciBCb3VuZHNDaGFuZ2VUeXBlO1xuKGZ1bmN0aW9uIChCb3VuZHNDaGFuZ2VUeXBlKSB7XG4gICAgQm91bmRzQ2hhbmdlVHlwZVtCb3VuZHNDaGFuZ2VUeXBlW1wiUE9TSVRJT05cIl0gPSAwXSA9IFwiUE9TSVRJT05cIjtcbiAgICBCb3VuZHNDaGFuZ2VUeXBlW0JvdW5kc0NoYW5nZVR5cGVbXCJTSVpFXCJdID0gMV0gPSBcIlNJWkVcIjtcbiAgICBCb3VuZHNDaGFuZ2VUeXBlW0JvdW5kc0NoYW5nZVR5cGVbXCJQT1NJVElPTl9BTkRfU0laRVwiXSA9IDJdID0gXCJQT1NJVElPTl9BTkRfU0laRVwiO1xufSkoQm91bmRzQ2hhbmdlVHlwZSA9IGV4cG9ydHMuQm91bmRzQ2hhbmdlVHlwZSB8fCAoZXhwb3J0cy5Cb3VuZHNDaGFuZ2VUeXBlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9GYWN0b3J5XCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRmFjdG9yeV8xLmRlZmF1bHQ7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2hhcGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JbnN0YW5jZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYm91bmRzLWNoYW5nZWRcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5PcGVuRmluID0gZXhwb3J0cy5maW4gPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBzcGFjZWQtY29tbWVudCAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3RyaXBsZS1zbGFzaC1yZWZlcmVuY2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZSAqL1xuLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL09wZW5GaW4uZC50c1wiLz5cbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGZpbl8xID0gcmVxdWlyZShcIi4vYXBpL2ZpblwiKTtcbmNvbnN0IEVudGl0eVR5cGVfMSA9IHJlcXVpcmUoXCIuL3NoYXBlcy9FbnRpdHlUeXBlXCIpO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnQvdHJhbnNwb3J0XCIpO1xuY2xhc3MgTW9ja1dpcmUgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbm5lY3QoYWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgbm90IHJ1bm5pbmcgaW4gT3BlbkZpbi4nKTtcbiAgICB9XG4gICAgY29ubmVjdFN5bmMoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBub3QgcnVubmluZyBpbiBPcGVuRmluLicpO1xuICAgIH1cbiAgICBzZW5kKGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIG5vdCBydW5uaW5nIGluIE9wZW5GaW4uJyk7XG4gICAgfVxuICAgIHNodXRkb3duKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgbm90IHJ1bm5pbmcgaW4gT3BlbkZpbi4nKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG59XG5jbGFzcyBNb2NrRW52aXJvbm1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoaWxkVmlld3MgPSB0cnVlO1xuICAgIH1cbiAgICBnZXRNYW5hZ2VyQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgZ2V0UHJvdmlkZXJJbml0aWFsaXplcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICB3cml0ZVRva2VuKHBhdGgsIHRva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgcmV0cmlldmVQb3J0KGNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIGdldE5leHRNZXNzYWdlSWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgZ2V0UmFuZG9tSWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgY3JlYXRlQ2hpbGRDb250ZW50KG9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICBnZXRXZWJXaW5kb3coaWRlbnRpdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICBnZXRDdXJyZW50RW50aXR5SWRlbnRpdHkoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgZ2V0Q3VycmVudEVudGl0eVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBFbnRpdHlUeXBlXzEuZGVmYXVsdC5VTktOT1dOO1xuICAgIH1cbiAgICByYWlzZUV2ZW50KGV2ZW50TmFtZSwgZXZlbnRBcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgZ2V0VXJsKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxufVxuZXhwb3J0cy5maW4gPSAoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSB3aW5kb3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maW4pKSB8fFxuICAgICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVudmlyb25tZW50ID0gbmV3IE1vY2tFbnZpcm9ubWVudCgpO1xuICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0XzEuZGVmYXVsdChNb2NrV2lyZSwgZW52aXJvbm1lbnQsIHtcbiAgICAgICAgICAgIHV1aWQ6ICcnLFxuICAgICAgICAgICAgbmFtZTogJydcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgZmluXzEuZGVmYXVsdCh0cmFuc3BvcnQpO1xuICAgIH0pKCkpO1xuZXhwb3J0cy5pbk9wZW5GaW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmZpbiA9PT0gJ29iamVjdCc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFbnRpdHlUeXBlO1xuKGZ1bmN0aW9uIChFbnRpdHlUeXBlKSB7XG4gICAgRW50aXR5VHlwZVtcIldJTkRPV1wiXSA9IFwid2luZG93XCI7XG4gICAgRW50aXR5VHlwZVtcIklGUkFNRVwiXSA9IFwiaWZyYW1lXCI7XG4gICAgRW50aXR5VHlwZVtcIkVYVEVSTkFMXCJdID0gXCJleHRlcm5hbCBjb25uZWN0aW9uXCI7XG4gICAgRW50aXR5VHlwZVtcIlZJRVdcIl0gPSBcInZpZXdcIjtcbiAgICBFbnRpdHlUeXBlW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xufSkoRW50aXR5VHlwZSB8fCAoRW50aXR5VHlwZSA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFbnRpdHlUeXBlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldpbmRvd0NyZWF0aW9uUmVhc29uID0gZXhwb3J0cy5Ib3N0Q29udGV4dENoYW5nZWRSZWFzb25zID0gdm9pZCAwO1xudmFyIEhvc3RDb250ZXh0Q2hhbmdlZFJlYXNvbnM7XG4oZnVuY3Rpb24gKEhvc3RDb250ZXh0Q2hhbmdlZFJlYXNvbnMpIHtcbiAgICBIb3N0Q29udGV4dENoYW5nZWRSZWFzb25zW1widXBkYXRlZFwiXSA9IFwidXBkYXRlZFwiO1xuICAgIEhvc3RDb250ZXh0Q2hhbmdlZFJlYXNvbnNbXCJyZXBhcmVudGVkXCJdID0gXCJyZXBhcmVudGVkXCI7XG59KShIb3N0Q29udGV4dENoYW5nZWRSZWFzb25zID0gZXhwb3J0cy5Ib3N0Q29udGV4dENoYW5nZWRSZWFzb25zIHx8IChleHBvcnRzLkhvc3RDb250ZXh0Q2hhbmdlZFJlYXNvbnMgPSB7fSkpO1xudmFyIFdpbmRvd0NyZWF0aW9uUmVhc29uO1xuKGZ1bmN0aW9uIChXaW5kb3dDcmVhdGlvblJlYXNvbikge1xuICAgIFdpbmRvd0NyZWF0aW9uUmVhc29uW1wiVGVhcm91dFwiXSA9IFwidGVhcm91dFwiO1xuICAgIFdpbmRvd0NyZWF0aW9uUmVhc29uW1wiQ3JlYXRlVmlld1dpdGhvdXRUYXJnZXRcIl0gPSBcImNyZWF0ZS12aWV3LXdpdGhvdXQtdGFyZ2V0XCI7XG4gICAgV2luZG93Q3JlYXRpb25SZWFzb25bXCJBUElDYWxsXCJdID0gXCJhcGktY2FsbFwiO1xuICAgIFdpbmRvd0NyZWF0aW9uUmVhc29uW1wiQXBwQ3JlYXRpb25cIl0gPSBcImFwcC1jcmVhdGlvblwiO1xuICAgIFdpbmRvd0NyZWF0aW9uUmVhc29uW1wiUmVzdG9yZVwiXSA9IFwicmVzdG9yZVwiO1xufSkoV2luZG93Q3JlYXRpb25SZWFzb24gPSBleHBvcnRzLldpbmRvd0NyZWF0aW9uUmVhc29uIHx8IChleHBvcnRzLldpbmRvd0NyZWF0aW9uUmVhc29uID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRGaW4gPSBleHBvcnRzLnJlZ2lzdGVyRmluID0gdm9pZCAwO1xuY29uc3QgZmluTWFwID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHJlZ2lzdGVyRmluKHdpcmUsIGZpbikge1xuICAgIGZpbk1hcC5zZXQod2lyZSwgZmluKTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJGaW4gPSByZWdpc3RlckZpbjtcbmZ1bmN0aW9uIGdldEZpbih3aXJlKSB7XG4gICAgY29uc3QgZmluID0gZmluTWFwLmdldCh3aXJlKTtcbiAgICBpZiAoIWZpbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBsb2NhdGUgZmluIGFwaSBmb3IgZ2l2ZW4gdHJhbnNwb3J0Jyk7XG4gICAgfVxuICAgIHJldHVybiBmaW47XG59XG5leHBvcnRzLmdldEZpbiA9IGdldEZpbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SdW50aW1lRXJyb3IgPSBleHBvcnRzLk5vdFN1cHBvcnRlZEVycm9yID0gZXhwb3J0cy5Ob3RJbXBsZW1lbnRlZEVycm9yID0gZXhwb3J0cy5Ob0Fja0Vycm9yID0gZXhwb3J0cy5EdXBsaWNhdGVDb3JyZWxhdGlvbkVycm9yID0gZXhwb3J0cy5VbmV4cGVjdGVkQWN0aW9uRXJyb3IgPSBleHBvcnRzLkRpc2Nvbm5lY3RlZEVycm9yID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cbmNvbnN0IHdpcmVfMSA9IHJlcXVpcmUoXCIuL3dpcmVcIik7XG5jbGFzcyBEaXNjb25uZWN0ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZWFkeVN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGBFeHBlY3RlZCB3ZWJzb2NrZXQgc3RhdGUgT1BFTiBidXQgZm91bmQgJHt3aXJlXzEuUkVBRFlfU1RBVEVbcmVhZHlTdGF0ZV19YCk7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHJlYWR5U3RhdGU7XG4gICAgfVxufVxuZXhwb3J0cy5EaXNjb25uZWN0ZWRFcnJvciA9IERpc2Nvbm5lY3RlZEVycm9yO1xuY2xhc3MgVW5leHBlY3RlZEFjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuZXhwb3J0cy5VbmV4cGVjdGVkQWN0aW9uRXJyb3IgPSBVbmV4cGVjdGVkQWN0aW9uRXJyb3I7XG5jbGFzcyBEdXBsaWNhdGVDb3JyZWxhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuZXhwb3J0cy5EdXBsaWNhdGVDb3JyZWxhdGlvbkVycm9yID0gRHVwbGljYXRlQ29ycmVsYXRpb25FcnJvcjtcbmNsYXNzIE5vQWNrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5leHBvcnRzLk5vQWNrRXJyb3IgPSBOb0Fja0Vycm9yO1xuY2xhc3MgTm90SW1wbGVtZW50ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmV4cG9ydHMuTm90SW1wbGVtZW50ZWRFcnJvciA9IE5vdEltcGxlbWVudGVkRXJyb3I7XG5jbGFzcyBOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmV4cG9ydHMuTm90U3VwcG9ydGVkRXJyb3IgPSBOb3RTdXBwb3J0ZWRFcnJvcjtcbmNsYXNzIFJ1bnRpbWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnBheWxvYWQgfHwgZGF0YTtcbiAgICAgICAgY29uc3QgeyByZWFzb24sIGVycm9yIH0gPSBwYXlsb2FkO1xuICAgICAgICBzdXBlcihyZWFzb24pO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUnVudGltZUVycm9yJztcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5zdGFjaykge1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SdW50aW1lRXJyb3IgPSBSdW50aW1lRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG4gICAgfVxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX3dpcmU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCB3aXJlXzEgPSByZXF1aXJlKFwiLi93aXJlXCIpO1xuY29uc3QgdHJhbnNwb3J0X2Vycm9yc18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0LWVycm9yc1wiKTtcbmNvbnN0IGV2ZW50QWdncmVnYXRvcl8xID0gcmVxdWlyZShcIi4uL2FwaS9ldmVudHMvZXZlbnRBZ2dyZWdhdG9yXCIpO1xuY29uc3QgbWVfMSA9IHJlcXVpcmUoXCIuLi9hcGkvbWVcIik7XG5jbGFzcyBUcmFuc3BvcnQgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKFdpcmVUeXBlLCBlbnZpcm9ubWVudCwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lyZUxpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50b3BpY1JlZk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ldmVudEFnZ3JlZ2F0b3IgPSBuZXcgZXZlbnRBZ2dyZWdhdG9yXzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycyA9IFt0aGlzLmV2ZW50QWdncmVnYXRvci5kaXNwYXRjaEV2ZW50XTtcbiAgICAgICAgX3dpcmUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMuY29ubmVjdFN5bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3aXJlID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfd2lyZSk7XG4gICAgICAgICAgICB3aXJlLmNvbm5lY3RTeW5jKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIGluIG91ciB0ZXN0cy5cbiAgICAgICAgdGhpcy5nZXRQb3J0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZW52aXJvbm1lbnQuY29uc3RydWN0b3IubmFtZSAhPT0gJ05vZGVFbnZpcm9ubWVudCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHJhbnNwb3J0X2Vycm9yc18xLk5vdEltcGxlbWVudGVkRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lyZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3dpcmUpO1xuICAgICAgICAgICAgcmV0dXJuIHdpcmUud2lyZS51cmwuc3BsaXQoJzonKS5zbGljZSgtMSlbMF07XG4gICAgICAgIH07XG4gICAgICAgIC8qIGBSRUFEWV9TVEFURWAgaXMgYW4gaW5zdGFuY2UgdmFyIHNldCBieSBgY29uc3RydWN0b3JgIHRvIHJlZmVyZW5jZSB0aGUgYFdlYlRyYW5zcG9ydFNvY2tldC5SRUFEWV9TVEFURWAgZW51bS5cbiAgICAgICAgICogVGhpcyBpcyBzeW50YWN0aWMgc3VnYXIgdGhhdCBtYWtlcyB0aGUgZW51bSBhY2Nlc3NpYmxlIHRocm91Z2ggdGhlIGB3aXJlYCBwcm9wZXJ0eSBvZiB0aGUgdmFyaW91cyBgZmluYCBzaW5nbGV0b25zLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgYGZpbi5zeXN0ZW0ud2lyZS5SRUFEWV9TVEFURWAgaXMgYSBzaG9ydGN1dCB0byBgZmluLnN5c3RlbS53aXJlLndpcmUuY29uc3RydWN0b3IuUkVBRFlfU1RBVEVgLlxuICAgICAgICAgKiBIb3dldmVyIGl0IGlzIGFjY2Vzc2VkLCB0aGUgZW51bSBpcyB1c2VmdWwgZm9yIGludGVycm9nYXRpbmcgdGhlIHN0YXRlIG9mIHRoZSB3ZWIgc29ja2V0IG9uIHNlbmQgZmFpbHVyZS5cbiAgICAgICAgICogVGhlIGBlcnIucmVhZHlTdGF0ZWAgdmFsdWUgaXMgcGFzc2VkIHRvIHRoZSBgcmVqZWN0YCBoYW5kbGVyIG9mIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IGVpdGhlciBvZlxuICAgICAgICAgKiBgc2VuZEFjdGlvbmAgb3IgYGZlcnJ5QWN0aW9uYCwgYW5kIGhlbmNlIGFsbCB0aGUgQVBJIG1ldGhvZHMgaW4gdGhlIHZhcmlvdXMgYGZpbmAgc2luZ2xldG9ucyB0aGF0IGNhbGwgdGhlbS5cbiAgICAgICAgICogVGhlIGVudW0gY2FuIGJlIHVzZWQgaW4gdHdvIGRpc3RpbmN0IHdheXMgYnkgdGhlIGByZWplY3RgIGhhbmRsZXIgKHVzaW5nIGBmaW4uU3lzdGVtLmdldFZlcnNpb25gIGJ5IHdheSBvZiBleGFtcGxlKTpcbiAgICAgICAgICogMS4gU3RhdGUgbmFtZSBieSBzdGF0ZSB2YWx1ZTpcbiAgICAgICAgICogZmluLnN5c3RlbS5nZXRWZXJzaW9uKCkuY2F0Y2goZXJyID0+IHsgY29uc29sZS5sb2coJ1N0YXRlOicsIGZpbi5zeXN0ZW0ud2lyZS5SRUFEWV9TVEFURVtlcnIucmVhZHlTdGF0ZV0pOyB9KTtcbiAgICAgICAgICogMi4gU3RhdGUgdmFsdWUgYnkgc3RhdGUgbmFtZTpcbiAgICAgICAgICogZmluLnN5c3RlbS5nZXRWZXJzaW9uKCkuY2F0Y2goZXJyID0+IHsgY29uc29sZS5sb2coJ0Nsb3NlZDonLCBlcnIucmVhZHlTdGF0ZSA9PT0gZmluLnN5c3RlbS53aXJlLlJFQURZX1NUQVRFLkNMT1NFRCk7IH0pO1xuICAgICAgICAgKiBOb3RlIHRoYXQgYHJlamVjdGAgaXMgY2FsbGVkIHdoZW4gYW5kIG9ubHkgd2hlbiBgcmVhZHlTdGF0ZWAgaXMgbm90IGBPUEVOYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuUkVBRFlfU1RBVEUgPSB3aXJlXzEuUkVBRFlfU1RBVEU7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX3dpcmUsIG5ldyBXaXJlVHlwZSh0aGlzLm9ubWVzc2FnZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuZW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudDtcbiAgICAgICAgdGhpcy5zZW5kUmF3ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfd2lyZSkuc2VuZC5iaW5kKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3dpcmUpKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVyKHRoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfd2lyZSkub24oJ2Rpc2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgWywgeyByZWplY3QgfV0gb2YgdGhpcy53aXJlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCdSZW1vdGUgY29ubmVjdGlvbiBoYXMgY2xvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndpcmVMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHV1aWQsIG5hbWUgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgZW50aXR5VHlwZSA9IHRoaXMuZW52aXJvbm1lbnQuZ2V0Q3VycmVudEVudGl0eVR5cGUoKTtcbiAgICAgICAgdGhpcy5tZSA9IG1lXzEuZ2V0QmFzZU1lKGVudGl0eVR5cGUsIHV1aWQsIG5hbWUpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgY29uc3Qgd2lyZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3dpcmUpO1xuICAgICAgICByZXR1cm4gd2lyZS5zaHV0ZG93bigpO1xuICAgIH1cbiAgICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAod2lyZV8xLmlzRXhpc3RpbmdDb25uZWN0Q29uZmlnKGNvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RCeVBvcnQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lyZV8xLmlzTmV3Q29ubmVjdENvbmZpZyhjb25maWcpKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gYXdhaXQgdGhpcy5lbnZpcm9ubWVudC5yZXRyaWV2ZVBvcnQoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RCeVBvcnQoeyAuLi5jb25maWcsIGFkZHJlc3M6IGB3czovL2xvY2FsaG9zdDoke3BvcnR9YCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBjb25uZWN0QnlQb3J0KGNvbmZpZykge1xuICAgICAgICBjb25zdCB7IGFkZHJlc3MsIHV1aWQgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgcmVxQXV0aFBheWxvYWQgPSB7IC4uLmNvbmZpZywgdHlwZTogJ2ZpbGUtdG9rZW4nIH07XG4gICAgICAgIGNvbnN0IHdpcmUgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF93aXJlKTtcbiAgICAgICAgYXdhaXQgd2lyZS5jb25uZWN0KGFkZHJlc3MpO1xuICAgICAgICBjb25zdCByZXF1ZXN0RXh0QXV0aFJldCA9IGF3YWl0IHRoaXMuc2VuZEFjdGlvbigncmVxdWVzdC1leHRlcm5hbC1hdXRob3JpemF0aW9uJywge1xuICAgICAgICAgICAgdXVpZCxcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlLXRva2VuJ1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgaWYgKHJlcXVlc3RFeHRBdXRoUmV0LmFjdGlvbiAhPT0gJ2V4dGVybmFsLWF1dGhvcml6YXRpb24tcmVzcG9uc2UnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHJhbnNwb3J0X2Vycm9yc18xLlVuZXhwZWN0ZWRBY3Rpb25FcnJvcihyZXF1ZXN0RXh0QXV0aFJldC5hY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdG9rZW4gfSA9IHJlcXVlc3RFeHRBdXRoUmV0LnBheWxvYWQ7XG4gICAgICAgIGF3YWl0IHRoaXMuZW52aXJvbm1lbnQud3JpdGVUb2tlbihyZXF1ZXN0RXh0QXV0aFJldC5wYXlsb2FkLmZpbGUsIHJlcXVlc3RFeHRBdXRoUmV0LnBheWxvYWQudG9rZW4pO1xuICAgICAgICBjb25zdCByZXF1ZXN0QXV0aFJldCA9IGF3YWl0IHRoaXMuc2VuZEFjdGlvbigncmVxdWVzdC1hdXRob3JpemF0aW9uJywgcmVxQXV0aFBheWxvYWQsIHRydWUpO1xuICAgICAgICBpZiAocmVxdWVzdEF1dGhSZXQuYWN0aW9uICE9PSAnYXV0aG9yaXphdGlvbi1yZXNwb25zZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB0cmFuc3BvcnRfZXJyb3JzXzEuVW5leHBlY3RlZEFjdGlvbkVycm9yKHJlcXVlc3RBdXRoUmV0LmFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxdWVzdEF1dGhSZXQucGF5bG9hZC5zdWNjZXNzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHJhbnNwb3J0X2Vycm9yc18xLlJ1bnRpbWVFcnJvcihyZXF1ZXN0QXV0aFJldC5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kQWN0aW9uKGFjdGlvbiwgcGF5bG9hZCA9IHt9LCB1bmNvcnJlbGF0ZWQgPSBmYWxzZVxuICAgIC8vIHNwZWNpYWxSZXNwb25zZSB0eXBlIGlzIG9ubHkgdXNlZCBmb3IgJ3JlcXVlc3RBdXRob3JpemF0aW9uJ1xuICAgICkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLmVudmlyb25tZW50LmdldE5leHRNZXNzYWdlSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgd2lyZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3dpcmUpO1xuICAgICAgICAgICAgdGhpcy5hZGRXaXJlTGlzdGVuZXIoaWQsIHJlc29sdmUsIHJlamVjdCwgdW5jb3JyZWxhdGVkKTtcbiAgICAgICAgICAgIHJldHVybiB3aXJlLnNlbmQobXNnKS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmVycnlBY3Rpb24ob3JpZ0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5lbnZpcm9ubWVudC5nZXROZXh0TWVzc2FnZUlkKCk7XG4gICAgICAgICAgICBvcmlnRGF0YS5tZXNzYWdlSWQgPSBpZDtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEucGF5bG9hZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgd2lyZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3dpcmUpO1xuICAgICAgICAgICAgcmV0dXJuIHdpcmVcbiAgICAgICAgICAgICAgICAuc2VuZChvcmlnRGF0YSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLmFkZFdpcmVMaXN0ZW5lcihpZCwgcmVzb2x2ZXIsIHJlamVjdCwgZmFsc2UpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgfVxuICAgIGFkZFdpcmVMaXN0ZW5lcihpZCwgcmVzb2x2ZSwgcmVqZWN0LCB1bmNvcnJlbGF0ZWQpIHtcbiAgICAgICAgaWYgKHVuY29ycmVsYXRlZCkge1xuICAgICAgICAgICAgdGhpcy51bmNvcnJlbGF0ZWRMaXN0ZW5lciA9IHJlc29sdmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy53aXJlTGlzdGVuZXJzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgdHJhbnNwb3J0X2Vycm9yc18xLkR1cGxpY2F0ZUNvcnJlbGF0aW9uRXJyb3IoU3RyaW5nKGlkKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53aXJlTGlzdGVuZXJzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGltZW91dCBhbmQgcmVqZWN0KCk/XG4gICAgfVxuICAgIC8vIFRoaXMgbWV0aG9kIGV4ZWN1dGVzIG1lc3NhZ2UgaGFuZGxlcnMgdW50aWwgdGhlIF9vbmVfIHRoYXQgaGFuZGxlcyB0aGUgbWVzc2FnZSAocmV0dXJucyB0cnV0aHkpIGhhcyBydW5cbiAgICBvbm1lc3NhZ2UoZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IGggb2YgdGhpcy5tZXNzYWdlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGguY2FsbChudWxsLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgaWQgPSBkYXRhLmNvcnJlbGF0aW9uSWQgfHwgTmFOO1xuICAgICAgICBpZiAoISgnY29ycmVsYXRpb25JZCcgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVuY29ycmVsYXRlZExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmNvcnJlbGF0ZWRMaXN0ZW5lci5jYWxsKG51bGwsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bmNvcnJlbGF0ZWRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBibG9ja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy53aXJlTGlzdGVuZXJzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGp1c3QgY2hlY2tlZCBmb3IgZXhpc3RlbmNlIGFib3ZlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMud2lyZUxpc3RlbmVycy5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGRhdGEuYWN0aW9uICE9PSAnYWNrJykge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgdHJhbnNwb3J0X2Vycm9yc18xLk5vQWNrRXJyb3IoZGF0YS5hY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEoJ3BheWxvYWQnIGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyB0cmFuc3BvcnRfZXJyb3JzXzEuUnVudGltZUVycm9yKGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhLnBheWxvYWQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgdHJhbnNwb3J0X2Vycm9yc18xLlJ1bnRpbWVFcnJvcihkYXRhLnBheWxvYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUuY2FsbChudWxsLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud2lyZUxpc3RlbmVycy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbl93aXJlID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zcG9ydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SRUFEWV9TVEFURSA9IGV4cG9ydHMuaXNJbnRlcm5hbENvbm5lY3RDb25maWcgPSBleHBvcnRzLmlzUG9ydERpc2NvdmVyeUNvbmZpZyA9IGV4cG9ydHMuaXNOZXdDb25uZWN0Q29uZmlnID0gZXhwb3J0cy5pc0V4aXN0aW5nQ29ubmVjdENvbmZpZyA9IGV4cG9ydHMuaXNFeHRlcm5hbENvbmZpZyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzRXh0ZXJuYWxDb25maWcoY29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcubWFuaWZlc3RVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzRXh0ZXJuYWxDb25maWcgPSBpc0V4dGVybmFsQ29uZmlnO1xuZnVuY3Rpb24gaXNFeGlzdGluZ0Nvbm5lY3RDb25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIGhhc1V1aWQoY29uZmlnKSAmJiB0eXBlb2YgY29uZmlnLmFkZHJlc3MgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc0V4aXN0aW5nQ29ubmVjdENvbmZpZyA9IGlzRXhpc3RpbmdDb25uZWN0Q29uZmlnO1xuZnVuY3Rpb24gaGFzVXVpZChjb25maWcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNvbmZpZy51dWlkID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGhhc1J1bnRpbWVWZXJzaW9uKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcucnVudGltZSAmJiB0eXBlb2YgY29uZmlnLnJ1bnRpbWUudmVyc2lvbiA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiBpc05ld0Nvbm5lY3RDb25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIGhhc1V1aWQoY29uZmlnKSAmJiBoYXNSdW50aW1lVmVyc2lvbihjb25maWcpO1xufVxuZXhwb3J0cy5pc05ld0Nvbm5lY3RDb25maWcgPSBpc05ld0Nvbm5lY3RDb25maWc7XG5mdW5jdGlvbiBpc1BvcnREaXNjb3ZlcnlDb25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIChpc0V4dGVybmFsQ29uZmlnKGNvbmZpZykgJiYgaGFzUnVudGltZVZlcnNpb24oY29uZmlnKSkgfHwgaXNOZXdDb25uZWN0Q29uZmlnKGNvbmZpZyk7XG59XG5leHBvcnRzLmlzUG9ydERpc2NvdmVyeUNvbmZpZyA9IGlzUG9ydERpc2NvdmVyeUNvbmZpZztcbmZ1bmN0aW9uIGlzSW50ZXJuYWxDb25uZWN0Q29uZmlnKGNvbmZpZykge1xuICAgIHJldHVybiBpc0V4aXN0aW5nQ29ubmVjdENvbmZpZyhjb25maWcpIHx8IGlzTmV3Q29ubmVjdENvbmZpZyhjb25maWcpO1xufVxuZXhwb3J0cy5pc0ludGVybmFsQ29ubmVjdENvbmZpZyA9IGlzSW50ZXJuYWxDb25uZWN0Q29uZmlnO1xudmFyIFJFQURZX1NUQVRFO1xuKGZ1bmN0aW9uIChSRUFEWV9TVEFURSkge1xuICAgIFJFQURZX1NUQVRFW1JFQURZX1NUQVRFW1wiQ09OTkVDVElOR1wiXSA9IDBdID0gXCJDT05ORUNUSU5HXCI7XG4gICAgUkVBRFlfU1RBVEVbUkVBRFlfU1RBVEVbXCJPUEVOXCJdID0gMV0gPSBcIk9QRU5cIjtcbiAgICBSRUFEWV9TVEFURVtSRUFEWV9TVEFURVtcIkNMT1NJTkdcIl0gPSAyXSA9IFwiQ0xPU0lOR1wiO1xuICAgIFJFQURZX1NUQVRFW1JFQURZX1NUQVRFW1wiQ0xPU0VEXCJdID0gM10gPSBcIkNMT1NFRFwiOyAvLyBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQuXG59KShSRUFEWV9TVEFURSA9IGV4cG9ydHMuUkVBRFlfU1RBVEUgfHwgKGV4cG9ydHMuUkVBRFlfU1RBVEUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb21pc2VNYXBTZXJpYWwgPSBleHBvcnRzLnNlcmlhbCA9IGV4cG9ydHMucHJvbWlzZU1hcCA9IGV4cG9ydHMucHJvbWlzaWZ5ID0gdm9pZCAwO1xuZnVuY3Rpb24gcHJvbWlzaWZ5KGZ1bmMpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZnVuYyguLi5hcmdzLCAoZXJyLCB2YWwpID0+IChlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUodmFsKSkpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5wcm9taXNpZnkgPSBwcm9taXNpZnk7XG5hc3luYyBmdW5jdGlvbiBwcm9taXNlTWFwKGFyciwgYXN5bmNGKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGFyci5tYXAoYXN5bmNGKSk7XG59XG5leHBvcnRzLnByb21pc2VNYXAgPSBwcm9taXNlTWFwO1xuYXN5bmMgZnVuY3Rpb24gc2VyaWFsKGFycikge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAoY29uc3QgZnVuYyBvZiBhcnIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICAgICAgY29uc3QgbmV4dCA9IGF3YWl0IGZ1bmMoKTtcbiAgICAgICAgcmV0LnB1c2gobmV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5leHBvcnRzLnNlcmlhbCA9IHNlcmlhbDtcbmFzeW5jIGZ1bmN0aW9uIHByb21pc2VNYXBTZXJpYWwoYXJyLCBmdW5jKSB7XG4gICAgcmV0dXJuIHNlcmlhbChhcnIubWFwKCh2YWx1ZSwgaW5kZXgsIGFycmF5KSA9PiAoKSA9PiBmdW5jKHZhbHVlLCBpbmRleCwgYXJyYXkpKSk7XG59XG5leHBvcnRzLnByb21pc2VNYXBTZXJpYWwgPSBwcm9taXNlTWFwU2VyaWFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBSZWZDb3V0bmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50b3BpY1JlZk1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLy8gcmV0dXJucyB0aGUgcmVmIGNvdW50IGFmdGVyIGluY3JlbWVudGluZ1xuICAgIGluY1JlZkNvdW50KGtleSkge1xuICAgICAgICBjb25zdCByZWZDb3VudCA9IHRoaXMudG9waWNSZWZNYXAuZ2V0KGtleSk7XG4gICAgICAgIGxldCByZXR1cm5Db3VudDtcbiAgICAgICAgaWYgKCFyZWZDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50b3BpY1JlZk1hcC5zZXQoa2V5LCAxKTtcbiAgICAgICAgICAgIHJldHVybkNvdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JlZkNvdW50ID0gcmVmQ291bnQgKyAxO1xuICAgICAgICAgICAgcmV0dXJuQ291bnQgPSBuZXdSZWZDb3VudDtcbiAgICAgICAgICAgIHRoaXMudG9waWNSZWZNYXAuc2V0KGtleSwgbmV3UmVmQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5Db3VudDtcbiAgICB9XG4gICAgLy8gcmV0dXJucyB0aGUgcmVmIGNvdW50IGFmdGVyIGRlY3JlbWVudGluZywgb3IgLTEgaWYgdGhlIGtleSBhbHJlYWR5IGhhZCBubyByZWZlcmVuY2VzXG4gICAgZGVjUmVmQ291bnQoa2V5KSB7XG4gICAgICAgIGNvbnN0IHJlZkNvdW50ID0gdGhpcy50b3BpY1JlZk1hcC5nZXQoa2V5KTtcbiAgICAgICAgbGV0IHJldHVybkNvdW50O1xuICAgICAgICBpZiAocmVmQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JlZkNvdW50ID0gcmVmQ291bnQgLSAxO1xuICAgICAgICAgICAgdGhpcy50b3BpY1JlZk1hcC5zZXQoa2V5LCBuZXdSZWZDb3VudCk7XG4gICAgICAgICAgICByZXR1cm5Db3VudCA9IG5ld1JlZkNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuQ291bnQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuQ291bnQ7XG4gICAgfVxuICAgIC8vIEV4ZWN1dGUgZmlyc3RBY3Rpb24gaWYgaXQgaXMgdGhlIGZpcnN0IHN1Y2ggcmVmLCBlbHNlIGV4ZWN1dGUgbm9uRmlyc3RBY3Rpb24uXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UgdGhlIHJldHVybiB2YWx1ZSBpcyB0aGF0IG9mIHRoZSBhY3Rpb24gZXhlY3V0ZWRcbiAgICBhY3RPbkZpcnN0KGtleSwgZmlyc3RBY3Rpb24sIG5vbkZpcnN0QWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG51bVJlZnMgPSB0aGlzLmluY1JlZkNvdW50KGtleSk7XG4gICAgICAgIGNvbnN0IGlzRmlyc3RSZWYgPSBudW1SZWZzID09PSAxO1xuICAgICAgICByZXR1cm4gaXNGaXJzdFJlZiA/IGZpcnN0QWN0aW9uKCkgOiBub25GaXJzdEFjdGlvbigpO1xuICAgIH1cbiAgICAvLyBFeGVjdXRlIGxhc3RBY3Rpb24gaWYgaXQgaXMgdGhlIGZpcnN0IHN1Y2ggcmVmLCBlbHNlIGV4ZWN1dGUgbm9uTGFzdEFjdGlvbi5cbiAgICAvLyBJbiBlaXRoZXIgY2FzZSB0aGUgcmV0dXJuIHZhbHVlIGlzIHRoYXQgb2YgdGhlIGFjdGlvbiBleGVjdXRlZFxuICAgIGFjdE9uTGFzdChrZXksIGxhc3RBY3Rpb24sIG5vbkxhc3RBY3Rpb24pIHtcbiAgICAgICAgY29uc3QgbnVtUmVmcyA9IHRoaXMuZGVjUmVmQ291bnQoa2V5KTtcbiAgICAgICAgY29uc3QgaXNMYXN0UmVmID0gbnVtUmVmcyA9PT0gMDtcbiAgICAgICAgcmV0dXJuIGlzTGFzdFJlZiA/IGxhc3RBY3Rpb24oKSA6IG5vbkxhc3RBY3Rpb24oKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSZWZDb3V0bmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJ1bnRpbWVVdWlkTWVldHNNaW5pbXVtUnVudGltZVZlcnNpb24gPSBleHBvcnRzLnBhcnNlUnVudGltZVV1aWQgPSBleHBvcnRzLm1lZXRzTWluaW11bVJ1bnRpbWVWZXJzaW9uID0gdm9pZCAwO1xuZnVuY3Rpb24gdk51bSh4KSB7XG4gICAgcmV0dXJuIFsuLi54LnNwbGl0KCcuJykucmV2ZXJzZSgpLmVudHJpZXMoKV0ucmVkdWNlKChwLCBbaSwgdl0pID0+IHAgKyArdiAqIDEwMDAwICoqIGksIDApO1xufVxuLypcbiAgQ29tcGFyZXMgcnVudGltZSB2ZXJzaW9ucyB0byBzZWUgaWYgdGhlIGN1cnJlbnQgcnVudGltZSBtZWV0cyB5b3VyIGRlc2lyZWQgbWluaW11bS5cbiovXG5mdW5jdGlvbiBtZWV0c01pbmltdW1SdW50aW1lVmVyc2lvbihjdXJyZW50VmVyc2lvbiwgbWluVmVyc2lvbikge1xuICAgIGNvbnN0IGN1cnJlbnRWZXJzaW9uUGFyc2VkID0gdk51bShjdXJyZW50VmVyc2lvbik7XG4gICAgY29uc3QgbWluVmVyc2lvblBhcnNlZCA9IHZOdW0obWluVmVyc2lvbik7XG4gICAgcmV0dXJuIGN1cnJlbnRWZXJzaW9uUGFyc2VkID49IG1pblZlcnNpb25QYXJzZWQ7XG59XG5leHBvcnRzLm1lZXRzTWluaW11bVJ1bnRpbWVWZXJzaW9uID0gbWVldHNNaW5pbXVtUnVudGltZVZlcnNpb247XG4vLyBTdHJpcHMgdGhlIHBvcnQgaW5mbyBmcm9tIHRoZSBydW50aW1lVXVpZCwgbGVhdmluZyBqdXN0IHRoZSBydW50aW1lIHZlcnNpb24uXG5mdW5jdGlvbiBwYXJzZVJ1bnRpbWVVdWlkKHJ1bnRpbWVVdWlkKSB7XG4gICAgcmV0dXJuIHJ1bnRpbWVVdWlkLnNwbGl0KCcvJylbMF07XG59XG5leHBvcnRzLnBhcnNlUnVudGltZVV1aWQgPSBwYXJzZVJ1bnRpbWVVdWlkO1xuZnVuY3Rpb24gcnVudGltZVV1aWRNZWV0c01pbmltdW1SdW50aW1lVmVyc2lvbihydW50aW1lVXVpZCwgbWluVmVyc2lvbikge1xuICAgIGNvbnN0IHJ1bnRpbWVWZXJzaW9uID0gcGFyc2VSdW50aW1lVXVpZChydW50aW1lVXVpZCk7XG4gICAgcmV0dXJuIG1lZXRzTWluaW11bVJ1bnRpbWVWZXJzaW9uKHJ1bnRpbWVWZXJzaW9uLCBtaW5WZXJzaW9uKTtcbn1cbmV4cG9ydHMucnVudGltZVV1aWRNZWV0c01pbmltdW1SdW50aW1lVmVyc2lvbiA9IHJ1bnRpbWVVdWlkTWVldHNNaW5pbXVtUnVudGltZVZlcnNpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVJZGVudGl0eSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHZhbGlkYXRlSWRlbnRpdHkoaWRlbnRpdHkpIHtcbiAgICBsZXQgZXJyb3JNc2c7XG4gICAgaWYgKHR5cGVvZiBpZGVudGl0eSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGlkZW50aXR5LnV1aWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yTXNnID0gJ05vdCBhIHZhbGlkIGlkZW50aXR5IG9iamVjdCc7XG4gICAgfVxuICAgIHJldHVybiBlcnJvck1zZztcbn1cbmV4cG9ydHMudmFsaWRhdGVJZGVudGl0eSA9IHZhbGlkYXRlSWRlbnRpdHk7XG5leHBvcnRzLmRlZmF1bHQgPSB7IHZhbGlkYXRlSWRlbnRpdHkgfTtcbiIsImltcG9ydCB7IEFwcCB9IGZyb20gXCJAb3BlbmZpbi93b3Jrc3BhY2Uvc2hhcGVzXCI7XHJcbmltcG9ydCB7IGZpbiB9IGZyb20gJ29wZW5maW4tYWRhcHRlci9zcmMvbW9jayc7XHJcbmltcG9ydCB7IGdldFNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcclxuXHJcbmxldCBjYWNoZWRBcHBzO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVFbnRyaWVzKGFwcHM6QXBwW10pIHtcclxuICAgIGxldCBjYW5MYXVuY2hFeHRlcm5hbFByb2Nlc3NSZXNwb25zZSA9IGF3YWl0IGZpbi5TeXN0ZW0ucXVlcnlQZXJtaXNzaW9uRm9yQ3VycmVudENvbnRleHQoJ1N5c3RlbS5sYXVuY2hFeHRlcm5hbFByb2Nlc3MnKTtcclxuICAgIGxldCBjYW5MYXVuY2hFeHRlcm5hbFByb2Nlc3MgPSBjYW5MYXVuY2hFeHRlcm5hbFByb2Nlc3NSZXNwb25zZSAhPT0gdW5kZWZpbmVkICYmIGNhbkxhdW5jaEV4dGVybmFsUHJvY2Vzc1Jlc3BvbnNlLmdyYW50ZWQ7XHJcblxyXG4gICAgbGV0IGNhbkRvd25sb2FkQXBwQXNzZXRzUmVzcG9uc2UgPSBhd2FpdCBmaW4uU3lzdGVtLnF1ZXJ5UGVybWlzc2lvbkZvckN1cnJlbnRDb250ZXh0KCdTeXN0ZW0uZG93bmxvYWRBc3NldCcpO1xyXG4gICAgbGV0IGNhbkRvd25sb2FkQXBwQXNzZXRzID0gY2FuRG93bmxvYWRBcHBBc3NldHNSZXNwb25zZSAhPT0gdW5kZWZpbmVkICYmIGNhbkRvd25sb2FkQXBwQXNzZXRzUmVzcG9uc2UuZ3JhbnRlZDtcclxuXHJcbiAgICBpZihjYW5MYXVuY2hFeHRlcm5hbFByb2Nlc3MgJiYgY2FuRG93bmxvYWRBcHBBc3NldHMpIHtcclxuICAgICAgICByZXR1cm4gYXBwcztcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdmFsaWRhdGVkQXBwcyA9IFtdO1xyXG4gICAgbGV0IHJlamVjdGVkQXBwSWRzID0gW107XHJcbiAgICBsZXQgc2V0dGluZ3MgPSBhd2FpdCBnZXRTZXR0aW5ncygpO1xyXG4gICAgbGV0IGFwcEFzc2V0VGFnID0gc2V0dGluZ3M/LmFwcFByb3ZpZGVyPy5hcHBBc3NldFRhZyA/PyBcImFwcGFzc2V0XCI7XHJcbiAgICAgICAgXHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgYXBwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmKGFwcHNbaV0ubWFuaWZlc3RUeXBlICE9PSBcImV4dGVybmFsXCIpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVkQXBwcy5wdXNoKGFwcHNbaV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmKGNhbkxhdW5jaEV4dGVybmFsUHJvY2VzcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdGVkQXBwSWRzLnB1c2goYXBwc1tpXS5hcHBJZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihBcnJheS5pc0FycmF5KGFwcHNbaV0udGFncykgJiYgYXBwc1tpXS50YWdzLmluZGV4T2YoYXBwQXNzZXRUYWcpID4gLTEgJiYgY2FuRG93bmxvYWRBcHBBc3NldHMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3RlZEFwcElkcy5wdXNoKGFwcHNbaV0uYXBwSWQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVkQXBwcy5wdXNoKGFwcHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKHJlamVjdGVkQXBwSWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJBcHBzLnRzOiB2YWxpZGF0ZUVudHJpZXM6IE5vdCBwYXNzaW5nIHRoZSBmb2xsb3dpbmcgbGlzdCBvZiBhcHBsaWNhdGlvbnMgYXMgdGhleSB3aWxsIG5vdCBiZSBhYmxlIHRvIHJ1biBvbiB0aGlzIG1hY2hpbmUgZHVlIHRvIG1pc3NpbmcgcGVybWlzc2lvbnMuIEFsdGVybmF0aXZlbHkgdGhpcyBsb2dpYyBjb3VsZCBiZSBtb3ZlZCB0byB0aGUgbGF1bmNoIGZ1bmN0aW9uIHdoZXJlIGEgc2VsZWN0aW9uIGlzIG5vdCBsYXVuY2hlZCBidXQgdGhlIHVzZXIgaXMgcHJlc2VudGVkIHdpdGggYSBtb2RhbCBzYXlpbmcgdGhleSBjYW4ndCBsYXVuY2ggaXQgZHVlIHRvIHBlcm1pc3Npb25zLlwiLCByZWplY3RlZEFwcElkcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbGlkYXRlZEFwcHM7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3RFbnRyaWVzKHVybDpzdHJpbmcsIGNyZWRlbnRpYWxzPzpcIm9taXRcIiB8IFwic2FtZS1vcmlnaW5cIiB8IFwiaW5jbHVkZVwiLCBjYWNoZUR1cmF0aW9uPzogbnVtYmVyKSA6IFByb21pc2U8QXBwW10+e1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQgPyB7IGNyZWRlbnRpYWxzIH0gOiB1bmRlZmluZWQ7XHJcbiAgICBpZih1cmwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zKTtcclxuXHJcbiAgICBsZXQgYXBwczogQXBwW10gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgY2FjaGVkQXBwcyA9IGF3YWl0IHZhbGlkYXRlRW50cmllcyhhcHBzKTtcclxuXHJcbiAgICBpZihjYWNoZUR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsZXQgc2V0VGltZW91dEluTXMgPSBjYWNoZUR1cmF0aW9uICogNjAgKiAxMDAwO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2xlYXJpbmcgY2FjaGUgb2YgYXBwcyBhcyBjYWNoZSBkdXJhdGlvbiBoYXMgcGFzc2VkLlwiKTtcclxuICAgICAgICAgICAgY2FjaGVkQXBwcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9LCBzZXRUaW1lb3V0SW5Ncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FjaGVkQXBwcztcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFwcHMoKTogUHJvbWlzZTxBcHBbXT4ge1xyXG4gICAgY29uc29sZS5sb2coXCJSZXF1ZXN0aW5nIGFwcHMuXCIpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBsZXQgc2V0dGluZ3MgPSBhd2FpdCBnZXRTZXR0aW5ncygpO1xyXG4gICAgICAgIGxldCBhcHBzID0gY2FjaGVkQXBwcyA/PyBhd2FpdCBnZXRSZXN0RW50cmllcyhzZXR0aW5ncz8uYXBwUHJvdmlkZXI/LmFwcHNTb3VyY2VVcmwsIHNldHRpbmdzPy5hcHBQcm92aWRlcj8uaW5jbHVkZUNyZWRlbnRpYWxPblNvdXJjZVJlcXVlc3QsIHNldHRpbmdzPy5hcHBQcm92aWRlcj8uY2FjaGVEdXJhdGlvbkluTWludXRlcyk7XHJcbiAgICAgICAgcmV0dXJuIGFwcHM7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBhcHBzLiBSZXR1cm5pbmcgZW1wdHkgbGlzdC5cIiwgZXJyKTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBcHBzQnlUYWcodGFnczpzdHJpbmdbXSkgOiBQcm9taXNlPEFwcFtdPiB7XHJcbiAgICBsZXQgYXBwcyA9IGF3YWl0IGdldEFwcHMoKTtcclxuICAgIGxldCBmaWx0ZXJlZEFwcHMgPSBhcHBzLmZpbHRlcigodmFsdWUpPT4ge1xyXG4gICAgICAgIGlmKHZhbHVlLnRhZ3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmKHZhbHVlLnRhZ3MuaW5kZXhPZih0YWdzW2ldKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBmaWx0ZXJlZEFwcHM7XHJcbn0iLCJpbXBvcnQgeyBpbml0IGFzIGluaXRTZWFyY2ggfSBmcm9tICcuL3NlYXJjaCc7XHJcbmltcG9ydCB7IGluaXQgYXMgaW5pdFN0b3JlLCBzaG93IGFzIHNob3dTdG9yZSB9IGZyb20gJy4vc3RvcmUnO1xyXG5pbXBvcnQgeyBzdGFydCBhcyBzdGFydFdvcmtzcGFjZSB9IGZyb20gJy4vd29ya3NwYWNlJztcclxuaW1wb3J0IHsgZ2V0U2V0dGluZ3MgfSBmcm9tICcuL3NldHRpbmdzJztcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgLy8geW91IGNhbiBraWNrIG9mZiB5b3VyIGJvb3RzdHJhcHBpbmcgcHJvY2VzcyBoZXJlIHdoZXJlIHlvdSBtYXkgZGVjaWRlIHRvIHByb21wdCBmb3IgYXV0aGVudGljYXRpb24sIFxyXG4gICAgLy8gZ2F0aGVyIHJlZmVyZW5jZSBkYXRhIGV0YyBiZWZvcmUgc3RhcnRpbmcgd29ya3NwYWNlIGFuZCBpbnRlcmFjdGluZyB3aXRoIGl0LlxyXG4gICAgY29uc29sZS5sb2coXCJJbml0aWFsaXNpbmcgdGhlIGJvb3RzdHJhcHBlclwiKTtcclxuICAgIGxldCBzZXR0aW5ncyA9IGF3YWl0IGdldFNldHRpbmdzKCk7XHJcbiAgICBsZXQgd29ya3NwYWNlTG9hZGVkID0gZmFsc2U7XHJcbiAgICBsZXQgc2V0dXBTZWFyY2ggPSBzZXR0aW5ncz8uYm9vdHN0cmFwPy5zZWFyY2ggPz8gdHJ1ZTtcclxuICAgIGxldCBzZXR1cFN0b3JlID0gc2V0dGluZ3M/LmJvb3RzdHJhcD8uc3RvcmUgPz8gdHJ1ZTtcclxuXHJcbiAgICBpZihzZXR1cFNlYXJjaCkge1xyXG4gICAgICAgIGF3YWl0IHN0YXJ0V29ya3NwYWNlKCk7XHJcbiAgICAgICAgd29ya3NwYWNlTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAvLyBvbmx5IHJlZ2lzdGVyIHNlYXJjaCBsb2dpYyBvbmNlIHdvcmtzcGFjZSBpcyBydW5uaW5nXHJcbiAgICAgICAgYXdhaXQgaW5pdFNlYXJjaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHNldHVwU3RvcmUpIHtcclxuICAgICAgICBhd2FpdCBpbml0U3RvcmUoKTtcclxuICAgICAgICBpZighd29ya3NwYWNlTG9hZGVkKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHNob3dTdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCB7IGxhdW5jaEFwcCB9IGZyb20gXCJAb3BlbmZpbi93b3Jrc3BhY2VcIjtcclxuaW1wb3J0IHsgQXBwIH0gZnJvbSBcIkBvcGVuZmluL3dvcmtzcGFjZS9zaGFwZXNcIjtcclxuaW1wb3J0IHsgZmluIH0gZnJvbSAnb3BlbmZpbi1hZGFwdGVyL3NyYy9tb2NrJztcclxuaW1wb3J0IHsgZ2V0U2V0dGluZ3MgfSBmcm9tIFwiLi9zZXR0aW5nc1wiO1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxhdW5jaChhcHBFbnRyeTogQXBwKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkFwcGxpY2F0aW9uIGxhdW5jaCByZXF1ZXN0ZWQ6IFwiLCBhcHBFbnRyeSk7XHJcbiAgICBpZihhcHBFbnRyeS5tYW5pZmVzdFR5cGUgPT09IFwiZXh0ZXJuYWxcIikge1xyXG4gICAgICAgIGxldCBzZXR0aW5ncyA9IGF3YWl0IGdldFNldHRpbmdzKCk7XHJcbiAgICAgICAgbGV0IGFwcEFzc2V0VGFnID0gc2V0dGluZ3M/LmFwcFByb3ZpZGVyPy5hcHBBc3NldFRhZyA/PyBcImFwcGFzc2V0XCI7XHJcblxyXG4gICAgICAgIGlmKGFwcEVudHJ5LnRhZ3MgIT09IHVuZGVmaW5lZCAmJiBhcHBFbnRyeS50YWdzLmluZGV4T2YoYXBwQXNzZXRUYWcpID4gLTEpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBcHBsaWNhdGlvbiByZXF1ZXN0ZWQgaXMgYSBuYXRpdmUgYXBwIHdpdGggYSB0YWcgb2YgYXBwYXNzZXQgc28gaXQgaXMgcHJvdmlkZWQgYnkgdGhpcyB3b3Jrc3BhY2UgcGxhdGZvcm0uIE1hbmFnaW5nIHJlcXVlc3QgdmlhIHBsYXRmb3JtIGFuZCBub3QgV29ya3NwYWNlLlwiKTtcclxuICAgICAgICAgICAgbGV0IG9wdGlvbnM6IE9wZW5GaW4uRXh0ZXJuYWxQcm9jZXNzUmVxdWVzdFR5cGUgPSB7fTtcclxuICAgICAgICAgICAgb3B0aW9ucy5hbGlhcyA9IGFwcEVudHJ5Lm1hbmlmZXN0O1xyXG4gICAgICAgICAgICBvcHRpb25zLnV1aWQgPSBhcHBFbnRyeS5hcHBJZDtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGZpbi5TeXN0ZW0ubGF1bmNoRXh0ZXJuYWxQcm9jZXNzKG9wdGlvbnMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXBwbGljYXRpb24gcmVxdWVzdGVkIGlzIGEgbmF0aXZlIGFwcC4gTWFuYWdpbmcgcmVxdWVzdCB2aWEgcGxhdGZvcm0gYW5kIG5vdCBXb3Jrc3BhY2UuXCIpO1xyXG4gICAgICAgICAgICBsZXQgb3B0aW9uczogT3BlbkZpbi5FeHRlcm5hbFByb2Nlc3NSZXF1ZXN0VHlwZSA9IHt9O1xyXG4gICAgICAgICAgICBvcHRpb25zLnBhdGggPSBhcHBFbnRyeS5tYW5pZmVzdDtcclxuICAgICAgICAgICAgb3B0aW9ucy51dWlkID0gYXBwRW50cnkuYXBwSWQ7XHJcbiAgICBcclxuICAgICAgICAgICAgYXdhaXQgZmluLlN5c3RlbS5sYXVuY2hFeHRlcm5hbFByb2Nlc3Mob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBhd2FpdCBsYXVuY2hBcHAoYXBwRW50cnkpO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coXCJGaW5pc2hlZCBhcHBsaWNhdGlvbiBsYXVuY2ggcmVxdWVzdFwiKTtcclxufSIsImltcG9ydCB7IGZpbiB9IGZyb20gJ29wZW5maW4tYWRhcHRlci9zcmMvbW9jayc7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhbGlzaW5nIHBsYXRmb3JtXCIpO1xyXG4gICAgYXdhaXQgZmluLlBsYXRmb3JtLmluaXQoe1xyXG4gICAgfSk7XHJcbn0gIiwiaW1wb3J0IHsgRGlzcGF0Y2hlZFNlYXJjaFJlc3VsdCwgUmVzdWx0RGlzcGF0Y2hMaXN0ZW5lciwgU2VhcmNoTGlzdGVuZXIsIFNlYXJjaExpc3RlbmVyUmVxdWVzdCwgU2VhcmNoTGlzdGVuZXJSZXNwb25zZSwgU2VhcmNoUHJvdmlkZXIsIFNlYXJjaFJlc3VsdCwgU2VhcmNoUmVzdWx0UGxhaW4sIFNlYXJjaFJlc3VsdFNpbXBsZVRleHQsIFNlYXJjaFRvcGljQ2xpZW50LCBzdWJzY3JpYmUsIFRlbXBsYXRlTmFtZXMgfSBmcm9tIFwiQG9wZW5maW4vc2VhcmNoLWFwaVwiO1xyXG5pbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCI7XHJcbmltcG9ydCB7IGxhdW5jaCB9IGZyb20gXCIuL2xhdW5jaFwiO1xyXG5pbXBvcnQgeyBVVUlEIGFzIFdvcmtzcGFjZVVVSUQgfSBmcm9tIFwiLi93b3Jrc3BhY2VcIjtcclxuaW1wb3J0IHsgZ2V0QXBwcyB9IGZyb20gXCIuL2FwcHNcIjtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3VsdHMoKSA6IFByb21pc2U8U2VhcmNoUmVzdWx0W10+IHtcclxuICAgIGxldCBzZXR0aW5ncyA9IGF3YWl0IGdldFNldHRpbmdzKCk7XHJcbiAgICBsZXQgYXBwcyA9IGF3YWl0IGdldEFwcHMoKTtcclxuXHJcbiAgICBpZihBcnJheS5pc0FycmF5KGFwcHMpKXtcclxuICAgICAgICBsZXQgcmVzdWx0czogU2VhcmNoUmVzdWx0W10gPSBbXTtcclxuICAgICAgICBsZXQgZGVmYXVsdEFjdGlvbiA9IHNldHRpbmdzLnNlYXJjaFByb3ZpZGVyLmRlZmF1bHRBY3Rpb247XHJcblxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhcHBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmKGFwcHNbaV0uZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVudHJ5OiBTZWFyY2hSZXN1bHRTaW1wbGVUZXh0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleTogYXBwc1tpXS5hcHBJZCxcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogYXBwc1tpXS50aXRsZSxcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBbeyBuYW1lOiBkZWZhdWx0QWN0aW9uIH1dLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGFwcHNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGFwcHNbaV0uZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgc2hvcnREZXNjcmlwdGlvbjogYXBwc1tpXS5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogVGVtcGxhdGVOYW1lcy5TaW1wbGVUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlQ29udGVudDogYXBwc1tpXS5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVudHJ5OiBTZWFyY2hSZXN1bHRQbGFpbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IGFwcHNbaV0uYXBwSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGFwcHNbaV0udGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogW3sgbmFtZTogZGVmYXVsdEFjdGlvbiB9XSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBhcHBzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBUZW1wbGF0ZU5hbWVzLlBsYWluXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhbGlzaW5nIHNlYXJjaC5cIik7XHJcbiAgICBsZXQgc2V0dGluZ3MgPSBhd2FpdCBnZXRTZXR0aW5ncygpO1xyXG4gICAgaWYoc2V0dGluZ3Muc2VhcmNoUHJvdmlkZXIgPT09IHVuZGVmaW5lZCB8fCBzZXR0aW5ncy5zZWFyY2hQcm92aWRlci5uYW1lID09PSB1bmRlZmluZWQgfHwgc2V0dGluZ3Muc2VhcmNoUHJvdmlkZXIudGl0bGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcInNlYXJjaFByb3ZpZGVyOiBub3QgY29uZmlndXJlZCBpbiB0aGUgY3VzdG9tU2V0dGluZ3Mgb2YgeW91ciBtYW5pZmVzdCBjb3JyZWN0bHkuIEVuc3VyZSB5b3UgaGF2ZSB0aGUgc2VhcmNoUHJvdmlkZXIgb2JqZWN0IGRlZmluZWQgaW4gY3VzdG9tU2V0dGluZ3Mgd2l0aCB0aGUgZm9sbG93aW5nIGRlZmluZWQ6IG5hbWUsIHRpdGxlXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHRvcGljcyA9IHNldHRpbmdzPy5zZWFyY2hQcm92aWRlcj8udG9waWNzIHx8IFtcImFsbFwiLCBcImFwcHNcIl07XHJcbiAgICBsZXQgc2VhcmNoVG9waWNDbGllbnRzOiBTZWFyY2hUb3BpY0NsaWVudFtdID0gW107XHJcblxyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHRvcGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBzZWFyY2hUb3BpY0NsaWVudCA9IGF3YWl0IHN1YnNjcmliZSh7IHRvcGljOiB0b3BpY3NbaV0sIHV1aWQ6IFdvcmtzcGFjZVVVSUQgfSk7XHJcbiAgICAgICAgc2VhcmNoVG9waWNDbGllbnRzLnB1c2goc2VhcmNoVG9waWNDbGllbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHF1ZXJ5TWluTGVuZ3RoID0gc2V0dGluZ3M/LnNlYXJjaFByb3ZpZGVyPy5xdWVyeU1pbkxlbmd0aCB8fCAzO1xyXG4gICAgY29uc3QgcXVlcnlBZ2FpbnN0ID0gc2V0dGluZ3M/LnNlYXJjaFByb3ZpZGVyPy5xdWVyeUFnYWluc3QgfHwgW1widGl0bGVcIl07XHJcblxyXG4gICAgY29uc3Qgb25TZWFyY2g6IFNlYXJjaExpc3RlbmVyID0gYXN5bmMgKHJlcXVlc3Q6IFNlYXJjaExpc3RlbmVyUmVxdWVzdCwgcmVzcG9uc2U6IFNlYXJjaExpc3RlbmVyUmVzcG9uc2UpID0+IHtcclxuICAgICAgICAvLyBUaGVzZSByZXN1bHRzIGFyZSBwdWxsZWQgaW4gYnkgdGhlIHNlYXJjaCByZXF1ZXN0ZXIuXHJcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBnZXRSZXN1bHRzKCk7XHJcbiAgICAgICAgbGV0IHF1ZXJ5ID0gcmVxdWVzdC5xdWVyeS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmKHF1ZXJ5LmluZGV4T2YoXCIvXCIpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHF1ZXJ5Lmxlbmd0aCA8IHF1ZXJ5TWluTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMuZmlsdGVyKGVudHJ5ID0+IHtcclxuICAgICAgICAgICAgbGV0IG1hdGNoRm91bmQgPSBxdWVyeUFnYWluc3Quc29tZSh0YXJnZXQgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhdGggPSB0YXJnZXQuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgIGlmKHBhdGgubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldFZhbHVlID0gZW50cnlbcGF0aFswXV07XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGFyZ2V0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXRWYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0VmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFZhbHVlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihxdWVyeSkgPiAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYocGF0aC5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZW50cnlbcGF0aFswXV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldFZhbHVlOiBzdHJpbmcgfCBzdHJpbmdbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZih0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSB0YXJnZXRbcGF0aFsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZih0YXJnZXRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldFZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXRWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0VmFsdWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHF1ZXJ5KSA+IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGFyZ2V0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXRWYWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHRhcmdldFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0YXJnZXRWYWx1ZS5sZW5ndGggPiAwICYmIHR5cGVvZiB0YXJnZXRWYWx1ZVswXSA9PT0gXCJzdHJpbmdcIiAmJiB0YXJnZXRWYWx1ZS5zb21lKHRhcmdldCA9PiB0YXJnZXQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHF1ZXJ5KSA9PT0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTWFuaWZlc3QgY29uZmlndXJhdGlvbiBmb3Igc2VhcmNoIHNwZWNpZmllZCBhIHF1ZXJ5QWdhaW5zdCB0YXJnZXQgdGhhdCBpcyBhbiBhcnJheSBidXQgbm90IGFuIGFycmF5IG9mIHN0cmluZ3MuIE9ubHkgc3RyaW5nIHZhbHVlcyBhbmQgYXJyYXlzIGFyZSBzdXBwb3J0ZWQ6IFwiICsgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBtYW5pZmVzdCBjb25maWd1cmF0aW9uIGZvciBzZWFyY2ggaGFzIGEgcXVlcnlBZ2FpbnN0IGVudHJ5IHRoYXQgaGFzIGEgZGVwdGggZ3JlYXRlciB0aGFuIDEuIFlvdSBjYW4gc2VhcmNoIGZvciBlLmcuIGRhdGEudGFncyBpZiBkYXRhIGhhcyB0YWdzIGluIGl0IGFuZCBpdCBpcyBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cIik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaEZvdW5kO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBvblNlbGVjdGlvbjogUmVzdWx0RGlzcGF0Y2hMaXN0ZW5lciA9IGFzeW5jIChyZXN1bHQ6RGlzcGF0Y2hlZFNlYXJjaFJlc3VsdCkgPT4ge1xyXG4gICAgICAgIGlmIChyZXN1bHQuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGxhdW5jaChyZXN1bHQuZGF0YSk7XHJcbiAgICAgICAgfSAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBleGVjdXRlIHJlc3VsdCB3aXRob3V0IGRhdGEgYmVpbmcgcGFzc2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgc2VhcmNoUHJvdmlkZXI6U2VhcmNoUHJvdmlkZXIgPSB7XHJcbiAgICAgICAgdGl0bGU6IHNldHRpbmdzLnNlYXJjaFByb3ZpZGVyLnRpdGxlLFxyXG4gICAgICAgIG5hbWU6IHNldHRpbmdzLnNlYXJjaFByb3ZpZGVyLm5hbWUsXHJcbiAgICAgICAgb25TZWFyY2g6IG9uU2VhcmNoLFxyXG4gICAgICAgIG9uUmVzdWx0RGlzcGF0Y2g6IG9uU2VsZWN0aW9uXHJcbiAgICAgfTtcclxuICAgICAgICBcclxuICAgIC8vIFJlZ2lzdGVyIHRoZSBzZWFyY2ggZGF0YSBwcm92aWRlci5cclxuICAgIGZvcihsZXQgc3RjID0gMDsgc3RjIDwgc2VhcmNoVG9waWNDbGllbnRzLmxlbmd0aDsgc3RjKyspIHtcclxuICAgICAgICBhd2FpdCBzZWFyY2hUb3BpY0NsaWVudHNbc3RjXS5yZWdpc3RlcihzZWFyY2hQcm92aWRlcik7XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhcIlNlYXJjaCBjb25maWd1cmVkLlwiKTtcclxufVxyXG4iLCJpbXBvcnQgeyBmaW4gfSBmcm9tICdvcGVuZmluLWFkYXB0ZXIvc3JjL21vY2snO1xyXG5pbXBvcnQgeyBDdXN0b21TZXR0aW5ncyB9IGZyb20gJy4vc2hhcGVzJztcclxuXHJcbmxldCBzZXR0aW5nczpDdXN0b21TZXR0aW5ncztcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldENvbmZpZ3VyZWRTZXR0aW5ncygpOiBQcm9taXNlPEN1c3RvbVNldHRpbmdzPiB7XHJcbiAgICBjb25zdCBhcHAgPSBhd2FpdCBmaW4uQXBwbGljYXRpb24uZ2V0Q3VycmVudCgpO1xyXG4gICAgY29uc3QgbWFuaWZlc3QgPSBhd2FpdCBhcHAuZ2V0TWFuaWZlc3QoKTtcclxuICBcclxuICAgIGlmIChtYW5pZmVzdC5jdXN0b21TZXR0aW5ncyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHNldHRpbmdzID0gbWFuaWZlc3QuY3VzdG9tU2V0dGluZ3M7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNldHRpbmdzID0ge307XHJcbiAgICB9XHJcbiAgXHJcbiAgICByZXR1cm4gc2V0dGluZ3M7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTZXR0aW5ncygpOiBQcm9taXNlPEN1c3RvbVNldHRpbmdzPiB7XHJcbiAgICBpZihzZXR0aW5ncyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc2V0dGluZ3MgPSBhd2FpdCBnZXRDb25maWd1cmVkU2V0dGluZ3MoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZXR0aW5ncztcclxufSIsImltcG9ydCB7IFN0b3JlZnJvbnQgfSBmcm9tIFwiQG9wZW5maW4vd29ya3NwYWNlXCI7XHJcbmltcG9ydCB7XHJcbiAgU3RvcmVmcm9udExhbmRpbmdQYWdlLFxyXG4gIFN0b3JlZnJvbnROYXZpZ2F0aW9uU2VjdGlvbixcclxuICBTdG9yZWZyb250Rm9vdGVyLFxyXG4gIEFwcCxcclxuICBTdG9yZWZyb250UHJvdmlkZXIsXHJcbiAgU3RvcmVmcm9udFRlbXBsYXRlLFxyXG4gIFN0b3JlZnJvbnROYXZpZ2F0aW9uSXRlbSxcclxuICBTdG9yZWZyb250RGV0YWlsZWROYXZpZ2F0aW9uSXRlbSxcclxufSBmcm9tIFwiQG9wZW5maW4vd29ya3NwYWNlL3NoYXBlc1wiO1xyXG5pbXBvcnQgeyBnZXRBcHBzLCBnZXRBcHBzQnlUYWcgfSBmcm9tIFwiLi9hcHBzXCI7XHJcbmltcG9ydCB7IGxhdW5jaCB9IGZyb20gXCIuL2xhdW5jaFwiO1xyXG5pbXBvcnQgeyBnZXRTZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCI7XHJcbmltcG9ydCB7XHJcbiAgQ3VzdG9tU2V0dGluZ3MsXHJcbiAgU3RvcmVmcm9udFNldHRpbmdzTGFuZGluZ1BhZ2VSb3csXHJcbiAgU3RvcmVmcm9udFNldHRpbmdzTmF2aWdhdGlvbkl0ZW0sXHJcbn0gZnJvbSBcIi4vc2hhcGVzXCI7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdCgpIHtcclxuICBjb25zb2xlLmxvZyhcIkluaXRpYWxpc2luZyB0aGUgc3RvcmVmcm9udCBwcm92aWRlci5cIik7XHJcbiAgbGV0IHByb3ZpZGVyID0gYXdhaXQgZ2V0U3RvcmVQcm92aWRlcigpO1xyXG4gIGlmIChwcm92aWRlciAhPT0gbnVsbCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgU3RvcmVmcm9udC5yZWdpc3Rlcihwcm92aWRlcik7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU3RvcmVmcm9udCBwcm92aWRlciBpbml0aWFsaXNlZC5cIik7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICBcIkFuIGVycm9yIHdhcyBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gcmVnaXN0ZXIgdGhlIGNvbnRlbnQgc3RvcmUgcHJvdmlkZXJcIixcclxuICAgICAgICBlcnJcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaG93KCkge1xyXG4gIGNvbnNvbGUubG9nKFwiU2hvd2luZyB0aGUgc3RvcmUuXCIpO1xyXG4gIHJldHVybiBTdG9yZWZyb250LnNob3coKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhpZGUoKSB7XHJcbiAgY29uc29sZS5sb2coXCJIaWRpbmcgdGhlIHN0b3JlLlwiKTtcclxuICByZXR1cm4gU3RvcmVmcm9udC5zaG93KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgd2hlbiBhIG5hdmlnYXRpb24gaXRlbSBvciBzZWN0aW9uIGhhc24ndCBiZWVuIGNvbmZpZ3VyZWQgd2l0aCBhbiBJRC4gVGhpcyBpcyB0byBzaW1wbGlmeSBjb25maWd1cmF0aW9uIGZvciB0aGlzIGRlbW8uXHJcbiAqIEluIGEgcmVhbCBhcHBsaWNhdGlvbiB5b3Ugd291bGQgbmVlZCBhbiBpZGVtcG90ZW50IGFuZCB1bmlxdWUgSUQgKHRoaW5rIEdVSUQpIHRoYXQgZG9lc24ndCBjaGFuZ2UgZm9yIHRoYXQgbmF2aWdhdGlvbiBpdGVtL3NlY3Rpb24gcmVnYXJkbGVzcyBvZiBob3dcclxuICogbWFueSB0aW1lcyBpdCBpcyByZWdlbmVyYXRlZCAoZS5nLiBtb3JlIGl0ZW1zIGNhbiBiZSBhZGRlZCB0byB0aGUgaXRlbS9zZWN0aW9uIGJ1dCB0aGUgSUQgc3RheXMgdGhlIHNhbWUpLlxyXG4gKiBBcyB5b3UgbmF2aWdhdGUgYXJvdW5kIHRoZSBzdG9yZSB0aGlzIElEIGlzIHVzZWQgYXMgYSByb3V0ZS4gU28gaWYgYSB1c2VyIGNsaWNrcyBvbiBhIGxpbmssIG5hdmlnYXRlcyB0byBhIG5ldyBwYWdlIGFuZCB0aGUgcmUtcmVxdWVzdGVkIG5hdmlnYXRpb24gaXRlbSBoYXNcclxuICogYSBkaWZmZXJlbnQgSUQgdGhlbiB0aGUgc3RvcmUgd2lsbCBub3QgYmUgYWJsZSB0byBmaW5kIGEgbWF0Y2ggYW5kIGl0IHdvbid0IGJlIGFibGUgdG8gcmVuZGVyIHRoZSBuYXZpZ2F0aW9uIGl0ZW0uXHJcbiAqIEEgcmVhbCBhcHBsaWNhdGlvbiB3b3VsZCBub3QgdXNlIHRoaXMgYXBwcm9hY2ggKGFzIGFuIHVwZGF0ZSB0byB0aGUgdGFnIGxpc3Qgd291bGQgcmVzdWx0IGluIGEgbmV3IElEIHdoaWNoIHdvdWxkIGZhaWwgaWYgdGhlIGNvbmZpZyB3YXMgZmV0Y2hlZCBmcm9tIGEgc2VydmVyIGFuZCBub3QgYSBtYW5pZmVzdClcclxuICovXHJcbmZ1bmN0aW9uIGdldElkKHRpdGxlOiBzdHJpbmcsIHRhZ3M6IHN0cmluZ1tdID0gW10pIHtcclxuICBjb25zdCBzZWFyY2ggPSBcIiBcIjtcclxuICBjb25zdCByZXBsYWNlV2l0aCA9IFwiLVwiO1xyXG4gIGxldCByZXN1bHQgPSB0aXRsZS5yZXBsYWNlQWxsKHNlYXJjaCwgcmVwbGFjZVdpdGgpO1xyXG4gIHJlc3VsdCArPSBcIi1cIiArIHRhZ3Muam9pbihcIi1cIik7XHJcbiAgcmV0dXJuIHJlc3VsdC50b0xvd2VyQ2FzZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1N0b3JlZnJvbnRDb25maWd1cmF0aW9uVmFsaWQoY29uZmlnOiBDdXN0b21TZXR0aW5ncyk6IGJvb2xlYW4ge1xyXG4gIGxldCBpZExpc3QgPSBbXTtcclxuICBsZXQgaGFzRHVwbGljYXRlSWRzID0gZmFsc2U7XHJcblxyXG4gIGlmIChcclxuICAgIGNvbmZpZyA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICBjb25maWcuc3RvcmVmcm9udFByb3ZpZGVyID09PSB1bmRlZmluZWQgfHxcclxuICAgIGNvbmZpZy5zdG9yZWZyb250UHJvdmlkZXIuaWQgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgY29uZmlnLnN0b3JlZnJvbnRQcm92aWRlci50aXRsZSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAoY29uZmlnLnN0b3JlZnJvbnRQcm92aWRlci5mb290ZXIgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICBjb25maWcuc3RvcmVmcm9udFByb3ZpZGVyLmxhbmRpbmdQYWdlICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgY29uZmlnLnN0b3JlZnJvbnRQcm92aWRlci5sYW5kaW5nUGFnZS50b3BSb3cgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICBjb25maWcuc3RvcmVmcm9udFByb3ZpZGVyLmxhbmRpbmdQYWdlLm1pZGRsZVJvdyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgIGNvbmZpZy5zdG9yZWZyb250UHJvdmlkZXIubGFuZGluZ1BhZ2UuYm90dG9tUm93ICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgY29uZmlnLnN0b3JlZnJvbnRQcm92aWRlci5uYXZpZ2F0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICBcIlN0b3JlZnJvbnRQcm92aWRlciBpcyBub3QgY29ycmVjdGx5IGNvbmZpZ3VyZWQgaW4gdGhlIGN1c3RvbVNldHRpbmdzIG9mIHRoaXMgbWFuaWZlc3QuIFlvdSBtdXN0IGVuc3VyZSB0aGF0IHN0b3JlZnJvbnRQcm92aWRlciBpcyBkZWZpbmVkLCB0aGF0IGl0IGhhcyBhbiBpZCBhbmQgdGl0bGUgYW5kIHRoYXQgdGhlIGZvb3RlciwgbGFuZGluZ1BhZ2UgKHRvcCByb3csIG1pZGRsZSByb3cgYW5kIGJvdHRvbSByb3cpIGFuZCBuYXZpZ2F0aW9uIHNlY3Rpb25zIGhhdmUgYmVlbiBkZWZpbmVkLlwiXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgbGV0IHZhbGlkYXRlSWQgPSAoaWQ6IHN0cmluZywgbmFtZXNwYWNlOiBzdHJpbmcsIHdhcm5pbmc6IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc29sZS53YXJuKG5hbWVzcGFjZSArIFwiOiBcIiArIHdhcm5pbmcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGlkTGlzdC5pbmRleE9mKGlkKSA+IC0xKSB7XHJcbiAgICAgICAgaGFzRHVwbGljYXRlSWRzID0gdHJ1ZTtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgbmFtZXNwYWNlICtcclxuICAgICAgICAgICAgXCI6IFRoZSBpZCBpcyB1c2VkIGluIG1vcmUgdGhhbiBvbmUgcGxhY2UuIFBsZWFzZSBoYXZlIGEgdW5pcXVlIGFuZCBpZGVtcG90ZW50IGlkOiBcIiArXHJcbiAgICAgICAgICAgIGlkXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZExpc3QucHVzaChpZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBsZXQgd2FybmluZ01lc3NhZ2UgPVxyXG4gICAgXCJUaGUgaWQgaXMgbm90IGRlZmluZWQuIFRoaXMgZGVtbyB3aWxsIGdlbmVyYXRlIGFuIGlkIGJhc2VkIG9uIHRpdGxlIGJ1dCB5b3Ugc2hvdWxkIGhhdmUgYSB1bmlxdWUgYW5kIGlkZW1wb3RlbnQgaWQgd2hlbiBidWlsZGluZyB5b3VyIG93biBzdG9yZS5cIjtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlZhbGlkYXRpbmcgc2V0dGluZ3Mgc3RvcmVmcm9udFByb3ZpZGVyIG5hdmlnYXRpb24gY29uZmlnXCIpO1xyXG4gIGxldCBuYXZpZ2F0aW9uID0gY29uZmlnLnN0b3JlZnJvbnRQcm92aWRlci5uYXZpZ2F0aW9uO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmF2aWdhdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFsaWRhdGVJZChcclxuICAgICAgbmF2aWdhdGlvbltpXS5pZCxcclxuICAgICAgXCJzdG9yZWZyb250UHJvdmlkZXIubmF2aWdhdGlvbltcIiArIGkgKyBcIl0uaWRcIixcclxuICAgICAgd2FybmluZ01lc3NhZ2VcclxuICAgICk7XHJcbiAgICBsZXQgaXRlbXMgPSBuYXZpZ2F0aW9uW2ldLml0ZW1zO1xyXG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBpdGVtcy5sZW5ndGg7IG4rKykge1xyXG4gICAgICB2YWxpZGF0ZUlkKFxyXG4gICAgICAgIGl0ZW1zW25dLmlkLFxyXG4gICAgICAgIFwic3RvcmVmcm9udFByb3ZpZGVyLm5hdmlnYXRpb25bXCIgKyBpICsgXCJdLml0ZW1zW1wiICsgbiArIFwiXS5pZFwiLFxyXG4gICAgICAgIHdhcm5pbmdNZXNzYWdlXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhcIlZhbGlkYXRpbmcgc2V0dGluZ3Mgc3RvcmVmcm9udFByb3ZpZGVyIGxhbmRpbmcgcGFnZSBoZXJvIGNvbmZpZ1wiKTtcclxuICBsZXQgbGFuZGluZ1BhZ2UgPSBjb25maWcuc3RvcmVmcm9udFByb3ZpZGVyLmxhbmRpbmdQYWdlO1xyXG5cclxuICBpZiAobGFuZGluZ1BhZ2U/Lmhlcm8/LmN0YSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICB2YWxpZGF0ZUlkKFxyXG4gICAgICBsYW5kaW5nUGFnZS5oZXJvLmN0YS5pZCxcclxuICAgICAgXCJzdG9yZWZyb250UHJvdmlkZXIubGFuZGluZ1BhZ2UuaGVyby5jdGEuaWRcIixcclxuICAgICAgd2FybmluZ01lc3NhZ2VcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhcIlZhbGlkYXRpbmcgc2V0dGluZ3Mgc3RvcmVmcm9udFByb3ZpZGVyIGxhbmRpbmcgcGFnZSB0b3Agcm93IGNvbmZpZ1wiKTtcclxuICBsZXQgdG9wUm93ID0gbGFuZGluZ1BhZ2UudG9wUm93O1xyXG5cclxuICBpZiAodG9wUm93Lml0ZW1zICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9wUm93Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhbGlkYXRlSWQoXHJcbiAgICAgICAgdG9wUm93Lml0ZW1zW2ldLmlkLFxyXG4gICAgICAgIFwic3RvcmVmcm9udFByb3ZpZGVyLmxhbmRpbmdQYWdlLnRvcFJvdy5pdGVtc1tcIiArIGkgKyBcIl0uaWRcIixcclxuICAgICAgICB3YXJuaW5nTWVzc2FnZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coXCJWYWxpZGF0aW5nIHNldHRpbmdzIHN0b3JlZnJvbnRQcm92aWRlciBsYW5kaW5nIHBhZ2UgYm90dG9tIHJvdyBjb25maWdcIik7XHJcbiAgbGV0IGJvdHRvbVJvdyA9IGxhbmRpbmdQYWdlLmJvdHRvbVJvdztcclxuICBpZiAoYm90dG9tUm93Lml0ZW1zICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm90dG9tUm93Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhbGlkYXRlSWQoXHJcbiAgICAgICAgYm90dG9tUm93Lml0ZW1zW2ldLmlkLFxyXG4gICAgICAgIFwic3RvcmVmcm9udFByb3ZpZGVyLmxhbmRpbmdQYWdlLmJvdHRvbVJvdy5pdGVtc1tcIiArIGkgKyBcIl0uaWRcIixcclxuICAgICAgICB3YXJuaW5nTWVzc2FnZVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coXCJWYWxpZGF0aW5nIGlkcywgY2hlY2tpbmcgZm9yIGR1cGxpY2F0ZSBpZHMuXCIpO1xyXG4gIGlmIChoYXNEdXBsaWNhdGVJZHMpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgIFwiWW91IGhhdmUgZGVmaW5lZCBkdXBsaWNhdGUgaWRzIChwbGVhc2Ugc2VlIHRoZSBvdGhlciBlcnJvciBtZXNzYWdlcykgd2hpY2ggY291bGQgcmVzdWx0IGluIHN0cmFuZ2UgYmVoYXZpb3VyIChpZiB3ZSBhcmUgcm91dGluZyBieSBpZCBhbmQgeW91IGhhdmUgdHdvIG9yIG1vcmUgaXRlbXMgdGhhdCByZXNvbHZlIHRvIHRoZSBzYW1lIGlkIHRoZW4gaXQgY291bGQgbmF2aWdhdGUgdG8gc29tZXRoaW5nIHVuZXhwZWN0ZWQuIFBsZWFzZSBlbnN1cmUgaWRzIGFyZSB1bmlxdWUgYW5kIGlkZW1wb3RlbnQuXCJcclxuICAgICk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmVQcm92aWRlcigpOiBQcm9taXNlPFN0b3JlZnJvbnRQcm92aWRlcj4ge1xyXG4gIGNvbnNvbGUubG9nKFwiR2V0dGluZyB0aGUgc3RvcmUgcHJvdmlkZXIuXCIpO1xyXG4gIGxldCBzZXR0aW5ncyA9IGF3YWl0IGdldFNldHRpbmdzKCk7XHJcbiAgaWYgKGlzU3RvcmVmcm9udENvbmZpZ3VyYXRpb25WYWxpZChzZXR0aW5ncykpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiBzZXR0aW5ncy5zdG9yZWZyb250UHJvdmlkZXIuaWQsXHJcbiAgICAgIHRpdGxlOiBzZXR0aW5ncy5zdG9yZWZyb250UHJvdmlkZXIudGl0bGUsXHJcbiAgICAgIGdldE5hdmlnYXRpb246IGdldE5hdmlnYXRpb24uYmluZCh0aGlzKSxcclxuICAgICAgZ2V0TGFuZGluZ1BhZ2U6IGdldExhbmRpbmdQYWdlLmJpbmQodGhpcyksXHJcbiAgICAgIGdldEZvb3RlcjogZ2V0Rm9vdGVyLmJpbmQodGhpcyksXHJcbiAgICAgIGdldEFwcHMsXHJcbiAgICAgIGxhdW5jaEFwcDogbGF1bmNoLFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldE5hdmlnYXRpb24oKTogUHJvbWlzZTxcclxuICBbU3RvcmVmcm9udE5hdmlnYXRpb25TZWN0aW9uPywgU3RvcmVmcm9udE5hdmlnYXRpb25TZWN0aW9uP11cclxuPiB7XHJcbiAgY29uc29sZS5sb2coXCJTaG93aW5nIHRoZSBzdG9yZSBuYXZpZ2F0aW9uLlwiKTtcclxuICBjb25zdCBuYXZpZ2F0aW9uU2VjdGlvbkl0ZW1MaW1pdCA9IDU7XHJcbiAgY29uc3QgbmF2aWdhdGlvblNlY3Rpb25MaW1pdCA9IDI7XHJcbiAgbGV0IHNldHRpbmdzID0gYXdhaXQgZ2V0U2V0dGluZ3MoKTtcclxuICBsZXQgbmF2aWdhdGlvblNlY3Rpb25zOiBbXHJcbiAgICBTdG9yZWZyb250TmF2aWdhdGlvblNlY3Rpb24/LFxyXG4gICAgU3RvcmVmcm9udE5hdmlnYXRpb25TZWN0aW9uP1xyXG4gIF0gPSBbXTtcclxuXHJcbiAgaWYgKHNldHRpbmdzPy5zdG9yZWZyb250UHJvdmlkZXI/Lm5hdmlnYXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5zdG9yZWZyb250UHJvdmlkZXIubmF2aWdhdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKG5hdmlnYXRpb25TZWN0aW9ucy5sZW5ndGggPT09IG5hdmlnYXRpb25TZWN0aW9uTGltaXQpIHtcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgXCJNb3JlIHRoYW4gMiBuYXZpZ2F0aW9uIHNlY3Rpb25zIGRlZmluZWQgaW4gU3RvcmVmcm9udFByb3ZpZGVyIHNldHRpbmdzLiBPbmx5IHR3byBhcmUgdGFrZW4uXCJcclxuICAgICAgKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBsZXQgbmF2aWdhdGlvblNlY3Rpb246IFN0b3JlZnJvbnROYXZpZ2F0aW9uU2VjdGlvbiA9IHtcclxuICAgICAgaWQ6XHJcbiAgICAgICAgc2V0dGluZ3Muc3RvcmVmcm9udFByb3ZpZGVyLm5hdmlnYXRpb25baV0uaWQgPz9cclxuICAgICAgICBnZXRJZChzZXR0aW5ncy5zdG9yZWZyb250UHJvdmlkZXIubmF2aWdhdGlvbltpXS50aXRsZSksXHJcbiAgICAgIHRpdGxlOiBzZXR0aW5ncy5zdG9yZWZyb250UHJvdmlkZXIubmF2aWdhdGlvbltpXS50aXRsZSxcclxuICAgICAgaXRlbXM6IChhd2FpdCBnZXROYXZpZ2F0aW9uSXRlbXMoXHJcbiAgICAgICAgc2V0dGluZ3Muc3RvcmVmcm9udFByb3ZpZGVyLm5hdmlnYXRpb25baV0uaXRlbXMsXHJcbiAgICAgICAgbmF2aWdhdGlvblNlY3Rpb25JdGVtTGltaXRcclxuICAgICAgKSkgYXMgW1xyXG4gICAgICAgIFN0b3JlZnJvbnROYXZpZ2F0aW9uSXRlbSxcclxuICAgICAgICBTdG9yZWZyb250TmF2aWdhdGlvbkl0ZW0/LFxyXG4gICAgICAgIFN0b3JlZnJvbnROYXZpZ2F0aW9uSXRlbT8sXHJcbiAgICAgICAgU3RvcmVmcm9udE5hdmlnYXRpb25JdGVtPyxcclxuICAgICAgICBTdG9yZWZyb250TmF2aWdhdGlvbkl0ZW0/XHJcbiAgICAgIF0sXHJcbiAgICB9O1xyXG4gICAgbmF2aWdhdGlvblNlY3Rpb25zLnB1c2gobmF2aWdhdGlvblNlY3Rpb24pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5hdmlnYXRpb25TZWN0aW9ucztcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0TGFuZGluZ1BhZ2UoKTogUHJvbWlzZTxTdG9yZWZyb250TGFuZGluZ1BhZ2U+IHtcclxuICBjb25zb2xlLmxvZyhcIkdldHRpbmcgdGhlIHN0b3JlIGxhbmRpbmcgcGFnZS5cIik7XHJcbiAgbGV0IGxhbmRpbmdQYWdlOiBTdG9yZWZyb250TGFuZGluZ1BhZ2UgPSB7XHJcbiAgICB0b3BSb3c6IG51bGwsXHJcbiAgICBtaWRkbGVSb3c6IG51bGwsXHJcbiAgICBib3R0b21Sb3c6IG51bGwsXHJcbiAgfTtcclxuXHJcbiAgbGV0IHNldHRpbmdzID0gYXdhaXQgZ2V0U2V0dGluZ3MoKTtcclxuICBjb25zdCBzdG9yZUZyb250RGV0YWlsZWROYXZpZ2F0aW9uSXRlbUJvdHRvbVJvd0xpbWl0ID0gMztcclxuICBjb25zdCBzdG9yZUZyb250RGV0YWlsZWROYXZpZ2F0aW9uSXRlbVRvcFJvd0xpbWl0ID0gNDtcclxuICBjb25zdCBtaWRkbGVSb3dBcHBMaW1pdCA9IDY7XHJcblxyXG4gIGlmIChzZXR0aW5ncz8uc3RvcmVmcm9udFByb3ZpZGVyPy5sYW5kaW5nUGFnZT8uaGVybyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBsZXQgaGVybyA9IHNldHRpbmdzLnN0b3JlZnJvbnRQcm92aWRlci5sYW5kaW5nUGFnZS5oZXJvO1xyXG4gICAgbGV0IGN0YSA9IGF3YWl0IGdldE5hdmlnYXRpb25JdGVtKFxyXG4gICAgICBoZXJvLmN0YS5pZCxcclxuICAgICAgaGVyby5jdGEudGl0bGUsXHJcbiAgICAgIGhlcm8uY3RhLnRhZ3NcclxuICAgICk7XHJcbiAgICBsYW5kaW5nUGFnZS5oZXJvID0ge1xyXG4gICAgICB0aXRsZTogaGVyby50aXRsZSxcclxuICAgICAgaW1hZ2U6IGhlcm8uaW1hZ2UsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBoZXJvLmRlc2NyaXB0aW9uLFxyXG4gICAgICBjdGEsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgaWYgKHNldHRpbmdzPy5zdG9yZWZyb250UHJvdmlkZXI/LmxhbmRpbmdQYWdlPy50b3BSb3cgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgbGFuZGluZ1BhZ2UudG9wUm93ID0gYXdhaXQgZ2V0TGFuZGluZ1BhZ2VSb3coXHJcbiAgICAgIHNldHRpbmdzPy5zdG9yZWZyb250UHJvdmlkZXI/LmxhbmRpbmdQYWdlPy50b3BSb3csXHJcbiAgICAgIHN0b3JlRnJvbnREZXRhaWxlZE5hdmlnYXRpb25JdGVtVG9wUm93TGltaXRcclxuICAgICk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgbmVlZCB0byBoYXZlIGEgdG9wUm93IGRlZmluZWQgaW4geW91ciBsYW5kaW5nIHBhZ2UuXCIpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHNldHRpbmdzPy5zdG9yZWZyb250UHJvdmlkZXI/LmxhbmRpbmdQYWdlPy5taWRkbGVSb3cgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgbGV0IG1pZGRsZVJvdyA9IHNldHRpbmdzLnN0b3JlZnJvbnRQcm92aWRlci5sYW5kaW5nUGFnZS5taWRkbGVSb3c7XHJcbiAgICBsZXQgbWlkZGxlUm93QXBwcyA9IGF3YWl0IGdldEFwcHNCeVRhZyhtaWRkbGVSb3cudGFncyk7XHJcbiAgICBpZiAobWlkZGxlUm93QXBwcy5sZW5ndGggPiBtaWRkbGVSb3dBcHBMaW1pdCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYFRvbyBtYW55IGFwcHMgKCR7XHJcbiAgICAgICAgICBtaWRkbGVSb3dBcHBzLmxlbmd0aFxyXG4gICAgICAgIH0pIGhhdmUgYmVlbiByZXR1cm5lZCBieSB0aGUgbWlkZGxlIHJvdyB0YWcgZGVmaW5pdGlvbiAke21pZGRsZVJvdy50YWdzLmpvaW4oXHJcbiAgICAgICAgICBcIiBcIlxyXG4gICAgICAgICl9LiBPbmx5ICR7bWlkZGxlUm93QXBwTGltaXR9IHdpbGwgYmUgc2hvd24uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgbGV0IHZhbGlkYXRlZE1pZGRsZVJvd0FwcHMgPSBtaWRkbGVSb3dBcHBzLnNsaWNlKDAsIG1pZGRsZVJvd0FwcExpbWl0KSBhcyBbXHJcbiAgICAgIEFwcD8sXHJcbiAgICAgIEFwcD8sXHJcbiAgICAgIEFwcD8sXHJcbiAgICAgIEFwcD8sXHJcbiAgICAgIEFwcD8sXHJcbiAgICAgIEFwcD9cclxuICAgIF07XHJcbiAgICBsYW5kaW5nUGFnZS5taWRkbGVSb3cgPSB7XHJcbiAgICAgIHRpdGxlOiBtaWRkbGVSb3cudGl0bGUsXHJcbiAgICAgIGFwcHM6IHZhbGlkYXRlZE1pZGRsZVJvd0FwcHMsXHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiWW91IG5lZWQgdG8gaGF2ZSBhIG1pZGRsZVJvdyBkZWZpbmVkIGluIHlvdXIgbGFuZGluZyBwYWdlLlwiKTtcclxuICB9XHJcblxyXG4gIGlmIChzZXR0aW5ncz8uc3RvcmVmcm9udFByb3ZpZGVyPy5sYW5kaW5nUGFnZT8uYm90dG9tUm93ICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGxhbmRpbmdQYWdlLmJvdHRvbVJvdyA9IGF3YWl0IGdldExhbmRpbmdQYWdlUm93KFxyXG4gICAgICBzZXR0aW5ncy5zdG9yZWZyb250UHJvdmlkZXIubGFuZGluZ1BhZ2UuYm90dG9tUm93LFxyXG4gICAgICBzdG9yZUZyb250RGV0YWlsZWROYXZpZ2F0aW9uSXRlbUJvdHRvbVJvd0xpbWl0XHJcbiAgICApO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiWW91IG5lZWQgdG8gaGF2ZSBhIGJvdHRvbVJvdyBkZWZpbmVkIGluIHlvdXIgbGFuZGluZyBwYWdlLlwiKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBsYW5kaW5nUGFnZTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0Rm9vdGVyKCk6IFByb21pc2U8U3RvcmVmcm9udEZvb3Rlcj4ge1xyXG4gIGNvbnNvbGUubG9nKFwiR2V0dGluZyB0aGUgc3RvcmUgZm9vdGVyLlwiKTtcclxuICBsZXQgc2V0dGluZ3MgPSBhd2FpdCBnZXRTZXR0aW5ncygpO1xyXG4gIGlmIChzZXR0aW5ncz8uc3RvcmVmcm9udFByb3ZpZGVyPy5mb290ZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIHNldHRpbmdzLnN0b3JlZnJvbnRQcm92aWRlci5mb290ZXI7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgIFwiU3RvcmVmcm9udCBpcyBiZWluZyBpbml0aWFsaXNlZCB3aXRob3V0IGEgZm9vdGVyIGNvbmZpZ3VyZWQuXCJcclxuICAgICk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIHNlY3Rpb24gZ2VuZXJhdGVzIGEgbmF2aWdhdGlvbiBpdGVtIGZvciBTdG9yZWZyb250IGJhc2VkIG9uIHNvbWUgY29uZmlndXJhdGlvbi5cclxuICogQHBhcmFtIGlkXHJcbiAqIFRoaXMgaWQgc2hvdWxkIGJlIHVuaXF1ZSBhbmQgaWRlbXBvdGVudCBhbmQgaXNuJ3QgY2hhbmdlZCByZWdhcmRsZXNzIG9mIGhvdyBvZnRlbiB0aGUgc2FtZSBuYXZpZ2F0aW9uIGl0ZW0gaXMgcmVnZW5lcmF0ZWQuXHJcbiAqIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgYmVjYXVzZSBpdCBpcyB1c2VkIGZvciByb3V0aW5nIGluIFN0b3JlZnJvbnQuIElmIGEgdXNlciBuYXZpZ2F0ZWQgZnJvbSBhIGxpbmsgYW5kIHRoZSBpZCBjaGFuZ2VzIHdoZW4gdGhlIGl0ZW1cclxuICogaXMgcmUtcmVxdWVzdGVkIGJ5IHN0b3JlZnJvbnQgdGhlbiBpdCB3aWxsIG5vdCBiZSBhYmxlIHRvIHJlbmRlciB0aGUgY29udGVudHMuXHJcbiAqIEBwYXJhbSB0aXRsZVxyXG4gKiBAcGFyYW0gdGFnc1xyXG4gKiBUYWdzIGFyZSB1c2VkIGFzIGEgd2F5IG9mIGZpbHRlcmluZyBvdXQgd2hpY2ggYXBwcyBzaG91bGQgYmUgYXNzaWduZWQgdG8gYSBTdG9yZWZyb250TmF2aWdhdGlvbkl0ZW0uXHJcbiAqIFRoaXMgYWxsb3dzIGFwcHMgdG8gYmUgdGFnZ2VkIG9uIHRoZSBzZXJ2ZXIgYW5kIHRoZSBzdG9yZSB3b3VsZCBhdXRvbWF0aWNhbGx5IHVwZGF0ZSB0aGUgYXBwcyBhc3NpZ25lZCB0byBhIHBhcnRpY3VsYXIgc2VjdGlvbi5cclxuICogQHJldHVybnMgU3RvcmVmcm9udE5hdmlnYXRpb25JdGVtXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBnZXROYXZpZ2F0aW9uSXRlbShcclxuICBpZDogc3RyaW5nLFxyXG4gIHRpdGxlOiBzdHJpbmcsXHJcbiAgdGFnczogc3RyaW5nW11cclxuKTogUHJvbWlzZTxTdG9yZWZyb250TmF2aWdhdGlvbkl0ZW0+IHtcclxuICBsZXQgbmF2aWdhdGlvbkl0ZW06IFN0b3JlZnJvbnROYXZpZ2F0aW9uSXRlbSA9IHtcclxuICAgIGlkOiBpZCA/PyBnZXRJZCh0aXRsZSwgdGFncyksXHJcbiAgICB0aXRsZSxcclxuICAgIHRlbXBsYXRlSWQ6IFwiYXBwR3JpZFwiIGFzIFN0b3JlZnJvbnRUZW1wbGF0ZS5BcHBHcmlkLFxyXG4gICAgdGVtcGxhdGVEYXRhOiB7XHJcbiAgICAgIGFwcHM6IFtdLFxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICBsZXQgYXBwcyA9IGF3YWl0IGdldEFwcHNCeVRhZyh0YWdzKTtcclxuXHJcbiAgaWYgKGFwcHMgIT09IHVuZGVmaW5lZCAmJiBhcHBzLmxlbmd0aCA+IDApIHtcclxuICAgIG5hdmlnYXRpb25JdGVtLnRlbXBsYXRlRGF0YS5hcHBzID0gYXBwcztcclxuICB9XHJcblxyXG4gIHJldHVybiBuYXZpZ2F0aW9uSXRlbTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0TmF2aWdhdGlvbkl0ZW1zKFxyXG4gIGl0ZW1zOiBTdG9yZWZyb250U2V0dGluZ3NOYXZpZ2F0aW9uSXRlbVtdLFxyXG4gIGxpbWl0OiBudW1iZXJcclxuKSB7XHJcbiAgbGV0IG5hdmlnYXRpb25JdGVtczogU3RvcmVmcm9udE5hdmlnYXRpb25JdGVtW10gPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgbGV0IG5hdmlnYXRpb25JdGVtID0gYXdhaXQgZ2V0TmF2aWdhdGlvbkl0ZW0oXHJcbiAgICAgIGl0ZW1zW2ldLmlkLFxyXG4gICAgICBpdGVtc1tpXS50aXRsZSxcclxuICAgICAgaXRlbXNbaV0udGFnc1xyXG4gICAgKTtcclxuICAgIG5hdmlnYXRpb25JdGVtcy5wdXNoKG5hdmlnYXRpb25JdGVtKTtcclxuICB9XHJcblxyXG4gIGlmIChuYXZpZ2F0aW9uSXRlbXMubGVuZ3RoID4gbGltaXQpIHtcclxuICAgIGNvbnNvbGUud2FybihcclxuICAgICAgYFlvdSBoYXZlIGRlZmluZWQgdG9vIG1hbnkgbmF2aWdhdGlvbnMgaXRlbXMgKCR7bmF2aWdhdGlvbkl0ZW1zLmxlbmd0aH0pLiBQbGVhc2UgbGltaXQgaXQgdG8gJHtsaW1pdH0gYXMgd2Ugd2lsbCBvbmx5IHRha2UgdGhlIGZpcnN0ICR7bGltaXR9YFxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIG5hdmlnYXRpb25JdGVtcy5zbGljZSgwLCBsaW1pdCk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldExhbmRpbmdQYWdlUm93KFxyXG4gIGRlZmluaXRpb246IFN0b3JlZnJvbnRTZXR0aW5nc0xhbmRpbmdQYWdlUm93LFxyXG4gIGxpbWl0OiBudW1iZXJcclxuKSB7XHJcbiAgbGV0IGl0ZW1zOiBTdG9yZWZyb250RGV0YWlsZWROYXZpZ2F0aW9uSXRlbVtdID0gW107XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVmaW5pdGlvbi5pdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgbGV0IG5hdmlnYXRpb25JdGVtID0gYXdhaXQgZ2V0TmF2aWdhdGlvbkl0ZW0oXHJcbiAgICAgIGRlZmluaXRpb24uaXRlbXNbaV0uaWQsXHJcbiAgICAgIGRlZmluaXRpb24uaXRlbXNbaV0udGl0bGUsXHJcbiAgICAgIGRlZmluaXRpb24uaXRlbXNbaV0udGFnc1xyXG4gICAgKTtcclxuICAgIGxldCBpdGVtOiBTdG9yZWZyb250RGV0YWlsZWROYXZpZ2F0aW9uSXRlbSA9IHtcclxuICAgICAgZGVzY3JpcHRpb246IGRlZmluaXRpb24uaXRlbXNbaV0uZGVzY3JpcHRpb24sXHJcbiAgICAgIGltYWdlOiBkZWZpbml0aW9uLml0ZW1zW2ldLmltYWdlLFxyXG4gICAgICAuLi5uYXZpZ2F0aW9uSXRlbSxcclxuICAgIH07XHJcbiAgICBpdGVtcy5wdXNoKGl0ZW0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGl0ZW1zLmxlbmd0aCA+IGxpbWl0KSB7XHJcbiAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgIGBZb3UgaGF2ZSBkZWZpbmVkIHRvbyBtYW55IHN0b3JlZnJvbnQgZGV0YWlsZWQgbmF2aWdhdGlvbiBpdGVtcyAoJHtpdGVtcy5sZW5ndGh9KS4gUGxlYXNlIGtlZXAgaXQgdG8gdGhlIGxpbWl0IG9mICR7bGltaXR9IGFzIG9ubHkgdGhlIGZpcnN0ICR7bGltaXR9IHdpbGwgYmUgcmV0dXJuZWQuYFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGxldCBkZXRhaWxlZE5hdmlnYXRpb25JdGVtcyA9IGl0ZW1zLnNsaWNlKDAsIGxpbWl0KSBhcyBhbnk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB0aXRsZTogZGVmaW5pdGlvbi50aXRsZSxcclxuICAgIGl0ZW1zOiBkZXRhaWxlZE5hdmlnYXRpb25JdGVtcyxcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGZpbiB9IGZyb20gJ29wZW5maW4tYWRhcHRlci9zcmMvbW9jayc7XHJcblxyXG5mdW5jdGlvbiBnZXRXb3Jrc3BhY2UoKSB7XHJcbiAgbGV0IHBsYXRmb3JtID0gZmluLlBsYXRmb3JtLndyYXBTeW5jKHsgdXVpZDogVVVJRCB9KTtcclxuICByZXR1cm4gcGxhdGZvcm07XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGlzV29ya3NwYWNlUnVubmluZygpIHtcclxuICByZXR1cm4gZ2V0V29ya3NwYWNlKCkuQXBwbGljYXRpb24uaXNSdW5uaW5nKCk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGxhdW5jaE9wZW5GaW5Xb3Jrc3BhY2UoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkxhdW5jaGluZyBXb3Jrc3BhY2UuXCIpO1xyXG4gICAgcmV0dXJuIGZpbi5TeXN0ZW0ubGF1bmNoTWFuaWZlc3QoXHJcbiAgICAgICAgXCJmaW5zOi8vc3lzdGVtLWFwcHMvd29ya3NwYWNlXCJcclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICBjb25zb2xlLmxvZyhcIkluaXRpYWxpc2luZyB3b3Jrc3BhY2UuXCIpO1xyXG4gIGlmIChhd2FpdCBpc1dvcmtzcGFjZVJ1bm5pbmcoKSkge1xyXG4gICAgY29uc29sZS5sb2coXCJXb3Jrc3BhY2UgYWxyZWFkeSBydW5uaW5nIGFuZCBpbml0aWFsaXNlZC5cIik7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPihhc3luYyAocmVzb2x2ZSkgPT4ge1xyXG4gICAgZ2V0V29ya3NwYWNlKCkub25jZShcInBsYXRmb3JtLWFwaS1yZWFkeVwiLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJXb3Jrc3BhY2UgaXMgbm93IHJlYWR5IGFuZCBpbml0aWFsaXNlZC5cIik7XHJcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgIH0pO1xyXG4gICAgYXdhaXQgbGF1bmNoT3BlbkZpbldvcmtzcGFjZSgpO1xyXG4gICAgaXNXb3Jrc3BhY2VSdW5uaW5nKCkudGhlbihhc3luYyAoaXNSdW5uaW5nKSA9PiB7XHJcbiAgICAgIGlmIChpc1J1bm5pbmcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIldvcmtzcGFjZSBzdGF0dXMuIElzIHJ1bm5pbmcgYW5kIGluaXRpYWxpc2VkOiBcIiArIGlzUnVubmluZyk7XHJcbiAgICAgICAgcmVzb2x2ZShpc1J1bm5pbmcpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFVVSUQgPSBcIm9wZW5maW4tYnJvd3NlclwiO1xyXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiXHJcbmltcG9ydCB7IGluaXQgYXMgaW5pdGlhbGlzZVBsYXRmb3JtIH0gZnJvbSAnLi9wbGF0Zm9ybSc7XHJcbmltcG9ydCB7IGluaXQgYXMgYm9vdHN0cmFwIH0gZnJvbSAnLi9ib290c3RyYXBwZXInO1xyXG5pbXBvcnQgeyBmaW4gfSBmcm9tICdvcGVuZmluLWFkYXB0ZXIvc3JjL21vY2snO1xyXG5cclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgbGV0IHBsYXRmb3JtID0gZmluLlBsYXRmb3JtLmdldEN1cnJlbnRTeW5jKCk7XHJcbiAgcGxhdGZvcm0ub25jZSgncGxhdGZvcm0tYXBpLXJlYWR5JywgYm9vdHN0cmFwLmJpbmQodGhpcykpO1xyXG4gIGF3YWl0IGluaXRpYWxpc2VQbGF0Zm9ybSgpO1xyXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=