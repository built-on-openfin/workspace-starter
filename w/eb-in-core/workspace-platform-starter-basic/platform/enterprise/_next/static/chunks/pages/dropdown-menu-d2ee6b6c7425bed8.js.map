{"version":3,"file":"static/chunks/pages/dropdown-menu-d2ee6b6c7425bed8.js","mappings":"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","sources":["webpack://_N_E/?1e5a","webpack://_N_E/./src/hooks/useHideWindowOnBlur.ts","webpack://_N_E/./src/hooks/useIsWindows.ts","webpack://_N_E/./src/hooks/useManagePopupWindow.ts","webpack://_N_E/./src/components/App/ContextMenu/DropdownMenu.tsx","webpack://_N_E/./src/pages/dropdown-menu.tsx"],"sourcesContent":["\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/dropdown-menu\",\n      function () {\n        return require(\"private-next-pages/dropdown-menu.tsx\");\n      }\n    ]);\n    if(module.hot) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/dropdown-menu\"])\n      });\n    }\n  ","import { useCallback, useEffect, useRef } from 'react';\n\nimport OpenFin from '@openfin/core';\n\nexport const useHideWindowOnBlur = (disable?: boolean, onHide?: () => void) => {\n    const onWindowBlurRef = useRef<() => void>();\n\n    onWindowBlurRef.current = useCallback(async () => {\n        if (disable) {\n            return;\n        }\n\n        onHide && onHide();\n        await (fin.me as OpenFin.Window).hide();\n    }, [disable, onHide]);\n\n    useEffect(() => {\n        const handleBlur = async () => {\n            if (onWindowBlurRef.current) {\n                onWindowBlurRef.current();\n            }\n        };\n\n        (async () => {\n            await (fin.me as OpenFin.Window).on('blurred', handleBlur);\n            await (fin.me as OpenFin.Window).on('hidden', handleBlur);\n        })();\n\n        return () => {\n            // TODO WRK-4956: Unawaited promises in react hook disposers can cause global rejections\n            (fin.me as OpenFin.Window).removeListener('blurred', handleBlur);\n            (fin.me as OpenFin.Window).removeListener('hidden', handleBlur);\n        };\n    }, []);\n};\n","import { useEffect, useState } from 'react';\n\nimport { isOSWindows } from '@common/utils/os';\n\n/**\n * Custom hook that determines if the operating system is Windows.\n *\n * NOTE: This hook should only be used in non-browser window components.\n * Otherwise, opt for the selectIsWindows selector to access the Redux store.\n *\n * @returns {boolean} - Returns `true` if the operating system is Windows, otherwise `false`.\n */\nexport const useIsWindows = () => {\n    const [isWindows, setIsWindows] = useState(true);\n\n    useEffect(() => {\n        (async () => {\n            setIsWindows(await isOSWindows());\n        })();\n    }, []);\n\n    return isWindows;\n};\n","import { useCallback, useEffect, useRef, useState } from 'react';\n\nimport OpenFin from '@openfin/core';\n\nimport {\n    BaseEnterpriseMenuChannelMessage,\n    ContextMenuChannelMessage,\n    EnterpriseMenuType,\n    RenameSupertabChannelMessage\n} from '@common/utils/popup-window';\nimport { getCurrentOFWindow, WindowName } from '@common/utils/window';\n\nexport type ContextMenuWindowMessage = ContextMenuChannelMessage | RenameSupertabChannelMessage;\n\n/*\n * This hook is used to manage the popup window state and show the popup window.\n * @param windowName - The name of the popup window.\n * @param createChannel - The function to create the channel.\n * @param showPopupOverride - The function to show the popup window. If not provided, the default behavior will be used to show the popup window.\n * @param options - An object containing optional parameters.\n * @param options.blurBehavior - The behavior of the popup window when it loses focus. Can be 'hide' or 'modal'. Defaults to 'hide'.\n * @param options.dispatchDirectlyToChannel - If true, the response will be dispatched directly to the channel. If false, the response will be dispatched to the parent window.\n * @param options.forwardTopicName - The topic name to forward the response to.\n */\nexport const useManagePopupWindow = <T extends BaseEnterpriseMenuChannelMessage>(\n    windowName: string,\n    createChannel: () => Promise<OpenFin.ChannelProvider>,\n    showPopupOverride?: (bounds: OpenFin.Bounds) => Promise<void>,\n    options?: {\n        blurBehavior?: 'hide' | 'modal';\n        dispatchDirectlyToChannel?: boolean;\n        forwardTopicName?: string;\n    }\n) => {\n    const channelToParent = useRef<OpenFin.ChannelProvider | null>(null);\n    const [payload, setPayload] = useState<T | null>(null);\n\n    const handlePopupRequest = useCallback(async (ev: T) => {\n        const window = fin.me as OpenFin.Window;\n\n        // Assuming a popup window is currently active, if a user attempts to activate the popup window elsewhere, we want to\n        // first blur the popup window to emit a response for the first invocation before setting the payload to re-show.\n        if (await window.isShowing()) {\n            // Do not blur the zoom controls dialog in this instance. The dialog should stay open on successive show calls.\n            if (ev.type !== EnterpriseMenuType.ZoomControls) {\n                await window.blur();\n            }\n        }\n        setPayload(ev);\n    }, []);\n\n    const showPopup = useCallback(\n        async (bounds: OpenFin.Bounds) => {\n            if (!payload) return;\n            const popupWindow = fin.Window.wrapSync({ name: windowName, uuid: fin.me.uuid });\n            const parentWindow = fin.Window.wrapSync(payload.parentIdentity);\n\n            // SAAS-2980 - Windows Limitation:\n            // - when showTaskbarIcon: false - the window is visible on all desktops\n            // - to prevent this, we set a parentIdentity on the popupWindow\n            // - we need to keep it alive after the parent window is closed,\n            // so on hidden we set the parentIdentity to a non-existent window identity\n            // which in core will unset the parent.\n\n            // always set the parent identity during showPopup\n            await popupWindow.updateOptions({\n                // @ts-expect-error type mismatch\n                experimental: { parentIdentity: payload.parentIdentity }\n            });\n\n            await popupWindow.prependOnceListener('hidden', async () => {\n                // bookmarks dialog \"child\" popup window has a parent of the bookmarks dialog,\n                // skip it for that case\n                if (payload.parentIdentity.name !== WindowName.EnterpriseBookmarkDialogWindow) {\n                    await popupWindow.updateOptions({\n                        // @ts-expect-error type mismatch\n                        experimental: { parentIdentity: { uuid: '__NON_EXISTENT', name: '__NON_EXISTENT' } }\n                    });\n                }\n            });\n\n            if (showPopupOverride) {\n                await showPopupOverride(bounds);\n                return;\n            }\n\n            try {\n                const { height, width, top, left } = bounds;\n\n                (fin.me as OpenFin.Window).once('blurred', () => setPayload(null));\n                const response = await parentWindow.showPopupWindow({\n                    name: windowName,\n                    resultDispatchBehavior: 'hide',\n                    blurBehavior: options?.blurBehavior ?? 'hide',\n                    hideOnClose: true,\n                    focus: true,\n                    height,\n                    width,\n                    x: left,\n                    y: top,\n                    additionalOptions: {\n                        alwaysOnTop: true,\n                        contextMenuOptions: {\n                            enabled: true,\n                            template: ['inspect']\n                        }\n                    }\n                });\n\n                const shouldTargetRequestId =\n                    'requestId' in payload &&\n                    (payload.type === EnterpriseMenuType.ContextMenu || payload.type === EnterpriseMenuType.GlobalMenu);\n\n                // Context menu invocations coming from the provider window should target a topic with a specific requestId.\n                const responseTopic = shouldTargetRequestId ? `response-${payload.requestId}` : 'response';\n                await channelToParent.current?.dispatch(payload.responseIdentity, responseTopic, response);\n\n                if (options?.forwardTopicName) {\n                    channelToParent.current?.publish(options.forwardTopicName, response);\n                }\n            } catch (error) {\n                console.error('Error showing popup:', error);\n            }\n        },\n        [payload]\n    );\n\n    const onResponse = useCallback(\n        async (data?: any) => {\n            try {\n                if (options?.dispatchDirectlyToChannel) {\n                    if (payload) {\n                        await channelToParent.current?.dispatch(payload.responseIdentity, 'response', data);\n\n                        if (options.forwardTopicName) {\n                            Promise.all(channelToParent.current?.publish(options.forwardTopicName, data)).catch(() => {\n                                /* Channel that listens to forwarding messages is not open */\n                            });\n                        }\n                    }\n\n                    if (data.type === 'cancel' || data.type === 'dropdown-blurred') {\n                        setPayload(null);\n                    }\n                } else {\n                    await getCurrentOFWindow().dispatchPopupResult(data);\n\n                    if (payload) {\n                        fin.Window.wrapSync(payload.parentIdentity).focus();\n                        setPayload(null);\n                    }\n                }\n            } catch (error) {\n                console.error('Error handling response:', error);\n            }\n        },\n        [payload]\n    );\n\n    useEffect(() => {\n        const setupChannel = async () => {\n            const channel = await createChannel();\n            channel.register('open', handlePopupRequest);\n            channelToParent.current = channel;\n        };\n\n        try {\n            setupChannel();\n        } catch (error) {\n            console.error('Error setting up channel:', error);\n        }\n\n        return () => {\n            if (channelToParent.current) {\n                channelToParent.current.destroy();\n                channelToParent.current = null;\n            }\n        };\n    }, [handlePopupRequest, createChannel]);\n\n    return {\n        channelRef: channelToParent,\n        payload,\n        showPopup,\n        onResponse\n    };\n};\n","import { FC, useRef } from 'react';\n\nimport styled from 'styled-components';\n\nimport { OpenFin } from '@openfin/core';\n\nimport { BASE_CONTEXT_MENU, CustomContextMenu, CustomContextMenuTemplate } from '@openfin/ui-library';\n\nimport { DropdownMenuChannelMessage } from '@common/utils/popup-window';\n\nimport { ContextMenuProps } from '@enterprise/components/App/ContextMenu/ContextMenu';\n\nimport { useHideWindowOnBlur } from '@enterprise/hooks/useHideWindowOnBlur';\n\nexport type DropdownMenuResponseData = { type: string; data?: any };\n\nconst DropdownMenuContainer = styled.div<{ width?: number }>`\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n\n    button {\n        span {\n            font-size: ${({ theme }) => theme.fontSize.large} !important;\n        }\n        cursor: default !important;\n    }\n\n    .active_context_menu {\n        width: ${({ width }) => width}px;\n\n        // Context menu item inner container\n        & > div > div {\n            height: 32px;\n        }\n\n        // Context menu item text\n        span {\n            padding-right: ${({ theme }) => theme.px.small};\n            font-size: ${({ theme }) => theme.fontSize.large};\n        }\n    }\n`;\n\nexport const DropdownMenu: FC<ContextMenuProps<DropdownMenuChannelMessage>> = ({\n    messageData,\n    showPopup,\n    onResponse,\n    isWindows\n}) => {\n    const containerRef = useRef<HTMLDivElement>();\n\n    const showContextMenuPopup = async () => {\n        const { x, y } = messageData;\n        const baseMenu = document.getElementById(BASE_CONTEXT_MENU);\n        const { width, height } = baseMenu.getBoundingClientRect();\n        showPopup({ height, width, left: x, top: y });\n    };\n\n    const handleValueChanged = (response: any) => {\n        onResponse({ type: 'value-changed', data: response });\n        fin.me.hide();\n    };\n\n    useHideWindowOnBlur(false, () => {\n        onResponse({ type: 'dropdown-blurred' });\n    });\n\n    const width = messageData.payload.width;\n    const menuTemplate =\n        ((messageData.payload as OpenFin.ShowPopupMenuOptions).template as CustomContextMenuTemplate[]) ?? [];\n\n    return (\n        <DropdownMenuContainer ref={containerRef} width={width}>\n            <CustomContextMenu\n                menuTemplate={menuTemplate}\n                onClick={handleValueChanged}\n                onContextMenuReady={showContextMenuPopup}\n                isWindows={isWindows}\n            />\n        </DropdownMenuContainer>\n    );\n};\n","import { useCallback } from 'react';\n\nimport OpenFin from '@openfin/core';\n\nimport { createDropdownMenuChannel } from '@common/utils/enterprise-channels';\nimport { getClosestBoundsIfModalBoundsOffscreen } from '@common/utils/modal-bounds';\nimport { DropdownMenuChannelMessage } from '@common/utils/popup-window';\nimport { WindowName } from '@common/utils/window';\n\nimport { DropdownMenu } from '@enterprise/components/App/ContextMenu/DropdownMenu';\nimport BrowserThemeProvider from '@enterprise/components/App/ThemeProvider/BrowserThemeProvider';\n\nimport { useIsWindows } from '@enterprise/hooks/useIsWindows';\nimport { useManagePopupWindow } from '@enterprise/hooks/useManagePopupWindow';\n\nexport const DropdownMenuPopup = () => {\n    const isWindows = useIsWindows();\n\n    const showPopupOverride = useCallback(async (bounds: OpenFin.Bounds) => {\n        const window = fin.me as OpenFin.Window;\n        await window.setBounds(await getClosestBoundsIfModalBoundsOffscreen(bounds));\n        await window.bringToFront();\n        await window.show();\n        await window.focus();\n    }, []);\n\n    const { payload, showPopup, onResponse } = useManagePopupWindow<DropdownMenuChannelMessage>(\n        WindowName.DropdownMenu,\n        createDropdownMenuChannel,\n        showPopupOverride,\n        { dispatchDirectlyToChannel: true }\n    );\n\n    return (\n        <BrowserThemeProvider>\n            {payload && (\n                <DropdownMenu\n                    messageData={payload}\n                    showPopup={showPopup}\n                    onResponse={onResponse}\n                    isWindows={isWindows}\n                />\n            )}\n        </BrowserThemeProvider>\n    );\n};\n\nexport default DropdownMenuPopup;\n"],"names":["window","__NEXT_P","push","__webpack_require__","useHideWindowOnBlur","disable","onHide","onWindowBlurRef","useRef","current","useCallback","fin","me","hide","useEffect","handleBlur","on","removeListener","useIsWindows","isWindows","setIsWindows","useState","isOSWindows","useManagePopupWindow","windowName","createChannel","showPopupOverride","options","channelToParent","payload","setPayload","handlePopupRequest","ev","isShowing","type","EnterpriseMenuType","ZoomControls","blur","showPopup","bounds","popupWindow","Window","wrapSync","name","uuid","parentWindow","parentIdentity","updateOptions","experimental","prependOnceListener","WindowName","EnterpriseBookmarkDialogWindow","height","width","top","left","once","response","showPopupWindow","resultDispatchBehavior","blurBehavior","hideOnClose","focus","x","y","additionalOptions","alwaysOnTop","contextMenuOptions","enabled","template","responseTopic","shouldTargetRequestId","ContextMenu","GlobalMenu","concat","requestId","dispatch","responseIdentity","forwardTopicName","publish","error","console","onResponse","data","dispatchDirectlyToChannel","Promise","all","catch","getCurrentOFWindow","dispatchPopupResult","setupChannel","channel","register","destroy","channelRef","DropdownMenuContainer","styled","div","withConfig","theme","param","fontSize","large","px","small","DropdownMenu","_messageData_payload_template","messageData","containerRef","showContextMenuPopup","baseMenu","getElementById","BASE_CONTEXT_MENU","getBoundingClientRect","menuTemplate","jsx_runtime","jsx","ref","CustomContextMenu","onClick","onContextMenuReady","DropdownMenuPopup","setBounds","getClosestBoundsIfModalBoundsOffscreen","bringToFront","show","createDropdownMenuChannel","BrowserThemeProvider","dropdown_menu"],"sourceRoot":""}