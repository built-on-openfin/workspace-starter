{"version":3,"file":"apps.bundle.js","mappings":"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","sources":["webpack://openfin-workspace--workspace-platform-starter/webpack/bootstrap","webpack://openfin-workspace--workspace-platform-starter/webpack/runtime/define property getters","webpack://openfin-workspace--workspace-platform-starter/webpack/runtime/hasOwnProperty shorthand","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/shapes/favorite-shapes.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/utils.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/integrations/apps/integration.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/integrations/apps/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import type { PlatformStorageMetadata } from \"./platform-shapes\";\n\n/**\n * Favorite type for App.\n */\nexport const FAVORITE_TYPE_NAME_APP = \"app\";\n\n/**\n * Favorite type for Workspace.\n */\nexport const FAVORITE_TYPE_NAME_WORKSPACE = \"workspace\";\n\n/**\n * Favorite type for Page.\n */\nexport const FAVORITE_TYPE_NAME_PAGE = \"page\";\n\n/**\n * Favorite type for Query.\n */\nexport const FAVORITE_TYPE_NAME_QUERY = \"query\";\n\n/**\n * Names for all the favorite types.\n */\nexport type FavoriteTypeNames =\n\t| typeof FAVORITE_TYPE_NAME_APP\n\t| typeof FAVORITE_TYPE_NAME_WORKSPACE\n\t| typeof FAVORITE_TYPE_NAME_PAGE\n\t| typeof FAVORITE_TYPE_NAME_QUERY;\n\n/**\n * Options for the favorite provider.\n */\nexport interface FavoriteProviderOptions {\n\t/**\n\t * Is the provider enabled, defaults to true.\n\t */\n\tenabled?: boolean;\n\n\t/**\n\t * The icon that should be used if you want to indicate this is a favorite action\n\t */\n\tfavoriteIcon: string;\n\n\t/**\n\t * The icon to use to indicate that this favorite can be unset\n\t */\n\tunfavoriteIcon: string;\n\n\t/**\n\t * What commands should integrations check for if they intent to support the display of favorites\n\t */\n\tfavoriteCommand?: string;\n\n\t/**\n\t * The connection provider can have actions registered against it from the platform. This provides a default list of\n\t * actions that connections should be able to use if actions are enabled for that connection.\n\t */\n\tsupportedFavoriteTypes?: FavoriteTypeNames[];\n}\n\n/**\n * When an entry is made it represents a type supported by this platform. This can be used to lookup and launch the thing this entry refers to.\n */\nexport interface FavoriteEntry {\n\t/**\n\t * A unique guid to represent this favorite entry so that it can be updated or removed\n\t */\n\tid: string;\n\n\t/**\n\t * The id for the favorite type this entry represents\n\t */\n\ttypeId: string;\n\n\t/**\n\t * What type of favorite entry does this entry represent\n\t */\n\ttype: FavoriteTypeNames;\n\n\t/**\n\t * The timestamp for the entry.\n\t */\n\ttimestamp?: Date;\n\n\t/**\n\t * Does this favorite have a suggested label that can be used to avoid a lookup\n\t */\n\tlabel?: string;\n\n\t/**\n\t * Does this favorite have a suggested icon that can be used to avoid a lookup\n\t */\n\ticon?: string;\n}\n\n/**\n * Info to return to interested parties to help them support favorites\n */\nexport interface FavoriteInfo {\n\t/**\n\t * The path to an icon that can be used to indicate the ability to favorite\n\t */\n\tfavoriteIcon?: string;\n\t/**\n\t * The path to an icon that can be used to indicate the ability to remove this favorite\n\t */\n\tunfavoriteIcon?: string;\n\t/**\n\t * A command that supporting modules should listen for if they are to display favorites that fall under them\n\t */\n\tcommand?: string;\n\t/**\n\t * What types of favorite item are supported on this platform, this also determines the ordering in the dock menu.\n\t */\n\tenabledTypes?: FavoriteTypeNames[];\n\t/**\n\t * Is favorite support enabled on this platform.\n\t */\n\tisEnabled: boolean;\n}\n\n/**\n * A client that can be used to provide access to some or all of the favorite functionality\n */\nexport interface FavoriteClient {\n\t/**\n\t * The ability to request supporting information about whether favorites are initialized for the platform and supporting information.\n\t * @returns Supporting information.\n\t */\n\tgetInfo(): FavoriteInfo;\n\t/**\n\t * The ability to request all (or some if by type) of the saved favorites\n\t * @param byType the type of saved favorite you are looking for\n\t * @returns An array of saved favorites or an empty array if it was unable to get any back\n\t */\n\tgetSavedFavorites(byType?: FavoriteTypeNames): Promise<FavoriteEntry[] | undefined>;\n\t/**\n\t * The ability to request a particular saved favorite.\n\t * @param id the id of the favorite you are looking for\n\t * @returns the saved favorite if available or false if it didn't exist\n\t */\n\tgetSavedFavorite(id: string): Promise<FavoriteEntry | undefined>;\n\t/**\n\t * The ability to save a favorite.\n\t * @param favorite the Favorite you wish to save\n\t * @returns whether or not the favorite was saved\n\t */\n\tsetSavedFavorite?(favorite: FavoriteEntry): Promise<boolean>;\n\t/**\n\t * The ability to remove/delete a saved favorite.\n\t * @param id The id of the favorite to delete\n\t * @returns whether or not the favorite was deleted.\n\t */\n\tdeleteSavedFavorite?(id: string): Promise<boolean>;\n}\n\n/**\n * An object that represents a favorite and meta data related to it\n */\nexport interface EndpointFavoriteEntry {\n\t/**\n\t * Information related to the platform providing the payload.\n\t */\n\tmetaData: PlatformStorageMetadata;\n\t/**\n\t * The favorite entry\n\t */\n\tpayload: FavoriteEntry;\n}\n\n/**\n * A request type for the FavoriteEndpoint that gets all saved favorite entries\n */\nexport interface EndpointFavoriteListRequest {\n\t/**\n\t * The id of the platform making the request\n\t */\n\tplatform: string;\n\t/**\n\t * The type if specified should be used to filter the response to only send the entries that are relevant\n\t */\n\tfavoriteType?: FavoriteTypeNames;\n}\n\n/**\n * The response after the request for favorites was fulfilled\n */\nexport interface EndpointFavoriteListResponse {\n\t/**\n\t * The list of favorite entries with information of what platform versions they were originally saved against\n\t */\n\tentries: EndpointFavoriteEntry[];\n}\n\n/**\n * The request for getting a specific favorite entry\n */\nexport interface EndpointFavoriteGetRequest {\n\t/**\n\t * The id of the platform making the request\n\t */\n\tplatform: string;\n\t/**\n\t * The id of the specific entry that has been saved\n\t */\n\tid: string;\n}\n\n/**\n * The response after the request for a specific favorite was fulfilled\n */\nexport type EndpointFavoriteGetResponse = EndpointFavoriteEntry;\n\n/**\n * The request for getting a specific favorite entry\n */\nexport interface EndpointFavoriteSetRequest extends EndpointFavoriteEntry {\n\t/**\n\t * The id of the platform making the request\n\t */\n\tplatform: string;\n\t/**\n\t * The id of the specific entry that is to be set\n\t */\n\tid: string;\n}\n\n/**\n * The request for removing a specific favorite entry\n */\nexport interface EndpointFavoriteRemoveRequest {\n\t/**\n\t * The id of the platform making the request\n\t */\n\tplatform: string;\n\t/**\n\t * The id of the specific entry that is to be removed\n\t */\n\tid: string;\n}\n","/**\n * Test if a value is a undefined or null.\n * @param value The value to test.\n * @returns True if the value is null or undefined.\n */\nexport function isEmpty(value: unknown): value is null | undefined {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value === undefined || value === null;\n}\n\n/**\n * Test if a value is an object.\n * @param value The value to test.\n * @returns True if the value is an object.\n */\nexport function isObject(value: unknown): value is object {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n/**\n * Test if a value is a string.\n * @param value The value to test.\n * @returns True if the value is a string.\n */\nexport function isString(value: unknown): value is string {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"string\";\n}\n\n/**\n * Test if a value is a string that is not empty.\n * @param value The value to test.\n * @returns True if the value is a string that is not empty.\n */\nexport function isStringValue(value: unknown): value is string {\n\treturn isString(value) && value.trim().length > 0;\n}\n\n/**\n * Test if a value is a number.\n * @param value The value to test.\n * @returns True if the value is a number.\n */\nexport function isNumber(value: unknown): value is number {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"number\";\n}\n\n/**\n * Test if a value is a number with a real value i.e. not NaN or Infinite.\n * @param value The value to test.\n * @returns True if the value is a number.\n */\nexport function isNumberValue(value: unknown): value is number {\n\treturn isNumber(value) && !Number.isNaN(value) && Number.isFinite(value);\n}\n\n/**\n * Test if a value is a boolean.\n * @param value The value to test.\n * @returns True if the value is a boolean.\n */\nexport function isBoolean(value: unknown): value is boolean {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"boolean\";\n}\n\n/**\n * Test if a value is an integer.\n * @param value The value to test.\n * @returns True if the value is an integer.\n */\nexport function isInteger(value: unknown): value is number {\n\treturn isNumber(value) && Number.isInteger(value);\n}\n\n/**\n * Deep clone an object.\n * @param obj The object to clone.\n * @returns The clone of the object.\n */\nexport function objectClone<T>(obj: T): T {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn obj === undefined ? undefined : JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Do a deep comparison of the objects.\n * @param obj1 The first object to compare.\n * @param obj2 The second object to compare.\n * @param matchPropertyOrder If true the properties must be in the same order.\n * @returns True if the objects are the same.\n */\nexport function deepEqual(obj1: unknown, obj2: unknown, matchPropertyOrder: boolean = true): boolean {\n\tif (isObject(obj1) && isObject(obj2)) {\n\t\tconst objKeys1 = Object.keys(obj1);\n\t\tconst objKeys2 = Object.keys(obj2);\n\n\t\tif (objKeys1.length !== objKeys2.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (matchPropertyOrder && JSON.stringify(objKeys1) !== JSON.stringify(objKeys2)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const key of objKeys1) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst value1 = (obj1 as any)[key];\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst value2 = (obj2 as any)[key];\n\n\t\t\tif (!deepEqual(value1, value2, matchPropertyOrder)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t} else if (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\tif (obj1.length !== obj2.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < obj1.length; i++) {\n\t\t\tif (!deepEqual(obj1[i], obj2[i], matchPropertyOrder)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn JSON.stringify(obj1) === JSON.stringify(obj2);\n}\n\n/**\n * Deep merge two objects.\n * @param target The object to be merged into.\n * @param sources The objects to merge into the target.\n * @returns The merged object.\n */\nexport function deepMerge<T = unknown>(target: T, ...sources: T[]): T {\n\tif (!Array.isArray(sources) || sources.length === 0) {\n\t\treturn target;\n\t}\n\n\tconst targetAsMap = target as { [id: string]: unknown };\n\tconst source = sources.shift();\n\n\tlet keys;\n\tif (isObject(targetAsMap) && isObject(source)) {\n\t\tkeys = Object.keys(source);\n\t} else if (Array.isArray(source)) {\n\t\tif (!Array.isArray(target)) {\n\t\t\treturn source;\n\t\t}\n\t\tkeys = Object.keys(source).map((k) => Number.parseInt(k, 10));\n\t}\n\n\tif (keys) {\n\t\tconst sourceAsMap = source as { [id: string]: unknown };\n\t\tfor (const key of keys) {\n\t\t\tconst value = sourceAsMap[key];\n\t\t\tif (isObject(value)) {\n\t\t\t\tif (isEmpty(targetAsMap[key])) {\n\t\t\t\t\ttargetAsMap[key] = {};\n\t\t\t\t}\n\t\t\t\tdeepMerge(targetAsMap[key], value);\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tif (isEmpty(targetAsMap[key])) {\n\t\t\t\t\ttargetAsMap[key] = [];\n\t\t\t\t}\n\t\t\t\tdeepMerge(targetAsMap[key], value);\n\t\t\t} else {\n\t\t\t\ttargetAsMap[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Polyfills randomUUID if running in a non-secure context.\n * @returns The random UUID.\n */\nexport function randomUUID(): string {\n\tif (\"randomUUID\" in globalThis.crypto) {\n\t\t// eslint-disable-next-line no-restricted-syntax\n\t\treturn globalThis.crypto.randomUUID();\n\t}\n\t// Polyfill the window.crypto.randomUUID if we are running in a non secure context that doesn't have it\n\t// we are still using window.crypto.getRandomValues which is always available\n\t// https://stackoverflow.com/a/2117523/2800218\n\t/**\n\t * Get random hex value.\n\t * @param c The number to base the random value on.\n\t * @returns The random value.\n\t */\n\tfunction getRandomHex(c: string): string {\n\t\t// eslint-disable-next-line no-bitwise\n\t\tconst rnd = globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (Number(c) / 4));\n\t\treturn (\n\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t(Number(c) ^ rnd).toString(16)\n\t\t);\n\t}\n\treturn \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, getRandomHex);\n}\n\n/**\n * Format an error to a readable string.\n * @param err The error to format.\n * @returns The formatted error.\n */\nexport function formatError(err: unknown): string {\n\tif (isEmpty(err)) {\n\t\treturn \"\";\n\t} else if (err instanceof Error) {\n\t\treturn err.message;\n\t} else if (isStringValue(err)) {\n\t\treturn err;\n\t} else if (isObject(err) && \"message\" in err && isString(err.message)) {\n\t\treturn err.message;\n\t}\n\treturn JSON.stringify(err);\n}\n\n/**\n * A basic string sanitize function that removes angle brackets <> from a string.\n * @param content the content to sanitize\n * @returns a string without angle brackets <>\n */\nexport function sanitizeString(content: unknown): string {\n\tif (isStringValue(content)) {\n\t\treturn content\n\t\t\t.replace(/<[^>]*>?/gm, \"\")\n\t\t\t.replace(/&gt;/g, \">\")\n\t\t\t.replace(/&lt;/g, \"<\")\n\t\t\t.replace(/&amp;/g, \"&\")\n\t\t\t.replace(/&nbsp;/g, \" \")\n\t\t\t.replace(/\\n\\s*\\n/g, \"\\n\");\n\t}\n\treturn \"\";\n}\n\n/**\n * Get the command line arguments from a command line string.\n * Examples of command line strings: arg1 key1=value1 key2=\"value with spaces\" key3='value3' key4='value with more spaces'`.\n * @param commandLine The command line string.\n * @returns The command line arguments or an empty array if none\n */\nexport function getCommandLineArgs(commandLine: string): string[] {\n\tif (!isStringValue(commandLine)) {\n\t\treturn [];\n\t}\n\tconst matches = commandLine.match(/(\\w+=)?(\"[^\"]*\"|'[^']*'|[^ ]+)/g);\n\tif (isEmpty(matches)) {\n\t\treturn [];\n\t}\n\treturn matches;\n}\n","import type {\n\tCLIFilter,\n\tCLIFilterOptionType,\n\tCLITemplate,\n\tHomeDispatchedSearchResult,\n\tHomeSearchListenerResponse,\n\tHomeSearchResponse,\n\tHomeSearchResult\n} from \"@openfin/workspace\";\nimport type { ManifestTypeId, PlatformApp } from \"workspace-platform-starter/shapes/app-shapes\";\nimport {\n\tFAVORITE_TYPE_NAME_APP,\n\ttype FavoriteClient,\n\ttype FavoriteEntry,\n\ttype FavoriteInfo,\n\ttype FavoriteTypeNames\n} from \"workspace-platform-starter/shapes/favorite-shapes\";\nimport type {\n\tIntegrationHelpers,\n\tIntegrationModule,\n\tIntegrationModuleDefinition\n} from \"workspace-platform-starter/shapes/integrations-shapes\";\nimport type { FavoriteChangedLifecyclePayload } from \"workspace-platform-starter/shapes/lifecycle-shapes\";\nimport type { Logger, LoggerCreator } from \"workspace-platform-starter/shapes/logger-shapes\";\nimport type { ModuleDefinition } from \"workspace-platform-starter/shapes/module-shapes\";\nimport { isEmpty, isObject, isStringValue, randomUUID } from \"workspace-platform-starter/utils\";\nimport type { AppManifestTypeMapping, AppSettings } from \"./shapes\";\n\n/**\n * Implement the integration provider for apps.\n */\nexport class AppProvider implements IntegrationModule<AppSettings> {\n\t/**\n\t * The default base score for ordering.\n\t * @internal\n\t */\n\tprivate static readonly _DEFAULT_BASE_SCORE = 0;\n\n\t/**\n\t * The key used to filter out by tag.\n\t * @internal\n\t */\n\tprivate static readonly _HOME_TAG_FILTERS = \"tags\";\n\n\t/**\n\t * Provider id.\n\t * @internal\n\t */\n\tprivate _providerId?: string;\n\n\t/**\n\t * The module definition.\n\t * @internal\n\t */\n\tprivate _definition: IntegrationModuleDefinition<AppSettings> | undefined;\n\n\t/**\n\t * The settings from config.\n\t */\n\tprivate _settings?: AppSettings;\n\n\t/**\n\t * The settings for the integration.\n\t * @internal\n\t */\n\tprivate _logger?: Logger;\n\n\t/**\n\t * The integration helpers.\n\t * @internal\n\t */\n\tprivate _integrationHelpers: IntegrationHelpers | undefined;\n\n\t/**\n\t * The last search response.\n\t */\n\tprivate _lastResponse?: HomeSearchListenerResponse;\n\n\t/**\n\t * The last query.\n\t */\n\tprivate _lastQuery?: string;\n\n\t/**\n\t * The last query min length.\n\t */\n\tprivate _lastQueryMinLength?: number;\n\n\t/**\n\t * The last query against array.\n\t */\n\tprivate _lastQueryAgainst?: string[];\n\n\t/**\n\t * The last query against array.\n\t */\n\tprivate _lastCLIFilters?: CLIFilter[];\n\n\t/**\n\t * The last app results.\n\t */\n\tprivate _lastAppResults?: PlatformApp[];\n\n\t/**\n\t * The list of the ids of the last set of results\n\t */\n\tprivate _lastResultIds?: string[];\n\n\t/**\n\t * Subscription id for theme-changed lifecycle event.\n\t */\n\tprivate _themeChangedSubscriptionId: string | undefined;\n\n\t/**\n\t * Subscription id for favorite-changed lifecycle event.\n\t */\n\tprivate _favChangedSubscriptionId: string | undefined;\n\n\t/**\n\t * Initialize the module.\n\t * @param definition The definition of the module from configuration include custom options.\n\t * @param loggerCreator For logging entries.\n\t * @param helpers Helper methods for the module to interact with the application core.\n\t * @returns Nothing.\n\t */\n\tpublic async initialize(\n\t\tdefinition: ModuleDefinition<AppSettings>,\n\t\tloggerCreator: LoggerCreator,\n\t\thelpers: IntegrationHelpers\n\t): Promise<void> {\n\t\tthis._settings = definition.data;\n\t\tthis._integrationHelpers = helpers;\n\t\tthis._definition = definition;\n\t\tthis._logger = loggerCreator(\"AppProvider\");\n\t\tthis._providerId = definition.id;\n\n\t\tif (this._integrationHelpers.subscribeLifecycleEvent) {\n\t\t\tthis._themeChangedSubscriptionId = this._integrationHelpers.subscribeLifecycleEvent(\n\t\t\t\t\"theme-changed\",\n\t\t\t\tasync () => {\n\t\t\t\t\tawait this.rebuildResults();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tthis._favChangedSubscriptionId =\n\t\t\t\tthis._integrationHelpers.subscribeLifecycleEvent<FavoriteChangedLifecyclePayload>(\n\t\t\t\t\t\"favorite-changed\",\n\t\t\t\t\tasync (_: unknown, payload?: FavoriteChangedLifecyclePayload) => {\n\t\t\t\t\t\tif (!isEmpty(payload)) {\n\t\t\t\t\t\t\tawait this.updateAppFavoriteButtons(payload);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Close down any resources being used by the module.\n\t * @returns Nothing.\n\t */\n\tpublic async closedown(): Promise<void> {\n\t\tif (this._integrationHelpers?.unsubscribeLifecycleEvent) {\n\t\t\tif (isStringValue(this._themeChangedSubscriptionId)) {\n\t\t\t\tthis._integrationHelpers.unsubscribeLifecycleEvent(this._themeChangedSubscriptionId, \"theme-changed\");\n\t\t\t\tthis._themeChangedSubscriptionId = undefined;\n\t\t\t}\n\n\t\t\tif (isStringValue(this._favChangedSubscriptionId)) {\n\t\t\t\tthis._integrationHelpers.unsubscribeLifecycleEvent(\n\t\t\t\t\tthis._favChangedSubscriptionId,\n\t\t\t\t\t\"favorite-changed\"\n\t\t\t\t);\n\t\t\t\tthis._favChangedSubscriptionId = undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get a list of the static help entries.\n\t * @returns The list of help entries.\n\t */\n\tpublic async getHelpSearchEntries(): Promise<HomeSearchResult[]> {\n\t\treturn [];\n\t}\n\n\t/**\n\t * Get a list of search results based on the query and filters.\n\t * @param query The query to search for.\n\t * @param filters The filters to apply.\n\t * @param lastResponse The last search response used for updating existing results.\n\t * @param options Options for the search query.\n\t * @param options.queryMinLength The minimum length before a query is actioned.\n\t * @param options.queryAgainst The fields in the data to query against.\n\t * @param options.isSuggestion Is the query from a suggestion.\n\t * @returns The list of results and new filters.\n\t */\n\tpublic async getSearchResults(\n\t\tquery: string,\n\t\tfilters: CLIFilter[],\n\t\tlastResponse: HomeSearchListenerResponse,\n\t\toptions: {\n\t\t\tqueryMinLength?: number;\n\t\t\tqueryAgainst?: string[];\n\t\t\tisSuggestion?: boolean;\n\t\t}\n\t): Promise<HomeSearchResponse> {\n\t\tconst queryLower = query.toLowerCase();\n\t\tthis._lastResponse = lastResponse;\n\t\tconst appResponse: HomeSearchResponse = await this.getResults(queryLower, filters, options);\n\n\t\treturn appResponse;\n\t}\n\n\t/**\n\t * An entry has been selected.\n\t * @param result The dispatched result.\n\t * @param lastResponse The last response.\n\t * @returns True if the item was handled.\n\t */\n\tpublic async itemSelection(\n\t\tresult: HomeDispatchedSearchResult,\n\t\tlastResponse: HomeSearchListenerResponse\n\t): Promise<boolean> {\n\t\tlet handled = false;\n\t\tif (result.action.trigger === \"user-action\") {\n\t\t\tif (result.action.name.endsWith(\"favorite\") && result.data?.app) {\n\t\t\t\tconst { favoriteClient } = await this.getFavInfo(FAVORITE_TYPE_NAME_APP);\n\t\t\t\tif (favoriteClient) {\n\t\t\t\t\tif (result.action.name.startsWith(\"un\")) {\n\t\t\t\t\t\tif (!isEmpty(result.data?.favoriteId) && favoriteClient.deleteSavedFavorite) {\n\t\t\t\t\t\t\tawait favoriteClient.deleteSavedFavorite(result.data.favoriteId);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (favoriteClient.setSavedFavorite) {\n\t\t\t\t\t\tawait favoriteClient.setSavedFavorite({\n\t\t\t\t\t\t\tid: randomUUID(),\n\t\t\t\t\t\t\ttype: FAVORITE_TYPE_NAME_APP,\n\t\t\t\t\t\t\ttypeId: result.key,\n\t\t\t\t\t\t\tlabel: result.title,\n\t\t\t\t\t\t\ticon: result.icon\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\thandled = true;\n\t\t\t\t}\n\t\t\t} else if (this._integrationHelpers?.launchApp) {\n\t\t\t\tconst data: {\n\t\t\t\t\tapp: { appId?: string };\n\t\t\t\t} = result.data;\n\n\t\t\t\tif (data?.app?.appId) {\n\t\t\t\t\thandled = true;\n\t\t\t\t\tawait this._integrationHelpers.launchApp(data.app.appId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn handled;\n\t}\n\n\t/**\n\t * Get the results for the apps.\n\t * @param queryLower The query.\n\t * @param filters The filters to apply.\n\t * @param options The query options.\n\t * @param options.queryMinLength The minimum length before a query is actioned.\n\t * @param options.queryAgainst The fields in the data to query against.\n\t * @param options.isSuggestion Is the query from a suggestion.\n\t * @param cachedApps The cached apps.\n\t * @returns The search response.\n\t */\n\tprivate async getResults(\n\t\tqueryLower: string,\n\t\tfilters: CLIFilter[],\n\t\toptions: {\n\t\t\tqueryMinLength?: number;\n\t\t\tqueryAgainst?: string[];\n\t\t\tisSuggestion?: boolean;\n\t\t},\n\t\tcachedApps?: PlatformApp[]\n\t): Promise<HomeSearchResponse> {\n\t\tif (this._integrationHelpers?.getApps) {\n\t\t\tconst queryMinLength = options?.queryMinLength ?? 3;\n\t\t\tconst queryAgainst = options?.queryAgainst ?? [\"title\"];\n\n\t\t\tthis._lastQuery = queryLower;\n\t\t\tthis._lastQueryMinLength = queryMinLength;\n\t\t\tthis._lastQueryAgainst = queryAgainst;\n\t\t\tthis._lastCLIFilters = filters;\n\n\t\t\tlet apps: PlatformApp[] = cachedApps ?? (await this._integrationHelpers.getApps());\n\t\t\tlet matchQuery = queryLower;\n\n\t\t\tconst { favoriteClient, favoriteInfo } = await this.getFavInfo(FAVORITE_TYPE_NAME_APP);\n\n\t\t\tif (\n\t\t\t\tfavoriteInfo?.isEnabled &&\n\t\t\t\tisStringValue(favoriteInfo?.command) &&\n\t\t\t\tqueryLower === favoriteInfo.command &&\n\t\t\t\tfavoriteClient\n\t\t\t) {\n\t\t\t\tconst favoriteApps = await favoriteClient.getSavedFavorites(FAVORITE_TYPE_NAME_APP);\n\t\t\t\tconst favIds = favoriteApps?.map((f) => f.typeId) ?? [];\n\t\t\t\tapps = apps.filter((a) => favIds.includes(a.appId));\n\t\t\t\tmatchQuery = \"\";\n\t\t\t}\n\n\t\t\tthis._lastAppResults = apps;\n\t\t\tconst appSearchEntries = await this.mapAppEntriesToSearchEntries(apps);\n\n\t\t\tconst tags: string[] = [];\n\n\t\t\tif (appSearchEntries.length > 0) {\n\t\t\t\tconst finalResults = appSearchEntries.filter((entry) => {\n\t\t\t\t\tlet textMatchFound = true;\n\t\t\t\t\tlet filterMatchFound = true;\n\n\t\t\t\t\tconst isCommand = matchQuery.startsWith(\"/\");\n\n\t\t\t\t\tif (matchQuery.length >= queryMinLength || isCommand) {\n\t\t\t\t\t\ttextMatchFound = queryAgainst.some((target) => {\n\t\t\t\t\t\t\tconst entryObject = entry as unknown as {\n\t\t\t\t\t\t\t\t[id: string]: string | string[] | { [id: string]: string | string[] };\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconst path = target.split(\".\");\n\t\t\t\t\t\t\tif (path.length === 1) {\n\t\t\t\t\t\t\t\tconst targetValue: { [id: string]: string | string[] } | string | string[] | undefined =\n\t\t\t\t\t\t\t\t\tentryObject[path[0]];\n\n\t\t\t\t\t\t\t\tif (isStringValue(targetValue)) {\n\t\t\t\t\t\t\t\t\tconst lowerTarget = targetValue.toLowerCase();\n\t\t\t\t\t\t\t\t\tif (isCommand) {\n\t\t\t\t\t\t\t\t\t\treturn lowerTarget.startsWith(matchQuery);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn lowerTarget.includes(matchQuery);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (path.length === 2) {\n\t\t\t\t\t\t\t\tconst specifiedTarget = entryObject[path[0]] as { [id: string]: string | string[] };\n\n\t\t\t\t\t\t\t\tif (isObject(specifiedTarget)) {\n\t\t\t\t\t\t\t\t\tlet targetValue: string | string[] | undefined;\n\t\t\t\t\t\t\t\t\tif (!isEmpty(specifiedTarget)) {\n\t\t\t\t\t\t\t\t\t\ttargetValue = specifiedTarget[path[1]];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (isStringValue(targetValue)) {\n\t\t\t\t\t\t\t\t\t\tconst lowerTarget = targetValue.toLowerCase();\n\t\t\t\t\t\t\t\t\t\tif (isCommand) {\n\t\t\t\t\t\t\t\t\t\t\treturn lowerTarget.startsWith(matchQuery);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn lowerTarget.includes(matchQuery);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (Array.isArray(targetValue)) {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\ttargetValue.length > 0 &&\n\t\t\t\t\t\t\t\t\t\t\tisStringValue(targetValue[0]) &&\n\t\t\t\t\t\t\t\t\t\t\ttargetValue.some((mt) => mt.toLowerCase().startsWith(matchQuery))\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\t\t\t\t\t`Manifest configuration for search specified a queryAgainst target that is an array but not an array of strings. Only string values and arrays are supported: ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\t\t\tspecifiedTarget\n\t\t\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._logger?.warn(\n\t\t\t\t\t\t\t\t\t\"The manifest configuration for search has a queryAgainst entry that has a depth greater than 1. You can search for e.g. data.tags if data has tags in it and it is either a string or an array of strings\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tconst tagFilters = Array.isArray(filters)\n\t\t\t\t\t\t? filters.filter((f) => f.id === AppProvider._HOME_TAG_FILTERS)\n\t\t\t\t\t\t: [];\n\t\t\t\t\tif (tagFilters.length > 0) {\n\t\t\t\t\t\tfilterMatchFound = tagFilters.some((filter) => {\n\t\t\t\t\t\t\tif (Array.isArray(filter.options)) {\n\t\t\t\t\t\t\t\tif (!isEmpty(entry.data?.app?.tags)) {\n\t\t\t\t\t\t\t\t\treturn filter.options.every(\n\t\t\t\t\t\t\t\t\t\t(option) => !option.isSelected || entry.data.app.tags.includes(option.value)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (filter.options.isSelected && !isEmpty(entry.data?.app?.tags)) {\n\t\t\t\t\t\t\t\treturn entry.data.app.tags.includes(filter.options.value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (textMatchFound && Array.isArray(entry.data?.app?.tags)) {\n\t\t\t\t\t\ttags.push(...(entry.data.app.tags as string[]));\n\t\t\t\t\t}\n\t\t\t\t\treturn textMatchFound && filterMatchFound;\n\t\t\t\t});\n\n\t\t\t\tthis._lastResultIds = finalResults.map((entry) => entry.key);\n\n\t\t\t\treturn {\n\t\t\t\t\tresults: finalResults,\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\tfilters: this.getSearchFilters(tags.filter(Boolean))\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tthis._lastResultIds = [];\n\t\treturn {\n\t\t\tresults: [],\n\t\t\tcontext: {\n\t\t\t\tfilters: []\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Get search filters.\n\t * @param tags The tags to create the filters from.\n\t * @returns The filters.\n\t */\n\tprivate getSearchFilters(tags: string[]): CLIFilter[] {\n\t\tif (Array.isArray(tags)) {\n\t\t\tconst filters: CLIFilter[] = [];\n\t\t\tconst uniqueTags = [...new Set(tags)].sort((a, b) => a.localeCompare(b));\n\t\t\tconst tagFilter: CLIFilter = {\n\t\t\t\tid: AppProvider._HOME_TAG_FILTERS,\n\t\t\t\ttitle: \"Tags\",\n\t\t\t\ttype: \"MultiSelect\" as CLIFilterOptionType.MultiSelect,\n\t\t\t\toptions: []\n\t\t\t};\n\n\t\t\tfor (const tag of uniqueTags) {\n\t\t\t\tif (Array.isArray(tagFilter.options)) {\n\t\t\t\t\ttagFilter.options.push({\n\t\t\t\t\t\tvalue: tag,\n\t\t\t\t\t\tisSelected: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfilters.push(tagFilter);\n\t\t\treturn filters;\n\t\t}\n\t\treturn [];\n\t}\n\n\t/**\n\t * Maps platform apps to search results.\n\t * @param apps The apps to convert.\n\t * @returns The search results.\n\t */\n\tprivate async mapAppEntriesToSearchEntries(apps: PlatformApp[]): Promise<HomeSearchResult[]> {\n\t\tconst appResults: HomeSearchResult[] = [];\n\t\tif (Array.isArray(apps) && this._integrationHelpers) {\n\t\t\tlet savedFavorites: FavoriteEntry[] | undefined;\n\t\t\tconst { favoriteClient, favoriteInfo } = await this.getFavInfo(FAVORITE_TYPE_NAME_APP);\n\n\t\t\tif (favoriteClient) {\n\t\t\t\tsavedFavorites = await favoriteClient.getSavedFavorites(FAVORITE_TYPE_NAME_APP);\n\t\t\t}\n\n\t\t\tfor (const app of apps) {\n\t\t\t\tconst favoriteId = savedFavorites?.find((f) => f.typeId === app.appId)?.id;\n\t\t\t\tconst res = await this.mapAppEntryToSearchEntry(\n\t\t\t\t\tapp,\n\t\t\t\t\tthis._settings?.manifestTypeMapping,\n\t\t\t\t\tfavoriteInfo,\n\t\t\t\t\tfavoriteId\n\t\t\t\t);\n\t\t\t\tif (res) {\n\t\t\t\t\tappResults.push(res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn appResults;\n\t}\n\n\t/**\n\t * Map a single app to a search result.\n\t * @param app The app to map.\n\t * @param typeMapping The type mappings to include.\n\t * @param favInfo The favorites info if it is enabled.\n\t * @param favoriteId The id of the favorite.\n\t * @returns The search result.\n\t */\n\tprivate async mapAppEntryToSearchEntry(\n\t\tapp: PlatformApp,\n\t\ttypeMapping: AppManifestTypeMapping | undefined,\n\t\tfavInfo: FavoriteInfo | undefined,\n\t\tfavoriteId: string | undefined\n\t): Promise<HomeSearchResult | undefined> {\n\t\tconst manifestType = app.manifestType;\n\t\tif (isStringValue(manifestType)) {\n\t\t\tconst action = { name: \"Launch View\", hotkey: \"enter\" };\n\t\t\tconst entry: Partial<HomeSearchResult> = {\n\t\t\t\tkey: app.appId,\n\t\t\t\tscore: this._definition?.baseScore ?? AppProvider._DEFAULT_BASE_SCORE,\n\t\t\t\ttitle: app.title,\n\t\t\t\tdata: { app, providerId: this._providerId, favoriteId }\n\t\t\t};\n\n\t\t\tif (!isEmpty(typeMapping)) {\n\t\t\t\tconst manifestTypeMapping = typeMapping[manifestType as ManifestTypeId];\n\n\t\t\t\tif (!isEmpty(manifestTypeMapping)) {\n\t\t\t\t\tif (isStringValue(manifestTypeMapping.entryLabel)) {\n\t\t\t\t\t\tentry.label = manifestTypeMapping.entryLabel;\n\t\t\t\t\t}\n\t\t\t\t\tif (isStringValue(manifestTypeMapping.actionName)) {\n\t\t\t\t\t\taction.name = manifestTypeMapping.actionName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.actions = [action];\n\t\t\tentry.icon = this.getAppIcon(app);\n\n\t\t\tif (!isEmpty(app.description)) {\n\t\t\t\tentry.description = app.description;\n\t\t\t\tentry.shortDescription = app.description;\n\t\t\t}\n\n\t\t\tconst headerButtons: { icon: string; action: string }[] = [];\n\n\t\t\tif (favInfo?.favoriteIcon && favInfo.unfavoriteIcon && this._integrationHelpers) {\n\t\t\t\tconst themeClient = await this._integrationHelpers.getThemeClient();\n\n\t\t\t\tconst favoriteIcon = await themeClient.themeUrl(\n\t\t\t\t\t!isEmpty(favoriteId) ? favInfo.favoriteIcon : favInfo.unfavoriteIcon\n\t\t\t\t);\n\t\t\t\tif (favoriteIcon) {\n\t\t\t\t\theaderButtons.push({\n\t\t\t\t\t\ticon: favoriteIcon,\n\t\t\t\t\t\taction: !isEmpty(favoriteId) ? \"unfavorite\" : \"favorite\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.template = \"Custom\" as CLITemplate.Custom;\n\t\t\tentry.templateContent = await this._integrationHelpers?.templateHelpers.createApp(\n\t\t\t\tapp,\n\t\t\t\tentry.icon ?? \"\",\n\t\t\t\taction.name,\n\t\t\t\theaderButtons\n\t\t\t);\n\n\t\t\treturn entry as HomeSearchResult;\n\t\t}\n\t}\n\n\t/**\n\t * Get the icon for an application.\n\t * @param app The application to get the icon for.\n\t * @returns The icon.\n\t */\n\tprivate getAppIcon(app: PlatformApp): string | undefined {\n\t\tif (Array.isArray(app.icons) && app.icons.length > 0) {\n\t\t\treturn app.icons[0].src;\n\t\t}\n\t}\n\n\t/**\n\t * Rebuild the results if the theme changes.\n\t */\n\tprivate async rebuildResults(): Promise<void> {\n\t\tif (\n\t\t\t!isEmpty(this._lastResponse) &&\n\t\t\tArray.isArray(this._lastResultIds) &&\n\t\t\t!isEmpty(this._lastQuery) &&\n\t\t\t!isEmpty(this._lastCLIFilters) &&\n\t\t\t!isEmpty(this._lastQueryAgainst) &&\n\t\t\t!isEmpty(this._lastQueryMinLength) &&\n\t\t\t!isEmpty(this._lastResultIds)\n\t\t) {\n\t\t\tthis._logger?.info(\"Rebuilding results...\");\n\t\t\tconst lastResultIds = this._lastResultIds.slice();\n\t\t\tconst appResponse = await this.getResults(\n\t\t\t\tthis._lastQuery,\n\t\t\t\tthis._lastCLIFilters,\n\t\t\t\t{ queryMinLength: this._lastQueryMinLength, queryAgainst: this._lastQueryAgainst },\n\t\t\t\tthis._lastAppResults\n\t\t\t);\n\t\t\tconst removeResultIds = lastResultIds.filter((id) => !this._lastResultIds?.includes(id));\n\t\t\tif (removeResultIds.length > 0) {\n\t\t\t\tthis._lastResponse.revoke(...removeResultIds);\n\t\t\t}\n\t\t\tthis._lastResponse.respond(appResponse.results);\n\t\t\tthis._logger?.info(\"Results rebuilt.\");\n\t\t}\n\t}\n\n\t/**\n\t * Update the app buttons if the favorites have changed.\n\t * @param payload The payload of the favorite change.\n\t */\n\tprivate async updateAppFavoriteButtons(payload: FavoriteChangedLifecyclePayload): Promise<void> {\n\t\tconst favorite: FavoriteEntry = payload.favorite;\n\n\t\tif (\n\t\t\t!isEmpty(this._lastResponse) &&\n\t\t\t(payload.action === \"set\" || payload.action === \"delete\") &&\n\t\t\t!isEmpty(favorite) &&\n\t\t\tfavorite.type === FAVORITE_TYPE_NAME_APP &&\n\t\t\tthis._lastAppResults &&\n\t\t\tthis._integrationHelpers\n\t\t) {\n\t\t\tconst { favoriteInfo } = await this.getFavInfo(FAVORITE_TYPE_NAME_APP);\n\n\t\t\tif (this._lastQuery === favoriteInfo?.command && payload.action === \"delete\") {\n\t\t\t\tthis._lastResponse.revoke(favorite.typeId);\n\t\t\t} else if (this._lastAppResults) {\n\t\t\t\tlet lastApp = this._lastAppResults.find((a) => a.appId === favorite.typeId);\n\n\t\t\t\t// If it wasn't in the last results add it, but only if we are in fav command\n\t\t\t\tif (!lastApp && this._integrationHelpers?.getApp && this._lastQuery === favoriteInfo?.command) {\n\t\t\t\t\tlastApp = await this._integrationHelpers.getApp(favorite.typeId);\n\t\t\t\t}\n\n\t\t\t\tif (!isEmpty(lastApp)) {\n\t\t\t\t\tconst rebuilt = await this.mapAppEntryToSearchEntry(\n\t\t\t\t\t\tlastApp,\n\t\t\t\t\t\tthis._settings?.manifestTypeMapping,\n\t\t\t\t\t\tfavoriteInfo,\n\t\t\t\t\t\tpayload.action === \"set\" ? favorite.id : undefined\n\t\t\t\t\t);\n\n\t\t\t\t\tif (rebuilt) {\n\t\t\t\t\t\tthis._lastResponse.respond([rebuilt]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the favorite info and client if they are enabled.\n\t * @param favoriteTypeNames The type of client to get.\n\t * @returns The favorite info and client.\n\t */\n\tprivate async getFavInfo(\n\t\tfavoriteTypeNames: FavoriteTypeNames\n\t): Promise<{ favoriteClient: FavoriteClient | undefined; favoriteInfo: FavoriteInfo | undefined }> {\n\t\tlet favoriteInfo: FavoriteInfo | undefined;\n\t\tlet favoriteClient: FavoriteClient | undefined;\n\n\t\tif ((this._definition?.data?.favoritesEnabled ?? true) && this._integrationHelpers?.getFavoriteClient) {\n\t\t\tfavoriteClient = await this._integrationHelpers.getFavoriteClient();\n\t\t\tif (favoriteClient) {\n\t\t\t\tfavoriteInfo = favoriteClient.getInfo();\n\t\t\t\tif (favoriteInfo.isEnabled) {\n\t\t\t\t\tconst isSupported = favoriteInfo?.enabledTypes?.includes(favoriteTypeNames) ?? true;\n\t\t\t\t\tif (!isSupported) {\n\t\t\t\t\t\tfavoriteInfo = undefined;\n\t\t\t\t\t\tfavoriteClient = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tfavoriteClient,\n\t\t\tfavoriteInfo\n\t\t};\n\t}\n}\n","import { AppProvider } from \"./integration\";\n\nexport const entryPoints: { [id: string]: AppProvider } = {\n\tintegrations: new AppProvider()\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","FAVORITE_TYPE_NAME_APP","isEmpty","value","isStringValue","isString","trim","length","AppProvider","initialize","loggerCreator","helpers","this","_settings","data","_integrationHelpers","_definition","_logger","_providerId","id","subscribeLifecycleEvent","_themeChangedSubscriptionId","async","rebuildResults","_favChangedSubscriptionId","_","payload","updateAppFavoriteButtons","closedown","unsubscribeLifecycleEvent","undefined","getHelpSearchEntries","getSearchResults","query","filters","lastResponse","options","queryLower","toLowerCase","_lastResponse","getResults","itemSelection","result","handled","action","trigger","name","endsWith","app","favoriteClient","getFavInfo","startsWith","favoriteId","deleteSavedFavorite","setSavedFavorite","globalThis","crypto","randomUUID","replace","c","rnd","getRandomValues","Uint8Array","Number","toString","type","typeId","label","title","icon","launchApp","appId","cachedApps","getApps","queryMinLength","queryAgainst","_lastQuery","_lastQueryMinLength","_lastQueryAgainst","_lastCLIFilters","apps","matchQuery","favoriteInfo","isEnabled","command","favoriteApps","getSavedFavorites","favIds","map","f","filter","a","includes","_lastAppResults","appSearchEntries","mapAppEntriesToSearchEntries","tags","finalResults","entry","textMatchFound","filterMatchFound","isCommand","some","target","entryObject","path","split","targetValue","lowerTarget","specifiedTarget","Array","isArray","mt","warn","JSON","stringify","tagFilters","_HOME_TAG_FILTERS","every","option","isSelected","push","_lastResultIds","results","context","getSearchFilters","Boolean","uniqueTags","Set","sort","b","localeCompare","tagFilter","tag","appResults","savedFavorites","find","res","mapAppEntryToSearchEntry","manifestTypeMapping","typeMapping","favInfo","manifestType","hotkey","score","baseScore","_DEFAULT_BASE_SCORE","providerId","entryLabel","actionName","actions","getAppIcon","description","shortDescription","headerButtons","favoriteIcon","unfavoriteIcon","themeClient","getThemeClient","themeUrl","template","templateContent","templateHelpers","createApp","icons","src","info","lastResultIds","slice","appResponse","removeResultIds","revoke","respond","favorite","lastApp","getApp","rebuilt","favoriteTypeNames","favoritesEnabled","getFavoriteClient","getInfo","enabledTypes","entryPoints","integrations"],"sourceRoot":""}