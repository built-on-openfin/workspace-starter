var e={d:(t,r)=>{for(var o in r)e.o(r,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:r[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{k:()=>ot});var r={d:(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},o={};r.d(o,{MS:()=>D,_7:()=>je,cX:()=>J,zL:()=>Ue,_W:()=>M,p8:()=>N,YR:()=>ze,U$:()=>De,U7:()=>Je,OF:()=>Ne});var n={d:(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},i={};n.d(i,{MS:()=>a,cF:()=>s,AK:()=>d,M_:()=>c,cX:()=>l,Yd:()=>E,O4:()=>$,_W:()=>u,p8:()=>h,m$:()=>f,U$:()=>b,U7:()=>_,OV:()=>y,N7:()=>x,HP:()=>p,Rp:()=>K});class a extends Error{constructor(e,t){var r,o;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"An unexpected error has occurred"),this.name=this.constructor.name,this.stack=(e?this.stack:null!==(o=null==t?void 0:t.stack)&&void 0!==o?o:this.stack).replace(/^(\w*Error)/,`${this.constructor.name}`)}}class s extends a{constructor(e,t,r){var o;super(e=null!==(o=null!=e?e:null==r?void 0:r.message)&&void 0!==o?o:"An error occurred when executing the API request",r),this.status=t}}class c extends a{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"An authorization error occurred",t)}}class d extends a{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"The API request failed as the authorization tokens have expired",t)}}class l extends a{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"An initialization error occurred",t)}}class u extends a{constructor(e){super(e=null!=e?e:"Invalid parameter detected")}}class h extends a{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"A token validation error occurred",t)}}const p=()=>void 0!==crypto.randomUUID?crypto.randomUUID():"10000000-1000-4000-8000-100000000000".replace(/[018]/g,(e=>{const t=window.crypto.getRandomValues(new Uint8Array(1))[0]&15>>Number(e)/4;return(Number(e)^t).toString(16)})),g="oauth-api-auth-flow",w=(e,t,r,o,n,i,a,s)=>async d=>{const l=new URL(d);if(0!==l.href.toLowerCase().indexOf(n.toLowerCase()))return!1;if(window.clearInterval(s),window.clearTimeout(t),window.clearTimeout(r),e.removeAllListeners(),e.close(!0),l.searchParams.get("error")){const e=new c("Authorization error");return e.data=l.toString(),a(e),!0}if(l.searchParams.get("state")!==o){const e=new c("State mismatch");return e.data=l.toString(),a(e),!0}const u=l.searchParams.get("code");if(!u){const e=new c("Authorization code missing");return e.data=l.toString(),a(e),!0}return i(u),!0},f=async(e,t,r={})=>{const{defaultHeight:o,defaultWidth:n}=r;return t(await fin.Window.create(Object.assign({alwaysOnTop:!0,maximizable:!1,minimizable:!1,autoShow:!1,defaultCentered:!0,defaultHeight:null!=o?o:750,defaultWidth:null!=n?n:600,includeInSnapshots:!1,name:g,resizable:!1,saveWindowState:!1,showTaskbarIcon:!1,url:e},r)))},m=(e,t,r)=>o=>new Promise(((n,i)=>{let a;const s=window.setTimeout((()=>{window.clearInterval(a),window.clearTimeout(s),o.removeAllListeners(),o.close(!0),i(new c("Authorization timed out"))}),3e5);o.addListener("closing",(async()=>{r.logInfo("User closed auth window"),window.clearInterval(a),window.clearTimeout(s),o.removeAllListeners(),i(new c("Failed to complete authorization code flow"))}));const d=window.setTimeout((async()=>{try{await o.isShowing()||(r.logInfo("Showing auth window"),await o.show(!0),await o.focus())}catch(e){r.logWarning("Unable to show auth window")}}),2e3);(async()=>{const{version:l}=await fin.System.getRuntimeInfo();parseInt(l.split(".")[0],10)>=30?await w(o,s,d,e,t,n,i)((await o.getInfo()).url)||await o.addListener("url-changed",(a=>{r.logInfo("Auth window navigated to",a.url),w(o,s,d,e,t,n,i)(a.url)})):a=window.setInterval((()=>(async(e,t,r,o,n,i,a,s)=>{let d;try{d=await e.getInfo()}catch(e){return window.clearInterval(t),window.clearTimeout(r),window.clearTimeout(o),s(new c("Could not locate auth window")),!1}return w(e,r,o,n,i,a,s,t)(d.url)})(o,a,s,d,e,t,n,i)),500)})()})),y=async(e,t)=>{let r;null==t||t.logInfo("Retrieving authorization server metadata",e);try{r=new URL(e)}catch(e){throw new u("Unexpected invalid discovery URL")}const o=await fetch(r,{headers:{Accept:"application/json"}});if(!o.ok)throw new Error("Failed to retrieve authorization server metadata");const n=await o.json();if(!n)throw new Error("Unexpected empty authorization server metadata response");return null==t||t.logInfo("Retrieved authorization server metadata",n),n},v=e=>{let t=fin.Integrations;t||(fin.Integrations={},t=fin.Integrations);let r=t[e];return r||(t[e]={},r=t[e]),r},b=e=>{v(e).loggingEnabled=!1},_=(e,t="0.0.0")=>{v(e).loggingEnabled=!0,console.log(S(e),`v${t}`)},S=e=>`[@openfin/${e.toLowerCase()}]`;class E{constructor(e){this.name=e,this.prefix=S(e),this.isLoggingEnabled=this.isLoggingEnabled.bind(this),this.logError=this.logError.bind(this),this.logInfo=this.logInfo.bind(this),this.logWarning=this.logWarning.bind(this)}isLoggingEnabled(){return v(this.name).loggingEnabled}logError(e){this.isLoggingEnabled()&&(e.innerError?console.error(this.prefix,e,"\n\n(inner)",e.innerError):console.error(this.prefix,e))}logInfo(...e){this.isLoggingEnabled()&&console.log(this.prefix,...e)}logWarning(...e){this.isLoggingEnabled()&&console.warn(this.prefix,...e)}}const I=()=>{let e,t,r,o,n;const i=async(t,r=!1)=>{const{command:o,data:n,id:s}=t,c={command:o,id:s};try{if(!e)throw new Error("Access token not found");const{apiRequestUrl:o,data:s,headers:d,httpMethod:l,includeAuthorization:u}=n,h=await(async(t,r,o,n,i)=>{var a,s;const c=Object.assign({Accept:"application/json"},n);"PATCH"!==r&&"POST"!==r&&"PUT"!==r||/content-type/i.test(Object.keys(c).join(","))||(c["Content-Type"]="application/json"),i&&(c.Authorization=`Bearer ${e}`);const d=await fetch(t,{body:"object"==typeof o?JSON.stringify(o):o,headers:c,method:r});if(!d.ok){const e={message:"Failed to execute API request"};return(null===(a=d.headers.get("Content-Type"))||void 0===a?void 0:a.includes("application/json"))&&(e.data=await d.json()),[d.status,void 0,void 0,e]}let l;const u=null!==(s=d.headers.get("Content-Type"))&&void 0!==s?s:"";switch(!0){case!u:break;case/^application\/(\w+\+)?json/i.test(u):l=await d.json();break;case/^multipart\/form-?data|^application\/x-?www-?form-?urlencoded/i.test(u):l=await d.formData();break;case/^application\/(([^/]+)?xml|vnd\.openxmlformats)|^text\/|^image\/svg/i.test(u):l=await d.text();break;default:l=await d.arrayBuffer()}return[d.status,l,u,void 0]})(o,l,s,d,u),[p,g,w,f]=h;if(c.status=p,f){if(!r&&401===p){const[e,r]=await a();return r?(c.status=e,c.error=r,c):await i(t,!0)}c.error=f}else g&&(c.data=g,c.type=w)}catch(e){e instanceof Error?c.error={message:e.message}:c.error={message:"Failed to execute API request"}}return Promise.resolve(c)},a=async()=>{var r;if(!o)throw new Error("Authorization server metadata not set");if(!t)throw new Error("Client ID not set");const i=`grant_type=refresh_token&client_id=${t}&refresh_token=${n}`,a=await fetch(o.token_endpoint,{body:i,headers:{Accept:"application/json","Content-Type":"application/x-www-form-urlencoded"},method:"POST"});if(!a.ok){const e={message:"Failed to refresh access token"};return(null===(r=a.headers.get("Content-Type"))||void 0===r?void 0:r.includes("application/json"))&&(e.data=await a.json()),[a.status,e]}const s=await a.json();return e=s.access_token,[a.status]};self.onmessage=async a=>{const{command:s,id:c}=a.data;let d={command:s,id:c};switch(s){case"API_REQUEST":d=await i(a.data);break;case"CODE_EXCHANGE":d=await(async i=>{var a;const{command:s,data:c,id:d}=i,l={command:s,id:d};try{if(!o)throw new Error("Authorization server metadata not set");if(!t)throw new Error("Client ID not set");const{code:i,codeVerifier:s,redirectUri:d}=c,u=`grant_type=authorization_code&client_id=${t}&code=${i}&code_verifier=${s}&redirect_uri=${d}`,h=await fetch(o.token_endpoint,{body:u,headers:{Accept:"application/json","Content-Type":"application/x-www-form-urlencoded"},method:"POST"});if(h.ok){const t=await h.json();e=t.access_token,r=t.id_token,n=t.refresh_token}else{const e={message:"Failed to retrieve tokens"};(null===(a=h.headers.get("Content-Type"))||void 0===a?void 0:a.includes("application/json"))&&(e.data=await h.json()),l.error=e}}catch(e){e instanceof Error?l.error={message:e.message}:l.error={message:"Failed to retrieve tokens"}}return Promise.resolve(l)})(a.data);break;case"EXPIRE_TOKENS":d=await(async r=>{var i;const{command:a,expireAccessTokenOnly:s,id:c}=r,d={command:a,id:c};try{if(!o)throw new Error("Authorization server metadata not set");if(!o.revocation_endpoint)throw new Error("Revocation endpoint missing in authorization server metadata");if(!s&&!n)throw new Error("Refresh token not found");const r=o.revocation_endpoint;let a,c=!1;const l={body:`client_id=${t}`,headers:{Accept:"application/json","Content-Type":"application/x-www-form-urlencoded"},method:"POST"};if(s){const t=await fetch(r,Object.assign(Object.assign({},l),{body:`${l.body}&token=${e}&token_type_hint=access_token`}));t.ok||(c=!0,(null===(i=t.headers.get("Content-Type"))||void 0===i?void 0:i.includes("application/json"))&&(a=await t.json()))}else{const t=(await Promise.all([await fetch(r,Object.assign(Object.assign({},l),{body:`${l.body}&token=${e}&token_type_hint=access_token`})),await fetch(r,Object.assign(Object.assign({},l),{body:`${l.body}&token=${n}&token_type_hint=refresh_token`}))])).filter((e=>!e.ok));t.length&&(c=!0,a=await t[0].json())}if(c){const e={data:a,message:"Failed to expire tokens"};d.error=e}}catch(e){e instanceof Error?d.error={message:e.message}:d.error={message:"Failed to expire tokens"}}return Promise.resolve(d)})(a.data);break;case"GET_ID_TOKEN":l=a.data,d=Object.assign(Object.assign({},l),{idToken:r});break;case"INIT":d=await(async e=>{const{command:r,data:n,id:i}=e,a={command:r,id:i};return t=n.clientId,o=n.metadata,Promise.resolve(a)})(a.data);break;default:d.error=new Error(`Unexpected oauth worker command: ${s}`)}var l;self.postMessage(d)}};var k;!function(e){e.ApiRequest="API_REQUEST",e.CodeExchange="CODE_EXCHANGE",e.ExpireTokens="EXPIRE_TOKENS",e.GetIdToken="GET_ID_TOKEN",e.Init="INIT"}(k||(k={}));const A=[],T=e=>{A.push(e)},R=(e,t)=>(r,o,n)=>new Promise(((i,a)=>{const s={command:k.CodeExchange,data:{code:r,codeVerifier:o,redirectUri:n},id:p()},{command:c,id:d}=s;T({command:c,id:d,reject:a,resolve:i}),e.postMessage(s),t.logInfo("Worker request sent",s)})),O=(e,t,r)=>(o,n,i,a,s)=>new Promise(((c,d)=>{const l={command:k.ApiRequest,data:{apiRequestUrl:o,clientId:e,data:i,headers:a,httpMethod:n,includeAuthorization:s},id:p()},{command:u,id:h}=l;T({command:u,id:h,reject:d,resolve:c}),t.postMessage(l),r.logInfo("Worker request sent",l)})),P=(e,t)=>r=>new Promise(((o,n)=>{const i={command:k.ExpireTokens,expireAccessTokenOnly:r,id:p()},{command:a,id:s}=i;T({command:a,id:s,reject:n,resolve:o}),e.postMessage(i),t.logInfo("Worker request sent",i)})),C=(e,t)=>async()=>(await new Promise(((r,o)=>{const n={command:k.GetIdToken,id:p()},{command:i,id:a}=n;T({command:i,id:a,reject:o,resolve:r}),e.postMessage(n),t.logInfo("Worker request sent",n)}))).idToken,x=async(e,t,r)=>{const o=new Blob([`(${I})()`],{type:"text/javascript"}),n=URL.createObjectURL(o),i=new Worker(n);return i.onmessage=W(r),await((e,t,r,o)=>new Promise(((n,i)=>{const a={command:k.Init,data:{clientId:t,metadata:e},id:p()},{command:s,id:c}=a;T({command:s,id:c,reject:i,resolve:n}),r.postMessage(a),o.logInfo("Worker request sent",a)})))(e,t,i,r),{exchangeCodeForTokens:R(i,r),executeApiRequest:O(t,i,r),expireTokens:P(i,r),getIdToken:C(i,r),terminate:U(i,r)}},W=e=>t=>{e.logInfo("Worker response received",t.data);const r=t.data,{command:o,error:n,id:i}=r,a=function(e,t){var r={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(r[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(o=Object.getOwnPropertySymbols(e);n<o.length;n++)t.indexOf(o[n])<0&&Object.prototype.propertyIsEnumerable.call(e,o[n])&&(r[o[n]]=e[o[n]])}return r}(r,["command","error","id"]),s=((e,t)=>A.find((r=>r.command===t&&r.id===e)))(i,o);s?(n?("status"in a&&void 0!==a.status&&(n.status=a.status),s.reject(n)):s.resolve(a),j(i,o)):e.logError(new Error("Unable to locate awaited request"))},j=(e,t)=>{const r=A.findIndex((r=>r.command===t&&r.id===e));r>=0&&A.splice(r,1)},U=(e,t)=>async()=>{try{await P(e,t)(!1)}catch(e){t.logWarning(e.message)}e.terminate(),t.logInfo("Worker terminated")};class ${get apiOrigin(){return this._apiOrigin}get clientId(){return this._clientId}get logger(){return this._logger}get metadata(){return this._metadata}get worker(){return this._worker}constructor(e,t,r,o,n){if(this.executeApiRequest=async(e,t="GET",r,o,n=!0,i=!1)=>{this._logger.logInfo("ExecuteApiRequest started",e,t,r,o);try{const i=await((e,t)=>async(r,o,n,i,a)=>{try{return await t.executeApiRequest(`${e}${r}`,o,n,i,a)}catch(e){let t;const{data:r,message:o,status:n}=e;throw t=e instanceof Error?new s(o,n):"Failed to refresh access token"===o?new d(o):new s(o,n),t.data=r,t}})(this._apiOrigin,this._worker)(e,t,r,o,n);return this._logger.logInfo("ExecuteApiRequest completed",i),i}catch(e){if(e instanceof s){const{data:t,message:r,name:o,stack:n}=e,i=this.getErrorMessageFromServerResponse(t);i&&(e.message=i,e.stack=null==n?void 0:n.replace(`${o}: ${r}`,`${o}: ${i}`))}throw i&&this.logger.logError(e),e}},!(t&&r&&o&&n))throw new l("Provider has not been properly initialized (call init to create new instances)");this._apiOrigin=null!=e?e:"",this._clientId=t,this._metadata=r,this._worker=o,this._logger=n,this.authorize=this.authorize.bind(this),this.close=this.close.bind(this),this.executeApiRequest=this.executeApiRequest.bind(this),this.expireTokens=this.expireTokens.bind(this),this.getErrorMessageFromServerResponse=this.getErrorMessageFromServerResponse.bind(this),this.getIdToken=this.getIdToken.bind(this)}async authorize(e,t,r){this._logger.logInfo("Authorize started",e,t,r);try{await(o=this._metadata,n=this._clientId,i=this._worker,s=this._logger,async(e,t={},r={})=>{const{authorization_endpoint:a}=o,c=fin.Application.getCurrentSync(),d=(await c.getChildWindows()).find((e=>e.identity.name===g));d&&await d.close(!0);const l=p(),u=(()=>{const e=new Uint32Array(64);return window.crypto.getRandomValues(e),Array.from(e,(e=>`0${e.toString(16)}`.slice(-2))).join("")})(),h=(await(async e=>{const t=(new TextEncoder).encode(e),r=await window.crypto.subtle.digest("SHA-256",t),o=await(e=>new Promise(((t,r)=>{try{const o=new Blob([e]),n=new FileReader;n.onload=e=>{var o,n;const i=null===(o=e.target)||void 0===o?void 0:o.result;if(i){const[,e]=Array.from(null!==(n=i.match(/base64,(.*)$/i))&&void 0!==n?n:[]);t(null!=e?e:"")}r(new Error("Unexpected empty result"))},n.readAsDataURL(o)}catch(e){r(e)}})))(r);return o.replace(/\+/g,"-").replace(/\//g,"_")})(u)).replace(/=+$/,""),w=new URL(a);w.searchParams.set("client_id",n),w.searchParams.set("redirect_uri",e),w.searchParams.set("response_type","code"),w.searchParams.set("state",l),w.searchParams.set("code_challenge",h),w.searchParams.set("code_challenge_method","S256"),Object.entries(t).forEach((e=>w.searchParams.set(e[0],e[1]))),s.logInfo("Starting OAuth flow",w,r);const y=await f(w.toString(),m(l,e,s),r);s.logInfo("Received authorization code"),await i.exchangeCodeForTokens(y,u,e),s.logInfo("Received tokens")})(e,t,r),this._logger.logInfo("Authorize completed")}catch(e){let t;if(e instanceof a){const{data:r}=e,o=this.getErrorMessageFromServerResponse(r);t=new c(o,e),t.data=r}else t=new c(void 0,e);throw this.logger.logError(t),t}var o,n,i,s}async close(){var e;this._logger.logInfo("Close started");try{await(null===(e=this._worker)||void 0===e?void 0:e.terminate()),this._worker=void 0,this._apiOrigin=void 0,this._clientId=void 0,this._metadata=void 0,this._logger.logInfo("Close completed")}catch(e){const t=new a(void 0,e);throw this._logger.logError(t),t}}async expireTokens(e=!1){var t;this._logger.logInfo("ExpireTokens started");try{await(null===(t=this._worker)||void 0===t?void 0:t.expireTokens(e)),this._logger.logInfo("ExpireTokens completed")}catch(e){const t=new a(void 0,e);throw this._logger.logError(t),t}}getErrorMessageFromServerResponse(e){e&&this._logger.logWarning(e)}async getIdToken(){var e;this._logger.logInfo("GetIdToken started");try{const t=await(null===(e=this._worker)||void 0===e?void 0:e.getIdToken());return this._logger.logInfo("GetIdToken completed",t),t}catch(e){const t=new a(void 0,e);throw this._logger.logError(t),t}}static async init(e,t,r,o,...n){const i=new E(o);i.logInfo("Init started",e,t,r);try{let o;if("discoveryEndpoint"in e){const{additionalMetadata:t,discoveryEndpoint:r}=e;o=Object.assign(Object.assign({},await y(r)),null!=t?t:{})}else o=e;if(!o.response_types_supported.find((e=>"code"===e.toLowerCase())))throw new l("Authorization server does not support the authorization code response type");const n=await x(o,r,i),a=new $(t,r,o,n,i);return i.logInfo("Init completed",a),a}catch(e){let t;throw t=e instanceof a?e:new l(void 0,e),i.logError(t),t}}}const K=e=>async(t,r,o)=>{let n;null==e||e.logInfo("Validating token against introspection endpoint",t,r,o);try{n=await fetch(o,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:`token=${t}&client_id=${r}`})}catch(e){throw new h(void 0,e)}if(n.ok){const t=await n.json(),{active:r}=t,o=function(e,t){var r={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(r[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(o=Object.getOwnPropertySymbols(e);n<o.length;n++)t.indexOf(o[n])<0&&Object.prototype.propertyIsEnumerable.call(e,o[n])&&(r[o[n]]=e[o[n]])}return r}(t,["active"]),i=Object.assign({valid:r},o);return null==e||e.logInfo("Token validation result",i),i}const i=await n.json();throw null==e||e.logWarning("Token Validation failed",i),new h};var D=i.MS,J=i.cX,H=i.Yd,L=i.O4,M=i._W,N=i.p8,F=i.m$,z=i.U$,q=i.U7,G=i.OV,V=i.N7,B=i.Rp;const X=new TextEncoder,Y=new TextDecoder,Q=e=>{let t=e;t instanceof Uint8Array&&(t=Y.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r})(t)}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};class Z extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null===(t=Error.captureStackTrace)||void 0===t||t.call(Error,this,this.constructor)}}class ee extends Z{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=t,this.reason=r}}class te extends Z{static get code(){return"ERR_JWT_EXPIRED"}constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_EXPIRED",this.claim=t,this.reason=r}}class re extends Z{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class oe extends Z{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class ne extends Z{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class ie extends Z{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class ae extends Z{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}static get code(){return"ERR_JWKS_INVALID"}}class se extends Z{constructor(){super(...arguments),this.code="ERR_JWKS_NO_MATCHING_KEY",this.message="no applicable key found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_NO_MATCHING_KEY"}}class ce extends Z{constructor(){super(...arguments),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS",this.message="multiple matching keys found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}Symbol.asyncIterator;class de extends Z{constructor(){super(...arguments),this.code="ERR_JWKS_TIMEOUT",this.message="request timed out"}static get code(){return"ERR_JWKS_TIMEOUT"}}class le extends Z{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}const ue=crypto,he=e=>e instanceof CryptoKey;ue.getRandomValues.bind(ue);const pe=async e=>{var t,r;if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:o,keyUsages:n}=function(e){let t,r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.slice(-3)}`},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new oe(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new oe('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new oe('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new oe('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new oe('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new oe('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),i=[o,null!==(t=e.ext)&&void 0!==t&&t,null!==(r=e.key_ops)&&void 0!==r?r:n];if("PBKDF2"===o.name)return ue.subtle.importKey("raw",Q(e.k),...i);const a={...e};return delete a.alg,delete a.use,ue.subtle.importKey("jwk",a,...i)};function ge(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}function we(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function fe(e,t){return e.name===t}function me(e){return parseInt(e.name.slice(4),10)}function ye(e,t,...r){if(r.length>2){const t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else 2===r.length?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor&&t.constructor.name&&(e+=` Received an instance of ${t.constructor.name}`),e}Symbol();const ve=(e,...t)=>ye("Key must be ",e,...t);function be(e,t,...r){return ye(`Key for the ${e} algorithm must be `,t,...r)}const _e=e=>he(e),Se=["CryptoKey"];async function Ee(e,t,r){if(e instanceof Uint8Array&&(e=Y.decode(e)),"string"!=typeof e)throw new ne("Compact JWS must be a string or Uint8Array");const{0:o,1:n,2:i,length:a}=e.split(".");if(3!==a)throw new ne("Invalid Compact JWS");const s=await async function(e,t,r){var o;if(!ge(e))throw new ne("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new ne('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new ne("JWS Protected Header incorrect type");if(void 0===e.payload)throw new ne("JWS Payload missing");if("string"!=typeof e.signature)throw new ne("JWS Signature missing or incorrect type");if(void 0!==e.header&&!ge(e.header))throw new ne("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const t=Q(e.protected);n=JSON.parse(Y.decode(t))}catch(e){throw new ne("JWS Protected Header is invalid")}if(!((...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0})(n,e.header))throw new ne("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...n,...e.header};let a=!0;if(function(e,t,r,o,n){if(void 0!==n.crit&&void 0===o.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!o||void 0===o.crit)return new Set;if(!Array.isArray(o.crit)||0===o.crit.length||o.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;i=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of o.crit){if(!i.has(t))throw new oe(`Extension Header Parameter "${t}" is not recognized`);if(void 0===n[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(i.get(t)&&void 0===o[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(o.crit)}(ne,new Map([["b64",!0]]),null==r?void 0:r.crit,n,i).has("b64")&&(a=n.b64,"boolean"!=typeof a))throw new ne('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=i;if("string"!=typeof s||!s)throw new ne('JWS "alg" (Algorithm) Header Parameter missing or invalid');const c=r&&((e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError('"algorithms" option must be an array of strings');if(t)return new Set(t)})(0,r.algorithms);if(c&&!c.has(s))throw new re('"alg" (Algorithm) Header Parameter not allowed');if(a){if("string"!=typeof e.payload)throw new ne("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new ne("JWS Payload must be a string or an Uint8Array instance");let d=!1;"function"==typeof t&&(t=await t(n,e),d=!0),((e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!_e(t))throw new TypeError(be(e,t,...Se,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${Se.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,r)=>{if(!_e(t))throw new TypeError(be(e,t,...Se));if("secret"===t.type)throw new TypeError(`${Se.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if(t.algorithm&&"private"===t.type)throw new TypeError(`${Se.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);t.algorithm})(e,t)})(s,t);const l=function(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let o=0;return e.forEach((e=>{r.set(e,o),o+=e.length})),r}(X.encode(null!==(o=e.protected)&&void 0!==o?o:""),X.encode("."),"string"==typeof e.payload?X.encode(e.payload):e.payload),u=Q(e.signature);if(!await(async(e,t,r,o)=>{const n=await function(e,t,r){if(he(t))return function(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!fe(e.algorithm,"HMAC"))throw we("HMAC");const r=parseInt(t.slice(2),10);if(me(e.algorithm.hash)!==r)throw we(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!fe(e.algorithm,"RSASSA-PKCS1-v1_5"))throw we("RSASSA-PKCS1-v1_5");const r=parseInt(t.slice(2),10);if(me(e.algorithm.hash)!==r)throw we(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!fe(e.algorithm,"RSA-PSS"))throw we("RSA-PSS");const r=parseInt(t.slice(2),10);if(me(e.algorithm.hash)!==r)throw we(`SHA-${r}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw we("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!fe(e.algorithm,"ECDSA"))throw we("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw we(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}!function(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}(e,r)}(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(ve(t,...Se));return ue.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(ve(t,...Se,"Uint8Array"))}(e,t,"verify");((e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}})(e,n);const i=function(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new oe(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}(e,n.algorithm);try{return await ue.subtle.verify(i,n,r,o)}catch(e){return!1}})(s,t,u,l))throw new le;let h;h=a?Q(e.payload):"string"==typeof e.payload?X.encode(e.payload):e.payload;const p={payload:h};return void 0!==e.protected&&(p.protectedHeader=n),void 0!==e.header&&(p.unprotectedHeader=e.header),d?{...p,key:t}:p}({payload:n,protected:o,signature:i},t,r),c={payload:s.payload,protectedHeader:s.protectedHeader};return"function"==typeof t?{...c,key:s.key}:c}const Ie=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i,ke=e=>{const t=Ie.exec(e);if(!t)throw new TypeError("Invalid time period format");const r=parseFloat(t[1]);switch(t[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(60*r);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(3600*r);case"day":case"days":case"d":return Math.round(86400*r);case"week":case"weeks":case"w":return Math.round(604800*r);default:return Math.round(31557600*r)}},Ae=e=>e.toLowerCase().replace(/^application\//,""),Te=(e,t,r={})=>{const{typ:o}=r;if(o&&("string"!=typeof e.typ||Ae(e.typ)!==Ae(o)))throw new ee('unexpected "typ" JWT header value',"typ","check_failed");let n;try{n=JSON.parse(Y.decode(t))}catch(e){}if(!ge(n))throw new ie("JWT Claims Set must be a top-level JSON object");const{requiredClaims:i=[],issuer:a,subject:s,audience:c,maxTokenAge:d}=r;void 0!==d&&i.push("iat"),void 0!==c&&i.push("aud"),void 0!==s&&i.push("sub"),void 0!==a&&i.push("iss");for(const e of new Set(i.reverse()))if(!(e in n))throw new ee(`missing required "${e}" claim`,e,"missing");if(a&&!(Array.isArray(a)?a:[a]).includes(n.iss))throw new ee('unexpected "iss" claim value',"iss","check_failed");if(s&&n.sub!==s)throw new ee('unexpected "sub" claim value',"sub","check_failed");if(c&&(u="string"==typeof c?[c]:c,!("string"==typeof(l=n.aud)?u.includes(l):Array.isArray(l)&&u.some(Set.prototype.has.bind(new Set(l))))))throw new ee('unexpected "aud" claim value',"aud","check_failed");var l,u;let h;switch(typeof r.clockTolerance){case"string":h=ke(r.clockTolerance);break;case"number":h=r.clockTolerance;break;case"undefined":h=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:p}=r,g=(w=p||new Date,Math.floor(w.getTime()/1e3));var w;if((void 0!==n.iat||d)&&"number"!=typeof n.iat)throw new ee('"iat" claim must be a number',"iat","invalid");if(void 0!==n.nbf){if("number"!=typeof n.nbf)throw new ee('"nbf" claim must be a number',"nbf","invalid");if(n.nbf>g+h)throw new ee('"nbf" claim timestamp check failed',"nbf","check_failed")}if(void 0!==n.exp){if("number"!=typeof n.exp)throw new ee('"exp" claim must be a number',"exp","invalid");if(n.exp<=g-h)throw new te('"exp" claim timestamp check failed',"exp","check_failed")}if(d){const e=g-n.iat;if(e-h>("number"==typeof d?d:ke(d)))throw new te('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(e<0-h)throw new ee('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return n};function Re(e){return e&&"object"==typeof e&&Array.isArray(e.keys)&&e.keys.every(Oe)}function Oe(e){return ge(e)}class Pe{constructor(e){if(this._cached=new WeakMap,!Re(e))throw new ae("JSON Web Key Set malformed");var t;this._jwks=(t=e,"function"==typeof structuredClone?structuredClone(t):JSON.parse(JSON.stringify(t)))}async getKey(e,t){const{alg:r,kid:o}={...e,...null==t?void 0:t.header},n=function(e){switch("string"==typeof e&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new oe('Unsupported "alg" value for a JSON Web Key Set')}}(r),i=this._jwks.keys.filter((e=>{let t=n===e.kty;if(t&&"string"==typeof o&&(t=o===e.kid),t&&"string"==typeof e.alg&&(t=r===e.alg),t&&"string"==typeof e.use&&(t="sig"===e.use),t&&Array.isArray(e.key_ops)&&(t=e.key_ops.includes("verify")),t&&"EdDSA"===r&&(t="Ed25519"===e.crv||"Ed448"===e.crv),t)switch(r){case"ES256":t="P-256"===e.crv;break;case"ES256K":t="secp256k1"===e.crv;break;case"ES384":t="P-384"===e.crv;break;case"ES512":t="P-521"===e.crv}return t})),{0:a,length:s}=i;if(0===s)throw new se;if(1!==s){const e=new ce,{_cached:t}=this;throw e[Symbol.asyncIterator]=async function*(){for(const e of i)try{yield await Ce(t,e,r)}catch(e){continue}},e}return Ce(this._cached,a,r)}}async function Ce(e,t,r){const o=e.get(t)||e.set(t,{}).get(t);if(void 0===o[r]){const e=await async function(e,t,r){var o;if(!ge(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=r||(r=!0!==e.ext),r?pe({...e,alg:t,ext:null!==(o=e.ext)&&void 0!==o&&o}):Q(e.k);case"RSA":if(void 0!==e.oth)throw new oe('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return pe({...e,alg:t});default:throw new oe('Unsupported "kty" (Key Type) Parameter value')}}({...t,ext:!0},r);if(e instanceof Uint8Array||"public"!==e.type)throw new ae("JSON Web Key Set members must be public keys");o[r]=e}return o[r]}class xe extends Pe{constructor(e,t){if(super({keys:[]}),this._jwks=void 0,!(e instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(e.href),this._options={agent:null==t?void 0:t.agent,headers:null==t?void 0:t.headers},this._timeoutDuration="number"==typeof(null==t?void 0:t.timeoutDuration)?null==t?void 0:t.timeoutDuration:5e3,this._cooldownDuration="number"==typeof(null==t?void 0:t.cooldownDuration)?null==t?void 0:t.cooldownDuration:3e4,this._cacheMaxAge="number"==typeof(null==t?void 0:t.cacheMaxAge)?null==t?void 0:t.cacheMaxAge:6e5}coolingDown(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cooldownDuration}fresh(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cacheMaxAge}async getKey(e,t){this._jwks&&this.fresh()||await this.reload();try{return await super.getKey(e,t)}catch(r){if(r instanceof se&&!1===this.coolingDown())return await this.reload(),super.getKey(e,t);throw r}}async reload(){this._pendingFetch&&("undefined"!=typeof WebSocketPair||"undefined"!=typeof navigator&&"Cloudflare-Workers"===navigator.userAgent||"undefined"!=typeof EdgeRuntime&&"vercel"===EdgeRuntime)&&(this._pendingFetch=void 0),this._pendingFetch||(this._pendingFetch=(async(e,t,r)=>{let o,n,i=!1;"function"==typeof AbortController&&(o=new AbortController,n=setTimeout((()=>{i=!0,o.abort()}),t));const a=await fetch(e.href,{signal:o?o.signal:void 0,redirect:"manual",headers:r.headers}).catch((e=>{if(i)throw new de;throw e}));if(void 0!==n&&clearTimeout(n),200!==a.status)throw new Z("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await a.json()}catch(e){throw new Z("Failed to parse the JSON Web Key Set HTTP response as JSON")}})(this._url,this._timeoutDuration,this._options).then((e=>{if(!Re(e))throw new ae("JSON Web Key Set malformed");this._jwks={keys:e.keys},this._jwksTimestamp=Date.now(),this._pendingFetch=void 0})).catch((e=>{throw this._pendingFetch=void 0,e}))),await this._pendingFetch}}const We=Q;class je extends D{constructor(e,t){super(e=e??t?.message??"An error occurred during authentication",t)}}class Ue extends D{constructor(e,t){super(e=e??t?.message??"An error occurred during logout",t)}}const $e="1.0.0",Ke="OIDC",De=()=>{z(Ke)},Je=()=>{q(Ke,$e)};"undefined"!=typeof window&&("undefined"==typeof fin&&Object.assign(window,{fin:{}}),Object.assign(fin,{Integrations:{OIDC:{enableLogging:Je,disableLogging:De}}}));const He=e=>`${e.replace(/\/$/,"")}/.well-known/openid-configuration`;var Le;(Le||(Le={})).OpenIdConnect="OpenID-Connect";class Me extends L{get idToken(){return this._idToken}get openIdProviderUrl(){return this._openIdProviderUrl}get redirectUri(){return this._redirectUri}get scope(){return this._scope}get userInfo(){return this._userInfo}async authorize(e,t,r){await super.authorize(e,t,r),this._idToken=await this.getIdToken(),this._userInfo=await(async e=>{const t=e.metadata?.userinfo_endpoint;if(!t)return;const{data:r}=await e.executeApiRequest(t);return r})(this)}async close(){await super.close(),this._idToken=void 0,this._openIdProviderUrl=void 0,this._redirectUri=void 0,this._scope=void 0,this._userInfo=void 0}getErrorMessageFromServerResponse(e){return e}static async init(e,t,r,o,n,i,a){const s=new H(o);s.logInfo("Init started",e,t,r,o,n,i,a);try{const{additionalMetadata:t,discoveryEndpoint:o}=e,c={...await G(o),...t??{}};if(!c.response_types_supported.find((e=>"code"===e.toLowerCase())))throw new J("OpenID Provider does not support the authorization code response type");const d=await V(c,r,s),l=new Me(void 0,r,c,d,s);return l._openIdProviderUrl=n,l._redirectUri=i,l._scope=a,s.logInfo("Init completed",l),(async(e,t)=>{try{await fin.System.registerUsage({type:"integration-feature",data:{apiVersion:$e,componentName:e}})}catch(r){t.logWarning(`Unable to register usage for feature ${e}: ${r?.message}`)}})(Le.OpenIdConnect,s),l}catch(e){let t;throw t=e instanceof D?e:new J(void 0,e),s.logError(t),t}}}const Ne=async(e,t,r)=>{const o=new H(Ke),n=He(r);let i;try{i=await G(n)}catch(e){const t=new N(`Failed to retrieve OpenID Connect metadata from ${n}`);throw o.logError(t),t}const{introspection_endpoint:a,jwks_uri:s}=i;if(a)try{return await B(o)(e,t,a)}catch(e){}else o?.logWarning("No introspection endpoint found in OpenID Connect metadata");if(!s){const e=new N(`Failed to retrieve JSON Web Key Set (JWKS) from ${s}`);throw o.logError(e),e}o?.logInfo("Validating id token against JWKS endpoint",s);try{const{payload:n}=await async function(e,t,r){var o;const n=await Ee(e,t,r);if((null===(o=n.protectedHeader.crit)||void 0===o?void 0:o.includes("b64"))&&!1===n.protectedHeader.b64)throw new ie("JWTs MUST NOT use unencoded payload");const i={payload:Te(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return"function"==typeof t?{...i,key:n.key}:i}(e,function(e,t){const r=new xe(e,void 0);return async function(e,t){return r.getKey(e,t)}}(new URL(s)),{audience:t,issuer:r});return o?.logInfo("ID token validation successful",n),{valid:!0,...n}}catch(e){if(!(e instanceof ee||e instanceof te||e instanceof ie||e instanceof le)){const t=new N(void 0,e);throw o.logError(t),t}return o.logWarning(`ID token validation failed: ${e.message}`),{valid:!1}}},Fe=["openid","profile","email"],ze=async(e,t,r,o=[],n,i,a)=>{if(e=e?.trim().replace(/\/$/,""),!e)throw new M("OpenID Provider URL must be a non-empty string");if(!t)throw new M("Client Identifier must be a non-empty string");if(!r)throw new M("Redirection URI must be a non-empty string");const s=await Ge(e,t,r,o,n);if(!s)throw new J("Provider not initialized");const c=s.metadata?.scopes_supported;if(!c){const e=new je("OpenID Provider metadata does not define supported scopes");throw s.logger.logError(e),e}const d=Fe.filter((e=>!c.includes(e)));if(d.length>0){const e=new je(`OpenID Provider does not support required scopes: ${d.join(", ")}`);throw s.logger.logError(e),e}const l=new Set([...Fe,...o]);await s.authorize(r,{display:"popup",scope:[...l].join(" "),...i},a);const{idToken:u}=s;if(!u){const e=new je("No ID token returned");throw s.logger.logError(e),e}const h=function(e){if("string"!=typeof e)throw new ie("JWTs must use Compact JWS serialization, JWT must be a string");const{1:t,length:r}=e.split(".");if(5===r)throw new ie("Only JWTs using Compact JWS serialization can be decoded");if(3!==r)throw new ie("Invalid JWT");if(!t)throw new ie("JWTs must contain a payload");let o,n;try{o=We(t)}catch(e){throw new ie("Failed to parse the base64url encoded payload")}try{n=JSON.parse(Y.decode(o))}catch(e){throw new ie("Failed to parse the decoded payload as JSON")}if(!ge(n))throw new ie("Invalid JWT Claims Set");return n}(u);if(!h){const e=new je("Failed to decode ID token");throw s.logger.logError(e),e}const{aud:p,iss:g}=h;return await Ne(u,Array.isArray(p)?p[0]:p,g),{claims:h,clientId:t,idToken:u,logout:Ve(t,u,s),openIdProviderUrl:e,userInfo:s.userInfo}},qe=(e,t,r,o,n,i)=>async n=>{if(0!==new URL(n).href.toLowerCase().indexOf(r.toLowerCase()))return!1;window.clearInterval(i),window.clearTimeout(t);try{e.removeAllListeners(),e.close(!0)}catch(e){}return o(),!0},Ge=async(e,t,r,o,n)=>{const i={additionalMetadata:n,discoveryEndpoint:He(e)};return Me.init(i,void 0,t,Ke,e,r,o)},Ve=(e,t,r)=>async(o,n)=>{if(!o)throw new M("Logout Redirection URI must be a non-empty string");const{logger:i,metadata:a}=r;i.logInfo("Logout started",e,t,o,n);const{end_session_endpoint:s}=a??{};if(!s){const e=new Ue("OpenID Provider metadata does not define end session endpoint");throw i.logError(e),e}const c=`${s}?id_token_hint=${t}&client_id=${e}&post_logout_redirect_uri=${encodeURIComponent(o)}${n?`&logout_hint=${encodeURIComponent(n)}`:""}`;await F(c,Be(o,i)),await(r?.close()),i.logInfo("Logout completed")},Be=(e,t)=>r=>new Promise(((o,n)=>{let i;r.addListener("closing",(async()=>{t.logInfo("User closed auth window"),window.clearInterval(i),r.removeAllListeners(),n(new Ue("Failed to complete logout process"))}));const a=window.setTimeout((async()=>{try{await r.isShowing()||(t.logInfo("Showing auth window"),await r.show(!0),await r.focus())}catch{t.logWarning("Unable to show auth window")}}),2e3);(async()=>{const{version:s}=await fin.System.getRuntimeInfo();parseInt(s.split(".")[0],10)>=30?await qe(r,a,e,o)((await r.getInfo()).url)||await r.addListener("url-changed",(n=>{t.logInfo("Auth window navigated to",n.url),qe(r,a,e,o)(n.url)})):i=window.setInterval((()=>(async(e,t,r,o,n,i)=>{let a;try{a=await e.getInfo()}catch(e){return window.clearInterval(t),window.clearTimeout(r),i(new Ue("Could not locate auth window")),!1}return qe(e,r,o,n,0,t)(a.url)})(r,i,a,e,o,n)),500)})()}));var Xe=o.YR,Ye=o.U7,Qe=o.OF;function Ze(e){return null==e}function et(e){return null!=e&&"string"==typeof e}function tt(e){return et(e)&&e.trim().length>0}function rt(e){return Ze(e)?"":e instanceof Error?e.message:tt(e)?e:null!=(t=e)&&"object"==typeof t&&!Array.isArray(t)&&"message"in e&&et(e.message)?e.message:JSON.stringify(e);var t}const ot={auth:new class{constructor(){this._subscribeIdMap={},this._eventSubscribers={}}async initialize(e,t,r){this._definition=e,this._logger=t("OpenIdConnectProvider"),this._logger.info("Initializing"),this._definition.data?.enableLogging&&Ye();const o=this._definition.data?.providerUrl,n=this._definition.data?.clientId,i=this._definition.data?.loginRedirectUrl,a=this._definition.data?.logoutRedirectUrl;tt(o)||this._logger.error("providerUrl is not configured"),tt(n)||this._logger.error("ClientId is not configured"),tt(i)||this._logger.error("loginRedirectUrl is not configured"),tt(a)||this._logger.error("logoutRedirectUrl is not configured")}async closedown(){this._logger?.info("Closedown"),this._sessionExpiryTimerId&&(window.clearTimeout(this._sessionExpiryTimerId),this._sessionExpiryTimerId=void 0)}subscribe(e,t){const r="randomUUID"in globalThis.crypto?globalThis.crypto.randomUUID():"10000000-1000-4000-8000-100000000000".replace(/[018]/g,(function(e){const t=globalThis.crypto.getRandomValues(new Uint8Array(1))[0]&15>>Number(e)/4;return(Number(e)^t).toString(16)})),o=this._eventSubscribers[e]??{};return o[r]=t,this._eventSubscribers[e]=o,this._subscribeIdMap[r]=e,this._logger?.info(`Subscription to ${e} events registered. Subscription Id: ${r}`),r}unsubscribe(e){const t=this._subscribeIdMap[e];if(Ze(t))return this._logger?.warn(`You have tried to unsubscribe with a key ${e} that is invalid`),!1;const r=this._eventSubscribers[t];return Ze(r)||delete r[e],this._subscribeIdMap[e]?(delete this._subscribeIdMap[e],this._logger?.info(`Subscription to ${t} events with subscription Id: ${e} has been cleared`),!0):(this._logger?.warn(`Subscription to ${t} events with subscription Id: ${e} could not be cleared as we do not have a register of that event type.`),!1)}async isAuthenticationRequired(){return Ze(this._authResult)}async login(){const e=this._definition?.data?.providerUrl,t=this._definition?.data?.clientId,r=this._definition?.data?.loginRedirectUrl,o=this._definition?.data?.scopes;if(tt(e)&&tt(t)&&tt(r))try{return this._authResult=await Xe(e,t,r,o),await this.notifySubscribers("logged-in"),this.checkForSessionExpiry(),!0}catch(e){this._logger?.error("Authentication failed",rt(e))}return!1}async logout(){if(this._authResult){this._sessionExpiryTimerId&&(window.clearTimeout(this._sessionExpiryTimerId),this._sessionExpiryTimerId=void 0);const e=this._definition?.data?.logoutRedirectUrl;if(tt(e))try{await this.notifySubscribers("before-logged-out"),await this._authResult.logout(e)}catch(e){this._logger?.error("Logout failed",rt(e))}finally{await this.notifySubscribers("logged-out")}this._authResult=void 0}return!0}async getUserInfo(){if(this._authResult)return this._authResult.userInfo}async notifySubscribers(e){const t=this._eventSubscribers[e];if(t){const r=Object.keys(t);r.reverse();for(const o of r)this._logger?.info(`Notifying subscriber with subscription Id: ${o} of event type: ${e}`),await t[o]()}}checkForSessionExpiry(){const e=this._definition?.data?.checkSessionValidityInSeconds;var t;null!=(t=e)&&"number"==typeof t&&e>0&&Ze(this._sessionExpiryTimerId)&&(this._sessionExpiryTimerId=window.setTimeout((async()=>{this._sessionExpiryTimerId=void 0;const e=this._authResult?.idToken,t=this._definition?.data?.providerUrl,r=this._definition?.data?.clientId;let o=!1;if(tt(e)&&tt(t)&&tt(r))try{o=(await Qe(e,r,t)).valid}catch(e){this._logger?.error("Failed validating token",rt(e))}o?(this._logger?.info("Session Still Active"),this.checkForSessionExpiry()):(this._logger?.info("Session not valid"),this._authResult=void 0,await this.notifySubscribers("session-expired"))}),1e3*e))}}};var nt=t.k;export{nt as entryPoints};
//# sourceMappingURL=openid-connect.bundle.js.map