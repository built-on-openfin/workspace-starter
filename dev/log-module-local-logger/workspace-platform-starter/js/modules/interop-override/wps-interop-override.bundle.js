var t={d:(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};function n(t){return null==t}function i(t){return null!=t&&"string"==typeof t}function s(t){return i(t)&&t.trim().length>0}function a(t){return n(t)?"":t instanceof Error?t.message:s(t)?t:null!=(e=t)&&"object"==typeof e&&!Array.isArray(e)&&"message"in t&&i(t.message)?t.message:JSON.stringify(t);var e}function r(t){const e=[],i=[];if(Array.isArray(t.icons))for(const i of t.icons)n(i.src)||e.push(i.src);if(Array.isArray(t.images))for(const e of t.images)n(e.src)||i.push(e.src);return{appId:t.appId,description:t.description,icons:e,images:i,name:t.appId,title:t.title,tooltip:t.tooltip,version:t.version}}function o(t,e){return{appId:t.appId,description:t.description,icons:t.icons,name:t.name,screenshots:t.images,title:t.title,tooltip:t.tooltip,version:t.version,resultType:e}}t.d(e,{k:()=>x});const p="AppTimeout",d="NoAppsFound",c="ResolverUnavailable",l="TargetAppUnavailable",h="TargetInstanceUnavailable",u="IntentDeliveryFailed",g="unregistered-app";async function f(t){let e,i;try{const e=fin.View.wrapSync(t);i=await e.getCurrentWindow()}catch{}if(n(e))try{const n=i??fin.Window.wrapSync(t);e=await n.getBounds()}catch{}if(n(e))try{e=await fin.me.getBounds()}catch{}return e}async function I(t){const e=await fin.System.getMonitorInfo(),i=t.x,s=t.y;if(!n(i)&&!n(s))for(const t of e.nonPrimaryMonitors)if(w({x:i,y:s},t.monitorRect))return t;return e.primaryMonitor}function w(t,e){return t.x>=e.left&&t.x<=e.right&&t.y>=e.top&&t.y<=e.bottom}async function y(t,e){if(!0===t?.disableWindowPositioningStrategy)return;let i;if(n(e))i=(await fin.System.getMonitorInfo()).primaryMonitor;else if(!n(e)&&"monitorRect"in e)i=e;else if(!n(e)&&"x"in e)i=await I(e);else{const t=await f(e);i=n(t)?(await fin.System.getMonitorInfo()).primaryMonitor:await I({x:t.left,y:t.top})}const s=t?.defaults?.left??0,a=t?.defaults?.top??0,r=i.availableRect.left,o=i.availableRect.top,p=t?.windowPositioningStrategy?.x??30,d=t?.windowPositioningStrategy?.y??30,c=t?.windowPositioningStrategy?.maxIncrements??8,l=await async function(){const t=fin.Platform.getCurrentSync(),e=await t.Application.getChildWindows(),n=[];for(const t of e)try{await t.isShowing()&&n.push(t)}catch{}return n}(),h=await Promise.all(l.map((async t=>{try{const e=await t.getBounds();return{left:e.left,top:e.top,right:e.left+p,bottom:e.top+d}}catch{return{left:0,top:0,right:0,bottom:0}}})));let u=1e3,g=c;for(let t=0;t<c;t++){const e=s+t*p,n=a+t*d,i=h.filter((t=>t.left>=e+r&&t.right<=e+p+r&&t.top>=n+o&&t.bottom<=n+d+o));i.length<u&&(u=i.length,g=t)}return{left:s+g*p+r,top:a+g*d+o}}class m{constructor(t,e,n,i){this._validatedAppIds=[],this._invalidAppIds=[],this._unregisteredApp=i,this._logger=n,this._getApp=t,this._platformId=e}async lookupAppId(t){if(t.name.startsWith("internal-generated-"))return t.uuid===this._platformId?this._unregisteredApp?(this._logger.debug(`A window or view that is not an app but runs within the platform is running and a placeholder app has been specified ${this._unregisteredApp?.appId}}.`,t),this._unregisteredApp.appId):void this._logger.debug("A window or view that is not an app but runs within the platform is running and no unregistered placeholder app is specified so no appId will be returned.",t):void this._logger.debug("A window or view that follows the runtime generated naming convention is running from another platform. It will not be assigned an appId.",t);const e=t.name.split("/");let n;return n=1===e.length||2===e.length?e[0]:`${e[0]}/${e[1]}`,this._validatedAppIds.includes(n)?n:this._invalidAppIds.includes(n)?void 0:await this._getApp(n)?(this._validatedAppIds.push(n),n):(this._invalidAppIds.push(n),void this._logger.warn(`AppId ${n} does not exist in the directory and it isn't a generated view/window that falls under this platform. No app id will be returned as it is unconfirmed.`))}}class _{constructor(t,e){this._getApps=t,this._logger=e}async getAppsByIntent(t){return(await this._getApps()).filter((e=>{const i=e.interop?.intents?.listensFor;if(n(i))return!1;const s=Object.keys(i);for(const e of s)if(e.toLowerCase()===t.toLowerCase())return!0;return!1}))}async getIntent(t,e,i){const s=await this._getApps();if(0===s.length)return void this._logger.warn("There was no apps returned so we are unable to find apps that support an intent");const a={};for(const r of s)if(r.interop?.intents?.listensFor&&!n(r.interop.intents.listensFor[t])){const n=r.interop.intents.listensFor[t];this.appIntentContains(n,e,i)&&this.updateAppIntentsMap(a,t,n.displayName,r)}const r=Object.values(a);if(0!==r.length)return 1===r.length||this._logger.warn(`Received more than one result for findIntent for intent ${t} and context ${e} and resultType ${i}. Returning the first entry.`),r[0];this._logger.info(`No results found for findIntent for intent ${t} and context ${e} and resultType ${i}`)}async getIntentsByContext(t,e){const i=await this._getApps();if(0===i.length)return this._logger.warn("Unable to get apps so we can not get apps and intents that support a particular context"),[];const s={};for(const a of i){const i=a.interop?.intents?.listensFor;if(!n(i)){const n=Object.keys(i);for(const r of n){const n=i[r];this.appIntentContains(n,t,e)&&this.updateAppIntentsMap(s,r,n.displayName,a)}}}return Object.values(s)}appIntentContains(t,e,i){if(n(e)||n(i)){if(!n(e)&&!t?.contexts?.includes(e))return!1;if(!n(i)&&!t?.resultType?.includes(i))return!1}else if(!t?.contexts?.includes(e)||!t.resultType?.includes(i))return!1;return!0}updateAppIntentsMap(t,e,i,s){n(t[e])&&(t[e]={intent:{name:e,displayName:i},apps:[]}),t[e].apps.push(s)}}async function A(t,e,n,i,s){const a=[],r=[];if("1.2"===e){for(const e of t){const t=n(e);r.push(t)}return r}for(const e of t){const t=i(e),n=await s(e.appId);a.push(t);for(const e of n){const n={...t,instanceId:e.instanceId};a.push(n)}}return a}class R{constructor(t,e){this._logger=e,this._lookupAppId=t,this._clientReadyRequests={},this._trackedClientConnections={},this._trackedContextHandlers={},this._trackedIntentHandlers={}}async clientDisconnected(t){this._logger.info("Client Disconnected.",t);for(const[e,n]of Object.entries(this._trackedIntentHandlers))this._trackedIntentHandlers[e]=n.filter((e=>e.clientIdentity.endpointId!==t.endpointId));for(const[e,n]of Object.entries(this._trackedContextHandlers))this._trackedContextHandlers[e]=n.filter((e=>e.clientIdentity.endpointId!==t.endpointId));this.removeTrackedClientConnection(t)}async intentHandlerRegistered(t,e){if(this._logger.info("intentHandlerRegistered:",t,e),!n(t)){const i=t.handlerId.replace("intent-handler-","");let s=this._trackedIntentHandlers[i];if(n(s)&&(s=[],this._trackedIntentHandlers[i]=s),n(this._trackedIntentHandlers[i].find((t=>t.clientIdentity.endpointId===e.endpointId)))){this._logger.info(`intentHandler endpoint not registered. Registering ${e.endpointId} against intent ${i} and looking up app name.`);const s=await this._lookupAppId(e);if(n(s))return void this._logger.warn("Unable to determine app id based on name. This app will not be tracked via intent handler registration.");this._trackedIntentHandlers[i].push({fdc3Version:t.fdc3Version,clientIdentity:e,appId:s}),this._logger.info(`intentHandler endpoint: ${e.endpointId} registered against intent: ${i} and app Id: ${s}.`)}const a=this.getClientReadyKey(e,"intent",i);n(this._clientReadyRequests[a])||(this._logger.info("Resolving client ready request."),this._clientReadyRequests[a](e.endpointId))}}async contextHandlerRegistered(t,e){if(this._logger.info("contextHandlerRegistered:",t,e),!n(t?.handlerId)){const i=t?.contextType??"*",s=t.handlerId;let a=this._trackedContextHandlers[i];if(n(a)&&(a=[],this._trackedContextHandlers[i]=a),n(this._trackedContextHandlers[i].find((t=>t.clientIdentity.endpointId===e.endpointId)))){this._logger.info(`contextHandler endpoint not registered. Registering ${e.endpointId} against context handler for context type ${i} and looking up app name.`);const t=await this._lookupAppId(e);if(n(t))return void this._logger.warn("Unable to determine app id based on name. This app will not be tracked via context handler registration.");this._trackedContextHandlers[i].push({clientIdentity:e,appId:t,handlerId:s}),this._logger.info(`contextHandler endpoint: ${e.endpointId} registered against context type: ${i} and app Id: ${t}.`)}const r=this.getClientReadyKey(e,"context",i);n(this._clientReadyRequests[r])||(this._logger.info("Resolving client ready request."),this._clientReadyRequests[r](e.endpointId))}}async clientConnectionRegistered(t,e){const i=`${t.uuid}-${t.name}`;let a;if(n(this._trackedClientConnections[i])){if(t.uuid!==fin.me.identity.uuid){const i=e?.apiVersion;a=n(i)||n(i?.type)?s(t.connectionUrl)?{type:"fdc3",version:"2.0"}:{type:"interop"}:i}else{const e=t.entityType;if(n(e))a=await this.captureViewApiUsage(t),n(a)&&(a=await this.captureWindowApiUsage(t));else switch(e){case"window":a=await this.captureWindowApiUsage(t);break;case"view":a=await this.captureViewApiUsage(t);break;default:this._logger.warn(`We currently do not check for entity types that are not views or windows. Entity type: ${e}`)}}const r={clientIdentity:t,apiMetadata:a};this._trackedClientConnections[i]=r;const o=this.getClientReadyKey(t,"connection");n(this._clientReadyRequests[o])||(this._logger.info("Resolving client ready request."),this._clientReadyRequests[o](t.endpointId))}}getRegisteredContextHandler(t,e){const n=this._trackedContextHandlers[t]?.find((t=>t.clientIdentity.endpointId===e));return n}async findAppInstances(t,e,i="connected"){const s={};if("intent"===i){for(const[,e]of Object.entries(this._trackedIntentHandlers)){const n=e.filter((e=>e.appId===t.appId));for(const t of n)s[t.clientIdentity.endpointId]={appId:t.appId??"",instanceId:t.clientIdentity.endpointId}}return Object.values(s)}for(const[,e]of Object.entries(this._trackedClientConnections))await this._lookupAppId(e.clientIdentity)===t.appId&&n(s[e.clientIdentity.endpointId])&&(s[e.clientIdentity.endpointId]={appId:t.appId??"",instanceId:e.clientIdentity.endpointId});return Object.values(s)}getApiVersion(t){const e=`${t.uuid}-${t.name}`,n=this._trackedClientConnections[e]?.apiMetadata;return n}async onConnectionClientReady(t,e=15e3){return new Promise(((i,s)=>{const a=this.getClientIdentity(t);n(a)||i(a.endpointId);const r=this.getClientReadyKey(t,"connection"),o=setTimeout((()=>{n(this._clientReadyRequests[r])||(delete this._clientReadyRequests[r],s(h))}),e);this._clientReadyRequests[r]=t=>{clearTimeout(o),delete this._clientReadyRequests[r],i(t)}}))}async onIntentClientReady(t,e,i=15e3){return new Promise(((s,a)=>{const r=this._trackedIntentHandlers[e];let o;if(!n(r))for(const e of r)if(e.clientIdentity.uuid===t.uuid&&e.clientIdentity.name===t.name){o=e.clientIdentity.endpointId;break}n(o)||s(o);const p=this.getClientReadyKey(t,"intent",e),d=setTimeout((()=>{n(this._clientReadyRequests[p])||(delete this._clientReadyRequests[p],a(u))}),i);this._clientReadyRequests[p]=t=>{clearTimeout(d),delete this._clientReadyRequests[p],s(t)}}))}async onContextClientReady(t,e,i=15e3){return new Promise(((s,a)=>{const r=this._trackedContextHandlers[e],o=this._trackedContextHandlers["*"];let d;if(!n(r))for(const e of r)if(e.clientIdentity.uuid===t.uuid&&e.clientIdentity.name===t.name){d=e.clientIdentity.endpointId;break}if(!n(o)&&n(d))for(const e of o)if(e.clientIdentity.uuid===t.uuid&&e.clientIdentity.name===t.name){d=e.clientIdentity.endpointId;break}if(!n(d))return void s(d);const c=this.getClientReadyKey(t,"context",e),l=this.getClientReadyKey(t,"context","*"),h=setTimeout((()=>{const t=!n(this._clientReadyRequests[c]),e=!n(this._clientReadyRequests[l]);(t||e)&&(delete this._clientReadyRequests[c],delete this._clientReadyRequests[l],a(p))}),i);let u=!1;this._clientReadyRequests[c]=t=>{clearTimeout(h),u||(u=!0,delete this._clientReadyRequests[c],delete this._clientReadyRequests[l],s(t))},this._clientReadyRequests[l]=t=>{clearTimeout(h),u||(u=!0,delete this._clientReadyRequests[c],delete this._clientReadyRequests[l],s(t))}}))}getClientIdentity(t){const e=`${t.uuid}-${t.name}`,n=this._trackedClientConnections[e]?.clientIdentity;return n}removeTrackedClientConnection(t){const e=`${t.uuid}-${t.name}`;delete this._trackedClientConnections[e]}async captureWindowApiUsage(t){try{const e=fin.Window.wrapSync(t),i=await e.getOptions();if(!n(i.fdc3InteropApi))return{type:"fdc3",version:i.fdc3InteropApi}}catch{}}async captureViewApiUsage(t){try{const e=fin.View.wrapSync(t),i=await e.getOptions();if(!n(i.fdc3InteropApi))return{type:"fdc3",version:i.fdc3InteropApi}}catch{}}getClientReadyKey(t,e,i){return n(i)?`${t.uuid}/${t.name}/${e}`:`${t.uuid}/${t.name}/${e}/${i}`}}class v{constructor(t,e,n){this._defaultIntentResolverHeight=715,this._defaultIntentResolverWidth=665,this._intentResolverOptions={height:this._defaultIntentResolverHeight,width:this._defaultIntentResolverWidth,fdc3InteropApi:"2.0",title:"Intent Resolver",...t},this._logger=e}async launchIntentResolver(t,e){try{const i=await async function(t,e){const i=function(t){let e,i;if(!n(t)){const n=t.width/2,s=t.height/2;return e=t.left+n,i=t.top+s,{x:Math.round(e),y:Math.round(i)}}return{}}(await f(t));return function(t,e){const n=t.bottom-t.top,i=(t.right-t.left)/2,s=n/2,a=e.width/2,r=e.height/2,o=t.left+i-a,p=t.top+s-r;return{x:Math.round(o),y:Math.round(p)}}((await I(i)).availableRect,e)}(e,{height:this._intentResolverOptions?.height??this._defaultIntentResolverHeight,width:this._intentResolverOptions?.width??this._defaultIntentResolverWidth}),s={name:"intent-picker",includeInSnapshots:!1,fdc3InteropApi:this._intentResolverOptions?.fdc3InteropApi,defaultWidth:this._intentResolverOptions?.width,defaultHeight:this._intentResolverOptions?.height,showTaskbarIcon:!1,saveWindowState:!1,customData:{title:this._intentResolverOptions?.title,apps:t.apps,intent:t.intent,intents:t.intents,unregisteredAppId:this._unregisteredAppId},url:this._intentResolverOptions?.url,frame:!1,autoShow:!0,alwaysOnTop:!0};n(i)?s.defaultCentered=!0:(s.defaultLeft=i.x,s.defaultTop=i.y);const a=(await fin.Window.create(s)).getWebWindow();return await a.getIntentSelection()}catch(e){const n=a(e);if(n?.includes("UserCancelledResolution"))throw this._logger.info("App for intent not selected/launched by user",t.intent),new Error(n);throw this._logger.error("Unexpected error from intent picker/resolver for intent",t.intent),new Error(c)}}}const x={interopOverride:new class{async initialize(t,e,n){this._definition=t;const i=t.data?.loggerName??"WpsInteropOverride";this._logger=e(i),this._helpers=n,this._logger.info("Initializing")}async closedown(){this._logger?.info("Closedown")}async getConstructorOverride(t){if(!this._helpers||!this._logger)throw new Error("Module not initialized");return async function(t,e,f){if(!f?.getApp||!f?.getApps||!f.launchApp)throw new Error("Interop Broker Constructor is missing required helpers. The broker will not function correctly so this error is to flag the issue.");const I=f.getApp,w=f.getApps;let x;f?.getEndpointClient&&(x=await(f?.getEndpointClient()));const C=f.launchApp;let H;return f?.getConnectionClient&&(H=await f.getConnectionClient()),b=>class extends b{constructor(){super(),e.info("Interop Broker Constructor applying settings."),this._appIntentHelper=new _(w,e),this._metadataKey=`_metadata_${"randomUUID"in globalThis.crypto?globalThis.crypto.randomUUID():"10000000-1000-4000-8000-100000000000".replace(/[018]/g,(function(t){const e=globalThis.crypto.getRandomValues(new Uint8Array(1))[0]&15>>Number(t)/4;return(Number(t)^e).toString(16)}))}`,t.intentResolver&&(this._intentResolverHelper=new v(t.intentResolver,e,t?.unregisteredApp?.appId)),this._openOptions=t?.openOptions,this._unregisteredApp=t?.unregisteredApp,this._contextOptions=t?.contextOptions,n(this._unregisteredApp)||(this._unregisteredApp.manifestType=g),this._appIdHelper=new m(I,fin.me.identity.uuid,e,this._unregisteredApp),this._clientRegistrationHelper=new R((async t=>this._appIdHelper.lookupAppId(t)),e)}async isConnectionAuthorized(t,i){e.info("Interop connection being made by the following identity. About to verify connection",t);const s=i;if(!n(H)){const n=await H.isConnectionValid(t,i,{type:"broker"});return n.isValid?(e.info("Connection validation request was validated and is valid."),await this._clientRegistrationHelper.clientConnectionRegistered(t,s)):e.warn(`Connection request from ${JSON.stringify(t)} was validated and rejected.`),n.isValid}const a=await super.isConnectionAuthorized(t,i);return a&&await this._clientRegistrationHelper.clientConnectionRegistered(t,s),a}async setContext(t,e){t.context=await this.processContext(t.context);const n=await this.getContextMetadata(e);t.context={...t.context,[this._metadataKey]:n},super.setContext(t,e)}async invokeContextHandler(t,e,i){const s={...i},a=s[this._metadataKey];if(n(a)||delete s[this._metadataKey],!1!==this._contextOptions?.includeOriginator||a?.source.instanceId!==t.endpointId)return super.invokeContextHandler(t,e,{...s,contextMetadata:a})}async handleInfoForIntentsByContext(t,e){let n,i,s;const a=this._clientRegistrationHelper.getApiVersion(e);"type"in t?n=t.type:(s=t,n=s.context.type,i=s.metadata.resultType);const p=await this._appIntentHelper.getIntentsByContext(n,i);if(0===p.length)throw new Error(d);const c=[];for(const t of p){const n=await A(t.apps,a?.version??"2.0",r,o,(async t=>this._clientRegistrationHelper.findAppInstances({appId:t},e,"intent")));c.push({intent:t.intent,apps:n})}return c}async handleInfoForIntent(t,e){const i=this._clientRegistrationHelper.getApiVersion(e);let s;const a=t?.context?.type;n(a)||"fdc3.nothing"===a||(s=a);const p=await this._appIntentHelper.getIntent(t.name,s,t?.metadata?.resultType);if(n(p))throw new Error(d);return{intent:p.intent,apps:await A(p.apps,i?.version??"2.0",r,o,(async t=>this._clientRegistrationHelper.findAppInstances({appId:t},e,"intent")))}}async handleFiredIntentForContext(t,e){const i=this.getApplicationIdentity(t.metadata),s=this.usesApplicationIdentity(e),a={context:t},r=await this._appIntentHelper.getIntentsByContext(t.type);if(!n(i)){const r=await I(i.appId);if(n(r))throw new Error(l);if(!r?.interop?.intents?.listensFor||!Object.values(r.interop.intents.listensFor).some((e=>e.contexts.includes(t.type))))throw new Error(d);const o=await this.handleTargetedIntent(i,a,!0,e);return this.shapeIntentResolver(o,s)}const o=await this.getUnregisteredAppIntentByContext(t.type,e);if(o.length>0&&!n(this._unregisteredApp)){const t=[];for(const e of r)o.includes(e.intent.name)&&(e.apps.push(this._unregisteredApp),t.push(e.intent.name));const e=o.filter((e=>!t.includes(e)));for(const t of e){const e=this._unregisteredApp.intents?.find((e=>e.name===t));e&&r.push({intent:{name:e.name,displayName:e.displayName},apps:[this._unregisteredApp]})}}let p;if(1===r.length){const t=r[0];if(a.name=t.intent.name,a.displayName=t.intent.displayName,1===t.apps.length&&(0===(await this._clientRegistrationHelper.findAppInstances(t.apps[0],e,"intent")).length||this.createNewInstance(t.apps[0]))){const i=await this.launchAppWithIntent(t.apps[0],a,void 0,e);if(n(i))throw new Error(d);return this.shapeIntentResolver(i,s)}p=await(this._intentResolverHelper?.launchIntentResolver({apps:r[0].apps,intent:a},e))}else p=await(this._intentResolverHelper?.launchIntentResolver({intent:a,intents:r},e));if(n(p))throw new Error(c);a.displayName=p.intent.displayName,a.name=p.intent.name;const h=await this.handleIntentPickerSelection(p,a,e);return this.shapeIntentResolver(h,s)}async handleFiredIntent(t,i){e.info("Received request for a raised intent",t);const s=this.getApplicationIdentity(t.metadata),a=this.usesApplicationIdentity(i),r=await this._appIntentHelper.getIntent(t.name,t?.context?.type),o=[];if(n(r)||o.push(...r.apps),!n(s)){if(n(await I(s.appId)))throw new Error(l);if(!o.some((t=>t.appId===s.appId)))throw new Error(d);const e=await this.handleTargetedIntent(s,t,!1,i);return this.shapeIntentResolver(e,a)}if(this._unregisteredApp&&await this.canAddUnregisteredApp(i,t.name,t?.context?.type)&&o.push(this._unregisteredApp),0===o.length)throw e.info("No apps support this intent"),new Error(d);if(1===o.length){const e=await this._clientRegistrationHelper.findAppInstances(o[0],i,"intent");let s;if(1===e.length&&(s=e[0].instanceId),0===e.length||this.useSingleInstance(o[0])||this.createNewInstance(o[0])){const e=await this.launchAppWithIntent(o[0],t,s,i);if(n(e))throw new Error(d);return this.shapeIntentResolver(e,a)}}const p=await(this._intentResolverHelper?.launchIntentResolver({apps:o,intent:t},i));if(n(p))throw new Error(c);const h=await this.handleIntentPickerSelection(p,t,i);return this.shapeIntentResolver(h,a)}async invokeIntentHandler(t,e,i){const{context:s}=i;let a,r;return n(s)||(r={...s},a=r[this._metadataKey],n(a)||delete r[this._metadataKey]),super.invokeIntentHandler(t,e,{...i,context:{...r,contextMetadata:a}})}async fdc3HandleOpen(s,r){if(n(s?.app))throw e.error("A request to fdc3.open did not pass an fdc3OpenOptions object"),new Error(d);e.info(`A request to Open has been sent to the platform by uuid: ${r?.uuid}, name: ${r?.name}, endpointId: ${r.endpointId} with passed context:`,s.context);try{let a,o,p,d,c=!1;i(s.app)?a=s.app:(a=s.app.appId??s.app.name,o=s.app.instanceId);const l=await I(a);if(n(l))throw new Error("AppNotFound");if(!n(o)){const t=(await this.getAllClientInfo()).find((t=>t.endpointId===o));if(n(t))throw new Error(h);e.info(`App Id: ${a} and instance Id: ${o} was provided and found.`),p=[{uuid:t.uuid,name:t.name,appId:a,instanceId:o}]}if("intent"===this._openOptions?.openStrategy){const t={context:s.context,name:"OpenApp",metadata:{target:{appId:a}}},e=await this.launchAppWithIntent(l,t,o,r);i(e.source)?d=e.source:(d=e.source.appId,o=e.source.instanceId)}else{if(n(p)){let e;const i=await y(t.windowPositionOptions,r);n(i)||(e={bounds:i}),p=await C(l?.appId,e)}else c=!0;if(!n(p)&&p?.length>0){d=p[0].appId;let i=!0;if(1===p.length){i=!1;const t=this._openOptions?.connectionTimeout;o=await this._clientRegistrationHelper.onConnectionClientReady(p[0],t)}else e.info(`Multiple instances of the app ${d} have been launched. We are assuming this is a composite app/snapshot. We are not returning an instance id as you can only return one and a composite app will be made up of many.`);if(!n(s?.context)){const n=t?.openOptions?.connectionTimeout,a=await this.processContext(s.context),o=await this.getContextMetadata(r),c={...a,[this._metadataKey]:o},l=p.map((async t=>this.processOpenContext(t,c,n,i)));Promise.allSettled(l).then((t=>{const n=t.some((t=>"fulfilled"===t.status));return n?e.info("Multi Instance open context sharing has been initiated and at least one entry supported receiving a context."):e.error("Multi Instance open context sharing was done but there were no context listeners registered."),n})).catch((t=>{e.error(`Context sharing for fdc3 open of ${d} failed`,t)}))}}}if(!n(d))return!c||n(p)||n(f?.bringAppToFront)||await f.bringAppToFront(l,p),{appId:d,instanceId:o};throw new Error("ErrorOnLaunch")}catch(t){const e=a(t);if(e===h||e===u||e===h||e===p)throw new Error(p);throw t}}async clientDisconnected(t){await this._clientRegistrationHelper.clientDisconnected(t),await super.clientDisconnected(t)}async fdc3HandleFindInstances(t,e){return this._clientRegistrationHelper.findAppInstances(t,e)}async fdc3HandleGetAppMetadata(t,i){e.info("fdc3HandleGetAppMetadata call received.",t,i);let a=await I(t.appId);if(n(a)&&t.appId===this._unregisteredApp?.appId&&(a=this._unregisteredApp),!n(a)){const i=o(a);if(!n(t.instanceId)){const a=(await this.getAllClientInfo()).find((e=>e.endpointId===t.instanceId));if(!n(a)&&a.uuid===fin.me.identity.uuid){const o={uuid:a.uuid,name:a.name};let p,d;try{if("window"===a.entityType){const t=fin.Window.wrapSync(o);await t.isShowing()&&(p=(await t.getInfo()).title,d=await this.getPreviewImage(t))}else{const t=fin.View.wrapSync(o);p=(await t.getInfo()).title,d=await this.getPreviewImage(t)}}catch(n){e.warn(`A connected client could not be queried for data. It could be it hasn't unregistered itself from the broker. AppId: ${t.appId}, instanceId: ${t.instanceId}, name: ${o.name}`,n)}return n(p)||(p=s(r=p)?r.replace(/<[^>]*>?/gm,"").replace(/&gt;/g,">").replace(/&lt;/g,"<").replace(/&amp;/g,"&").replace(/&nbsp;/g," ").replace(/\n\s*\n/g,"\n"):""),{...i,instanceId:t.instanceId,instanceMetadata:{title:p,preview:d}}}}return i}var r;throw new Error("TargetAppUnavailable")}async fdc3HandleGetInfo(t,i){if(e.info("fdc3HandleGetInfo",t,i),"2.0"===t?.fdc3Version){const e=await super.fdc3HandleGetInfo(t,i),s=await this._appIdHelper.lookupAppId(i);return n(s)?e:{...e,appMetadata:{appId:s,instanceId:i.endpointId}}}return super.fdc3HandleGetInfo(t,i)}async intentHandlerRegistered(t,e){await this._clientRegistrationHelper.intentHandlerRegistered(t,e),await super.intentHandlerRegistered(t,e)}async contextHandlerRegistered(t,e){await this._clientRegistrationHelper.contextHandlerRegistered(t,e),super.contextHandlerRegistered(t,e)}async launchAppWithIntent(i,s,a,r){e.info("Launching app with intent");let o,p=[],d=!0;if(n(s?.context)||(s.context=await this.processContext(s.context),n(r)||(o=await this.getContextMetadata(r),s.context={...s.context,[this._metadataKey]:o})),!n(a)){const t=(await this.getAllClientInfo()).find((t=>t.endpointId===a));if(n(t))throw new Error(h);e.info(`App Id: ${i.appId} and instance Id: ${a} was provided and found.`),p.push({uuid:t.uuid,name:t.name,appId:i.appId,instanceId:t.endpointId})}if(0===p.length){let e;const s=await y(t.windowPositionOptions,r);if(n(s)||(e={bounds:s}),p=await C(i.appId,e),!p?.length)throw new Error(u);d=!1}const c=t?.intentOptions?.intentTimeout;if(1===p.length)a=await this.processSetIntentTarget(p[0],s,c,!1);else{const t=p.map((async t=>this.processSetIntentTarget(t,s,c,!0)));Promise.allSettled(t).then((t=>{const n=t.some((t=>"fulfilled"===t.status));return n?e.info("Multi Instance intents target sharing has been initiated and at least one entry supported intents."):e.error("All intent sharing promises were rejected so not even one identity supported intents in time."),n})).catch((t=>{e.error(`Intent raising of multiple identities for app: ${i.appId} failed`,t)}))}if(d)for(const t of p)try{f.bringAppToFront&&await f.bringAppToFront(i,[t])}catch(n){e.warn(`There was an error bringing app: ${t.appId}, and instance ${t.instanceId} with name: ${t.name} to front.`,n)}return{source:{appId:i.appId,instanceId:a},version:i.version,intent:s.name}}async handleIntentPickerSelection(t,e,i){let s=await I(t.appId);if(n(s)&&!n(this._unregisteredApp)&&(s=this._unregisteredApp),n(s))throw new Error(d);const a=t.instanceId,r=await this.launchAppWithIntent(s,e,a,i);if(n(r))throw new Error(d);return r}async handleTargetedIntent(t,i,a,r){const o=[];let p=await I(t.appId);if(n(p)){if(n(t.instanceId)||t.appId!==this._unregisteredApp?.appId)throw new Error(l);p=this._unregisteredApp}if(!n(t.instanceId)){const e=await this._clientRegistrationHelper.findAppInstances(t,r,"intent");if(0===e.length||!e.some((e=>e.appId===t.appId&&e.instanceId===t.instanceId)))throw new Error(h)}if(!Array.isArray(p.intents)||0===p.intents.length)throw new Error(l);const d=p.intents.filter((t=>{let e=!0;const s=i.context?.type;return(!n(s)&&(e=t.contexts?.includes(s),a)||t.name===i.name)&&e}));if(0===d.length)throw new Error(l);if(1===d.length){if(i.name=d[0].name,!n(t.instanceId))return await this.launchAppWithIntent(p,i,t.instanceId,r);const e=await this._clientRegistrationHelper.findAppInstances(p,r,"intent"),s=1===e.length&&this.useSingleInstance(p);if(0===e.length||this.createNewInstance(p)||s){const t=await this.launchAppWithIntent(p,i,void 0,r);if(n(t))throw new Error(u);return t}}for(const t of d){const e={apps:[p],intent:{name:t.name,displayName:t.displayName}};o.push(e)}let g;if(1===o.length?(s(i.name)||n(o[0]?.intent?.name)||n(i?.context)||n(i?.context?.type)||(e.info(`A request to raise an intent was passed and the intent name was not passed but a context was ${i?.context?.type} with 1 matching intent. Name: ${o[0]?.intent?.name},  Display Name: ${o[0]?.intent?.displayName}. Updating intent object.`),i.name=o[0]?.intent?.name),g=await(this._intentResolverHelper?.launchIntentResolver({apps:o[0].apps,intent:i},r))):(g=await(this._intentResolverHelper?.launchIntentResolver({intent:i,intents:o},r)),s(i.name)||n(g?.intent?.name)||(e.info(`A request to raise an intent was passed and the following intent was selected (from a selection of ${o.length}). Name: ${g?.intent?.name},  Display Name: ${g?.intent?.displayName}. Updating intent object.`),i.name=g?.intent?.name??i.name)),n(g))throw new Error(c);return this.handleIntentPickerSelection(g,i,r)}async processOpenContext(t,i,s,a){const r=i.type,o=t.appId,p=await this._clientRegistrationHelper.onContextClientReady(t,r,s);let d=this._clientRegistrationHelper.getRegisteredContextHandler(r,p);n(d)&&(d=this._clientRegistrationHelper.getRegisteredContextHandler("*",p)),n(d)?a?e.info(`Unable to send context of type ${r} opened app ${o} with instanceId of ${p} as we cannot find a tracked context handler. This is likely a composite app and this app might not register a context handler.`):e.warn(`Unable to send context of type ${r} opened app ${o} with instanceId of ${p} as we cannot find a tracked context handler.`):await this.invokeContextHandler(d.clientIdentity,d.handlerId,i)}async processSetIntentTarget(t,n,i,s){try{const e=await this._clientRegistrationHelper.onIntentClientReady(t,n.name,i);return await super.setIntentTarget(n,t),e}catch(n){throw s?e.info(`An error occurred while getting a instance to target an intent at. If multiple views were launched as part of a composite and some of them do not register intent handlers then this may explain it.that may explain this warning. AppId: ${t.appId}, Name: ${t.name}`,n):e.warn(`An error occurred while getting a instance to target an intent at. AppId: ${t.appId}, Name: ${t.name}`,n),new Error(u)}}shapeIntentResolver(t,e){return e?t:{source:t.source.appId,version:t.version}}useSingleInstance(t){return"single"===t?.instanceMode}createNewInstance(t){return"new"===t?.instanceMode}async getPreviewImage(t){try{const e=await t.capturePage({format:"jpg",quality:85});if(s(e))return e}catch(n){e.error(`Error while trying to capture a preview image of the view/window: ${t.identity.name}`,n)}}async getUnregisteredAppIntentByContext(t,e){const i=[],s=[];if(n(this?._unregisteredApp))return i;if(Array.isArray(this?._unregisteredApp?.intents))for(const e of this._unregisteredApp.intents)if(e.contexts.includes(t)){const t=e.name;i.push(t)}if(i.length>0)for(const t of i)await this.canAddUnregisteredApp(e,t)&&s.push(t);return s}async canAddUnregisteredApp(t,e,i){if(n(this?._unregisteredApp))return!1;const s=this._unregisteredApp?.interop?.intents?.listensFor;return!(!n(e)&&(n(s)||n(s[e])))&&!!(n(i)||n(s)||n(e)||s[e].contexts.includes(i))&&(await this._clientRegistrationHelper.findAppInstances({appId:this._unregisteredApp.appId},t,"intent")).length>0}getApplicationIdentity(t){const e=t?.target;if(!n(e)){if(i(e)){if(0===e.trim().length)return;return{appId:e}}if(!n(e.appId))return{appId:e.appId,instanceId:e.instanceId}}}usesApplicationIdentity(t){const e=this._clientRegistrationHelper.getApiVersion(t);return!n(e)&&"fdc3"===e.type&&"2.0"===e.version}async processContext(t){if(n(x))return t;const i=`interopbroker.process.${t.type}`;if(x.hasEndpoint(i)){e.info(`Processing context ${t.type} with endpoint ${i}`);const n=await x.requestResponse(i,{context:t});if(n?.context)return n?.context}return t}async getContextMetadata(t){return{source:{appId:await this._appIdHelper.lookupAppId(t)??"unknown",instanceId:t.endpointId}}}}}(t,this._logger,this._helpers)}}};var C=e.k;export{C as entryPoints};
//# sourceMappingURL=wps-interop-override.bundle.js.map