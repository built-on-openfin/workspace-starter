{"version":3,"file":"local-storage.bundle.js","mappings":"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","sources":["webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/utils.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/endpoint/local-storage/platform-local-storage.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/endpoint/local-storage/index.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/endpoint/local-storage/endpoint.ts"],"sourcesContent":["/**\n * Test if a value is a undefined or null.\n * @param value The value to test.\n * @returns True if the value is null or undefined.\n */\nexport function isEmpty(value: unknown): value is null | undefined {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value === undefined || value === null;\n}\n\n/**\n * Test if a value is an object.\n * @param value The value to test.\n * @returns True if the value is an object.\n */\nexport function isObject(value: unknown): value is object {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n/**\n * Test if a value is a string.\n * @param value The value to test.\n * @returns True if the value is a string.\n */\nexport function isString(value: unknown): value is string {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"string\";\n}\n\n/**\n * Test if a value is a string that is not empty.\n * @param value The value to test.\n * @returns True if the value is a string that is not empty.\n */\nexport function isStringValue(value: unknown): value is string {\n\treturn isString(value) && value.trim().length > 0;\n}\n\n/**\n * Test if a value is a number.\n * @param value The value to test.\n * @returns True if the value is a number.\n */\nexport function isNumber(value: unknown): value is number {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"number\";\n}\n\n/**\n * Test if a value is a number with a real value i.e. not NaN or Infinite.\n * @param value The value to test.\n * @returns True if the value is a number.\n */\nexport function isNumberValue(value: unknown): value is number {\n\treturn isNumber(value) && !Number.isNaN(value) && Number.isFinite(value);\n}\n\n/**\n * Test if a value is a boolean.\n * @param value The value to test.\n * @returns True if the value is a boolean.\n */\nexport function isBoolean(value: unknown): value is boolean {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"boolean\";\n}\n\n/**\n * Test if a value is an integer.\n * @param value The value to test.\n * @returns True if the value is an integer.\n */\nexport function isInteger(value: unknown): value is number {\n\treturn isNumber(value) && Number.isInteger(value);\n}\n\n/**\n * Deep clone an object.\n * @param obj The object to clone.\n * @returns The clone of the object.\n */\nexport function objectClone<T>(obj: T): T {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn obj === undefined ? (undefined as T) : JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Do a deep comparison of the objects.\n * @param obj1 The first object to compare.\n * @param obj2 The second object to compare.\n * @param matchPropertyOrder If true the properties must be in the same order.\n * @returns True if the objects are the same.\n */\nexport function deepEqual(obj1: unknown, obj2: unknown, matchPropertyOrder: boolean = true): boolean {\n\tif (isObject(obj1) && isObject(obj2)) {\n\t\tconst objKeys1 = Object.keys(obj1);\n\t\tconst objKeys2 = Object.keys(obj2);\n\n\t\tif (objKeys1.length !== objKeys2.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (matchPropertyOrder && JSON.stringify(objKeys1) !== JSON.stringify(objKeys2)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const key of objKeys1) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst value1 = (obj1 as any)[key];\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst value2 = (obj2 as any)[key];\n\n\t\t\tif (!deepEqual(value1, value2, matchPropertyOrder)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t} else if (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\tif (obj1.length !== obj2.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < obj1.length; i++) {\n\t\t\tif (!deepEqual(obj1[i], obj2[i], matchPropertyOrder)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn JSON.stringify(obj1) === JSON.stringify(obj2);\n}\n\n/**\n * Deep merge two objects.\n * @param target The object to be merged into.\n * @param sources The objects to merge into the target.\n * @returns The merged object.\n */\nexport function deepMerge<T = unknown>(target: T, ...sources: T[]): T {\n\tif (!Array.isArray(sources) || sources.length === 0) {\n\t\treturn target;\n\t}\n\n\tconst targetAsMap = target as { [id: string]: unknown };\n\tconst source = sources.shift();\n\n\tlet keys;\n\tif (isObject(targetAsMap) && isObject(source)) {\n\t\tkeys = Object.keys(source);\n\t} else if (Array.isArray(source)) {\n\t\tif (!Array.isArray(target)) {\n\t\t\treturn source;\n\t\t}\n\t\tkeys = Object.keys(source).map((k) => Number.parseInt(k, 10));\n\t}\n\n\tif (keys) {\n\t\tconst sourceAsMap = source as { [id: string]: unknown };\n\t\tfor (const key of keys) {\n\t\t\tconst value = sourceAsMap[key];\n\t\t\tif (isObject(value)) {\n\t\t\t\tif (isEmpty(targetAsMap[key])) {\n\t\t\t\t\ttargetAsMap[key] = {};\n\t\t\t\t}\n\t\t\t\tdeepMerge(targetAsMap[key], value);\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tif (isEmpty(targetAsMap[key])) {\n\t\t\t\t\ttargetAsMap[key] = [];\n\t\t\t\t}\n\t\t\t\tdeepMerge(targetAsMap[key], value);\n\t\t\t} else {\n\t\t\t\ttargetAsMap[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Polyfills randomUUID if running in a non-secure context.\n * @returns The random UUID.\n */\nexport function randomUUID(): string {\n\tif (\"randomUUID\" in globalThis.crypto) {\n\t\t// eslint-disable-next-line no-restricted-syntax\n\t\treturn globalThis.crypto.randomUUID();\n\t}\n\t// Polyfill the window.crypto.randomUUID if we are running in a non secure context that doesn't have it\n\t// we are still using window.crypto.getRandomValues which is always available\n\t// https://stackoverflow.com/a/2117523/2800218\n\t/**\n\t * Get random hex value.\n\t * @param c The number to base the random value on.\n\t * @returns The random value.\n\t */\n\tfunction getRandomHex(c: string): string {\n\t\t// eslint-disable-next-line no-bitwise\n\t\tconst rnd = globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (Number(c) / 4));\n\t\treturn (\n\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t(Number(c) ^ rnd).toString(16)\n\t\t);\n\t}\n\treturn \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, getRandomHex);\n}\n\n/**\n * Format an error to a readable string.\n * @param err The error to format.\n * @returns The formatted error.\n */\nexport function formatError(err: unknown): string {\n\tif (isEmpty(err)) {\n\t\treturn \"\";\n\t} else if (err instanceof Error) {\n\t\treturn err.message;\n\t} else if (isStringValue(err)) {\n\t\treturn err;\n\t} else if (isObject(err) && \"message\" in err && isString(err.message)) {\n\t\treturn err.message;\n\t}\n\treturn JSON.stringify(err);\n}\n\n/**\n * A basic string sanitize function that removes angle brackets <> from a string.\n * @param content the content to sanitize\n * @returns a string without angle brackets <>\n */\nexport function sanitizeString(content: unknown): string {\n\tif (isStringValue(content)) {\n\t\treturn content\n\t\t\t.replace(/<[^>]*>?/gm, \"\")\n\t\t\t.replace(/&gt;/g, \">\")\n\t\t\t.replace(/&lt;/g, \"<\")\n\t\t\t.replace(/&amp;/g, \"&\")\n\t\t\t.replace(/&nbsp;/g, \" \")\n\t\t\t.replace(/\\n\\s*\\n/g, \"\\n\");\n\t}\n\treturn \"\";\n}\n\n/**\n * Get the command line arguments from a command line string.\n * Examples of command line strings: arg1 key1=value1 key2=\"value with spaces\" key3='value3' key4='value with more spaces'`.\n * @param commandLine The command line string.\n * @returns The command line arguments or an empty array if none\n */\nexport function getCommandLineArgs(commandLine: string): string[] {\n\tif (!isStringValue(commandLine)) {\n\t\treturn [];\n\t}\n\tconst matches = commandLine.match(/(\\w+=)?(\"[^\"]*\"|'[^']*'|[^ ]+)/g);\n\tif (isEmpty(matches)) {\n\t\treturn [];\n\t}\n\treturn matches;\n}\n","import type { Logger, LoggerCreator } from \"workspace-platform-starter/shapes/logger-shapes\";\nimport type { PlatformStorage } from \"workspace-platform-starter/shapes/platform-storage-shapes\";\nimport { isEmpty } from \"workspace-platform-starter/utils\";\n\n/**\n * Implement platform storage using local storage.\n */\nexport class PlatformLocalStorage<T = unknown> implements PlatformStorage<T> {\n\tprivate readonly _storageTypeName: string;\n\n\tprivate readonly _storageKey: string;\n\n\tprivate readonly _logger?: Logger;\n\n\t/**\n\t * Create a new instance of PlatformLocalStorage.\n\t * @param storageId The id of the storage.\n\t * @param storageType The storage tye=pe.\n\t * @param loggerCreator The creator for the logger.\n\t */\n\tconstructor(storageId: string, storageType: string, loggerCreator?: LoggerCreator) {\n\t\tthis._storageTypeName = storageType;\n\t\tthis._storageKey = `${fin.me.identity.uuid.toLowerCase().replaceAll(\" \", \"\")}-${storageId}`;\n\t\tif (loggerCreator) {\n\t\t\tthis._logger = loggerCreator(\"PlatformLocalStorage\");\n\t\t}\n\t}\n\n\t/**\n\t * Get items that are stored.\n\t * @param id The identity of the stored object\n\t * @returns The stored type or null if nothing was found.\n\t */\n\tpublic async get(id: string): Promise<T | undefined> {\n\t\tif (isEmpty(id)) {\n\t\t\tthis._logger?.error(`No id was specified for getting a ${this._storageTypeName} entry`);\n\t\t\treturn;\n\t\t}\n\t\tconst store = this.getCompleteStore();\n\t\treturn store[id];\n\t}\n\n\t/**\n\t * Save an item against storage.\n\t * @param id The identity of the item to store or update\n\t * @param entry The entry to store.\n\t * @returns Nothing.\n\t */\n\tpublic async set(id: string, entry: T): Promise<void> {\n\t\tif (isEmpty(id)) {\n\t\t\tthis._logger?.error(`You need to provide a id for the ${this._storageTypeName} entry you wish to save`);\n\t\t} else {\n\t\t\tconst store = this.getCompleteStore();\n\n\t\t\tstore[id] = entry;\n\n\t\t\tthis.setCompleteStore(store);\n\t\t}\n\t}\n\n\t/**\n\t * Get all the saved entries.\n\t * @param query Optional parameter that can be used to filter the result set\n\t * @returns All available entries.\n\t */\n\tpublic async getAll(query?: string): Promise<{ [key: string]: T }> {\n\t\tconst store = this.getCompleteStore();\n\t\tif (Object.keys(store).length === 0) {\n\t\t\tthis._logger?.info(`Storage has no ${this._storageTypeName} entries`);\n\t\t\treturn {};\n\t\t}\n\n\t\treturn store;\n\t}\n\n\t/**\n\t * Delete an entry from storage.\n\t * @param id The identity of the item to clear\n\t * @returns Nothing.\n\t */\n\tpublic async remove(id: string): Promise<void> {\n\t\tif (isEmpty(id)) {\n\t\t\tthis._logger?.error(`An id to clear the saved ${this._storageTypeName} was not provided`);\n\t\t} else {\n\t\t\tconst store = this.getCompleteStore();\n\t\t\tconst entry = store[id];\n\n\t\t\tif (!isEmpty(entry)) {\n\t\t\t\tdelete store[id];\n\t\t\t\tthis.setCompleteStore(store);\n\t\t\t} else {\n\t\t\t\tthis._logger?.error(`You tried to delete a non-existent ${this._storageTypeName} with id ${id}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the complete store.\n\t * @returns The complete store.\n\t */\n\tprivate getCompleteStore(): { [key: string]: T } {\n\t\tconst store = localStorage.getItem(this._storageKey);\n\t\tif (isEmpty(store)) {\n\t\t\tthis._logger?.info(`Storage has no ${this._storageTypeName} entries. Creating store`);\n\t\t\tthis.setCompleteStore({});\n\t\t\treturn {};\n\t\t}\n\n\t\treturn JSON.parse(store) as { [key: string]: T };\n\t}\n\n\t/**\n\t * Set the complete store.\n\t * @param store The store to save.\n\t */\n\tprivate setCompleteStore(store: { [key: string]: T }): void {\n\t\tlocalStorage.setItem(this._storageKey, JSON.stringify(store));\n\t}\n}\n","import type { ModuleImplementation, ModuleTypes } from \"workspace-platform-starter/shapes/module-shapes\";\nimport { LocalStorageEndpoint } from \"./endpoint\";\n\nexport const entryPoints: { [type in ModuleTypes]?: ModuleImplementation } = {\n\tendpoint: new LocalStorageEndpoint()\n};\n","import type { Endpoint, EndpointDefinition } from \"workspace-platform-starter/shapes/endpoint-shapes\";\nimport type { Logger, LoggerCreator } from \"workspace-platform-starter/shapes/logger-shapes\";\nimport type { ModuleDefinition, ModuleHelpers } from \"workspace-platform-starter/shapes/module-shapes\";\nimport type { PlatformStorageMetadata } from \"workspace-platform-starter/shapes/platform-shapes\";\nimport type { PlatformStorage } from \"workspace-platform-starter/shapes/platform-storage-shapes\";\nimport { isEmpty } from \"workspace-platform-starter/utils\";\nimport { PlatformLocalStorage } from \"./platform-local-storage\";\n\n/**\n * Endpoint for local storage.\n */\nexport class LocalStorageEndpoint implements Endpoint {\n\t/**\n\t * The logger for displaying information from the module.\n\t * @internal\n\t */\n\tprivate _logger?: Logger;\n\n\t/**\n\t * The logger creator to allow platform storage to perform their own logging.\n\t * @internal\n\t */\n\tprivate _loggerCreator?: LoggerCreator;\n\n\t/**\n\t * The storage for multiple types.\n\t * @internal\n\t */\n\tprivate _storage: { [key: string]: PlatformStorage<unknown> };\n\n\t/**\n\t * Create a new instance of LocalStorageEndpoint.\n\t */\n\tconstructor() {\n\t\tthis._storage = {};\n\t}\n\n\t/**\n\t * Initialize the module.\n\t * @param definition The definition of the module from configuration include custom options.\n\t * @param loggerCreator For logging entries.\n\t * @param helpers Helper methods for the module to interact with the application core.\n\t * @returns Nothing.\n\t */\n\tpublic async initialize(\n\t\tdefinition: ModuleDefinition,\n\t\tloggerCreator: LoggerCreator,\n\t\thelpers: ModuleHelpers\n\t): Promise<void> {\n\t\tthis._loggerCreator = loggerCreator;\n\t\tthis._logger = loggerCreator(\"LocalStorageEndpoint\");\n\t\tthis._logger.info(\"Was passed the following options\", definition.data);\n\t}\n\n\t/**\n\t * Handle an action sent to the endpoint.\n\t * @param endpointDefinition The definition of the endpoint.\n\t * @param endpointDefinition.dataType The type of the data.\n\t * @param endpointDefinition.method The method to use.\n\t * @param request The request to process.\n\t * @param request.platform The platform storing the item.\n\t * @param request.id The id of the storage item.\n\t * @param request.metaData The metadata associated with the payload to store.\n\t * @param request.payload The payload to store.\n\t * @returns True if processed.\n\t */\n\tpublic async action(\n\t\tendpointDefinition: EndpointDefinition<{ dataType: string; method: \"REMOVE\" | \"SET\" }>,\n\t\trequest?: { platform: string; id: string; metaData?: PlatformStorageMetadata; payload?: unknown }\n\t): Promise<boolean> {\n\t\tif (isEmpty(request)) {\n\t\t\tthis._logger?.warn(`A request is required for this action: ${endpointDefinition.id}. Returning false`);\n\t\t\treturn false;\n\t\t}\n\t\tif (endpointDefinition.type !== \"module\") {\n\t\t\tthis._logger?.warn(\n\t\t\t\t`We only expect endpoints of type module. Unable to perform action: ${endpointDefinition.id}`\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (isEmpty(endpointDefinition.options)) {\n\t\t\tthis._logger?.warn(\n\t\t\t\t`The endpoint definition options are required for this action: ${endpointDefinition.id}`\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { dataType, method } = endpointDefinition.options;\n\t\tconst localStorage = this.getStorage<{ metaData: PlatformStorageMetadata; payload: unknown }>(dataType);\n\n\t\tif (method === \"REMOVE\") {\n\t\t\tconst id: string = request.id;\n\t\t\tawait localStorage.remove(id);\n\t\t\treturn true;\n\t\t} else if (method === \"SET\") {\n\t\t\tif (isEmpty(request.metaData)) {\n\t\t\t\tthis._logger?.warn(`The metaData needs to be specified for this action: ${endpointDefinition.id}`);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (isEmpty(request.payload)) {\n\t\t\t\tthis._logger?.warn(`The payload needs to be specified for this action: ${endpointDefinition.id}`);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tawait localStorage.set(request.id, {\n\t\t\t\tmetaData: request.metaData,\n\t\t\t\tpayload: request.payload\n\t\t\t});\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Handle a request response on an endpoint.\n\t * @param endpointDefinition The definition of the endpoint.\n\t * @param endpointDefinition.dataType The type of the data.\n\t * @param endpointDefinition.method The method to use.\n\t * @param request The request to process.\n\t * @param request.platform The platform requesting the item.\n\t * @param request.id The id of the storage item.\n\t * @param request.query The payload to get.\n\t * @returns The response to the request, or null of not handled.\n\t */\n\tpublic async requestResponse(\n\t\tendpointDefinition: EndpointDefinition<{ dataType: string; method: \"GET\" }>,\n\t\trequest?: { platform: string; id?: string; query?: string }\n\t): Promise<unknown> {\n\t\tif (endpointDefinition.type !== \"module\") {\n\t\t\tthis._logger?.warn(\n\t\t\t\t`We only expect endpoints of type module. Unable to action request/response for: ${endpointDefinition.id}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tif (isEmpty(endpointDefinition.options)) {\n\t\t\tthis._logger?.warn(\n\t\t\t\t`The endpoint definition options are required for this action: ${endpointDefinition.id}`\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { dataType, method } = endpointDefinition.options;\n\t\tconst localStorage = this.getStorage<{ metaData: PlatformStorageMetadata; payload: unknown }>(dataType);\n\n\t\tif (method === \"GET\") {\n\t\t\tconst id = request?.id;\n\t\t\tif (isEmpty(id)) {\n\t\t\t\treturn localStorage.getAll();\n\t\t\t}\n\t\t\treturn localStorage.get(id);\n\t\t}\n\t}\n\n\t/**\n\t * Get the storage for the specified id.\n\t * @param id The id of the storage to get.\n\t * @returns The storage for the requested id.\n\t */\n\tprivate getStorage<T>(id: string): PlatformStorage<T> {\n\t\tlet localStorage: PlatformStorage<T> = this._storage[id] as PlatformLocalStorage<T>;\n\t\tif (isEmpty(localStorage)) {\n\t\t\tlocalStorage = new PlatformLocalStorage<T>(id, id, this._loggerCreator);\n\t\t\tthis._storage[id] = localStorage;\n\t\t}\n\t\treturn localStorage;\n\t}\n}\n"],"names":["isEmpty","value","PlatformLocalStorage","constructor","storageId","storageType","loggerCreator","this","_storageTypeName","_storageKey","fin","me","identity","uuid","toLowerCase","replaceAll","_logger","get","id","getCompleteStore","error","set","entry","store","setCompleteStore","getAll","query","Object","keys","length","info","remove","localStorage","getItem","JSON","parse","setItem","stringify","entryPoints","endpoint","_storage","initialize","definition","helpers","_loggerCreator","data","action","endpointDefinition","request","warn","type","options","dataType","method","getStorage","metaData","payload","requestResponse"],"sourceRoot":""}