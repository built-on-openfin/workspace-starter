{"version":3,"file":"favorites-menu.bundle.js","mappings":"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","sources":["webpack://openfin-workspace--workspace-platform-starter/webpack/bootstrap","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/shapes/actions-shapes.ts","webpack://openfin-workspace--workspace-platform-starter/webpack/runtime/define property getters","webpack://openfin-workspace--workspace-platform-starter/webpack/runtime/hasOwnProperty shorthand","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/utils.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/utils-position.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/actions/favorites-menu/index.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/actions/favorites-menu/actions.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/shapes/favorite-shapes.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","import type { CustomActionsMap, ToolbarButton, WorkspacePlatformModule } from \"@openfin/workspace-platform\";\nimport type { ModuleHelpers, ModuleImplementation, ModuleList } from \"./module-shapes\";\n\n/**\n * Definition for an action.\n */\nexport interface Actions<O = unknown> extends ModuleImplementation<O, ActionHelpers> {\n\t/**\n\t * Get the actions from the module.\n\t * @param platform The platform module.\n\t * @returns The map of custom actions.\n\t */\n\tget(platform: WorkspacePlatformModule): Promise<CustomActionsMap>;\n}\n\n/**\n * A list of modules that provide actions that can be used by the platform.\n */\nexport type ActionsProviderOptions = ModuleList;\n\n/**\n * Extended helpers used by action modules.\n */\nexport interface ActionHelpers extends ModuleHelpers {\n\t/**\n\t * Update toolbar buttons.\n\t * @param buttons The list of all buttons.\n\t * @param buttonId The button to update.\n\t * @param replacementButtonId The replacement for the button.\n\t * @returns The updated buttons.\n\t */\n\tupdateToolbarButtons: (\n\t\tbuttons: ToolbarButton[],\n\t\tbuttonId: string,\n\t\treplacementButtonId: string\n\t) => Promise<ToolbarButton[]>;\n}\n\n/**\n * Use this in preference to CustomActionCallerType from workspace-platform to avoid the import of the whole of workspace package in modules.\n */\nexport enum CustomActionCallerType {\n\tCustomButton = \"CustomButton\",\n\tStoreCustomButton = \"StoreCustomButton\",\n\tCustomDropdownItem = \"CustomDropdownItem\",\n\tGlobalContextMenu = \"GlobalContextMenu\",\n\tViewTabContextMenu = \"ViewTabContextMenu\",\n\tPageTabContextMenu = \"PageTabContextMenu\",\n\tSaveButtonContextMenu = \"SaveButtonContextMenu\",\n\tAPI = \"API\"\n}\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * Test if a value is a undefined or null.\n * @param value The value to test.\n * @returns True if the value is null or undefined.\n */\nexport function isEmpty(value: unknown): value is null | undefined {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value === undefined || value === null;\n}\n\n/**\n * Test if a value is an object.\n * @param value The value to test.\n * @returns True if the value is an object.\n */\nexport function isObject(value: unknown): value is object {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n/**\n * Test if a value is a string.\n * @param value The value to test.\n * @returns True if the value is a string.\n */\nexport function isString(value: unknown): value is string {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"string\";\n}\n\n/**\n * Test if a value is a string that is not empty.\n * @param value The value to test.\n * @returns True if the value is a string that is not empty.\n */\nexport function isStringValue(value: unknown): value is string {\n\treturn isString(value) && value.trim().length > 0;\n}\n\n/**\n * Test if a value is a number.\n * @param value The value to test.\n * @returns True if the value is a number.\n */\nexport function isNumber(value: unknown): value is number {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"number\";\n}\n\n/**\n * Test if a value is a number with a real value i.e. not NaN or Infinite.\n * @param value The value to test.\n * @returns True if the value is a number.\n */\nexport function isNumberValue(value: unknown): value is number {\n\treturn isNumber(value) && !Number.isNaN(value) && Number.isFinite(value);\n}\n\n/**\n * Test if a value is a boolean.\n * @param value The value to test.\n * @returns True if the value is a boolean.\n */\nexport function isBoolean(value: unknown): value is boolean {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"boolean\";\n}\n\n/**\n * Test if a value is an integer.\n * @param value The value to test.\n * @returns True if the value is an integer.\n */\nexport function isInteger(value: unknown): value is number {\n\treturn isNumber(value) && Number.isInteger(value);\n}\n\n/**\n * Deep clone an object.\n * @param obj The object to clone.\n * @returns The clone of the object.\n */\nexport function objectClone<T>(obj: T): T {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn obj === undefined ? undefined : JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Do a deep comparison of the objects.\n * @param obj1 The first object to compare.\n * @param obj2 The second object to compare.\n * @param matchPropertyOrder If true the properties must be in the same order.\n * @returns True if the objects are the same.\n */\nexport function deepEqual(obj1: unknown, obj2: unknown, matchPropertyOrder: boolean = true): boolean {\n\tif (isObject(obj1) && isObject(obj2)) {\n\t\tconst objKeys1 = Object.keys(obj1);\n\t\tconst objKeys2 = Object.keys(obj2);\n\n\t\tif (objKeys1.length !== objKeys2.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (matchPropertyOrder && JSON.stringify(objKeys1) !== JSON.stringify(objKeys2)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const key of objKeys1) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst value1 = (obj1 as any)[key];\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst value2 = (obj2 as any)[key];\n\n\t\t\tif (!deepEqual(value1, value2, matchPropertyOrder)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t} else if (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\tif (obj1.length !== obj2.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < obj1.length; i++) {\n\t\t\tif (!deepEqual(obj1[i], obj2[i], matchPropertyOrder)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn JSON.stringify(obj1) === JSON.stringify(obj2);\n}\n\n/**\n * Deep merge two objects.\n * @param target The object to be merged into.\n * @param sources The objects to merge into the target.\n * @returns The merged object.\n */\nexport function deepMerge<T = unknown>(target: T, ...sources: T[]): T {\n\tif (!Array.isArray(sources) || sources.length === 0) {\n\t\treturn target;\n\t}\n\n\tconst targetAsMap = target as { [id: string]: unknown };\n\tconst source = sources.shift();\n\n\tlet keys;\n\tif (isObject(targetAsMap) && isObject(source)) {\n\t\tkeys = Object.keys(source);\n\t} else if (Array.isArray(source)) {\n\t\tif (!Array.isArray(target)) {\n\t\t\treturn source;\n\t\t}\n\t\tkeys = Object.keys(source).map((k) => Number.parseInt(k, 10));\n\t}\n\n\tif (keys) {\n\t\tconst sourceAsMap = source as { [id: string]: unknown };\n\t\tfor (const key of keys) {\n\t\t\tconst value = sourceAsMap[key];\n\t\t\tif (isObject(value)) {\n\t\t\t\tif (isEmpty(targetAsMap[key])) {\n\t\t\t\t\ttargetAsMap[key] = {};\n\t\t\t\t}\n\t\t\t\tdeepMerge(targetAsMap[key], value);\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tif (isEmpty(targetAsMap[key])) {\n\t\t\t\t\ttargetAsMap[key] = [];\n\t\t\t\t}\n\t\t\t\tdeepMerge(targetAsMap[key], value);\n\t\t\t} else {\n\t\t\t\ttargetAsMap[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Polyfills randomUUID if running in a non-secure context.\n * @returns The random UUID.\n */\nexport function randomUUID(): string {\n\tif (\"randomUUID\" in globalThis.crypto) {\n\t\t// eslint-disable-next-line no-restricted-syntax\n\t\treturn globalThis.crypto.randomUUID();\n\t}\n\t// Polyfill the window.crypto.randomUUID if we are running in a non secure context that doesn't have it\n\t// we are still using window.crypto.getRandomValues which is always available\n\t// https://stackoverflow.com/a/2117523/2800218\n\t/**\n\t * Get random hex value.\n\t * @param c The number to base the random value on.\n\t * @returns The random value.\n\t */\n\tfunction getRandomHex(c: string): string {\n\t\t// eslint-disable-next-line no-bitwise\n\t\tconst rnd = globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (Number(c) / 4));\n\t\treturn (\n\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t(Number(c) ^ rnd).toString(16)\n\t\t);\n\t}\n\treturn \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, getRandomHex);\n}\n\n/**\n * Format an error to a readable string.\n * @param err The error to format.\n * @returns The formatted error.\n */\nexport function formatError(err: unknown): string {\n\tif (isEmpty(err)) {\n\t\treturn \"\";\n\t} else if (err instanceof Error) {\n\t\treturn err.message;\n\t} else if (isStringValue(err)) {\n\t\treturn err;\n\t} else if (isObject(err) && \"message\" in err && isString(err.message)) {\n\t\treturn err.message;\n\t}\n\treturn JSON.stringify(err);\n}\n\n/**\n * A basic string sanitize function that removes angle brackets <> from a string.\n * @param content the content to sanitize\n * @returns a string without angle brackets <>\n */\nexport function sanitizeString(content: unknown): string {\n\tif (isStringValue(content)) {\n\t\treturn content\n\t\t\t.replace(/<[^>]*>?/gm, \"\")\n\t\t\t.replace(/&gt;/g, \">\")\n\t\t\t.replace(/&lt;/g, \"<\")\n\t\t\t.replace(/&amp;/g, \"&\")\n\t\t\t.replace(/&nbsp;/g, \" \")\n\t\t\t.replace(/\\n\\s*\\n/g, \"\\n\");\n\t}\n\treturn \"\";\n}\n\n/**\n * Get the command line arguments from a command line string.\n * Examples of command line strings: arg1 key1=value1 key2=\"value with spaces\" key3='value3' key4='value with more spaces'`.\n * @param commandLine The command line string.\n * @returns The command line arguments or an empty array if none\n */\nexport function getCommandLineArgs(commandLine: string): string[] {\n\tif (!isStringValue(commandLine)) {\n\t\treturn [];\n\t}\n\tconst matches = commandLine.match(/(\\w+=)?(\"[^\"]*\"|'[^']*'|[^ ]+)/g);\n\tif (isEmpty(matches)) {\n\t\treturn [];\n\t}\n\treturn matches;\n}\n","import type OpenFin from \"@openfin/core\";\nimport type { BrowserProviderOptions, WindowPositioningOptions } from \"./shapes/browser-shapes\";\nimport { isEmpty } from \"./utils\";\n\n/**\n * Provides x and y co-ordinates to position a window of a given size in relation to another window/view.\n * @param clientIdentity The identity of the view/window these x/y co-ordinates should be in relation to.\n * @param dimensions The dimensions of the window that will be placed in the center of the screen.\n * @param dimensions.width The width of the window that is going to be placed.\n * @param dimensions.height The height of the window that is going to be placed.\n * @returns The x, y co-ordinates to position the window\n */\nexport async function centerContentInIdentity(\n\tclientIdentity: OpenFin.Identity,\n\tdimensions: { width: number; height: number }\n): Promise<{ x: number; y: number } | undefined> {\n\tconst bounds = await getIdentityBounds(clientIdentity);\n\tconst boundsCenter = getBoundsCenter(bounds);\n\tconst monitorInfo = await findMonitorContainingPoint(boundsCenter);\n\treturn centerContentInRect(monitorInfo.availableRect, dimensions);\n}\n\n/**\n * Provides x and y co-ordinates to position content of a given size in relation to a rect.\n * @param availableRect The available rect to position the content in.\n * @param availableRect.left The available rect left to position the content in.\n * @param availableRect.top The available rect top to position the content in.\n * @param availableRect.right The available rect right to position the content in.\n * @param availableRect.bottom The available rect bottom to position the content in.\n * @param contentDimensions The dimensions of the content that will be placed in the center of the screen.\n * @param contentDimensions.width The width of the content that is going to be placed.\n * @param contentDimensions.height The height of the content that is going to be placed.\n * @returns The x, y co-ordinates to position the content\n */\nexport function centerContentInRect(\n\tavailableRect: { left: number; top: number; right: number; bottom: number },\n\tcontentDimensions: { width: number; height: number }\n): { x: number; y: number } {\n\tconst height = availableRect.bottom - availableRect.top;\n\tconst width = availableRect.right - availableRect.left;\n\tconst dividedRectWidth = width / 2;\n\tconst dividedRectHeight = height / 2;\n\tconst dividedDimensionWidth = contentDimensions.width / 2;\n\tconst dividedDimensionHeight = contentDimensions.height / 2;\n\tconst x = availableRect.left + dividedRectWidth - dividedDimensionWidth;\n\tconst y = availableRect.top + dividedRectHeight - dividedDimensionHeight;\n\n\treturn { x: Math.round(x), y: Math.round(y) };\n}\n\n/**\n * Returns the monitor details for the monitor a view/window is placed on.\n * @param clientIdentity The identity of the view/window to check against.\n * @returns The monitor the view/window lives on or undefined if no match was found.\n */\nexport async function getIdentityBounds(\n\tclientIdentity: OpenFin.Identity\n): Promise<OpenFin.Bounds | undefined> {\n\tlet bounds: OpenFin.Bounds | undefined;\n\tlet currentWindow: OpenFin.Window | undefined;\n\n\ttry {\n\t\tconst targetView = fin.View.wrapSync(clientIdentity);\n\t\tcurrentWindow = await targetView.getCurrentWindow();\n\t} catch {\n\t\t// we were not passed a view.\n\t}\n\n\tif (isEmpty(bounds)) {\n\t\ttry {\n\t\t\tconst targetWindow = currentWindow ?? fin.Window.wrapSync(clientIdentity);\n\t\t\tbounds = await targetWindow.getBounds();\n\t\t} catch {\n\t\t\t// it wasn't a window\n\t\t}\n\t}\n\n\tif (isEmpty(bounds)) {\n\t\ttry {\n\t\t\tbounds = await fin.me.getBounds();\n\t\t} catch {\n\t\t\t// unable to get own bounds\n\t\t}\n\t}\n\n\treturn bounds;\n}\n\n/**\n * Find the monitor which contains the point and returns it.\n * @param point The point coord to locate.\n * @param point.x The x coord\n * @param point.y The y coord\n * @returns The monitor containing the point.\n */\nexport async function findMonitorContainingPoint(point: {\n\tx?: number;\n\ty?: number;\n}): Promise<OpenFin.MonitorDetails> {\n\tconst monitorInfo = await fin.System.getMonitorInfo();\n\n\tconst x = point.x;\n\tconst y = point.y;\n\tif (!isEmpty(x) && !isEmpty(y)) {\n\t\tfor (const monitor of monitorInfo.nonPrimaryMonitors) {\n\t\t\tif (pointInRect({ x, y }, monitor.monitorRect)) {\n\t\t\t\treturn monitor;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn monitorInfo.primaryMonitor;\n}\n\n/**\n * Is the point in the rectangle.\n * @param point The coord to match.\n * @param point.x The x coord.\n * @param point.y The y coord.\n * @param rect The rect.\n * @param rect.top The rect top.\n * @param rect.left The rect left.\n * @param rect.bottom The rect bottom.\n * @param rect.right The rect right.\n * @returns True if the point is in the rect.\n */\nexport function pointInRect(\n\tpoint: { x: number; y: number },\n\trect: {\n\t\ttop: number;\n\t\tleft: number;\n\t\tbottom: number;\n\t\tright: number;\n\t}\n): boolean {\n\treturn point.x >= rect.left && point.x <= rect.right && point.y >= rect.top && point.y <= rect.bottom;\n}\n\n/**\n * Get the center for a bounding rectangle.\n * @param bounds The rect\n * @param bounds.top The rect top\n * @param bounds.left The rect left\n * @param bounds.width The rect width\n * @param bounds.height The rect height\n * @returns the x and y of the bounds center or an object not containing x or y.\n */\nexport function getBoundsCenter(bounds?: OpenFin.Bounds): { x?: number; y?: number } {\n\tlet boundsCenterX: number | undefined;\n\tlet boundsCenterY: number | undefined;\n\tif (!isEmpty(bounds)) {\n\t\tconst halfWidth = bounds.width / 2;\n\t\tconst halfHeight = bounds.height / 2;\n\t\tboundsCenterX = bounds.left + halfWidth;\n\t\tboundsCenterY = bounds.top + halfHeight;\n\t\treturn { x: Math.round(boundsCenterX), y: Math.round(boundsCenterY) };\n\t}\n\treturn {};\n}\n\n/**\n * Given browser settings what window positioning options should be used?\n * @param settings The browser settings that have been provided.\n * @returns a set of window positioning options.\n */\nexport async function getWindowPositionOptions(\n\tsettings?: BrowserProviderOptions\n): Promise<WindowPositioningOptions> {\n\tconst windowPositioningOptions: WindowPositioningOptions = {};\n\twindowPositioningOptions.defaults = {};\n\tif (!isEmpty(settings)) {\n\t\twindowPositioningOptions.windowPositioningStrategy = settings.windowPositioningStrategy;\n\t\twindowPositioningOptions.disableWindowPositioningStrategy = settings.disableWindowPositioningStrategy;\n\t\tif (!isEmpty(settings?.defaultWindowOptions?.defaultLeft)) {\n\t\t\twindowPositioningOptions.defaults.left = settings.defaultWindowOptions.defaultLeft;\n\t\t}\n\t\tif (!isEmpty(settings?.defaultWindowOptions?.defaultTop)) {\n\t\t\twindowPositioningOptions.defaults.top = settings.defaultWindowOptions.defaultTop;\n\t\t}\n\t}\n\tif (isEmpty(windowPositioningOptions.defaults.left) || isEmpty(windowPositioningOptions.defaults.top)) {\n\t\tconst app = await fin.Application.getCurrent();\n\t\tconst platformManifest: OpenFin.Manifest = await app.getManifest();\n\t\tif (!isEmpty(platformManifest?.platform?.defaultWindowOptions?.defaultLeft)) {\n\t\t\twindowPositioningOptions.defaults.left = platformManifest.platform.defaultWindowOptions.defaultLeft;\n\t\t}\n\t\tif (!isEmpty(platformManifest?.platform?.defaultWindowOptions?.defaultTop)) {\n\t\t\twindowPositioningOptions.defaults.top = platformManifest.platform.defaultWindowOptions.defaultTop;\n\t\t}\n\t}\n\treturn windowPositioningOptions;\n}\n\n/**\n * Get the window position using a strategy.\n * @param windowPositioningOptions The options for window positioning.\n * @param windowPositioningOptions.windowPositioningStrategy The strategy for window positioning.\n * @param windowPositioningOptions.windowPositioningStrategy.x The x coordinate.\n * @param windowPositioningOptions.windowPositioningStrategy.y The y coordinate.\n * @param windowPositioningOptions.disableWindowPositioningStrategy Whether to disable the window positioning strategy.\n * @param relatedTo The related monitor or identity or x/y position.\n * @returns The x and y coordinates of the window position.\n */\nexport async function getWindowPositionUsingStrategy(\n\twindowPositioningOptions?: WindowPositioningOptions,\n\trelatedTo?: OpenFin.MonitorDetails | OpenFin.Identity | { x: number; y: number }\n): Promise<{ left: number; top: number } | undefined> {\n\tif (windowPositioningOptions?.disableWindowPositioningStrategy === true) {\n\t\treturn;\n\t}\n\tlet targetMonitor: OpenFin.MonitorDetails | undefined;\n\n\tif (isEmpty(relatedTo)) {\n\t\tconst monitors = await fin.System.getMonitorInfo();\n\t\ttargetMonitor = monitors.primaryMonitor;\n\t} else if (!isEmpty(relatedTo) && \"monitorRect\" in relatedTo) {\n\t\ttargetMonitor = relatedTo;\n\t} else if (!isEmpty(relatedTo) && \"x\" in relatedTo) {\n\t\ttargetMonitor = await findMonitorContainingPoint(relatedTo);\n\t} else {\n\t\tconst bounds = await getIdentityBounds(relatedTo);\n\t\tif (isEmpty(bounds)) {\n\t\t\tconst monitors = await fin.System.getMonitorInfo();\n\t\t\ttargetMonitor = monitors.primaryMonitor;\n\t\t} else {\n\t\t\ttargetMonitor = await findMonitorContainingPoint({ x: bounds.left, y: bounds.top });\n\t\t}\n\t}\n\tconst windowDefaultLeft = windowPositioningOptions?.defaults?.left ?? 0;\n\tconst windowDefaultTop = windowPositioningOptions?.defaults?.top ?? 0;\n\n\t// Get the available rect for the display so we can take in to account\n\t// OS menus, task bar etc\n\tconst availableLeft = targetMonitor.availableRect.left;\n\tconst availableTop = targetMonitor.availableRect.top;\n\tconst windowOffsetsX: number = windowPositioningOptions?.windowPositioningStrategy?.x ?? 30;\n\tconst windowOffsetsY: number = windowPositioningOptions?.windowPositioningStrategy?.y ?? 30;\n\tconst windowOffsetsMaxIncrements: number =\n\t\twindowPositioningOptions?.windowPositioningStrategy?.maxIncrements ?? 8;\n\tconst visibleWindows = await getAllVisibleWindows();\n\t// Get the top left bounds for all the visible windows\n\tconst topLeftBounds = await Promise.all(\n\t\tvisibleWindows.map(async (win) => {\n\t\t\ttry {\n\t\t\t\tconst bounds = await win.getBounds();\n\t\t\t\treturn {\n\t\t\t\t\tleft: bounds.left,\n\t\t\t\t\ttop: bounds.top,\n\t\t\t\t\tright: bounds.left + windowOffsetsX,\n\t\t\t\t\tbottom: bounds.top + windowOffsetsY\n\t\t\t\t};\n\t\t\t} catch {\n\t\t\t\t// return a dummy entry.\n\t\t\t\treturn {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\tbottom: 0\n\t\t\t\t};\n\t\t\t}\n\t\t})\n\t);\n\n\tlet minCountVal: number = 1000;\n\tlet minCountIndex = windowOffsetsMaxIncrements;\n\n\t// Now see how many windows appear in each increment slot\n\tfor (let i = 0; i < windowOffsetsMaxIncrements; i++) {\n\t\tconst xPos = i * windowOffsetsX;\n\t\tconst yPos = i * windowOffsetsY;\n\t\tconst leftPos = windowDefaultLeft + xPos;\n\t\tconst topPos = windowDefaultTop + yPos;\n\t\tconst foundWins = topLeftBounds.filter(\n\t\t\t(topLeftWinBounds) =>\n\t\t\t\ttopLeftWinBounds.left >= leftPos + availableLeft &&\n\t\t\t\ttopLeftWinBounds.right <= leftPos + windowOffsetsX + availableLeft &&\n\t\t\t\ttopLeftWinBounds.top >= topPos + availableTop &&\n\t\t\t\ttopLeftWinBounds.bottom <= topPos + windowOffsetsY + availableTop\n\t\t);\n\t\t// If this slot has less than the current minimum use this slot\n\t\tif (foundWins.length < minCountVal) {\n\t\t\tminCountVal = foundWins.length;\n\t\t\tminCountIndex = i;\n\t\t}\n\t}\n\n\tconst xOffset = minCountIndex * windowOffsetsX;\n\tconst x = windowDefaultLeft + xOffset + availableLeft;\n\tconst yOffset = minCountIndex * windowOffsetsY;\n\tconst y = windowDefaultTop + yOffset + availableTop;\n\n\treturn { left: x, top: y };\n}\n\n/**\n * Get a list of all the visible windows in the platform.\n * @returns The list of visible windows.\n */\nexport async function getAllVisibleWindows(): Promise<OpenFin.Window[]> {\n\tconst platform = fin.Platform.getCurrentSync();\n\tconst windows = await platform.Application.getChildWindows();\n\tconst availableWindows: OpenFin.Window[] = [];\n\tfor (const currentWindow of windows) {\n\t\ttry {\n\t\t\tconst isShowing = await currentWindow.isShowing();\n\t\t\tif (isShowing) {\n\t\t\t\tavailableWindows.push(currentWindow);\n\t\t\t}\n\t\t} catch {\n\t\t\t// if the window is destroyed before determining if it is showing then\n\t\t\t// we should move to the next window but not throw.\n\t\t}\n\t}\n\treturn availableWindows;\n}\n","import type { ModuleImplementation, ModuleTypes } from \"workspace-platform-starter/shapes/module-shapes\";\nimport { FavoritesMenuProvider } from \"./actions\";\n\n/**\n * Define the entry points for the module.\n */\nexport const entryPoints: { [type in ModuleTypes]?: ModuleImplementation } = {\n\tactions: new FavoritesMenuProvider()\n};\n","import type {\n\tCustomActionPayload,\n\tCustomActionsMap,\n\tWorkspacePlatformModule\n} from \"@openfin/workspace-platform\";\nimport { CustomActionCallerType, type Actions } from \"workspace-platform-starter/shapes/actions-shapes\";\nimport type { LaunchPreference } from \"workspace-platform-starter/shapes/app-shapes\";\nimport {\n\tFAVORITE_TYPE_NAME_APP,\n\tFAVORITE_TYPE_NAME_PAGE,\n\tFAVORITE_TYPE_NAME_WORKSPACE,\n\ttype FavoriteEntry\n} from \"workspace-platform-starter/shapes/favorite-shapes\";\nimport type { Logger, LoggerCreator } from \"workspace-platform-starter/shapes/logger-shapes\";\nimport type { PopupMenuEntry } from \"workspace-platform-starter/shapes/menu-shapes\";\nimport type { ModuleDefinition, ModuleHelpers } from \"workspace-platform-starter/shapes/module-shapes\";\nimport { isEmpty } from \"workspace-platform-starter/utils\";\nimport { getWindowPositionUsingStrategy } from \"workspace-platform-starter/utils-position\";\nimport type { FavoritesMenuSettings } from \"./shapes\";\n\n/**\n * Implementation for the favorites menu actions provider.\n */\nexport class FavoritesMenuProvider implements Actions<FavoritesMenuSettings> {\n\t/**\n\t * The logger for displaying information from the module.\n\t * @internal\n\t */\n\tprivate _logger?: Logger;\n\n\t/**\n\t * Helper methods for the module.\n\t * @internal\n\t */\n\tprivate _helpers: ModuleHelpers | undefined;\n\n\t/**\n\t * The settings for the menu.\n\t * @internal\n\t */\n\tprivate _settings: FavoritesMenuSettings | undefined;\n\n\t/**\n\t * Initialize the module.\n\t * @param definition The definition of the module from configuration include custom options.\n\t * @param loggerCreator For logging entries.\n\t * @param helpers Helper methods for the module to interact with the application core.\n\t * @returns Nothing.\n\t */\n\tpublic async initialize(\n\t\tdefinition: ModuleDefinition<FavoritesMenuSettings>,\n\t\tloggerCreator: LoggerCreator,\n\t\thelpers: ModuleHelpers\n\t): Promise<void> {\n\t\tthis._logger = loggerCreator(\"FavoritesMenuProvider\");\n\t\tthis._helpers = helpers;\n\t\tthis._settings = definition.data;\n\n\t\tthis._logger.info(\"Initializing\");\n\t}\n\n\t/**\n\t * Get the actions from the module.\n\t * @param platform The platform module.\n\t * @returns The map of custom actions.\n\t */\n\tpublic async get(platform: WorkspacePlatformModule): Promise<CustomActionsMap> {\n\t\tconst actionMap: CustomActionsMap = {};\n\n\t\tactionMap[\"favorites-menu\"] = async (payload: CustomActionPayload): Promise<void> => {\n\t\t\tif (payload.callerType === CustomActionCallerType.CustomButton && this._helpers) {\n\t\t\t\tconst getClient = this._helpers?.getFavoriteClient;\n\t\t\t\tif (!isEmpty(getClient)) {\n\t\t\t\t\tconst client = await getClient();\n\t\t\t\t\tif (!isEmpty(client)) {\n\t\t\t\t\t\tconst favInfo = client.getInfo();\n\t\t\t\t\t\tconst menuEntries: PopupMenuEntry<FavoriteEntry>[] = [];\n\n\t\t\t\t\t\tif (favInfo.enabledTypes) {\n\t\t\t\t\t\t\tlet hadEntries = false;\n\t\t\t\t\t\t\tfor (const type of favInfo.enabledTypes) {\n\t\t\t\t\t\t\t\tconst saved = await client.getSavedFavorites(type);\n\t\t\t\t\t\t\t\tif (saved && saved.length > 0) {\n\t\t\t\t\t\t\t\t\tif (hadEntries) {\n\t\t\t\t\t\t\t\t\t\tmenuEntries.push({ type: \"separator\" });\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tsaved.sort((f1, f2) => (f1.label ?? \"\").localeCompare(f2.label ?? \"\"));\n\n\t\t\t\t\t\t\t\t\tfor (const entry of saved) {\n\t\t\t\t\t\t\t\t\t\tmenuEntries.push({\n\t\t\t\t\t\t\t\t\t\t\tlabel: entry.label ?? \"\",\n\t\t\t\t\t\t\t\t\t\t\ticon: entry.icon,\n\t\t\t\t\t\t\t\t\t\t\tdata: entry\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\thadEntries = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst menuClient = await this._helpers.getMenuClient();\n\t\t\t\t\t\tconst popupMenuStyle = this._settings?.popupMenuStyle ?? menuClient.getPopupMenuStyle();\n\n\t\t\t\t\t\tconst result = await menuClient.showPopupMenu<FavoriteEntry>(\n\t\t\t\t\t\t\t{ x: payload.x, y: 48 },\n\t\t\t\t\t\t\tpayload.windowIdentity,\n\t\t\t\t\t\t\t\"There are no favorites\",\n\t\t\t\t\t\t\tmenuEntries,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpopupMenuStyle\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (isEmpty(result)) {\n\t\t\t\t\t\t\tthis._logger?.info(\"Favorites Menu Dismissed\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._logger?.info(\"Favorites Menu Item Selected\", result);\n\n\t\t\t\t\t\t\tif (result.type === FAVORITE_TYPE_NAME_APP) {\n\t\t\t\t\t\t\t\tif (!isEmpty(this._helpers?.launchApp)) {\n\t\t\t\t\t\t\t\t\tlet launchPreference: LaunchPreference | undefined;\n\t\t\t\t\t\t\t\t\tconst bounds = await getWindowPositionUsingStrategy(\n\t\t\t\t\t\t\t\t\t\tundefined, // go with defaults\n\t\t\t\t\t\t\t\t\t\tpayload.windowIdentity\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (!isEmpty(bounds)) {\n\t\t\t\t\t\t\t\t\t\tlaunchPreference = { bounds };\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tawait this._helpers?.launchApp(result.typeId, launchPreference);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (result.type === FAVORITE_TYPE_NAME_PAGE) {\n\t\t\t\t\t\t\t\tif (!isEmpty(this._helpers?.launchPage)) {\n\t\t\t\t\t\t\t\t\tawait this._helpers?.launchPage(result.typeId, undefined, this._logger);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (result.type === FAVORITE_TYPE_NAME_WORKSPACE) {\n\t\t\t\t\t\t\t\tif (!isEmpty(this._helpers?.launchWorkspace)) {\n\t\t\t\t\t\t\t\t\tawait this._helpers?.launchWorkspace(result.typeId);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._logger?.info(`Favorites Type ${result.type} no yet supported`, result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\treturn actionMap;\n\t}\n}\n","import type { PlatformStorageMetadata } from \"./platform-shapes\";\n\n/**\n * Favorite type for App.\n */\nexport const FAVORITE_TYPE_NAME_APP = \"app\";\n\n/**\n * Favorite type for Workspace.\n */\nexport const FAVORITE_TYPE_NAME_WORKSPACE = \"workspace\";\n\n/**\n * Favorite type for Page.\n */\nexport const FAVORITE_TYPE_NAME_PAGE = \"page\";\n\n/**\n * Favorite type for Query.\n */\nexport const FAVORITE_TYPE_NAME_QUERY = \"query\";\n\n/**\n * Names for all the favorite types.\n */\nexport type FavoriteTypeNames =\n\t| typeof FAVORITE_TYPE_NAME_APP\n\t| typeof FAVORITE_TYPE_NAME_WORKSPACE\n\t| typeof FAVORITE_TYPE_NAME_PAGE\n\t| typeof FAVORITE_TYPE_NAME_QUERY;\n\n/**\n * Options for the favorite provider.\n */\nexport interface FavoriteProviderOptions {\n\t/**\n\t * Is the provider enabled, defaults to true.\n\t */\n\tenabled?: boolean;\n\n\t/**\n\t * The icon that should be used if you want to indicate this is a favorite action\n\t */\n\tfavoriteIcon: string;\n\n\t/**\n\t * The icon to use to indicate that this favorite can be unset\n\t */\n\tunfavoriteIcon: string;\n\n\t/**\n\t * What commands should integrations check for if they intent to support the display of favorites\n\t */\n\tfavoriteCommand?: string;\n\n\t/**\n\t * The connection provider can have actions registered against it from the platform. This provides a default list of\n\t * actions that connections should be able to use if actions are enabled for that connection.\n\t */\n\tsupportedFavoriteTypes?: FavoriteTypeNames[];\n}\n\n/**\n * When an entry is made it represents a type supported by this platform. This can be used to lookup and launch the thing this entry refers to.\n */\nexport interface FavoriteEntry {\n\t/**\n\t * A unique guid to represent this favorite entry so that it can be updated or removed\n\t */\n\tid: string;\n\n\t/**\n\t * The id for the favorite type this entry represents\n\t */\n\ttypeId: string;\n\n\t/**\n\t * What type of favorite entry does this entry represent\n\t */\n\ttype: FavoriteTypeNames;\n\n\t/**\n\t * The timestamp for the entry.\n\t */\n\ttimestamp?: Date;\n\n\t/**\n\t * Does this favorite have a suggested label that can be used to avoid a lookup\n\t */\n\tlabel?: string;\n\n\t/**\n\t * Does this favorite have a suggested icon that can be used to avoid a lookup\n\t */\n\ticon?: string;\n}\n\n/**\n * Info to return to interested parties to help them support favorites\n */\nexport interface FavoriteInfo {\n\t/**\n\t * The path to an icon that can be used to indicate the ability to favorite\n\t */\n\tfavoriteIcon?: string;\n\t/**\n\t * The path to an icon that can be used to indicate the ability to remove this favorite\n\t */\n\tunfavoriteIcon?: string;\n\t/**\n\t * A command that supporting modules should listen for if they are to display favorites that fall under them\n\t */\n\tcommand?: string;\n\t/**\n\t * What types of favorite item are supported on this platform, this also determines the ordering in the dock menu.\n\t */\n\tenabledTypes?: FavoriteTypeNames[];\n\t/**\n\t * Is favorite support enabled on this platform.\n\t */\n\tisEnabled: boolean;\n}\n\n/**\n * A client that can be used to provide access to some or all of the favorite functionality\n */\nexport interface FavoriteClient {\n\t/**\n\t * The ability to request supporting information about whether favorites are initialized for the platform and supporting information.\n\t * @returns Supporting information.\n\t */\n\tgetInfo(): FavoriteInfo;\n\t/**\n\t * The ability to request all (or some if by type) of the saved favorites\n\t * @param byType the type of saved favorite you are looking for\n\t * @returns An array of saved favorites or an empty array if it was unable to get any back\n\t */\n\tgetSavedFavorites(byType?: FavoriteTypeNames): Promise<FavoriteEntry[] | undefined>;\n\t/**\n\t * The ability to request a particular saved favorite.\n\t * @param id the id of the favorite you are looking for\n\t * @returns the saved favorite if available or false if it didn't exist\n\t */\n\tgetSavedFavorite(id: string): Promise<FavoriteEntry | undefined>;\n\t/**\n\t * The ability to save a favorite.\n\t * @param favorite the Favorite you wish to save\n\t * @returns whether or not the favorite was saved\n\t */\n\tsetSavedFavorite?(favorite: FavoriteEntry): Promise<boolean>;\n\t/**\n\t * The ability to remove/delete a saved favorite.\n\t * @param id The id of the favorite to delete\n\t * @returns whether or not the favorite was deleted.\n\t */\n\tdeleteSavedFavorite?(id: string): Promise<boolean>;\n}\n\n/**\n * An object that represents a favorite and meta data related to it\n */\nexport interface EndpointFavoriteEntry {\n\t/**\n\t * Information related to the platform providing the payload.\n\t */\n\tmetaData: PlatformStorageMetadata;\n\t/**\n\t * The favorite entry\n\t */\n\tpayload: FavoriteEntry;\n}\n\n/**\n * A request type for the FavoriteEndpoint that gets all saved favorite entries\n */\nexport interface EndpointFavoriteListRequest {\n\t/**\n\t * The id of the platform making the request\n\t */\n\tplatform: string;\n\t/**\n\t * The type if specified should be used to filter the response to only send the entries that are relevant\n\t */\n\tfavoriteType?: FavoriteTypeNames;\n}\n\n/**\n * The response after the request for favorites was fulfilled\n */\nexport interface EndpointFavoriteListResponse {\n\t/**\n\t * The list of favorite entries with information of what platform versions they were originally saved against\n\t */\n\tentries: EndpointFavoriteEntry[];\n}\n\n/**\n * The request for getting a specific favorite entry\n */\nexport interface EndpointFavoriteGetRequest {\n\t/**\n\t * The id of the platform making the request\n\t */\n\tplatform: string;\n\t/**\n\t * The id of the specific entry that has been saved\n\t */\n\tid: string;\n}\n\n/**\n * The response after the request for a specific favorite was fulfilled\n */\nexport type EndpointFavoriteGetResponse = EndpointFavoriteEntry;\n\n/**\n * The request for getting a specific favorite entry\n */\nexport interface EndpointFavoriteSetRequest extends EndpointFavoriteEntry {\n\t/**\n\t * The id of the platform making the request\n\t */\n\tplatform: string;\n\t/**\n\t * The id of the specific entry that is to be set\n\t */\n\tid: string;\n}\n\n/**\n * The request for removing a specific favorite entry\n */\nexport interface EndpointFavoriteRemoveRequest {\n\t/**\n\t * The id of the platform making the request\n\t */\n\tplatform: string;\n\t/**\n\t * The id of the specific entry that is to be removed\n\t */\n\tid: string;\n}\n"],"names":["CustomActionCallerType","__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","value","async","findMonitorContainingPoint","point","monitorInfo","fin","System","getMonitorInfo","x","y","monitor","nonPrimaryMonitors","pointInRect","monitorRect","primaryMonitor","rect","left","right","top","bottom","getWindowPositionUsingStrategy","windowPositioningOptions","relatedTo","disableWindowPositioningStrategy","targetMonitor","bounds","clientIdentity","currentWindow","targetView","View","wrapSync","getCurrentWindow","targetWindow","Window","getBounds","me","getIdentityBounds","windowDefaultLeft","defaults","windowDefaultTop","availableLeft","availableRect","availableTop","windowOffsetsX","windowPositioningStrategy","windowOffsetsY","windowOffsetsMaxIncrements","maxIncrements","visibleWindows","platform","Platform","getCurrentSync","windows","Application","getChildWindows","availableWindows","isShowing","push","getAllVisibleWindows","topLeftBounds","Promise","all","map","win","minCountVal","minCountIndex","i","leftPos","topPos","foundWins","filter","topLeftWinBounds","length","entryPoints","actions","initialize","loggerCreator","helpers","this","_logger","_helpers","_settings","data","info","actionMap","payload","callerType","CustomButton","getClient","getFavoriteClient","client","favInfo","getInfo","menuEntries","enabledTypes","hadEntries","type","saved","getSavedFavorites","sort","f1","f2","label","localeCompare","entry","icon","menuClient","getMenuClient","popupMenuStyle","getPopupMenuStyle","result","showPopupMenu","windowIdentity","launchApp","launchPreference","undefined","typeId","launchPage","launchWorkspace"],"sourceRoot":""}