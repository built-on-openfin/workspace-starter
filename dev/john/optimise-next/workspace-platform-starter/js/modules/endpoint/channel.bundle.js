var n={d:(o,t)=>{for(var e in t)n.o(t,e)&&!n.o(o,e)&&Object.defineProperty(o,e,{enumerable:!0,get:t[e]})},o:(n,o)=>Object.prototype.hasOwnProperty.call(n,o)},o={};function t(n){return null==n}n.d(o,{k:()=>e});const e={endpoint:new class{async initialize(n,o,t){this._logger=o("ChannelEndpoint"),this._logger.info("Was passed the following options",n.data)}async action(n,o){if(t(o))return this._logger?.warn(`A request is required for this action: ${n.id}. Returning false`),!1;if("module"!==n.type)return this._logger?.warn(`We only expect endpoints of type module. Unable to perform action: ${n.id}`),!1;const e=n?.options?.logInfo??!0,i=n?.options?.logWarn??!0,r=n?.options?.logError??!0;if(t(n.options)||t(n.options.actionName)||t(n.options.channelName))return i&&this._logger?.warn(`You need to provide actionName and channelName for endpoint: ${n.id}`),!1;try{const r=await fin.InterApplicationBus.Channel.connect(n.options.channelName,{wait:n.options.wait,payload:n.options.payload});return t(n.options.uuid)||n.options.uuid===r.providerIdentity.uuid?(e&&this._logger?.info(`Sending action for endpoint id: ${n.id}`),await r.dispatch(n.options.actionName,o?.payload),await r.disconnect(),!0):(i&&this._logger?.warn(`Endpoint Id: ${n.id} has the source running (${n.options.uuid}) but the provider of the channel: ${n.options.channelName} is not coming from the source. Returning false.`),!1)}catch(o){return r&&this._logger?.error(`Error executing/or connecting to action. Endpoint with id: ${n.id}`,o),!1}}async requestResponse(n,o){let e=null;if("module"!==n.type)return this._logger?.warn(`We only expect endpoints of type module. Unable to action request/response for: ${n.id}`),e;const i=n?.options?.logInfo??!0,r=n?.options?.logWarn??!0,a=n?.options?.logError??!0;if(t(n?.options?.default)||("array"===n.options.default?e=[]:"object"===n.options.default&&(e={})),t(n.options)||t(n.options.actionName)||t(n.options.channelName))return r&&this._logger?.warn(`You need to provide actionName and channelName for endpoint: ${n.id}`),e;try{const a=await fin.InterApplicationBus.Channel.connect(n.options.channelName,{wait:n.options.wait,payload:n.options.payload});if(!t(n.options.uuid)&&n.options.uuid!==a.providerIdentity.uuid)return r&&this._logger?.warn(`Endpoint Id: ${n.id} has the source running (${n.options.uuid}) but the provider of the channel: ${n.options.channelName} is not coming from the source. Returning false.`),e;i&&this._logger?.info(`Sending request response for endpoint: ${n.id}`);const s=await a.dispatch(n.options.actionName,o?.payload);return await a.disconnect(),s}catch(o){return a&&this._logger?.error(`Error executing request/response and connecting to endpoint with id: ${n.id}`,o),e}}}};var i=o.k;export{i as entryPoints};
//# sourceMappingURL=channel.bundle.js.map