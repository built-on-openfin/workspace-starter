function t(t){return null==t}function e(t){return null!=t&&"string"==typeof t}function n(t){return e(t)&&t.trim().length>0}function i(e){const n=[],i=[];if(Array.isArray(e.icons))for(const i of e.icons)t(i.src)||n.push(i.src);if(Array.isArray(e.images))for(const n of e.images)t(n.src)||i.push(n.src);return{appId:e.appId,description:e.description,icons:n,images:i,name:e.appId,title:e.title,tooltip:e.tooltip,version:e.version}}function s(t,e){return{appId:t.appId,description:t.description,icons:t.icons,name:t.name,screenshots:t.images,title:t.title,tooltip:t.tooltip,version:t.version,resultType:e}}const a="AppTimeout",r="NoAppsFound",o="ResolverUnavailable",p="TargetAppUnavailable",d="TargetInstanceUnavailable",c="IntentDeliveryFailed",l="unregistered-app";class h{constructor(t,e,n,i){this._validatedAppIds=[],this._invalidAppIds=[],this._unregisteredApp=i,this._logger=n,this._getApp=t,this._platformId=e}async lookupAppId(t){if(t.name.startsWith("internal-generated-"))return t.uuid===this._platformId?this._unregisteredApp?(this._logger.debug(`A window or view that is not an app but runs within the platform is running and a placeholder app has been specified ${this._unregisteredApp?.appId}}.`,t),this._unregisteredApp.appId):void this._logger.debug("A window or view that is not an app but runs within the platform is running and no unregistered placeholder app is specified so no appId will be returned.",t):void this._logger.debug("A window or view that follows the runtime generated naming convention is running from another platform. It will not be assigned an appId.",t);const e=t.name.split("/");let n;return n=1===e.length||2===e.length?e[0]:`${e[0]}/${e[1]}`,this._validatedAppIds.includes(n)?n:this._invalidAppIds.includes(n)?void 0:await this._getApp(n)?(this._validatedAppIds.push(n),n):(this._invalidAppIds.push(n),void this._logger.warn(`AppId ${n} does not exist in the directory and it isn't a generated view/window that falls under this platform. No app id will be returned as it is unconfirmed.`))}}class u{constructor(t,e){this._getApps=t,this._logger=e}async getAppsByIntent(e){return(await this._getApps()).filter((n=>{const i=n.interop?.intents?.listensFor;if(t(i))return!1;const s=Object.keys(i);for(const t of s)if(t.toLowerCase()===e.toLowerCase())return!0;return!1}))}async getIntent(e,n,i){const s=await this._getApps();if(0===s.length)return void this._logger.warn("There was no apps returned so we are unable to find apps that support an intent");const a={};for(const r of s)if(r.interop?.intents?.listensFor&&!t(r.interop.intents.listensFor[e])){const t=r.interop.intents.listensFor[e];this.appIntentContains(t,n,i)&&this.updateAppIntentsMap(a,e,t.displayName,r)}const r=Object.values(a);if(0!==r.length)return 1===r.length||this._logger.warn(`Received more than one result for findIntent for intent ${e} and context ${n} and resultType ${i}. Returning the first entry.`),r[0];this._logger.info(`No results found for findIntent for intent ${e} and context ${n} and resultType ${i}`)}async getIntentsByContext(e,n){const i=await this._getApps();if(0===i.length)return this._logger.warn("Unable to get apps so we can not get apps and intents that support a particular context"),[];const s={};for(const a of i){const i=a.interop?.intents?.listensFor;if(!t(i)){const t=Object.keys(i);for(const r of t){const t=i[r];this.appIntentContains(t,e,n)&&this.updateAppIntentsMap(s,r,t.displayName,a)}}}return Object.values(s)}appIntentContains(e,n,i){if(t(n)||t(i)){if(!t(n)&&!e?.contexts?.includes(n))return!1;if(!t(i)&&!e?.resultType?.includes(i))return!1}else if(!e?.contexts?.includes(n)||!e.resultType?.includes(i))return!1;return!0}updateAppIntentsMap(e,n,i,s){t(e[n])&&(e[n]={intent:{name:n,displayName:i},apps:[]}),e[n].apps.push(s)}}async function g(t,e,n,i,s){const a=[],r=[];if("1.2"===e){for(const e of t){const t=n(e);r.push(t)}return r}for(const e of t){const t=i(e),n=await s(e.appId);a.push(t);for(const e of n){const n={...t,instanceId:e.instanceId};a.push(n)}}return a}class f{constructor(t,e){this._logger=e,this._lookupAppId=t,this._clientReadyRequests={},this._trackedClientConnections={},this._trackedContextHandlers={},this._trackedIntentHandlers={}}async clientDisconnected(t){this._logger.info("Client Disconnected.",t);for(const[e,n]of Object.entries(this._trackedIntentHandlers))this._trackedIntentHandlers[e]=n.filter((e=>e.clientIdentity.endpointId!==t.endpointId));for(const[e,n]of Object.entries(this._trackedContextHandlers))this._trackedContextHandlers[e]=n.filter((e=>e.clientIdentity.endpointId!==t.endpointId));this.removeTrackedClientConnection(t)}async intentHandlerRegistered(e,n){if(this._logger.info("intentHandlerRegistered:",e,n),!t(e)){const i=e.handlerId.replace("intent-handler-","");let s=this._trackedIntentHandlers[i];if(t(s)&&(s=[],this._trackedIntentHandlers[i]=s),t(this._trackedIntentHandlers[i].find((t=>t.clientIdentity.endpointId===n.endpointId)))){this._logger.info(`intentHandler endpoint not registered. Registering ${n.endpointId} against intent ${i} and looking up app name.`);const s=await this._lookupAppId(n);if(t(s))return void this._logger.warn("Unable to determine app id based on name. This app will not be tracked via intent handler registration.");this._trackedIntentHandlers[i].push({fdc3Version:e.fdc3Version,clientIdentity:n,appId:s}),this._logger.info(`intentHandler endpoint: ${n.endpointId} registered against intent: ${i} and app Id: ${s}.`)}const a=this.getClientReadyKey(n,"intent",i);t(this._clientReadyRequests[a])||(this._logger.info("Resolving client ready request."),this._clientReadyRequests[a](n.endpointId))}}async contextHandlerRegistered(e,n){if(this._logger.info("contextHandlerRegistered:",e,n),!t(e?.handlerId)){const i=e?.contextType??"*",s=e.handlerId;let a=this._trackedContextHandlers[i];if(t(a)&&(a=[],this._trackedContextHandlers[i]=a),t(this._trackedContextHandlers[i].find((t=>t.clientIdentity.endpointId===n.endpointId)))){this._logger.info(`contextHandler endpoint not registered. Registering ${n.endpointId} against context handler for context type ${i} and looking up app name.`);const e=await this._lookupAppId(n);if(t(e))return void this._logger.warn("Unable to determine app id based on name. This app will not be tracked via context handler registration.");this._trackedContextHandlers[i].push({clientIdentity:n,appId:e,handlerId:s}),this._logger.info(`contextHandler endpoint: ${n.endpointId} registered against context type: ${i} and app Id: ${e}.`)}const r=this.getClientReadyKey(n,"context",i);t(this._clientReadyRequests[r])||(this._logger.info("Resolving client ready request."),this._clientReadyRequests[r](n.endpointId))}}async clientConnectionRegistered(e,i){const s=`${e.uuid}-${e.name}`;let a;if(t(this._trackedClientConnections[s])){if(e.uuid!==fin.me.identity.uuid){const s=i?.apiVersion;a=t(s)||t(s?.type)?n(e.connectionUrl)?{type:"fdc3",version:"2.0"}:{type:"interop"}:s}else{const n=e.entityType;if(t(n))a=await this.captureViewApiUsage(e),t(a)&&(a=await this.captureWindowApiUsage(e));else switch(n){case"window":a=await this.captureWindowApiUsage(e);break;case"view":a=await this.captureViewApiUsage(e);break;default:this._logger.warn(`We currently do not check for entity types that are not views or windows. Entity type: ${n}`)}}const r={clientIdentity:e,apiMetadata:a};this._trackedClientConnections[s]=r;const o=this.getClientReadyKey(e,"connection");t(this._clientReadyRequests[o])||(this._logger.info("Resolving client ready request."),this._clientReadyRequests[o](e.endpointId))}}getRegisteredContextHandler(t,e){const n=this._trackedContextHandlers[t]?.find((t=>t.clientIdentity.endpointId===e));return n}async findAppInstances(e,n,i="connected"){const s={};if("intent"===i){for(const[,t]of Object.entries(this._trackedIntentHandlers)){const n=t.filter((t=>t.appId===e.appId));for(const t of n)s[t.clientIdentity.endpointId]={appId:t.appId??"",instanceId:t.clientIdentity.endpointId}}return Object.values(s)}for(const[,n]of Object.entries(this._trackedClientConnections))await this._lookupAppId(n.clientIdentity)===e.appId&&t(s[n.clientIdentity.endpointId])&&(s[n.clientIdentity.endpointId]={appId:e.appId??"",instanceId:n.clientIdentity.endpointId});return Object.values(s)}getApiVersion(t){const e=`${t.uuid}-${t.name}`,n=this._trackedClientConnections[e]?.apiMetadata;return n}async onConnectionClientReady(e,n=15e3){return new Promise(((i,s)=>{const a=this.getClientIdentity(e);t(a)||i(a.endpointId);const r=this.getClientReadyKey(e,"connection"),o=setTimeout((()=>{t(this._clientReadyRequests[r])||(delete this._clientReadyRequests[r],s(d))}),n);this._clientReadyRequests[r]=t=>{clearTimeout(o),delete this._clientReadyRequests[r],i(t)}}))}async onIntentClientReady(e,n,i=15e3){return new Promise(((s,a)=>{const r=this._trackedIntentHandlers[n];let o;if(!t(r))for(const t of r)if(t.clientIdentity.uuid===e.uuid&&t.clientIdentity.name===e.name){o=t.clientIdentity.endpointId;break}t(o)||s(o);const p=this.getClientReadyKey(e,"intent",n),d=setTimeout((()=>{t(this._clientReadyRequests[p])||(delete this._clientReadyRequests[p],a(c))}),i);this._clientReadyRequests[p]=t=>{clearTimeout(d),delete this._clientReadyRequests[p],s(t)}}))}async onContextClientReady(e,n,i=15e3){return new Promise(((s,r)=>{const o=this._trackedContextHandlers[n],p=this._trackedContextHandlers["*"];let d;if(!t(o))for(const t of o)if(t.clientIdentity.uuid===e.uuid&&t.clientIdentity.name===e.name){d=t.clientIdentity.endpointId;break}if(!t(p)&&t(d))for(const t of p)if(t.clientIdentity.uuid===e.uuid&&t.clientIdentity.name===e.name){d=t.clientIdentity.endpointId;break}if(!t(d))return void s(d);const c=this.getClientReadyKey(e,"context",n),l=this.getClientReadyKey(e,"context","*"),h=setTimeout((()=>{const e=!t(this._clientReadyRequests[c]),n=!t(this._clientReadyRequests[l]);(e||n)&&(delete this._clientReadyRequests[c],delete this._clientReadyRequests[l],r(a))}),i);let u=!1;this._clientReadyRequests[c]=t=>{clearTimeout(h),u||(u=!0,delete this._clientReadyRequests[c],delete this._clientReadyRequests[l],s(t))},this._clientReadyRequests[l]=t=>{clearTimeout(h),u||(u=!0,delete this._clientReadyRequests[c],delete this._clientReadyRequests[l],s(t))}}))}getClientIdentity(t){const e=`${t.uuid}-${t.name}`,n=this._trackedClientConnections[e]?.clientIdentity;return n}removeTrackedClientConnection(t){const e=`${t.uuid}-${t.name}`;delete this._trackedClientConnections[e]}async captureWindowApiUsage(e){try{const n=fin.Window.wrapSync(e),i=await n.getOptions();if(!t(i.fdc3InteropApi))return{type:"fdc3",version:i.fdc3InteropApi}}catch{}}async captureViewApiUsage(e){try{const n=fin.View.wrapSync(e),i=await n.getOptions();if(!t(i.fdc3InteropApi))return{type:"fdc3",version:i.fdc3InteropApi}}catch{}}getClientReadyKey(e,n,i){return t(i)?`${e.uuid}/${e.name}/${n}`:`${e.uuid}/${e.name}/${n}/${i}`}}async function I(e,n){const i=function(e){let n,i;if(!t(e)){const t=e.width/2,s=e.height/2;return n=e.left+t,i=e.top+s,{x:Math.round(n),y:Math.round(i)}}return{}}(await async function(e){let n,i;try{const t=fin.View.wrapSync(e);i=await t.getCurrentWindow()}catch{}if(t(n))try{const t=i??fin.Window.wrapSync(e);n=await t.getBounds()}catch{}if(t(n))try{n=await fin.me.getBounds()}catch{}return n}(e));return function(t,e){const n=t.bottom-t.top,i=(t.right-t.left)/2,s=n/2,a=e.width/2,r=e.height/2,o=t.left+i-a,p=t.top+s-r;return{x:Math.round(o),y:Math.round(p)}}((await async function(e){const n=await fin.System.getMonitorInfo(),i=e.x,s=e.y;if(!t(i)&&!t(s))for(const t of n.nonPrimaryMonitors)if(w({x:i,y:s},t.monitorRect))return t;return n.primaryMonitor}(i)).availableRect,n)}function w(t,e){return t.x>=e.left&&t.x<=e.right&&t.y>=e.top&&t.y<=e.bottom}class y{constructor(t,e,n){this._defaultIntentResolverHeight=715,this._defaultIntentResolverWidth=665,this._intentResolverOptions={height:this._defaultIntentResolverHeight,width:this._defaultIntentResolverWidth,fdc3InteropApi:"2.0",title:"Intent Resolver",...t},this._logger=e}async launchIntentResolver(e,n){try{const i=await I(n,{height:this._intentResolverOptions?.height??this._defaultIntentResolverHeight,width:this._intentResolverOptions?.width??this._defaultIntentResolverWidth}),s={name:"intent-picker",includeInSnapshots:!1,fdc3InteropApi:this._intentResolverOptions?.fdc3InteropApi,defaultWidth:this._intentResolverOptions?.width,defaultHeight:this._intentResolverOptions?.height,showTaskbarIcon:!1,saveWindowState:!1,customData:{title:this._intentResolverOptions?.title,apps:e.apps,intent:e.intent,intents:e.intents,unregisteredAppId:this._unregisteredAppId},url:this._intentResolverOptions?.url,frame:!1,autoShow:!0,alwaysOnTop:!0};t(i)?s.defaultCentered=!0:(s.defaultLeft=i.x,s.defaultTop=i.y);const a=(await fin.Window.create(s)).getWebWindow();return await a.getIntentSelection()}catch(t){const n=formatError(t);if(n?.includes(ResolveError.UserCancelled))throw this._logger.info("App for intent not selected/launched by user",e.intent),new Error(n);throw this._logger.error("Unexpected error from intent picker/resolver for intent",e.intent),new Error(ResolveError.ResolverUnavailable)}}}async function m(I,w,m){if(!m?.getApp||!m?.getApps||!m.launchApp)throw new Error("Interop Broker Constructor is missing required helpers. The broker will not function correctly so this error is to flag the issue.");const _=m.getApp,A=m.getApps;let R;m?.getEndpointClient&&(R=await(m?.getEndpointClient()));const v=m.launchApp;let x;return m?.getConnectionClient&&(x=await m.getConnectionClient()),C=>class extends C{constructor(){super(),w.info("Interop Broker Constructor applying settings."),this._appIntentHelper=new u(A,w),this._metadataKey=`_metadata_${"randomUUID"in globalThis.crypto?globalThis.crypto.randomUUID():"10000000-1000-4000-8000-100000000000".replace(/[018]/g,(function(t){const e=globalThis.crypto.getRandomValues(new Uint8Array(1))[0]&15>>Number(t)/4;return(Number(t)^e).toString(16)}))}`,I.intentResolver&&(this._intentResolverHelper=new y(I.intentResolver,w,I?.unregisteredApp?.appId)),this._openOptions=I?.openOptions,this._unregisteredApp=I?.unregisteredApp,this._contextOptions=I?.contextOptions,this._getInfoOptions=I?.getInfoOptions,t(this._unregisteredApp)||(this._unregisteredApp.manifestType=l),this._appIdHelper=new h(_,fin.me.identity.uuid,w,this._unregisteredApp),this._clientRegistrationHelper=new f((async t=>this._appIdHelper.lookupAppId(t)),w)}async isConnectionAuthorized(e,n){w.info("Interop connection being made by the following identity. About to verify connection",e);const i=n;if(!t(x)){const t=await x.isConnectionValid(e,n,{type:"broker"});return t.isValid?(w.info("Connection validation request was validated and is valid."),await this._clientRegistrationHelper.clientConnectionRegistered(e,i)):w.warn(`Connection request from ${JSON.stringify(e)} was validated and rejected.`),t.isValid}const s=await super.isConnectionAuthorized(e,n);return s&&await this._clientRegistrationHelper.clientConnectionRegistered(e,i),s}async setContext(t,e){t.context=await this.processContext(t.context);const n=await this.getContextMetadata(e);t.context={...t.context,[this._metadataKey]:n},super.setContext(t,e)}async invokeContextHandler(e,n,i){const s={...i},a=s[this._metadataKey];if(t(a)||delete s[this._metadataKey],!1!==this._contextOptions?.includeOriginator||a?.source.instanceId!==e.endpointId)return super.invokeContextHandler(e,n,{...s,contextMetadata:a})}async handleInfoForIntentsByContext(t,e){let n,a,o;const p=this._clientRegistrationHelper.getApiVersion(e);"type"in t?n=t.type:(o=t,n=o.context.type,a=o.metadata.resultType);const d=await this._appIntentHelper.getIntentsByContext(n,a);if(0===d.length)throw new Error(r);const c=[];for(const t of d){const n=await g(t.apps,p?.version??"2.0",i,s,(async t=>this._clientRegistrationHelper.findAppInstances({appId:t},e,"intent")));c.push({intent:t.intent,apps:n})}return c}async handleInfoForIntent(e,n){const a=this._clientRegistrationHelper.getApiVersion(n);let o;const p=e?.context?.type;t(p)||"fdc3.nothing"===p||(o=p);const d=await this._appIntentHelper.getIntent(e.name,o,e?.metadata?.resultType);if(t(d))throw new Error(r);return{intent:d.intent,apps:await g(d.apps,a?.version??"2.0",i,s,(async t=>this._clientRegistrationHelper.findAppInstances({appId:t},n,"intent")))}}async handleFiredIntentForContext(e,n){const i=this.getApplicationIdentity(e.metadata),s=this.usesApplicationIdentity(n),a={context:e},d=await this._appIntentHelper.getIntentsByContext(e.type);if(!t(i)){const o=await _(i.appId);if(t(o))throw new Error(p);if(!o?.interop?.intents?.listensFor||!Object.values(o.interop.intents.listensFor).some((t=>t.contexts.includes(e.type))))throw new Error(r);const d=await this.handleTargetedIntent(i,a,!0,n);return this.shapeIntentResolver(d,s)}const c=await this.getUnregisteredAppIntentByContext(e.type,n);if(c.length>0&&!t(this._unregisteredApp)){const t=[];for(const e of d)c.includes(e.intent.name)&&(e.apps.push(this._unregisteredApp),t.push(e.intent.name));const e=c.filter((e=>!t.includes(e)));for(const t of e){const e=this._unregisteredApp.intents?.find((e=>e.name===t));e&&d.push({intent:{name:e.name,displayName:e.displayName},apps:[this._unregisteredApp]})}}let l;if(1===d.length){const e=d[0];if(a.name=e.intent.name,a.displayName=e.intent.displayName,1===e.apps.length&&(0===(await this._clientRegistrationHelper.findAppInstances(e.apps[0],n,"intent")).length||this.createNewInstance(e.apps[0]))){const i=await this.launchAppWithIntent(e.apps[0],a,void 0,n);if(t(i))throw new Error(r);return this.shapeIntentResolver(i,s)}l=await(this._intentResolverHelper?.launchIntentResolver({apps:d[0].apps,intent:a},n))}else l=await(this._intentResolverHelper?.launchIntentResolver({intent:a,intents:d},n));if(t(l))throw new Error(o);a.displayName=l.intent.displayName,a.name=l.intent.name;const h=await this.handleIntentPickerSelection(l,a,n);return this.shapeIntentResolver(h,s)}async handleFiredIntent(e,n){w.info("Received request for a raised intent",e);const i=this.getApplicationIdentity(e.metadata),s=this.usesApplicationIdentity(n),a=await this._appIntentHelper.getIntent(e.name,e?.context?.type),d=[];if(t(a)||d.push(...a.apps),!t(i)){if(t(await _(i.appId)))throw new Error(p);if(!d.some((t=>t.appId===i.appId)))throw new Error(r);const a=await this.handleTargetedIntent(i,e,!1,n);return this.shapeIntentResolver(a,s)}if(this._unregisteredApp&&await this.canAddUnregisteredApp(n,e.name,e?.context?.type)&&d.push(this._unregisteredApp),0===d.length)throw w.info("No apps support this intent"),new Error(r);if(1===d.length){const i=await this._clientRegistrationHelper.findAppInstances(d[0],n,"intent");let a;if(1===i.length&&(a=i[0].instanceId),0===i.length||this.useSingleInstance(d[0])||this.createNewInstance(d[0])){const i=await this.launchAppWithIntent(d[0],e,a,n);if(t(i))throw new Error(r);return this.shapeIntentResolver(i,s)}}const c=await(this._intentResolverHelper?.launchIntentResolver({apps:d,intent:e},n));if(t(c))throw new Error(o);const l=await this.handleIntentPickerSelection(c,e,n);return this.shapeIntentResolver(l,s)}async invokeIntentHandler(e,n,i){const{context:s}=i;let a,r;return t(s)||(r={...s},a=r[this._metadataKey],t(a)||delete r[this._metadataKey]),super.invokeIntentHandler(e,n,{...i,context:{...r,contextMetadata:a}})}async fdc3HandleOpen(i,s){if(t(i?.app))throw w.error("A request to fdc3.open did not pass an fdc3OpenOptions object"),new Error(r);w.info(`A request to Open has been sent to the platform by uuid: ${s?.uuid}, name: ${s?.name}, endpointId: ${s.endpointId} with passed context:`,i.context);try{let n,a,r,o,p=!1;e(i.app)?n=i.app:(n=i.app.appId??i.app.name,a=i.app.instanceId);const c=await _(n);if(t(c))throw new Error("AppNotFound");if(!t(a)){const e=(await this.getAllClientInfo()).find((t=>t.endpointId===a));if(t(e))throw new Error(d);w.info(`App Id: ${n} and instance Id: ${a} was provided and found.`),r=[{uuid:e.uuid,name:e.name,appId:n,instanceId:a}]}if("intent"===this._openOptions?.openStrategy){const t={context:i.context,name:"OpenApp",metadata:{target:{appId:n}}},r=await this.launchAppWithIntent(c,t,a,s);e(r.source)?o=r.source:(o=r.source.appId,a=r.source.instanceId)}else if(t(r)?r=await v(c?.appId,void 0,s):p=!0,!t(r)&&r?.length>0){o=r[0].appId;let e=!0;if(1===r.length){e=!1;const t=this._openOptions?.connectionTimeout;a=await this._clientRegistrationHelper.onConnectionClientReady(r[0],t)}else w.info(`Multiple instances of the app ${o} have been launched. We are assuming this is a composite app/snapshot. We are not returning an instance id as you can only return one and a composite app will be made up of many.`);if(!t(i?.context)){const t=I?.openOptions?.connectionTimeout,n=await this.processContext(i.context),a=await this.getContextMetadata(s),p={...n,[this._metadataKey]:a},d=r.map((async n=>this.processOpenContext(n,p,t,e)));Promise.allSettled(d).then((t=>{const e=t.some((t=>"fulfilled"===t.status));return e?w.info("Multi Instance open context sharing has been initiated and at least one entry supported receiving a context."):w.error("Multi Instance open context sharing was done but there were no context listeners registered."),e})).catch((t=>{w.error(`Context sharing for fdc3 open of ${o} failed`,t)}))}}if(!t(o))return!p||t(r)||t(m?.bringAppToFront)||await m.bringAppToFront(c,r),{appId:o,instanceId:a};throw new Error("ErrorOnLaunch")}catch(i){const s=t(p=i)?"":p instanceof Error?p.message:n(p)?p:null!=(o=p)&&"object"==typeof o&&!Array.isArray(o)&&"message"in p&&e(p.message)?p.message:JSON.stringify(p);if(s===d||s===c||s===d||s===a)throw new Error(a);throw i}var o,p}async clientDisconnected(t){await this._clientRegistrationHelper.clientDisconnected(t),await super.clientDisconnected(t)}async fdc3HandleFindInstances(t,e){return this._clientRegistrationHelper.findAppInstances(t,e)}async fdc3HandleGetAppMetadata(e,i){w.info("fdc3HandleGetAppMetadata call received.",e,i);let a=await _(e.appId);if(t(a)&&e.appId===this._unregisteredApp?.appId&&(a=this._unregisteredApp),!t(a)){const i=s(a);if(!t(e.instanceId)){const s=(await this.getAllClientInfo()).find((t=>t.endpointId===e.instanceId));if(!t(s)&&s.uuid===fin.me.identity.uuid){const a={uuid:s.uuid,name:s.name};let o,p;try{if("window"===s.entityType){const t=fin.Window.wrapSync(a);await t.isShowing()&&(o=(await t.getInfo()).title,p=await this.getPreviewImage(t))}else{const t=fin.View.wrapSync(a);o=(await t.getInfo()).title,p=await this.getPreviewImage(t)}}catch(t){w.warn(`A connected client could not be queried for data. It could be it hasn't unregistered itself from the broker. AppId: ${e.appId}, instanceId: ${e.instanceId}, name: ${a.name}`,t)}return t(o)||(o=n(r=o)?r.replace(/<[^>]*>?/gm,"").replace(/&gt;/g,">").replace(/&lt;/g,"<").replace(/&amp;/g,"&").replace(/&nbsp;/g," ").replace(/\n\s*\n/g,"\n"):""),{...i,instanceId:e.instanceId,instanceMetadata:{title:o,preview:p}}}}return i}var r;throw new Error("TargetAppUnavailable")}async fdc3HandleGetInfo(e,n){if(w.info("fdc3HandleGetInfo",e,n),"2.0"===e?.fdc3Version){const i=await super.fdc3HandleGetInfo(e,n),a=await this._appIdHelper.lookupAppId(n);let r;const o=!0===this._getInfoOptions?.includeAllAppMetadataInfo,p=!0===this._getInfoOptions?.includeAppInteropInfo;if(!t(a)&&(o||p)){const e=await _(a);r={appId:a,instanceId:n.endpointId},t(e)||(o&&(r={...r,...s(e)}),p&&!t(e.interop)&&(r={...r,instanceMetadata:{interop:e.interop}}))}return{...i,optionalFeatures:{...i.optionalFeatures,OriginatingAppMetadata:!0},appMetadata:r}}return super.fdc3HandleGetInfo(e,n)}async intentHandlerRegistered(t,e){await this._clientRegistrationHelper.intentHandlerRegistered(t,e),await super.intentHandlerRegistered(t,e)}async contextHandlerRegistered(t,e){await this._clientRegistrationHelper.contextHandlerRegistered(t,e),super.contextHandlerRegistered(t,e)}async launchAppWithIntent(e,n,i,s){w.info("Launching app with intent");let a,r=[],o=!0;if(t(n?.context)||(n.context=await this.processContext(n.context),t(s)||(a=await this.getContextMetadata(s),n.context={...n.context,[this._metadataKey]:a})),!t(i)){const n=(await this.getAllClientInfo()).find((t=>t.endpointId===i));if(t(n))throw new Error(d);w.info(`App Id: ${e.appId} and instance Id: ${i} was provided and found.`),r.push({uuid:n.uuid,name:n.name,appId:e.appId,instanceId:n.endpointId})}if(0===r.length){if(r=await v(e.appId,void 0,s),!r?.length)throw new Error(c);o=!1}const p=I?.intentOptions?.intentTimeout;if(1===r.length)i=await this.processSetIntentTarget(r[0],n,p,!1);else{const t=r.map((async t=>this.processSetIntentTarget(t,n,p,!0)));Promise.allSettled(t).then((t=>{const e=t.some((t=>"fulfilled"===t.status));return e?w.info("Multi Instance intents target sharing has been initiated and at least one entry supported intents."):w.error("All intent sharing promises were rejected so not even one identity supported intents in time."),e})).catch((t=>{w.error(`Intent raising of multiple identities for app: ${e.appId} failed`,t)}))}if(o)for(const t of r)try{m.bringAppToFront&&await m.bringAppToFront(e,[t])}catch(e){w.warn(`There was an error bringing app: ${t.appId}, and instance ${t.instanceId} with name: ${t.name} to front.`,e)}return{source:{appId:e.appId,instanceId:i},version:e.version,intent:n.name}}async handleIntentPickerSelection(e,n,i){let s=await _(e.appId);if(t(s)&&!t(this._unregisteredApp)&&(s=this._unregisteredApp),t(s))throw new Error(r);const a=e.instanceId,o=await this.launchAppWithIntent(s,n,a,i);if(t(o))throw new Error(r);return o}async handleTargetedIntent(e,i,s,a){const r=[];let l=await _(e.appId);if(t(l)){if(t(e.instanceId)||e.appId!==this._unregisteredApp?.appId)throw new Error(p);l=this._unregisteredApp}if(!t(e.instanceId)){const t=await this._clientRegistrationHelper.findAppInstances(e,a,"intent");if(0===t.length||!t.some((t=>t.appId===e.appId&&t.instanceId===e.instanceId)))throw new Error(d)}if(!Array.isArray(l.intents)||0===l.intents.length)throw new Error(p);const h=l.intents.filter((e=>{let n=!0;const a=i.context?.type;return(!t(a)&&(n=e.contexts?.includes(a),s)||e.name===i.name)&&n}));if(0===h.length)throw new Error(p);if(1===h.length){if(i.name=h[0].name,!t(e.instanceId))return await this.launchAppWithIntent(l,i,e.instanceId,a);const n=await this._clientRegistrationHelper.findAppInstances(l,a,"intent"),s=1===n.length&&this.useSingleInstance(l);if(0===n.length||this.createNewInstance(l)||s){const e=await this.launchAppWithIntent(l,i,void 0,a);if(t(e))throw new Error(c);return e}}for(const t of h){const e={apps:[l],intent:{name:t.name,displayName:t.displayName}};r.push(e)}let u;if(1===r.length?(n(i.name)||t(r[0]?.intent?.name)||t(i?.context)||t(i?.context?.type)||(w.info(`A request to raise an intent was passed and the intent name was not passed but a context was ${i?.context?.type} with 1 matching intent. Name: ${r[0]?.intent?.name},  Display Name: ${r[0]?.intent?.displayName}. Updating intent object.`),i.name=r[0]?.intent?.name),u=await(this._intentResolverHelper?.launchIntentResolver({apps:r[0].apps,intent:i},a))):(u=await(this._intentResolverHelper?.launchIntentResolver({intent:i,intents:r},a)),n(i.name)||t(u?.intent?.name)||(w.info(`A request to raise an intent was passed and the following intent was selected (from a selection of ${r.length}). Name: ${u?.intent?.name},  Display Name: ${u?.intent?.displayName}. Updating intent object.`),i.name=u?.intent?.name??i.name)),t(u))throw new Error(o);return this.handleIntentPickerSelection(u,i,a)}async processOpenContext(e,n,i,s){const a=n.type,r=e.appId,o=await this._clientRegistrationHelper.onContextClientReady(e,a,i);let p=this._clientRegistrationHelper.getRegisteredContextHandler(a,o);t(p)&&(p=this._clientRegistrationHelper.getRegisteredContextHandler("*",o)),t(p)?s?w.info(`Unable to send context of type ${a} opened app ${r} with instanceId of ${o} as we cannot find a tracked context handler. This is likely a composite app and this app might not register a context handler.`):w.warn(`Unable to send context of type ${a} opened app ${r} with instanceId of ${o} as we cannot find a tracked context handler.`):await this.invokeContextHandler(p.clientIdentity,p.handlerId,n)}async processSetIntentTarget(t,e,n,i){try{const i=await this._clientRegistrationHelper.onIntentClientReady(t,e.name,n);return await super.setIntentTarget(e,t),i}catch(e){throw i?w.info(`An error occurred while getting a instance to target an intent at. If multiple views were launched as part of a composite and some of them do not register intent handlers then this may explain it.that may explain this warning. AppId: ${t.appId}, Name: ${t.name}`,e):w.warn(`An error occurred while getting a instance to target an intent at. AppId: ${t.appId}, Name: ${t.name}`,e),new Error(ResolveError.IntentDeliveryFailed)}}shapeIntentResolver(t,e){return e?t:{source:t.source.appId,version:t.version}}useSingleInstance(t){return"single"===t?.instanceMode}createNewInstance(t){return"new"===t?.instanceMode}async getPreviewImage(t){try{const e=await t.capturePage({format:"jpg",quality:85});if(n(e))return e}catch(e){w.error(`Error while trying to capture a preview image of the view/window: ${t.identity.name}`,e)}}async getUnregisteredAppIntentByContext(e,n){const i=[],s=[];if(t(this?._unregisteredApp))return i;if(Array.isArray(this?._unregisteredApp?.intents))for(const t of this._unregisteredApp.intents)if(t.contexts.includes(e)){const e=t.name;i.push(e)}if(i.length>0)for(const t of i)await this.canAddUnregisteredApp(n,t)&&s.push(t);return s}async canAddUnregisteredApp(e,n,i){if(t(this?._unregisteredApp))return!1;const s=this._unregisteredApp?.interop?.intents?.listensFor;return!(!t(n)&&(t(s)||t(s[n])))&&(!!(t(i)||t(s)||t(n)||s[n].contexts.includes(i))&&(await this._clientRegistrationHelper.findAppInstances({appId:this._unregisteredApp.appId},e,"intent")).length>0)}getApplicationIdentity(n){const i=n?.target;if(!t(i)){if(e(i)){if(0===i.trim().length)return;return{appId:i}}if(!t(i.appId))return{appId:i.appId,instanceId:i.instanceId}}}usesApplicationIdentity(e){const n=this._clientRegistrationHelper.getApiVersion(e);return!t(n)&&"fdc3"===n.type&&"2.0"===n.version}async processContext(e){if(t(R))return e;const n=`interopbroker.process.${e.type}`;if(R.hasEndpoint(n)){w.info(`Processing context ${e.type} with endpoint ${n}`);const t=await R.requestResponse(n,{context:e});if(t?.context)return t?.context}return e}async getContextMetadata(t){return{source:{appId:await this._appIdHelper.lookupAppId(t)??"unknown",instanceId:t.endpointId}}}}}const _={interopOverride:new class{async initialize(t,e,n){this._definition=t;const i=t.data?.loggerName??"WpsInteropOverride";this._logger=e(i),this._helpers=n,this._logger.info("Initializing")}async closedown(){this._logger?.info("Closedown")}async getConstructorOverride(t){if(!this._helpers||!this._logger)throw new Error("Module not initialized");return m(t,this._logger,this._helpers)}}};export{_ as entryPoints};
//# sourceMappingURL=wps-interop-override.bundle.js.map