var e={d:(t,i)=>{for(var a in i)e.o(i,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:i[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};function i(e){return null==e}e.d(t,{k:()=>a});const a={endpoint:new class{async initialize(e,t,i){this._definition=e,this._logger=t("ExampleNotificationSourceProvider"),this._helpers=i,this._logger.info("Initializing"),this._queuedNotifications=[]}async closedown(){this._logger?.info("Closedown"),i(this._readableStream)||await this._readableStream.cancel()}async action(e,t){return i(t)?(this._logger?.warn("Action called with an empty notification."),!1):(this._logger?.info(`Received notification: ${JSON.stringify(t)}`),this._queuedNotifications?.push(t),!0)}async requestStream(e,t){return i(this._readableStream)&&(this._logger?.info("Creating new stream"),this._readableStream=this.createReadableStream()),this._logger?.info("Returning requested stream"),this._readableStream}createReadableStream(){let e;const t=this._definition?.data?.intervalInSeconds??1,i=1e3*(t<1?1:t),a=()=>{const e=[...this._queuedNotifications??[]];return this._queuedNotifications=[],e};return new ReadableStream({start(t){e=setInterval((()=>{const e=a();for(const i of e)t.enqueue(i)}),i)},cancel(){clearInterval(e)}})}}};var n=t.k;export{n as entryPoints};
//# sourceMappingURL=example-notification-source.bundle.js.map