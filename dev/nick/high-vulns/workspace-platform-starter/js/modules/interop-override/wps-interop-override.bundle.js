var t={};function e(t){return null==t}function n(t){return null!=t&&"string"==typeof t}function i(t){return n(t)&&t.trim().length>0}function s(t){return e(t)?"":t instanceof Error?t.message:i(t)?t:null!=(s=t)&&"object"==typeof s&&!Array.isArray(s)&&"message"in t&&n(t.message)?t.message:JSON.stringify(t);var s}function a(t){const n=[],i=[];if(Array.isArray(t.icons))for(const i of t.icons)e(i.src)||n.push(i.src);if(Array.isArray(t.images))for(const n of t.images)e(n.src)||i.push(n.src);return{appId:t.appId,description:t.description,icons:n,images:i,name:t.appId,title:t.title,tooltip:t.tooltip,version:t.version}}function r(t,e){return{appId:t.appId,description:t.description,icons:t.icons,name:t.name,screenshots:t.images,title:t.title,tooltip:t.tooltip,version:t.version,resultType:e}}t.d=(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},t.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);const o="AppTimeout",p="NoAppsFound",d="ResolverUnavailable",c="TargetAppUnavailable",l="TargetInstanceUnavailable",h="IntentDeliveryFailed",u="unregistered-app";class g{constructor(t,e,n,i){this._validatedAppIds=[],this._invalidAppIds=[],this._unregisteredApp=i,this._logger=n,this._getApp=t,this._platformId=e}async lookupAppId(t){if(t.name.startsWith("internal-generated-"))return t.uuid===this._platformId?this._unregisteredApp?(this._logger.debug(`A window or view that is not an app but runs within the platform is running and a placeholder app has been specified ${this._unregisteredApp?.appId}}.`,t),this._unregisteredApp.appId):void this._logger.debug("A window or view that is not an app but runs within the platform is running and no unregistered placeholder app is specified so no appId will be returned.",t):void this._logger.debug("A window or view that follows the runtime generated naming convention is running from another platform. It will not be assigned an appId.",t);const e=t.name.split("/");let n;return n=1===e.length||2===e.length?e[0]:`${e[0]}/${e[1]}`,this._validatedAppIds.includes(n)?n:this._invalidAppIds.includes(n)?void 0:await this._getApp(n)?(this._validatedAppIds.push(n),n):(this._invalidAppIds.push(n),void this._logger.warn(`AppId ${n} does not exist in the directory and it isn't a generated view/window that falls under this platform. No app id will be returned as it is unconfirmed.`))}}class f{constructor(t,e){this._getApps=t,this._logger=e}async getAppsByIntent(t){return(await this._getApps()).filter(n=>{const i=n.interop?.intents?.listensFor;if(e(i))return!1;const s=Object.keys(i);for(const e of s)if(e.toLowerCase()===t.toLowerCase())return!0;return!1})}async getIntent(t,n,i){const s=await this._getApps();if(0===s.length)return void this._logger.warn("There was no apps returned so we are unable to find apps that support an intent");const a={};for(const r of s)if(r.interop?.intents?.listensFor&&!e(r.interop.intents.listensFor[t])){const e=r.interop.intents.listensFor[t];this.appIntentContains(e,n,i)&&this.updateAppIntentsMap(a,t,e.displayName,r)}const r=Object.values(a);if(0!==r.length)return 1===r.length||this._logger.warn(`Received more than one result for findIntent for intent ${t} and context ${n} and resultType ${i}. Returning the first entry.`),r[0];this._logger.info(`No results found for findIntent for intent ${t} and context ${n} and resultType ${i}`)}async getIntentsByContext(t,n){const i=await this._getApps();if(0===i.length)return this._logger.warn("Unable to get apps so we can not get apps and intents that support a particular context"),[];const s={};for(const a of i){const i=a.interop?.intents?.listensFor;if(!e(i)){const e=Object.keys(i);for(const r of e){const e=i[r];this.appIntentContains(e,t,n)&&this.updateAppIntentsMap(s,r,e.displayName,a)}}}return Object.values(s)}appIntentContains(t,n,i){if(e(n)||e(i)){if(!e(n)&&!t?.contexts?.includes(n))return!1;if(!e(i)&&!t?.resultType?.includes(i))return!1}else if(!t?.contexts?.includes(n)||!t.resultType?.includes(i))return!1;return!0}updateAppIntentsMap(t,n,i,s){e(t[n])&&(t[n]={intent:{name:n,displayName:i},apps:[]}),t[n].apps.push(s)}}async function I(t,e,n,i,s){const a=[],r=[];if("1.2"===e){for(const e of t){const t=n(e);r.push(t)}return r}for(const e of t){const t=i(e),n=await s(e.appId);a.push(t);for(const e of n){const n={...t,instanceId:e.instanceId};a.push(n)}}return a}class w{constructor(t,e){this._logger=e,this._lookupAppId=t,this._clientReadyRequests={},this._trackedClientConnections={},this._trackedContextHandlers={},this._trackedIntentHandlers={}}async clientDisconnected(t){this._logger.info("Client Disconnected.",t);for(const[e,n]of Object.entries(this._trackedIntentHandlers))this._trackedIntentHandlers[e]=n.filter(e=>e.clientIdentity.endpointId!==t.endpointId);for(const[e,n]of Object.entries(this._trackedContextHandlers))this._trackedContextHandlers[e]=n.filter(e=>e.clientIdentity.endpointId!==t.endpointId);this.removeTrackedClientConnection(t)}async intentHandlerRegistered(t,n){if(this._logger.info("intentHandlerRegistered:",t,n),!e(t)){const i=t.handlerId.replace("intent-handler-","");let s=this._trackedIntentHandlers[i];if(e(s)&&(s=[],this._trackedIntentHandlers[i]=s),e(this._trackedIntentHandlers[i].find(t=>t.clientIdentity.endpointId===n.endpointId))){this._logger.info(`intentHandler endpoint not registered. Registering ${n.endpointId} against intent ${i} and looking up app name.`);const s=await this._lookupAppId(n);if(e(s))return void this._logger.warn("Unable to determine app id based on name. This app will not be tracked via intent handler registration.");this._trackedIntentHandlers[i].push({fdc3Version:t.fdc3Version,clientIdentity:n,appId:s}),this._logger.info(`intentHandler endpoint: ${n.endpointId} registered against intent: ${i} and app Id: ${s}.`)}const a=this.getClientReadyKey(n,"intent",i);e(this._clientReadyRequests[a])||(this._logger.info("Resolving client ready request."),this._clientReadyRequests[a](n.endpointId))}}async contextHandlerRegistered(t,n){if(this._logger.info("contextHandlerRegistered:",t,n),!e(t?.handlerId)){const i=t?.contextType??"*",s=t.handlerId;let a=this._trackedContextHandlers[i];if(e(a)&&(a=[],this._trackedContextHandlers[i]=a),e(this._trackedContextHandlers[i].find(t=>t.clientIdentity.endpointId===n.endpointId))){this._logger.info(`contextHandler endpoint not registered. Registering ${n.endpointId} against context handler for context type ${i} and looking up app name.`);const t=await this._lookupAppId(n);if(e(t))return void this._logger.warn("Unable to determine app id based on name. This app will not be tracked via context handler registration.");this._trackedContextHandlers[i].push({clientIdentity:n,appId:t,handlerId:s}),this._logger.info(`contextHandler endpoint: ${n.endpointId} registered against context type: ${i} and app Id: ${t}.`)}const r=this.getClientReadyKey(n,"context",i);e(this._clientReadyRequests[r])||(this._logger.info("Resolving client ready request."),this._clientReadyRequests[r](n.endpointId))}}async clientConnectionRegistered(t,n){const s=`${t.uuid}-${t.name}`;let a;if(e(this._trackedClientConnections[s])){if(t.uuid!==fin.me.identity.uuid){const s=n?.apiVersion;a=e(s)||e(s?.type)?i(t.connectionUrl)?{type:"fdc3",version:"2.0"}:{type:"interop"}:s}else{const n=t.entityType;if(e(n))a=await this.captureViewApiUsage(t),e(a)&&(a=await this.captureWindowApiUsage(t));else switch(n){case"window":a=await this.captureWindowApiUsage(t);break;case"view":a=await this.captureViewApiUsage(t);break;default:this._logger.warn(`We currently do not check for entity types that are not views or windows. Entity type: ${n}`)}}const r={clientIdentity:t,apiMetadata:a};this._trackedClientConnections[s]=r;const o=this.getClientReadyKey(t,"connection");e(this._clientReadyRequests[o])||(this._logger.info("Resolving client ready request."),this._clientReadyRequests[o](t.endpointId))}}getRegisteredContextHandler(t,e){const n=this._trackedContextHandlers[t]?.find(t=>t.clientIdentity.endpointId===e);return n}async findAppInstances(t,n,i="connected"){const s={};if("intent"===i){for(const[,e]of Object.entries(this._trackedIntentHandlers)){const n=e.filter(e=>e.appId===t.appId);for(const t of n)s[t.clientIdentity.endpointId]={appId:t.appId??"",instanceId:t.clientIdentity.endpointId}}return Object.values(s)}for(const[,n]of Object.entries(this._trackedClientConnections))await this._lookupAppId(n.clientIdentity)===t.appId&&e(s[n.clientIdentity.endpointId])&&(s[n.clientIdentity.endpointId]={appId:t.appId??"",instanceId:n.clientIdentity.endpointId});return Object.values(s)}getApiVersion(t){const e=`${t.uuid}-${t.name}`,n=this._trackedClientConnections[e]?.apiMetadata;return n}async onConnectionClientReady(t,n=15e3){return new Promise((i,s)=>{const a=this.getClientIdentity(t);e(a)||i(a.endpointId);const r=this.getClientReadyKey(t,"connection"),o=setTimeout(()=>{e(this._clientReadyRequests[r])||(delete this._clientReadyRequests[r],s(l))},n);this._clientReadyRequests[r]=t=>{clearTimeout(o),delete this._clientReadyRequests[r],i(t)}})}async onIntentClientReady(t,n,i=15e3){return new Promise((s,a)=>{const r=this._trackedIntentHandlers[n];let o;if(!e(r))for(const e of r)if(e.clientIdentity.uuid===t.uuid&&e.clientIdentity.name===t.name){o=e.clientIdentity.endpointId;break}e(o)||s(o);const p=this.getClientReadyKey(t,"intent",n),d=setTimeout(()=>{e(this._clientReadyRequests[p])||(delete this._clientReadyRequests[p],a(h))},i);this._clientReadyRequests[p]=t=>{clearTimeout(d),delete this._clientReadyRequests[p],s(t)}})}async onContextClientReady(t,n,i=15e3){return new Promise((s,a)=>{const r=this._trackedContextHandlers[n],p=this._trackedContextHandlers["*"];let d;if(!e(r))for(const e of r)if(e.clientIdentity.uuid===t.uuid&&e.clientIdentity.name===t.name){d=e.clientIdentity.endpointId;break}if(!e(p)&&e(d))for(const e of p)if(e.clientIdentity.uuid===t.uuid&&e.clientIdentity.name===t.name){d=e.clientIdentity.endpointId;break}if(!e(d))return void s(d);const c=this.getClientReadyKey(t,"context",n),l=this.getClientReadyKey(t,"context","*"),h=setTimeout(()=>{const t=!e(this._clientReadyRequests[c]),n=!e(this._clientReadyRequests[l]);(t||n)&&(delete this._clientReadyRequests[c],delete this._clientReadyRequests[l],a(o))},i);let u=!1;this._clientReadyRequests[c]=t=>{clearTimeout(h),u||(u=!0,delete this._clientReadyRequests[c],delete this._clientReadyRequests[l],s(t))},this._clientReadyRequests[l]=t=>{clearTimeout(h),u||(u=!0,delete this._clientReadyRequests[c],delete this._clientReadyRequests[l],s(t))}})}getClientIdentity(t){const e=`${t.uuid}-${t.name}`,n=this._trackedClientConnections[e]?.clientIdentity;return n}removeTrackedClientConnection(t){const e=`${t.uuid}-${t.name}`;delete this._trackedClientConnections[e]}async captureWindowApiUsage(t){try{const n=fin.Window.wrapSync(t),i=await n.getOptions();if(!e(i.fdc3InteropApi))return{type:"fdc3",version:i.fdc3InteropApi}}catch{}}async captureViewApiUsage(t){try{const n=fin.View.wrapSync(t),i=await n.getOptions();if(!e(i.fdc3InteropApi))return{type:"fdc3",version:i.fdc3InteropApi}}catch{}}getClientReadyKey(t,n,i){return e(i)?`${t.uuid}/${t.name}/${n}`:`${t.uuid}/${t.name}/${n}/${i}`}}async function y(t,n){const i=function(t){let n,i;if(!e(t)){const e=t.width/2,s=t.height/2;return n=t.left+e,i=t.top+s,{x:Math.round(n),y:Math.round(i)}}return{}}(await async function(t){let n,i;try{const e=fin.View.wrapSync(t);i=await e.getCurrentWindow()}catch{}if(e(n))try{const e=i??fin.Window.wrapSync(t);n=await e.getBounds()}catch{}if(e(n))try{n=await fin.me.getBounds()}catch{}return n}(t));return function(t,e){const n=t.bottom-t.top,i=(t.right-t.left)/2,s=n/2,a=e.width/2,r=e.height/2,o=t.left+i-a,p=t.top+s-r;return{x:Math.round(o),y:Math.round(p)}}((await async function(t){const n=await fin.System.getMonitorInfo(),i=t.x,s=t.y;if(!e(i)&&!e(s))for(const t of n.nonPrimaryMonitors)if(m({x:i,y:s},t.monitorRect))return t;return n.primaryMonitor}(i)).availableRect,n)}function m(t,e){return t.x>=e.left&&t.x<=e.right&&t.y>=e.top&&t.y<=e.bottom}class _{constructor(t,e,n){this._defaultIntentResolverHeight=715,this._defaultIntentResolverWidth=665,this._intentResolverOptions={height:this._defaultIntentResolverHeight,width:this._defaultIntentResolverWidth,fdc3InteropApi:"2.0",title:"Intent Resolver",...t},this._logger=e}async launchIntentResolver(t,n){try{const i=await y(n,{height:this._intentResolverOptions?.height??this._defaultIntentResolverHeight,width:this._intentResolverOptions?.width??this._defaultIntentResolverWidth}),s={name:"intent-picker",includeInSnapshots:!1,fdc3InteropApi:this._intentResolverOptions?.fdc3InteropApi,defaultWidth:this._intentResolverOptions?.width,defaultHeight:this._intentResolverOptions?.height,showTaskbarIcon:!1,saveWindowState:!1,customData:{title:this._intentResolverOptions?.title,apps:t.apps,intent:t.intent,intents:t.intents,unregisteredAppId:this._unregisteredAppId},url:this._intentResolverOptions?.url,frame:!1,autoShow:!0,alwaysOnTop:!0};e(i)?s.defaultCentered=!0:(s.defaultLeft=i.x,s.defaultTop=i.y);const a=(await fin.Window.create(s)).getWebWindow();return await a.getIntentSelection()}catch(e){const n=s(e);if(n?.includes("UserCancelledResolution"))throw this._logger.info("App for intent not selected/launched by user",t.intent),new Error(n);throw this._logger.error("Unexpected error from intent picker/resolver for intent",t.intent),new Error(d)}}}const A={interopOverride:new class{async initialize(t,e,n){this._definition=t;const i=t.data?.loggerName??"WpsInteropOverride";this._logger=e(i),this._helpers=n,this._logger.info("Initializing")}async closedown(){this._logger?.info("Closedown")}async getConstructorOverride(t){if(!this._helpers||!this._logger)throw new Error("Module not initialized");return async function(t,y,m){if(!m?.getApp||!m?.getApps||!m.launchApp)throw new Error("Interop Broker Constructor is missing required helpers. The broker will not function correctly so this error is to flag the issue.");const A=m.getApp,R=m.getApps;let v;m?.getEndpointClient&&(v=await(m?.getEndpointClient()));const x=m.launchApp;let C;return m?.getConnectionClient&&(C=await m.getConnectionClient()),H=>class extends H{constructor(){super(),y.info("Interop Broker Constructor applying settings."),this._appIntentHelper=new f(R,y),this._metadataKey=`_metadata_${"randomUUID"in globalThis.crypto?globalThis.crypto.randomUUID():"10000000-1000-4000-8000-100000000000".replace(/[018]/g,function(t){const e=globalThis.crypto.getRandomValues(new Uint8Array(1))[0]&15>>Number(t)/4;return(Number(t)^e).toString(16)})}`,t.intentResolver&&(this._intentResolverHelper=new _(t.intentResolver,y,t?.unregisteredApp?.appId)),this._openOptions=t?.openOptions,this._unregisteredApp=t?.unregisteredApp,this._contextOptions=t?.contextOptions,this._getInfoOptions=t?.getInfoOptions,e(this._unregisteredApp)||(this._unregisteredApp.manifestType=u),this._appIdHelper=new g(A,fin.me.identity.uuid,y,this._unregisteredApp),this._clientRegistrationHelper=new w(async t=>this._appIdHelper.lookupAppId(t),y)}async isConnectionAuthorized(t,n){y.info("Interop connection being made by the following identity. About to verify connection",t);const i=n;if(!e(C)){const e=await C.isConnectionValid(t,n,{type:"broker"});return e.isValid?(y.info("Connection validation request was validated and is valid."),await this._clientRegistrationHelper.clientConnectionRegistered(t,i)):y.warn(`Connection request from ${JSON.stringify(t)} was validated and rejected.`),e.isValid}const s=await super.isConnectionAuthorized(t,n);return s&&await this._clientRegistrationHelper.clientConnectionRegistered(t,i),s}async setContext(t,e){t.context=await this.processContext(t.context);const n=await this.getContextMetadata(e);t.context={...t.context,[this._metadataKey]:n},super.setContext(t,e)}async invokeContextHandler(t,n,i){const s={...i},a=s[this._metadataKey];if(e(a)||delete s[this._metadataKey],!1!==this._contextOptions?.includeOriginator||a?.source.instanceId!==t.endpointId)return super.invokeContextHandler(t,n,{...s,contextMetadata:a})}async handleInfoForIntentsByContext(t,e){let n,i,s;const o=this._clientRegistrationHelper.getApiVersion(e);"type"in t?n=t.type:(s=t,n=s.context.type,i=s.metadata.resultType);const d=await this._appIntentHelper.getIntentsByContext(n,i);if(0===d.length)throw new Error(p);const c=[];for(const t of d){const n=await I(t.apps,o?.version??"2.0",a,r,async t=>this._clientRegistrationHelper.findAppInstances({appId:t},e,"intent"));c.push({intent:t.intent,apps:n})}return c}async handleInfoForIntent(t,n){const i=this._clientRegistrationHelper.getApiVersion(n);let s;const o=t?.context?.type;e(o)||"fdc3.nothing"===o||(s=o);const d=await this._appIntentHelper.getIntent(t.name,s,t?.metadata?.resultType);if(e(d))throw new Error(p);return{intent:d.intent,apps:await I(d.apps,i?.version??"2.0",a,r,async t=>this._clientRegistrationHelper.findAppInstances({appId:t},n,"intent"))}}async handleFiredIntentForContext(t,n){const i=this.getApplicationIdentity(t.metadata),s=this.usesApplicationIdentity(n),a={context:t},r=await this._appIntentHelper.getIntentsByContext(t.type);if(!e(i)){const r=await A(i.appId);if(e(r))throw new Error(c);if(!r?.interop?.intents?.listensFor||!Object.values(r.interop.intents.listensFor).some(e=>e.contexts.includes(t.type)))throw new Error(p);const o=await this.handleTargetedIntent(i,a,!0,n);return this.shapeIntentResolver(o,s)}const o=await this.getUnregisteredAppIntentByContext(t.type,n);if(o.length>0&&!e(this._unregisteredApp)){const t=[];for(const e of r)o.includes(e.intent.name)&&(e.apps.push(this._unregisteredApp),t.push(e.intent.name));const e=o.filter(e=>!t.includes(e));for(const t of e){const e=this._unregisteredApp.intents?.find(e=>e.name===t);e&&r.push({intent:{name:e.name,displayName:e.displayName},apps:[this._unregisteredApp]})}}let l;if(1===r.length){const t=r[0];if(a.name=t.intent.name,a.displayName=t.intent.displayName,1===t.apps.length&&(0===(await this._clientRegistrationHelper.findAppInstances(t.apps[0],n,"intent")).length||this.createNewInstance(t.apps[0]))){const i=await this.launchAppWithIntent(t.apps[0],a,void 0,n);if(e(i))throw new Error(p);return this.shapeIntentResolver(i,s)}l=await(this._intentResolverHelper?.launchIntentResolver({apps:r[0].apps,intent:a},n))}else l=await(this._intentResolverHelper?.launchIntentResolver({intent:a,intents:r},n));if(e(l))throw new Error(d);a.displayName=l.intent.displayName,a.name=l.intent.name;const h=await this.handleIntentPickerSelection(l,a,n);return this.shapeIntentResolver(h,s)}async handleFiredIntent(t,n){y.info("Received request for a raised intent",t);const i=this.getApplicationIdentity(t.metadata),s=this.usesApplicationIdentity(n),a=await this._appIntentHelper.getIntent(t.name,t?.context?.type),r=[];if(e(a)||r.push(...a.apps),!e(i)){if(e(await A(i.appId)))throw new Error(c);if(!r.some(t=>t.appId===i.appId))throw new Error(p);const a=await this.handleTargetedIntent(i,t,!1,n);return this.shapeIntentResolver(a,s)}if(this._unregisteredApp&&await this.canAddUnregisteredApp(n,t.name,t?.context?.type)&&r.push(this._unregisteredApp),0===r.length)throw y.info("No apps support this intent"),new Error(p);if(1===r.length){const i=await this._clientRegistrationHelper.findAppInstances(r[0],n,"intent");let a;if(1===i.length&&(a=i[0].instanceId),0===i.length||this.useSingleInstance(r[0])||this.createNewInstance(r[0])){const i=await this.launchAppWithIntent(r[0],t,a,n);if(e(i))throw new Error(p);return this.shapeIntentResolver(i,s)}}const o=await(this._intentResolverHelper?.launchIntentResolver({apps:r,intent:t},n));if(e(o))throw new Error(d);const l=await this.handleIntentPickerSelection(o,t,n);return this.shapeIntentResolver(l,s)}async invokeIntentHandler(t,n,i){const{context:s}=i;let a,r;return e(s)||(r={...s},a=r[this._metadataKey],e(a)||delete r[this._metadataKey]),super.invokeIntentHandler(t,n,{...i,context:{...r,contextMetadata:a}})}async fdc3HandleOpen(i,a){if(e(i?.app))throw y.error("A request to fdc3.open did not pass an fdc3OpenOptions object"),new Error(p);y.info(`A request to Open has been sent to the platform by uuid: ${a?.uuid}, name: ${a?.name}, endpointId: ${a.endpointId} with passed context:`,i.context);try{let s,r,o,p,d=!1;n(i.app)?s=i.app:(s=i.app.appId??i.app.name,r=i.app.instanceId);const c=await A(s);if(e(c))throw new Error("AppNotFound");if(!e(r)){const t=(await this.getAllClientInfo()).find(t=>t.endpointId===r);if(e(t))throw new Error(l);y.info(`App Id: ${s} and instance Id: ${r} was provided and found.`),o=[{uuid:t.uuid,name:t.name,appId:s,instanceId:r}]}if("intent"===this._openOptions?.openStrategy){const t={context:i.context,name:"OpenApp",metadata:{target:{appId:s}}},e=await this.launchAppWithIntent(c,t,r,a);n(e.source)?p=e.source:(p=e.source.appId,r=e.source.instanceId)}else if(e(o)?o=await x(c?.appId,void 0,a):d=!0,!e(o)&&o?.length>0){p=o[0].appId;let n=!0;if(1===o.length){n=!1;const t=this._openOptions?.connectionTimeout;r=await this._clientRegistrationHelper.onConnectionClientReady(o[0],t)}else y.info(`Multiple instances of the app ${p} have been launched. We are assuming this is a composite app/snapshot. We are not returning an instance id as you can only return one and a composite app will be made up of many.`);if(!e(i?.context)){const e=t?.openOptions?.connectionTimeout,s=await this.processContext(i.context),r=await this.getContextMetadata(a),d={...s,[this._metadataKey]:r},c=o.map(async t=>this.processOpenContext(t,d,e,n));Promise.allSettled(c).then(t=>{const e=t.some(t=>"fulfilled"===t.status);return e?y.info("Multi Instance open context sharing has been initiated and at least one entry supported receiving a context."):y.error("Multi Instance open context sharing was done but there were no context listeners registered."),e}).catch(t=>{y.error(`Context sharing for fdc3 open of ${p} failed`,t)})}}if(!e(p))return!d||e(o)||e(m?.bringAppToFront)||await m.bringAppToFront(c,o),{appId:p,instanceId:r};throw new Error("ErrorOnLaunch")}catch(t){const e=s(t);if(e===l||e===h||e===l||e===o)throw new Error(o);throw t}}async clientDisconnected(t){await this._clientRegistrationHelper.clientDisconnected(t),await super.clientDisconnected(t)}async fdc3HandleFindInstances(t,e){return this._clientRegistrationHelper.findAppInstances(t,e)}async fdc3HandleGetAppMetadata(t,n){y.info("fdc3HandleGetAppMetadata call received.",t,n);let s=await A(t.appId);if(e(s)&&t.appId===this._unregisteredApp?.appId&&(s=this._unregisteredApp),!e(s)){const n=r(s);if(!e(t.instanceId)){const s=(await this.getAllClientInfo()).find(e=>e.endpointId===t.instanceId);if(!e(s)&&s.uuid===fin.me.identity.uuid){const r={uuid:s.uuid,name:s.name};let o,p;try{if("window"===s.entityType){const t=fin.Window.wrapSync(r);await t.isShowing()&&(o=(await t.getInfo()).title,p=await this.getPreviewImage(t))}else{const t=fin.View.wrapSync(r);o=(await t.getInfo()).title,p=await this.getPreviewImage(t)}}catch(e){y.warn(`A connected client could not be queried for data. It could be it hasn't unregistered itself from the broker. AppId: ${t.appId}, instanceId: ${t.instanceId}, name: ${r.name}`,e)}return e(o)||(o=i(a=o)?a.replace(/<[^>]*>?/gm,"").replace(/&gt;/g,">").replace(/&lt;/g,"<").replace(/&amp;/g,"&").replace(/&nbsp;/g," ").replace(/\n\s*\n/g,"\n"):""),{...n,instanceId:t.instanceId,instanceMetadata:{title:o,preview:p}}}}return n}var a;throw new Error("TargetAppUnavailable")}async fdc3HandleGetInfo(t,n){if(y.info("fdc3HandleGetInfo",t,n),"2.0"===t?.fdc3Version){const i=await super.fdc3HandleGetInfo(t,n),s=await this._appIdHelper.lookupAppId(n);let a;const o=!0===this._getInfoOptions?.includeAllAppMetadataInfo,p=!0===this._getInfoOptions?.includeAppInteropInfo;if(!e(s)&&(o||p)){const t=await A(s);a={appId:s,instanceId:n.endpointId},e(t)||(o&&(a={...a,...r(t)}),p&&!e(t.interop)&&(a={...a,instanceMetadata:{interop:t.interop}}))}return{...i,optionalFeatures:{...i.optionalFeatures,OriginatingAppMetadata:!0},appMetadata:a}}return super.fdc3HandleGetInfo(t,n)}async intentHandlerRegistered(t,e){await this._clientRegistrationHelper.intentHandlerRegistered(t,e),await super.intentHandlerRegistered(t,e)}async contextHandlerRegistered(t,e){await this._clientRegistrationHelper.contextHandlerRegistered(t,e),super.contextHandlerRegistered(t,e)}async launchAppWithIntent(n,i,s,a){y.info("Launching app with intent");let r,o=[],p=!0;if(e(i?.context)||(i.context=await this.processContext(i.context),e(a)||(r=await this.getContextMetadata(a),i.context={...i.context,[this._metadataKey]:r})),!e(s)){const t=(await this.getAllClientInfo()).find(t=>t.endpointId===s);if(e(t))throw new Error(l);y.info(`App Id: ${n.appId} and instance Id: ${s} was provided and found.`),o.push({uuid:t.uuid,name:t.name,appId:n.appId,instanceId:t.endpointId})}if(0===o.length){if(o=await x(n.appId,void 0,a),!o?.length)throw new Error(h);p=!1}const d=t?.intentOptions?.intentTimeout;if(1===o.length)s=await this.processSetIntentTarget(o[0],i,d,!1);else{const t=o.map(async t=>this.processSetIntentTarget(t,i,d,!0));Promise.allSettled(t).then(t=>{const e=t.some(t=>"fulfilled"===t.status);return e?y.info("Multi Instance intents target sharing has been initiated and at least one entry supported intents."):y.error("All intent sharing promises were rejected so not even one identity supported intents in time."),e}).catch(t=>{y.error(`Intent raising of multiple identities for app: ${n.appId} failed`,t)})}if(p)for(const t of o)try{m.bringAppToFront&&await m.bringAppToFront(n,[t])}catch(e){y.warn(`There was an error bringing app: ${t.appId}, and instance ${t.instanceId} with name: ${t.name} to front.`,e)}return{source:{appId:n.appId,instanceId:s},version:n.version,intent:i.name}}async handleIntentPickerSelection(t,n,i){let s=await A(t.appId);if(e(s)&&!e(this._unregisteredApp)&&(s=this._unregisteredApp),e(s))throw new Error(p);const a=t.instanceId,r=await this.launchAppWithIntent(s,n,a,i);if(e(r))throw new Error(p);return r}async handleTargetedIntent(t,n,s,a){const r=[];let o=await A(t.appId);if(e(o)){if(e(t.instanceId)||t.appId!==this._unregisteredApp?.appId)throw new Error(c);o=this._unregisteredApp}if(!e(t.instanceId)){const e=await this._clientRegistrationHelper.findAppInstances(t,a,"intent");if(0===e.length||!e.some(e=>e.appId===t.appId&&e.instanceId===t.instanceId))throw new Error(l)}if(!Array.isArray(o.intents)||0===o.intents.length)throw new Error(c);const p=o.intents.filter(t=>{let i=!0;const a=n.context?.type;return(!e(a)&&(i=t.contexts?.includes(a),s)||t.name===n.name)&&i});if(0===p.length)throw new Error(c);if(1===p.length){if(n.name=p[0].name,!e(t.instanceId))return await this.launchAppWithIntent(o,n,t.instanceId,a);const i=await this._clientRegistrationHelper.findAppInstances(o,a,"intent"),s=1===i.length&&this.useSingleInstance(o);if(0===i.length||this.createNewInstance(o)||s){const t=await this.launchAppWithIntent(o,n,void 0,a);if(e(t))throw new Error(h);return t}}for(const t of p){const e={apps:[o],intent:{name:t.name,displayName:t.displayName}};r.push(e)}let u;if(1===r.length?(i(n.name)||e(r[0]?.intent?.name)||e(n?.context)||e(n?.context?.type)||(y.info(`A request to raise an intent was passed and the intent name was not passed but a context was ${n?.context?.type} with 1 matching intent. Name: ${r[0]?.intent?.name},  Display Name: ${r[0]?.intent?.displayName}. Updating intent object.`),n.name=r[0]?.intent?.name),u=await(this._intentResolverHelper?.launchIntentResolver({apps:r[0].apps,intent:n},a))):(u=await(this._intentResolverHelper?.launchIntentResolver({intent:n,intents:r},a)),i(n.name)||e(u?.intent?.name)||(y.info(`A request to raise an intent was passed and the following intent was selected (from a selection of ${r.length}). Name: ${u?.intent?.name},  Display Name: ${u?.intent?.displayName}. Updating intent object.`),n.name=u?.intent?.name??n.name)),e(u))throw new Error(d);return this.handleIntentPickerSelection(u,n,a)}async processOpenContext(t,n,i,s){const a=n.type,r=t.appId,o=await this._clientRegistrationHelper.onContextClientReady(t,a,i);let p=this._clientRegistrationHelper.getRegisteredContextHandler(a,o);e(p)&&(p=this._clientRegistrationHelper.getRegisteredContextHandler("*",o)),e(p)?s?y.info(`Unable to send context of type ${a} opened app ${r} with instanceId of ${o} as we cannot find a tracked context handler. This is likely a composite app and this app might not register a context handler.`):y.warn(`Unable to send context of type ${a} opened app ${r} with instanceId of ${o} as we cannot find a tracked context handler.`):await this.invokeContextHandler(p.clientIdentity,p.handlerId,n)}async processSetIntentTarget(t,e,n,i){try{const i=await this._clientRegistrationHelper.onIntentClientReady(t,e.name,n);return await super.setIntentTarget(e,t),i}catch(e){throw i?y.info(`An error occurred while getting a instance to target an intent at. If multiple views were launched as part of a composite and some of them do not register intent handlers then this may explain it.that may explain this warning. AppId: ${t.appId}, Name: ${t.name}`,e):y.warn(`An error occurred while getting a instance to target an intent at. AppId: ${t.appId}, Name: ${t.name}`,e),new Error(h)}}shapeIntentResolver(t,e){return e?t:{source:t.source.appId,version:t.version}}useSingleInstance(t){return"single"===t?.instanceMode}createNewInstance(t){return"new"===t?.instanceMode}async getPreviewImage(t){try{const e=await t.capturePage({format:"jpg",quality:85});if(i(e))return e}catch(e){y.error(`Error while trying to capture a preview image of the view/window: ${t.identity.name}`,e)}}async getUnregisteredAppIntentByContext(t,n){const i=[],s=[];if(e(this?._unregisteredApp))return i;if(Array.isArray(this?._unregisteredApp?.intents))for(const e of this._unregisteredApp.intents)if(e.contexts.includes(t)){const t=e.name;i.push(t)}if(i.length>0)for(const t of i)await this.canAddUnregisteredApp(n,t)&&s.push(t);return s}async canAddUnregisteredApp(t,n,i){if(e(this?._unregisteredApp))return!1;const s=this._unregisteredApp?.interop?.intents?.listensFor;return!(!e(n)&&(e(s)||e(s[n])))&&!!(e(i)||e(s)||e(n)||s[n].contexts.includes(i))&&(await this._clientRegistrationHelper.findAppInstances({appId:this._unregisteredApp.appId},t,"intent")).length>0}getApplicationIdentity(t){const i=t?.target;if(!e(i)){if(n(i)){if(0===i.trim().length)return;return{appId:i}}if(!e(i.appId))return{appId:i.appId,instanceId:i.instanceId}}}usesApplicationIdentity(t){const n=this._clientRegistrationHelper.getApiVersion(t);return!e(n)&&"fdc3"===n.type&&"2.0"===n.version}async processContext(t){if(e(v))return t;const n=`interopbroker.process.${t.type}`;if(v.hasEndpoint(n)){y.info(`Processing context ${t.type} with endpoint ${n}`);const e=await v.requestResponse(n,{context:t});if(e?.context)return e?.context}return t}async getContextMetadata(t){return{source:{appId:await this._appIdHelper.lookupAppId(t)??"unknown",instanceId:t.endpointId}}}}}(t,this._logger,this._helpers)}}};export{A as entryPoints};
//# sourceMappingURL=wps-interop-override.bundle.js.map