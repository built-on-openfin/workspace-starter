{"version":3,"file":"wps-interop-override.bundle.js","mappings":"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","sources":["webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/utils.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/fdc3/1.2/mapper.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/fdc3/2.0/mapper.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/fdc3/errors.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/manifest-types.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/interop-override/wps-interop-override/broker/app-id-helper.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/interop-override/wps-interop-override/broker/app-intent-helper.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/interop-override/wps-interop-override/broker/app-meta-data-helper.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/interop-override/wps-interop-override/broker/client-registration-helper.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/framework/utils-position.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/interop-override/wps-interop-override/broker/intent-resolver-helper.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/interop-override/wps-interop-override/index.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/interop-override/wps-interop-override/interop-override.ts","webpack://openfin-workspace--workspace-platform-starter/./client/src/modules/interop-override/wps-interop-override/broker/wps-interop-override.ts"],"sourcesContent":["/**\n * Test if a value is a undefined or null.\n * @param value The value to test.\n * @returns True if the value is null or undefined.\n */\nexport function isEmpty(value: unknown): value is null | undefined {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value === undefined || value === null;\n}\n\n/**\n * Test if a value is an object.\n * @param value The value to test.\n * @returns True if the value is an object.\n */\nexport function isObject(value: unknown): value is object {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n/**\n * Test if a value is a string.\n * @param value The value to test.\n * @returns True if the value is a string.\n */\nexport function isString(value: unknown): value is string {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"string\";\n}\n\n/**\n * Test if a value is a string that is not empty.\n * @param value The value to test.\n * @returns True if the value is a string that is not empty.\n */\nexport function isStringValue(value: unknown): value is string {\n\treturn isString(value) && value.trim().length > 0;\n}\n\n/**\n * Test if a value is a number.\n * @param value The value to test.\n * @returns True if the value is a number.\n */\nexport function isNumber(value: unknown): value is number {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"number\";\n}\n\n/**\n * Test if a value is a number with a real value i.e. not NaN or Infinite.\n * @param value The value to test.\n * @returns True if the value is a number.\n */\nexport function isNumberValue(value: unknown): value is number {\n\treturn isNumber(value) && !Number.isNaN(value) && Number.isFinite(value);\n}\n\n/**\n * Test if a value is a boolean.\n * @param value The value to test.\n * @returns True if the value is a boolean.\n */\nexport function isBoolean(value: unknown): value is boolean {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn value !== undefined && value !== null && typeof value === \"boolean\";\n}\n\n/**\n * Test if a value is an integer.\n * @param value The value to test.\n * @returns True if the value is an integer.\n */\nexport function isInteger(value: unknown): value is number {\n\treturn isNumber(value) && Number.isInteger(value);\n}\n\n/**\n * Deep clone an object.\n * @param obj The object to clone.\n * @returns The clone of the object.\n */\nexport function objectClone<T>(obj: T): T {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn obj === undefined ? (undefined as T) : JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Do a deep comparison of the objects.\n * @param obj1 The first object to compare.\n * @param obj2 The second object to compare.\n * @param matchPropertyOrder If true the properties must be in the same order.\n * @returns True if the objects are the same.\n */\nexport function deepEqual(obj1: unknown, obj2: unknown, matchPropertyOrder: boolean = true): boolean {\n\tif (isObject(obj1) && isObject(obj2)) {\n\t\tconst objKeys1 = Object.keys(obj1);\n\t\tconst objKeys2 = Object.keys(obj2);\n\n\t\tif (objKeys1.length !== objKeys2.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (matchPropertyOrder && JSON.stringify(objKeys1) !== JSON.stringify(objKeys2)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const key of objKeys1) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst value1 = (obj1 as any)[key];\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tconst value2 = (obj2 as any)[key];\n\n\t\t\tif (!deepEqual(value1, value2, matchPropertyOrder)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t} else if (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\tif (obj1.length !== obj2.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < obj1.length; i++) {\n\t\t\tif (!deepEqual(obj1[i], obj2[i], matchPropertyOrder)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn JSON.stringify(obj1) === JSON.stringify(obj2);\n}\n\n/**\n * Deep merge two objects.\n * @param target The object to be merged into.\n * @param sources The objects to merge into the target.\n * @returns The merged object.\n */\nexport function deepMerge<T = unknown>(target: T, ...sources: T[]): T {\n\tif (!Array.isArray(sources) || sources.length === 0) {\n\t\treturn target;\n\t}\n\n\tconst targetAsMap = target as { [id: string]: unknown };\n\tconst source = sources.shift();\n\n\tlet keys;\n\tif (isObject(targetAsMap) && isObject(source)) {\n\t\tkeys = Object.keys(source);\n\t} else if (Array.isArray(source)) {\n\t\tif (!Array.isArray(target)) {\n\t\t\treturn source;\n\t\t}\n\t\tkeys = Object.keys(source).map((k) => Number.parseInt(k, 10));\n\t}\n\n\tif (keys) {\n\t\tconst sourceAsMap = source as { [id: string]: unknown };\n\t\tfor (const key of keys) {\n\t\t\tconst value = sourceAsMap[key];\n\t\t\tif (isObject(value)) {\n\t\t\t\tif (isEmpty(targetAsMap[key])) {\n\t\t\t\t\ttargetAsMap[key] = {};\n\t\t\t\t}\n\t\t\t\tdeepMerge(targetAsMap[key], value);\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tif (isEmpty(targetAsMap[key])) {\n\t\t\t\t\ttargetAsMap[key] = [];\n\t\t\t\t}\n\t\t\t\tdeepMerge(targetAsMap[key], value);\n\t\t\t} else {\n\t\t\t\ttargetAsMap[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Polyfills randomUUID if running in a non-secure context.\n * @returns The random UUID.\n */\nexport function randomUUID(): string {\n\tif (\"randomUUID\" in globalThis.crypto) {\n\t\t// eslint-disable-next-line no-restricted-syntax\n\t\treturn globalThis.crypto.randomUUID();\n\t}\n\t// Polyfill the window.crypto.randomUUID if we are running in a non secure context that doesn't have it\n\t// we are still using window.crypto.getRandomValues which is always available\n\t// https://stackoverflow.com/a/2117523/2800218\n\t/**\n\t * Get random hex value.\n\t * @param c The number to base the random value on.\n\t * @returns The random value.\n\t */\n\tfunction getRandomHex(c: string): string {\n\t\t// eslint-disable-next-line no-bitwise\n\t\tconst rnd = globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (Number(c) / 4));\n\t\treturn (\n\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t(Number(c) ^ rnd).toString(16)\n\t\t);\n\t}\n\treturn \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, getRandomHex);\n}\n\n/**\n * Format an error to a readable string.\n * @param err The error to format.\n * @returns The formatted error.\n */\nexport function formatError(err: unknown): string {\n\tif (isEmpty(err)) {\n\t\treturn \"\";\n\t} else if (err instanceof Error) {\n\t\treturn err.message;\n\t} else if (isStringValue(err)) {\n\t\treturn err;\n\t} else if (isObject(err) && \"message\" in err && isString(err.message)) {\n\t\treturn err.message;\n\t}\n\treturn JSON.stringify(err);\n}\n\n/**\n * A basic string sanitize function that removes angle brackets <> from a string.\n * @param content the content to sanitize\n * @returns a string without angle brackets <>\n */\nexport function sanitizeString(content: unknown): string {\n\tif (isStringValue(content)) {\n\t\treturn content\n\t\t\t.replace(/<[^>]*>?/gm, \"\")\n\t\t\t.replace(/&gt;/g, \">\")\n\t\t\t.replace(/&lt;/g, \"<\")\n\t\t\t.replace(/&amp;/g, \"&\")\n\t\t\t.replace(/&nbsp;/g, \" \")\n\t\t\t.replace(/\\n\\s*\\n/g, \"\\n\");\n\t}\n\treturn \"\";\n}\n\n/**\n * Get the command line arguments from a command line string.\n * Examples of command line strings: arg1 key1=value1 key2=\"value with spaces\" key3='value3' key4='value with more spaces'`.\n * @param commandLine The command line string.\n * @returns The command line arguments or an empty array if none\n */\nexport function getCommandLineArgs(commandLine: string): string[] {\n\tif (!isStringValue(commandLine)) {\n\t\treturn [];\n\t}\n\tconst matches = commandLine.match(/(\\w+=)?(\"[^\"]*\"|'[^']*'|[^ ]+)/g);\n\tif (isEmpty(matches)) {\n\t\treturn [];\n\t}\n\treturn matches;\n}\n","import type { Image } from \"@openfin/workspace\";\nimport type { PlatformApp } from \"../../shapes/app-shapes\";\nimport type {\n\tAppDefinition,\n\tAppIcon,\n\tAppImage,\n\tAppIntents,\n\tAppMetadata,\n\tCustomConfig\n} from \"../../shapes/fdc3-1-2-shapes\";\nimport type { AppInterop, AppIntents as FDC3TwoPointZeroAppIntents } from \"../../shapes/fdc3-2-0-shapes\";\nimport { isBoolean, isEmpty, isStringValue } from \"../../utils\";\n\n/**\n * Map the app definition to a platform app.\n * @param app The app definition to map.\n * @returns The platform app.\n */\nexport function mapToPlatformApp(app: AppDefinition): PlatformApp {\n\tconst platformApp: PlatformApp = {\n\t\tappId: app.appId,\n\t\tname: app.name ?? app.appId,\n\t\ttitle: app.title ?? app.name,\n\t\tmanifestType: app.manifestType,\n\t\tmanifest: getManifestFromFDC3(app) as string,\n\t\tdescription: app.description,\n\t\tcustomConfig: app.customConfig,\n\t\tintents: app.intents,\n\t\tinterop: mapInteropFromFDC3(app.intents),\n\t\ttags: mapTagsFromFDC3(app),\n\t\tversion: app.version,\n\t\tpublisher: app.publisher ?? \"\",\n\t\tcontactEmail: app.contactEmail,\n\t\tsupportEmail: app.supportEmail,\n\t\ticons: mapIconsFromFDC3(app.icons),\n\t\timages: mapImagesFromFDC3(app.images),\n\t\tprivate: mapPrivateFromFDC3(app),\n\t\tautostart: mapAutostartFromFDC3(app),\n\t\tinstanceMode: app.customConfig?.instanceMode,\n\t\ttooltip: app.tooltip,\n\t\tlaunchPreference: app.customConfig?.launchPreference\n\t};\n\treturn platformApp;\n}\n\n/**\n * Map a platform app to an FDC3 1.2 app definition.\n * @param app The app definition to map.\n * @returns The fdc3 1.2 app.\n */\nexport function mapToFDC3App(app: PlatformApp): AppDefinition {\n\tconst manifestType: string = `${app.manifestType}`;\n\n\tconst fdc3App: AppDefinition = {\n\t\tappId: app.appId,\n\t\tname: app.name ?? app.appId,\n\t\ttitle: app.title ?? app.name,\n\t\tmanifestType,\n\t\tmanifest: app.manifest as string,\n\t\tdescription: app.description,\n\t\tcustomConfig: mapCustomConfigFromPlatformApp(app),\n\t\tintents: mapIntentsFromPlatformApp(app),\n\t\tcategories: app.tags ?? [],\n\t\tversion: app.version,\n\t\tpublisher: app.publisher ?? \"\",\n\t\tcontactEmail: app.contactEmail,\n\t\tsupportEmail: app.supportEmail,\n\t\ticons: mapIconsFromPlatformApp(app),\n\t\timages: mapImagesFromPlatformApp(app),\n\t\ttooltip: app.tooltip\n\t};\n\treturn fdc3App;\n}\n\n/**\n * Map the platform app to app metadata.\n * @param app The application to map.\n * @returns The app metadata.\n */\nexport function mapToAppMetaData(app: PlatformApp): AppMetadata {\n\tconst icons: string[] = [];\n\tconst images: string[] = [];\n\tif (Array.isArray(app.icons)) {\n\t\tfor (const icon of app.icons) {\n\t\t\tif (!isEmpty(icon.src)) {\n\t\t\t\ticons.push(icon.src);\n\t\t\t}\n\t\t}\n\t}\n\tif (Array.isArray(app.images)) {\n\t\tfor (const image of app.images) {\n\t\t\tif (!isEmpty(image.src)) {\n\t\t\t\timages.push(image.src);\n\t\t\t}\n\t\t}\n\t}\n\tconst appMetaData: AppMetadata = {\n\t\tappId: app.appId,\n\t\tdescription: app.description,\n\t\ticons,\n\t\timages,\n\t\tname: app.appId,\n\t\ttitle: app.title,\n\t\ttooltip: app.tooltip,\n\t\tversion: app.version\n\t};\n\treturn appMetaData;\n}\n\n/**\n * Map the app definition interop data to app interop format.\n * @param intents The intents to map.\n * @returns The app interop.\n */\nexport function mapInteropFromFDC3(intents: AppIntents[] | undefined): AppInterop | undefined {\n\tif (isEmpty(intents)) {\n\t\treturn;\n\t}\n\n\tconst listensFor: { [key: string]: FDC3TwoPointZeroAppIntents } = {};\n\n\tfor (const intent of intents) {\n\t\tlistensFor[intent.name] = {\n\t\t\tcontexts: intent.contexts,\n\t\t\tcustomConfig: intent.customConfig,\n\t\t\tdisplayName: intent.displayName\n\t\t};\n\t}\n\n\tconst interop: AppInterop = {\n\t\tintents: { listensFor }\n\t};\n\n\treturn interop;\n}\n\n/**\n * Maps the intents from a platform app to an FDC3 1.2 intents array.\n * @param app The platform app to use as a source\n * @returns an Array of Intents in FDC3 1.2 format\n */\nfunction mapIntentsFromPlatformApp(app: PlatformApp): AppIntents[] {\n\tconst intents: AppIntents[] = [];\n\tconst passedIntents = app.interop?.intents?.listensFor;\n\tif (!isEmpty(passedIntents)) {\n\t\tconst keys = Object.keys(passedIntents);\n\t\tfor (const key of keys) {\n\t\t\tconst displayName: string = passedIntents[key].displayName ?? key;\n\t\t\tintents.push({\n\t\t\t\tname: key,\n\t\t\t\tdisplayName,\n\t\t\t\tcontexts: passedIntents[key].contexts,\n\t\t\t\tcustomConfig: passedIntents[key].customConfig\n\t\t\t});\n\t\t}\n\t}\n\tif (intents.length === 0 && !isEmpty(app.intents)) {\n\t\treturn app.intents;\n\t}\n\treturn intents;\n}\n\n/**\n * Takes a platform app and returns an FDC3 custom config object.\n * @param app The platform app to map into a customConfig object.\n * @returns an FDC3 1.2 customConfig object based on the platform app settings.\n */\nfunction mapCustomConfigFromPlatformApp(app: PlatformApp): CustomConfig {\n\tconst config: CustomConfig = {\n\t\tautostart: mapBooleanValue(app?.autostart, false).toString(),\n\t\tinstanceMode: app.instanceMode,\n\t\tprivate: mapBooleanValue(app.private, false).toString(),\n\t\tlaunchPreference: app.launchPreference\n\t};\n\treturn config;\n}\n\n/**\n * Map the icon format.\n * @param icons The icons to map.\n * @returns The mapped icons.\n */\nfunction mapIconsFromFDC3(icons: AppIcon[] | undefined): Image[] {\n\tif (!Array.isArray(icons)) {\n\t\treturn [];\n\t}\n\tconst appIcons: Image[] = [];\n\tfor (const appIcon of icons) {\n\t\tappIcons.push({ src: appIcon.icon });\n\t}\n\treturn appIcons;\n}\n\n/**\n * Takes a Platform App and converts icons so they are in FDC3 1.2 format.\n * @param app The platform app to use as a source.\n * @returns The array of app icons in FDC3 1.2 format.\n */\nfunction mapIconsFromPlatformApp(app: PlatformApp): AppIcon[] {\n\tif (!Array.isArray(app.icons)) {\n\t\treturn [];\n\t}\n\tconst appIcons: AppIcon[] = [];\n\tfor (const appIcon of app.icons) {\n\t\tappIcons.push({ icon: appIcon.src });\n\t}\n\treturn appIcons;\n}\n\n/**\n * Map the image format.\n * @param images The images to map.\n * @returns The mapped images.\n */\nfunction mapImagesFromFDC3(images: AppImage[] | undefined): Image[] {\n\tif (!Array.isArray(images)) {\n\t\treturn [];\n\t}\n\tconst appImages: Image[] = [];\n\tfor (const appImage of images) {\n\t\tappImages.push({ src: appImage.url });\n\t}\n\treturn appImages;\n}\n\n/**\n * Returns an array of images in FDC3 1.2 format from a Platform App.\n * @param app The platform app to use as a source.\n * @returns The mapped images.\n */\nfunction mapImagesFromPlatformApp(app: PlatformApp): AppImage[] {\n\tif (!Array.isArray(app.images)) {\n\t\treturn [];\n\t}\n\tconst appImages: AppImage[] = [];\n\tfor (const appImage of app.images) {\n\t\tappImages.push({ url: appImage.src });\n\t}\n\treturn appImages;\n}\n\n/**\n * Get the manifest which can be plain string or JSON.\n * @param app The app to get the manifest from.\n * @returns The manifest.\n */\nfunction getManifestFromFDC3(app: AppDefinition): unknown {\n\tif (isStringValue(app.manifest) && app.manifest.startsWith(\"{\")) {\n\t\treturn JSON.parse(app.manifest);\n\t}\n\n\treturn app.manifest;\n}\n\n/**\n * Map the tags.\n * @param app The app definition to map the tags for.\n * @returns The mapped tags,\n */\nfunction mapTagsFromFDC3(app: AppDefinition & { tags?: string[] }): string[] {\n\tconst tags: string[] = app.tags ?? app.categories ?? [];\n\tif (tags.length === 0) {\n\t\ttags.push(app.manifestType);\n\t}\n\n\treturn tags;\n}\n\n/**\n * Map the private flag.\n * @param app The app containing the app.\n * @returns The flag or false if not found.\n */\nfunction mapPrivateFromFDC3(app: AppDefinition): boolean {\n\treturn mapBooleanValue(app?.customConfig?.private, false);\n}\n\n/**\n * Map the autostart flag.\n * @param app The app containing the app.\n * @returns The flag or false if not found.\n */\nfunction mapAutostartFromFDC3(app: AppDefinition): boolean {\n\treturn mapBooleanValue(app?.customConfig?.autostart, false);\n}\n\n/**\n * Map a boolean or string to a real boolean value.\n * @param flag The flag to convert.\n * @param defaultFlag The default value if missing.\n * @returns The mapped flag.\n */\nfunction mapBooleanValue(flag: string | boolean | undefined, defaultFlag: boolean): boolean {\n\tif (isStringValue(flag) || isBoolean(flag)) {\n\t\tswitch (flag) {\n\t\t\tcase \"False\":\n\t\t\tcase \"false\":\n\t\t\tcase false:\n\t\t\t\treturn false;\n\t\t\tcase \"True\":\n\t\t\tcase \"true\":\n\t\t\tcase true:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\t// if someone has defined a flag then the likely hood was to override the default value\n\t\t\t\treturn !defaultFlag;\n\t\t}\n\t}\n\treturn defaultFlag;\n}\n","import type { AppMetadata } from \"@finos/fdc3\";\nimport type { AppIntent } from \"@openfin/workspace\";\nimport type { PlatformApp } from \"../../shapes/app-shapes\";\nimport type {\n\tAppDefinition,\n\tWebAppDetails,\n\tNativeAppDetails,\n\tOnlineNativeAppDetails,\n\tAppInterop,\n\tAppDefinitionType,\n\tAppIntents,\n\tHostManifests\n} from \"../../shapes/fdc3-2-0-shapes\";\nimport { isEmpty, isObject } from \"../../utils\";\n\n/**\n * Map the app definition to a platform app.\n * @param app The app definition to map.\n * @returns The platform app.\n */\nexport function mapToPlatformApp(app: AppDefinition): PlatformApp {\n\tconst platformApp: PlatformApp = {\n\t\tappId: app.appId,\n\t\tname: app.name ?? app.appId,\n\t\ttitle: app.title ?? app.name,\n\t\tmanifestType: mapManifestTypeFromFDC3(app),\n\t\tmanifest: getManifestFromFDC3(app) as string,\n\t\tdescription: app.description,\n\t\tinstanceMode: app?.hostManifests?.OpenFin?.config?.instanceMode,\n\t\tintents: mapIntentsFromFDC3(app.interop),\n\t\tinterop: app.interop,\n\t\tcustomConfig: app.customConfig,\n\t\ttags: app.categories,\n\t\tversion: app.version,\n\t\tpublisher: app.publisher ?? \"\",\n\t\tcontactEmail: app.contactEmail,\n\t\tsupportEmail: app.supportEmail,\n\t\ticons: app.icons ?? [],\n\t\timages: app.screenshots,\n\t\tprivate: app?.hostManifests?.OpenFin?.config?.private,\n\t\tautostart: app?.hostManifests?.OpenFin?.config?.autostart,\n\t\tlaunchPreference: app?.hostManifests?.OpenFin?.config?.launchPreference\n\t};\n\treturn platformApp;\n}\n\n/**\n * Map a platform app to an FDC3 2.0 app definition.\n * @param app The app definition to map.\n * @returns The fdc3 2.0 app.\n */\nexport function mapToFDC3App(app: PlatformApp): AppDefinition {\n\tconst fdc3App: AppDefinition = {\n\t\tappId: app.appId,\n\t\tname: app.name ?? app.appId,\n\t\ttitle: app.title ?? app.name,\n\t\ttype: mapTypeFromPlatformApp(app),\n\t\tdetails: {},\n\t\tdescription: app.description,\n\t\tcategories: app.tags ?? [],\n\t\tversion: app.version,\n\t\tpublisher: app.publisher ?? \"\",\n\t\tcontactEmail: app.contactEmail,\n\t\tsupportEmail: app.supportEmail,\n\t\ticons: app.icons,\n\t\tscreenshots: app.images,\n\t\ttooltip: app.tooltip,\n\t\tinterop: getInteropFromPlatformApp(app),\n\t\thostManifests: getHostManifestsFromPlatformApp(app)\n\t};\n\treturn fdc3App;\n}\n\n/**\n * Map the platform app to app metadata.\n * @param app The application to map.\n * @param resultType The result type to include in the data.\n * @returns The app metadata.\n */\nexport function mapToAppMetaData(app: PlatformApp, resultType?: string): AppMetadata {\n\tconst appMetaData: AppMetadata = {\n\t\tappId: app.appId,\n\t\tdescription: app.description,\n\t\ticons: app.icons,\n\t\tname: app.name,\n\t\tscreenshots: app.images,\n\t\ttitle: app.title,\n\t\ttooltip: app.tooltip,\n\t\tversion: app.version,\n\t\tresultType\n\t};\n\treturn appMetaData;\n}\n\n/**\n * Map the app definition interop data to app interop format.\n * @param interop The interop to map.\n * @returns The app interop.\n */\nexport function mapIntentsFromFDC3(interop: AppInterop | undefined): AppIntent[] {\n\tconst intents: AppIntent[] = [];\n\n\tconst listensFor = interop?.intents?.listensFor;\n\tif (isEmpty(listensFor)) {\n\t\treturn intents;\n\t}\n\n\tconst intentIds = Object.keys(listensFor);\n\tfor (const intentName of intentIds) {\n\t\tintents.push({\n\t\t\tname: intentName,\n\t\t\tdisplayName: listensFor[intentName].displayName ?? \"\",\n\t\t\tcontexts: listensFor[intentName].contexts\n\t\t});\n\t}\n\n\treturn intents;\n}\n\n/**\n * Get the interop data from a Platform App in FDC3 2.0 format.\n * @param app The platform app to use as a source.\n * @returns The app interop definition.\n */\nfunction getInteropFromPlatformApp(app: PlatformApp): AppInterop {\n\tif (!isEmpty(app.interop)) {\n\t\treturn app.interop;\n\t}\n\tconst interop: AppInterop = {\n\t\tintents: {\n\t\t\tlistensFor: {}\n\t\t}\n\t};\n\n\tif (Array.isArray(app.intents) && app.intents.length > 0) {\n\t\tconst listensFor: { [key: string]: AppIntents } = {};\n\t\tfor (const intent of app.intents) {\n\t\t\tlistensFor[intent.name] = { displayName: intent.displayName, contexts: intent.contexts };\n\t\t}\n\t\tif (!isEmpty(interop.intents)) {\n\t\t\tinterop.intents.listensFor = listensFor;\n\t\t}\n\t}\n\n\treturn interop;\n}\n\n/**\n * Map the manifest type.\n * @param app The app definition to map the manifest type for.\n * @returns The mapped manifest type.\n */\nfunction mapManifestTypeFromFDC3(app: AppDefinition): string {\n\tlet manifestType: string;\n\n\tswitch (app.type) {\n\t\tcase \"web\": {\n\t\t\tmanifestType = \"inline-view\";\n\t\t\tbreak;\n\t\t}\n\t\tcase \"native\": {\n\t\t\tmanifestType = \"inline-external\";\n\t\t\tbreak;\n\t\t}\n\t\tcase \"onlineNative\": {\n\t\t\tmanifestType = \"desktop-browser\";\n\t\t\tbreak;\n\t\t}\n\t\tcase \"other\": {\n\t\t\tmanifestType = app.hostManifests?.OpenFin?.type ?? \"\";\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tmanifestType = app.type;\n\t\t}\n\t}\n\treturn manifestType;\n}\n\n/**\n * Maps to an FDC3 2.0 type from the manifest type specified by a platform app.\n * @param app the platform app to use as a source\n * @returns the FDC3 2.0 app definition type\n */\nfunction mapTypeFromPlatformApp(app: PlatformApp): AppDefinitionType {\n\tlet type: AppDefinitionType = \"other\";\n\tif (isEmpty(app.manifestType)) {\n\t\treturn type;\n\t}\n\tswitch (app.manifestType) {\n\t\tcase \"inline-view\": {\n\t\t\ttype = \"web\";\n\t\t\tbreak;\n\t\t}\n\t\tcase \"inline-external\": {\n\t\t\ttype = \"native\";\n\t\t\tbreak;\n\t\t}\n\t\tcase \"desktop-browser\": {\n\t\t\ttype = \"onlineNative\";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn type;\n}\n\n/**\n * Get the manifest which can be plain string or JSON.\n * @param app The app to get the manifest from.\n * @returns The manifest.\n */\nfunction getManifestFromFDC3(app: AppDefinition): string | unknown {\n\tlet manifest: string | unknown;\n\n\tswitch (app.type) {\n\t\tcase \"web\": {\n\t\t\tif (!isEmpty(app?.details)) {\n\t\t\t\tconst hostDetails = app.hostManifests?.OpenFin?.details;\n\t\t\t\tif (isObject(hostDetails)) {\n\t\t\t\t\tmanifest = {\n\t\t\t\t\t\turl: (app?.details as WebAppDetails).url,\n\t\t\t\t\t\tfdc3InteropApi: \"2.0\",\n\t\t\t\t\t\t...hostDetails\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tmanifest = {\n\t\t\t\t\t\turl: (app?.details as WebAppDetails).url,\n\t\t\t\t\t\tfdc3InteropApi: \"2.0\"\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"native\": {\n\t\t\tif (!isEmpty(app?.details)) {\n\t\t\t\t// our native api supports path and arguments.\n\t\t\t\tmanifest = app.details as NativeAppDetails;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"onlineNative\": {\n\t\t\tif (!isEmpty(app?.details)) {\n\t\t\t\tmanifest = (app?.details as OnlineNativeAppDetails).url;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"other\": {\n\t\t\tmanifest = app.hostManifests?.OpenFin?.details;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tmanifest = app.details;\n\t\t}\n\t}\n\treturn manifest;\n}\n\n/**\n * Get the Host Details from the platform app for this FDC3 2.0 App Definition.\n * @param app The platform app to get the information from.\n * @returns The host specific details.\n */\nfunction getHostManifestsFromPlatformApp(app: PlatformApp): HostManifests {\n\tconst hostManifests: HostManifests = {\n\t\tOpenFin: {\n\t\t\ttype: app.manifestType,\n\t\t\tdetails: app.manifest,\n\t\t\tconfig: {\n\t\t\t\tautostart: app.autostart,\n\t\t\t\tprivate: app.private,\n\t\t\t\tinstanceMode: app.instanceMode,\n\t\t\t\tlaunchPreference: app.launchPreference\n\t\t\t}\n\t\t}\n\t};\n\treturn hostManifests;\n}\n","/** Constants representing the errors that can be encountered when calling the `open` method on the DesktopAgent object (`fdc3`). */\nexport const OPEN_ERROR = {\n\t/** Returned if the specified application is not found.*/\n\tAppNotFound: \"AppNotFound\",\n\t/** Returned if the specified application fails to launch correctly.*/\n\tErrorOnLaunch: \"ErrorOnLaunch\",\n\t/** Returned if the specified application launches but fails to add a context listener in order to receive the context passed to the `fdc3.open` call.*/\n\tAppTimeout: \"AppTimeout\",\n\t/** Returned if the FDC3 desktop agent implementation is not currently able to handle the request.*/\n\tResolverUnavailable: \"ResolverUnavailable\",\n\t/** Returned if a call to the `open` function is made with an invalid context argument. Contexts should be Objects with at least a `type` field that has a `string` value.*/\n\tMalformedContext: \"MalformedContext\"\n};\n/** Constants representing the errors that can be encountered when calling the `findIntent`, `findIntentsByContext`, `raiseIntent` or `raiseIntentForContext` methods on the DesktopAgent (`fdc3`). */\nexport const RESOLVE_ERROR = {\n\t/** SHOULD be returned if no apps are available that can resolve the intent and context combination.*/\n\tNoAppsFound: \"NoAppsFound\",\n\t/** Returned if the FDC3 desktop agent implementation is not currently able to handle the request.*/\n\tResolverUnavailable: \"ResolverUnavailable\",\n\t/** Returned if the user cancelled the resolution request, for example by closing or cancelling a resolver UI.*/\n\tUserCancelled: \"UserCancelledResolution\",\n\t/** SHOULD be returned if a timeout cancels an intent resolution that required user interaction. Please use `ResolverUnavailable` instead for situations where a resolver UI or similar fails.*/\n\tResolverTimeout: \"ResolverTimeout\",\n\t/** Returned if a specified target application is not available or a new instance of it cannot be opened. */\n\tTargetAppUnavailable: \"TargetAppUnavailable\",\n\t/** Returned if a specified target application instance is not available, for example because it has been closed. */\n\tTargetInstanceUnavailable: \"TargetInstanceUnavailable\",\n\t/** Returned if the intent and context could not be delivered to the selected application or instance, for example because it has not added an intent handler within a timeout.*/\n\tIntentDeliveryFailed: \"IntentDeliveryFailed\",\n\t/** Returned if a call to one of the `raiseIntent` functions is made with an invalid context argument. Contexts should be Objects with at least a `type` field that has a `string` value.*/\n\tMalformedContext: \"MalformedContext\"\n};\n","import type { ManifestTypes } from \"./shapes/app-shapes\";\n\nexport const MANIFEST_TYPES: ManifestTypes = {\n\tView: {\n\t\tid: \"view\",\n\t\tlabel: \"View\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to be pointed to a json file that contains view options.\"\n\t},\n\tInlineView: {\n\t\tid: \"inline-view\",\n\t\tlabel: \"View\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to have the options inline rather than a url to a json file.\"\n\t},\n\tWindow: {\n\t\tid: \"window\",\n\t\tlabel: \"Window\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to point to a json file that contains classic window options.\"\n\t},\n\tInlineWindow: {\n\t\tid: \"inline-window\",\n\t\tlabel: \"Window\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to have the classic window options inline rather than a url to a json file.\"\n\t},\n\tSnapshot: {\n\t\tid: \"snapshot\",\n\t\tlabel: \"Snapshot\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to point to a json file that contains a snapshot (one or more windows)\"\n\t},\n\tInlineSnapshot: {\n\t\tid: \"inline-snapshot\",\n\t\tlabel: \"Snapshot\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to have a snapshot inline rather than a url to a json file that contains a snapshot (one or more windows)\"\n\t},\n\tManifest: {\n\t\tid: \"manifest\",\n\t\tlabel: \"App\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to point to a json file that is an openfin manifest. An openfin app.\"\n\t},\n\tExternal: {\n\t\tid: \"external\",\n\t\tlabel: \"Native App\",\n\t\tdescription: \"This manifest type expects the manifest setting to point to an exe.\"\n\t},\n\tInlineExternal: {\n\t\tid: \"inline-external\",\n\t\tlabel: \"Native App\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to point to an exe using an inline launch external process request.\"\n\t},\n\tAppasset: {\n\t\tid: \"appasset\",\n\t\tlabel: \"Native App\",\n\t\tdescription: \"This manifest type expects the manifest setting to point to an app asset name.\"\n\t},\n\tInlineAppAsset: {\n\t\tid: \"inline-appasset\",\n\t\tlabel: \"Native App\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to point to an app asset config using an inline launch external process request.\"\n\t},\n\tDesktopBrowser: {\n\t\tid: \"desktop-browser\",\n\t\tlabel: \"Desktop Browser\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to point to a url which will be launched in the default desktop browser.\"\n\t},\n\tEndpoint: {\n\t\tid: \"endpoint\",\n\t\tlabel: \"Endpoint\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to point to an endpoint (which should be defined in the endpointProvider). Action will be called on that endpoint and passed the specified app.\"\n\t},\n\tConnection: {\n\t\tid: \"connection\",\n\t\tlabel: \"Connected App\",\n\t\tdescription:\n\t\t\t\"This manifest type expects the manifest setting to have a uuid. This must match to a connection registered in the connectionProvider with app support.\"\n\t},\n\tUnregisteredApp: {\n\t\tid: \"unregistered-app\",\n\t\tlabel: \"Unregistered App\",\n\t\tdescription:\n\t\t\t\"This manifest type represents web page instances that have been launched that are not linked to an app. This manifest type should not be in the permitted manifest type list for app feeds as it is for dynamic urls.\"\n\t}\n};\n","import type OpenFin from \"@openfin/core\";\nimport type { PlatformApp } from \"../../../../framework/shapes/app-shapes\";\nimport type { Logger } from \"../../../../framework/shapes/logger-shapes\";\n/**\n * The AppIdHelper class provides helpful functions related to app ids.\n */\nexport class AppIdHelper {\n\tprivate readonly _validatedAppIds: string[] = [];\n\n\tprivate readonly _invalidAppIds: string[] = [];\n\n\tprivate readonly _unregisteredApp: PlatformApp | undefined;\n\n\tprivate readonly _logger: Logger;\n\n\tprivate readonly _getApp: (appId: string) => Promise<PlatformApp | undefined>;\n\n\tprivate readonly _platformId: string;\n\n\t/**\n\t * Provides helpful functions related to app ids.\n\t * @param getApp The function to use to get an app for validation.\n\t * @param platformId The platform id that represents the current platform.\n\t * @param logger The logger to use\n\t * @param unregisteredApp The app to use as a placeholder for unregistered apps.\n\t */\n\tconstructor(\n\t\tgetApp: (appId: string) => Promise<PlatformApp | undefined>,\n\t\tplatformId: string,\n\t\tlogger: Logger,\n\t\tunregisteredApp?: PlatformApp\n\t) {\n\t\tthis._unregisteredApp = unregisteredApp;\n\t\tthis._logger = logger;\n\t\tthis._getApp = getApp;\n\t\tthis._platformId = platformId;\n\t}\n\n\t/**\n\t * Lookup an application identity.\n\t * @param clientIdentity The client identity to use.\n\t * @returns The application identity.\n\t */\n\tpublic async lookupAppId(clientIdentity: OpenFin.ClientIdentity): Promise<string | undefined> {\n\t\tif (clientIdentity.name.startsWith(\"internal-generated-\")) {\n\t\t\tif (clientIdentity.uuid === this._platformId) {\n\t\t\t\tif (this._unregisteredApp) {\n\t\t\t\t\tthis._logger.debug(\n\t\t\t\t\t\t`A window or view that is not an app but runs within the platform is running and a placeholder app has been specified ${this._unregisteredApp?.appId}}.`,\n\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t);\n\t\t\t\t\treturn this._unregisteredApp.appId;\n\t\t\t\t}\n\t\t\t\tthis._logger.debug(\n\t\t\t\t\t\"A window or view that is not an app but runs within the platform is running and no unregistered placeholder app is specified so no appId will be returned.\",\n\t\t\t\t\tclientIdentity\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._logger.debug(\n\t\t\t\t\"A window or view that follows the runtime generated naming convention is running from another platform. It will not be assigned an appId.\",\n\t\t\t\tclientIdentity\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tconst nameParts = clientIdentity.name.split(\"/\");\n\t\tlet appId: string | undefined;\n\t\tif (nameParts.length === 1 || nameParts.length === 2) {\n\t\t\tappId = nameParts[0];\n\t\t} else {\n\t\t\tappId = `${nameParts[0]}/${nameParts[1]}`;\n\t\t}\n\n\t\tif (this._validatedAppIds.includes(appId)) {\n\t\t\treturn appId;\n\t\t}\n\t\tif (this._invalidAppIds.includes(appId)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// perform a lookup to validate the appId\n\t\tconst app = await this._getApp(appId);\n\n\t\tif (app) {\n\t\t\tthis._validatedAppIds.push(appId);\n\t\t\treturn appId;\n\t\t}\n\t\tthis._invalidAppIds.push(appId);\n\t\tthis._logger.warn(\n\t\t\t`AppId ${appId} does not exist in the directory and it isn't a generated view/window that falls under this platform. No app id will be returned as it is unconfirmed.`\n\t\t);\n\t}\n}\n","import type { AppsForIntent, PlatformApp } from \"workspace-platform-starter/shapes/app-shapes\";\nimport type { AppIntents } from \"workspace-platform-starter/shapes/fdc3-2-0-shapes\";\nimport type { Logger } from \"workspace-platform-starter/shapes/logger-shapes\";\nimport { isEmpty } from \"workspace-platform-starter/utils\";\n\n/**\n * The App Intent Helper inspects app catalogs to discover supported intents and contexts.\n */\nexport class AppIntentHelper {\n\tprivate readonly _getApps: () => Promise<PlatformApp[]>;\n\n\tprivate readonly _logger: Logger;\n\n\t/**\n\t * Create an instance of the App Intent Helper.\n\t * @param getApps returns an array of Apps\n\t * @param logger the logger to use.\n\t */\n\tconstructor(getApps: () => Promise<PlatformApp[]>, logger: Logger) {\n\t\tthis._getApps = getApps;\n\t\tthis._logger = logger;\n\t}\n\n\t/**\n\t * Get the application that support the requested intent.\n\t * @param intent The intent the application must support.\n\t * @returns The list of application that support the intent.\n\t */\n\tpublic async getAppsByIntent(intent: string): Promise<PlatformApp[]> {\n\t\tconst apps = await this._getApps();\n\t\treturn apps.filter((app) => {\n\t\t\tconst listensFor = app.interop?.intents?.listensFor;\n\n\t\t\tif (isEmpty(listensFor)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst intentNames = Object.keys(listensFor);\n\t\t\tfor (const intentName of intentNames) {\n\t\t\t\tif (intentName.toLowerCase() === intent.toLowerCase()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n\n\t/**\n\t * Get an intent and the apps that support it.\n\t * @param intent The intent to look for.\n\t * @param contextType Optional context type to look for.\n\t * @param resultType Optional result type to look for.\n\t * @returns The intent and its supporting apps if found.\n\t */\n\tpublic async getIntent(\n\t\tintent: string,\n\t\tcontextType?: string,\n\t\tresultType?: string\n\t): Promise<AppsForIntent | undefined> {\n\t\tconst apps = await this._getApps();\n\n\t\tif (apps.length === 0) {\n\t\t\tthis._logger.warn(\"There was no apps returned so we are unable to find apps that support an intent\");\n\t\t\treturn;\n\t\t}\n\n\t\tconst intentsMap: { [key: string]: AppsForIntent } = {};\n\n\t\tfor (const app of apps) {\n\t\t\tif (app.interop?.intents?.listensFor && !isEmpty(app.interop.intents.listensFor[intent])) {\n\t\t\t\tconst appIntent = app.interop.intents.listensFor[intent];\n\t\t\t\tconst include = this.appIntentContains(appIntent, contextType, resultType);\n\t\t\t\tif (include) {\n\t\t\t\t\t// re-use approach used by getting intents by context for the context map although this will only have one\n\t\t\t\t\tthis.updateAppIntentsMap(intentsMap, intent, appIntent.displayName, app);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst results = Object.values(intentsMap);\n\t\tif (results.length === 0) {\n\t\t\tthis._logger.info(\n\t\t\t\t`No results found for findIntent for intent ${intent} and context ${contextType} and resultType ${resultType}`\n\t\t\t);\n\t\t\treturn;\n\t\t} else if (results.length === 1) {\n\t\t\treturn results[0];\n\t\t}\n\n\t\tthis._logger.warn(\n\t\t\t`Received more than one result for findIntent for intent ${intent} and context ${contextType} and resultType ${resultType}. Returning the first entry.`\n\t\t);\n\t\treturn results[0];\n\t}\n\n\t/**\n\t * Get the apps that support intents by the context type.\n\t * @param contextType The context type the app must support.\n\t * @param resultType The optional result type to match as well.\n\t * @returns The apps for the specified intent.\n\t */\n\tpublic async getIntentsByContext(contextType: string, resultType?: string): Promise<AppsForIntent[]> {\n\t\tconst apps = await this._getApps();\n\n\t\tif (apps.length === 0) {\n\t\t\tthis._logger.warn(\n\t\t\t\t\"Unable to get apps so we can not get apps and intents that support a particular context\"\n\t\t\t);\n\t\t\treturn [];\n\t\t}\n\n\t\tconst intents: { [key: string]: AppsForIntent } = {};\n\n\t\tfor (const app of apps) {\n\t\t\tconst listensFor = app.interop?.intents?.listensFor;\n\n\t\t\tif (!isEmpty(listensFor)) {\n\t\t\t\tconst supportedIntents = Object.keys(listensFor);\n\t\t\t\tfor (const supportedIntent of supportedIntents) {\n\t\t\t\t\tconst appIntent = listensFor[supportedIntent];\n\t\t\t\t\tconst include = this.appIntentContains(appIntent, contextType, resultType);\n\t\t\t\t\tif (include) {\n\t\t\t\t\t\tthis.updateAppIntentsMap(intents, supportedIntent, appIntent.displayName, app);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Object.values(intents);\n\t}\n\n\t/**\n\t * Check to see if the supplied appIntent supports the context and result types.\n\t * @param appIntent The app intent to check.\n\t * @param contextType The optional context type to look for.\n\t * @param resultType The optional result type to look for.\n\t * @returns True if the app intent matches.\n\t */\n\tprivate appIntentContains(\n\t\tappIntent: AppIntents,\n\t\tcontextType: string | undefined,\n\t\tresultType: string | undefined\n\t): boolean {\n\t\tif (!isEmpty(contextType) && !isEmpty(resultType)) {\n\t\t\tif (!appIntent?.contexts?.includes(contextType) || !appIntent.resultType?.includes(resultType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (!isEmpty(contextType) && !appIntent?.contexts?.includes(contextType)) {\n\t\t\treturn false;\n\t\t} else if (!isEmpty(resultType) && !appIntent?.resultType?.includes(resultType)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Update the map containing the intent to apps.\n\t * @param intentsMap The map to update.\n\t * @param name The name of the intent.\n\t * @param displayName The Options display name to update with.\n\t * @param app The application to update.\n\t */\n\tprivate updateAppIntentsMap(\n\t\tintentsMap: {\n\t\t\t[key: string]: AppsForIntent;\n\t\t},\n\t\tname: string,\n\t\tdisplayName: string | undefined,\n\t\tapp: PlatformApp\n\t): void {\n\t\tif (isEmpty(intentsMap[name])) {\n\t\t\t// in a production app you would either need to ensure that every app was populated with the same name & displayName for an intent from a golden source (e.g. intents table) so picking the first entry wouldn't make a difference.\n\t\t\t// or you could pull in a golden source of intents from a service and then do a lookup using the intent name to get an object with intent name and official display name.\n\t\t\tintentsMap[name] = {\n\t\t\t\tintent: {\n\t\t\t\t\tname,\n\t\t\t\t\tdisplayName\n\t\t\t\t},\n\t\t\t\tapps: []\n\t\t\t};\n\t\t}\n\t\tintentsMap[name].apps.push(app);\n\t}\n}\n","import type { AppIdentifier, AppMetadata } from \"@finos/fdc3\";\nimport type { PlatformApp } from \"workspace-platform-starter/shapes/app-shapes\";\nimport type { AppMetadata as AppMetadataV1Point2 } from \"workspace-platform-starter/shapes/fdc3-1-2-shapes\";\n\n/**\n * Gets app meta data in the right format based on the version.\n * @param apps the apps to get the meta data for.\n * @param version the version of the meta data to get.\n * @param appToV1Point2 the function to convert the app to v1.2 meta data.\n * @param appTpV2Point0 the function to convert the app to v2.0 meta data.\n * @param findInstances the function to find the instances of an app so you can add them to the meta data.\n * @returns the app meta data.\n */\nexport async function getAppsMetaData(\n\tapps: PlatformApp[],\n\tversion: string,\n\tappToV1Point2: (app: PlatformApp) => AppMetadataV1Point2,\n\tappTpV2Point0: (app: PlatformApp) => AppMetadata,\n\tfindInstances: (appId: string) => Promise<AppIdentifier[]>\n): Promise<AppMetadata[] | AppMetadataV1Point2[]> {\n\tconst appsMetaData: AppMetadata[] = [];\n\tconst appsMetaDataV1Point2: AppMetadataV1Point2[] = [];\n\n\tif (version === \"1.2\") {\n\t\tfor (const app of apps) {\n\t\t\tconst appData = appToV1Point2(app);\n\t\t\tappsMetaDataV1Point2.push(appData);\n\t\t}\n\t\treturn appsMetaDataV1Point2;\n\t}\n\tfor (const app of apps) {\n\t\tconst appData = appTpV2Point0(app);\n\t\tconst instances = await findInstances(app.appId);\n\t\tappsMetaData.push(appData);\n\t\tfor (const instance of instances) {\n\t\t\tconst instanceAppEntry = { ...appData, instanceId: instance.instanceId };\n\t\t\tappsMetaData.push(instanceAppEntry);\n\t\t}\n\t}\n\treturn appsMetaData;\n}\n","import type { AppIdentifier } from \"@finos/fdc3\";\nimport type OpenFin from \"@openfin/core\";\nimport {\n\tOPEN_ERROR as OpenError,\n\tRESOLVE_ERROR as ResolveError\n} from \"workspace-platform-starter/fdc3/errors\";\nimport type {\n\tIntentRegistrationEntry,\n\tContextRegistrationEntry,\n\tBrokerClientConnection,\n\tIntentRegistrationPayload,\n\tCaptureApiPayload,\n\tApiMetadata\n} from \"workspace-platform-starter/shapes/interopbroker-shapes\";\nimport type { Logger } from \"workspace-platform-starter/shapes/logger-shapes\";\nimport { isEmpty, isStringValue } from \"workspace-platform-starter/utils\";\n\n/**\n * Used to track client interactions with a broker.\n */\nexport class ClientRegistrationHelper {\n\tprivate readonly _logger: Logger;\n\n\tprivate readonly _lookupAppId: (clientIdentity: OpenFin.ClientIdentity) => Promise<string | undefined>;\n\n\tprivate readonly _clientReadyRequests: { [key: string]: (instanceId: string) => void };\n\n\tprivate readonly _trackedClientConnections: { [key: string]: BrokerClientConnection };\n\n\tprivate readonly _trackedContextHandlers: { [key: string]: ContextRegistrationEntry[] };\n\n\tprivate readonly _trackedIntentHandlers: { [key: string]: IntentRegistrationEntry[] };\n\n\t/**\n\t * Create an instance of the Client Registration Helper.\n\t * @param lookupAppId determine appId based on clientIdentity\n\t * @param logger the logger to use.\n\t */\n\tconstructor(\n\t\tlookupAppId: (clientIdentity: OpenFin.ClientIdentity) => Promise<string | undefined>,\n\t\tlogger: Logger\n\t) {\n\t\tthis._logger = logger;\n\t\tthis._lookupAppId = lookupAppId;\n\t\tthis._clientReadyRequests = {};\n\t\tthis._trackedClientConnections = {};\n\t\tthis._trackedContextHandlers = {};\n\t\tthis._trackedIntentHandlers = {};\n\t}\n\n\t/**\n\t * The client has disconnected form the broker.\n\t * @param clientIdentity The identity of the client that disconnected.\n\t */\n\tpublic async clientDisconnected(clientIdentity: OpenFin.ClientIdentity): Promise<void> {\n\t\tthis._logger.info(\"Client Disconnected.\", clientIdentity);\n\n\t\tfor (const [key, value] of Object.entries(this._trackedIntentHandlers)) {\n\t\t\tthis._trackedIntentHandlers[key] = value.filter(\n\t\t\t\t(entry) => entry.clientIdentity.endpointId !== clientIdentity.endpointId\n\t\t\t);\n\t\t}\n\n\t\tfor (const [key, value] of Object.entries(this._trackedContextHandlers)) {\n\t\t\tthis._trackedContextHandlers[key] = value.filter(\n\t\t\t\t(entry) => entry.clientIdentity.endpointId !== clientIdentity.endpointId\n\t\t\t);\n\t\t}\n\t\tthis.removeTrackedClientConnection(clientIdentity);\n\t}\n\n\t/**\n\t * Handle an intent handler being registered.\n\t * @param payload The payload.\n\t * @param clientIdentity The client identity.\n\t * @returns Nothing.\n\t */\n\tpublic async intentHandlerRegistered(\n\t\tpayload: IntentRegistrationPayload,\n\t\tclientIdentity: OpenFin.ClientIdentity\n\t): Promise<void> {\n\t\tthis._logger.info(\"intentHandlerRegistered:\", payload, clientIdentity);\n\t\tif (!isEmpty(payload)) {\n\t\t\tconst intentName: string = payload.handlerId.replace(\"intent-handler-\", \"\");\n\n\t\t\tlet trackedIntentHandler = this._trackedIntentHandlers[intentName];\n\n\t\t\tif (isEmpty(trackedIntentHandler)) {\n\t\t\t\ttrackedIntentHandler = [];\n\t\t\t\tthis._trackedIntentHandlers[intentName] = trackedIntentHandler;\n\t\t\t}\n\n\t\t\tconst trackedHandler = this._trackedIntentHandlers[intentName].find(\n\t\t\t\t(entry) => entry.clientIdentity.endpointId === clientIdentity.endpointId\n\t\t\t);\n\n\t\t\tif (isEmpty(trackedHandler)) {\n\t\t\t\tthis._logger.info(\n\t\t\t\t\t`intentHandler endpoint not registered. Registering ${clientIdentity.endpointId} against intent ${intentName} and looking up app name.`\n\t\t\t\t);\n\t\t\t\tconst appId = await this._lookupAppId(clientIdentity);\n\n\t\t\t\tif (isEmpty(appId)) {\n\t\t\t\t\tthis._logger.warn(\n\t\t\t\t\t\t\"Unable to determine app id based on name. This app will not be tracked via intent handler registration.\"\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._trackedIntentHandlers[intentName].push({\n\t\t\t\t\tfdc3Version: payload.fdc3Version,\n\t\t\t\t\tclientIdentity,\n\t\t\t\t\tappId\n\t\t\t\t});\n\t\t\t\tthis._logger.info(\n\t\t\t\t\t`intentHandler endpoint: ${clientIdentity.endpointId} registered against intent: ${intentName} and app Id: ${appId}.`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst clientReadyKey = this.getClientReadyKey(clientIdentity, \"intent\", intentName);\n\t\t\tif (!isEmpty(this._clientReadyRequests[clientReadyKey])) {\n\t\t\t\tthis._logger.info(\"Resolving client ready request.\");\n\t\t\t\tthis._clientReadyRequests[clientReadyKey](clientIdentity.endpointId);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A context handler has been registered against the broker.\n\t * @param payload The payload from a context listener registration.\n\t * @param payload.contextType The context type that the client is listening for.\n\t * @param payload.handlerId The handler Id for this listener.\n\t * @param clientIdentity The identity of the application that is adding the context handler.\n\t */\n\tpublic async contextHandlerRegistered(\n\t\tpayload: { contextType: string | undefined; handlerId: string },\n\t\tclientIdentity: OpenFin.ClientIdentity\n\t): Promise<void> {\n\t\tthis._logger.info(\"contextHandlerRegistered:\", payload, clientIdentity);\n\t\tif (!isEmpty(payload?.handlerId)) {\n\t\t\tconst contextTypeName: string = payload?.contextType ?? \"*\";\n\t\t\tconst handlerId = payload.handlerId;\n\t\t\tlet trackedContextHandler = this._trackedContextHandlers[contextTypeName];\n\n\t\t\tif (isEmpty(trackedContextHandler)) {\n\t\t\t\ttrackedContextHandler = [];\n\t\t\t\tthis._trackedContextHandlers[contextTypeName] = trackedContextHandler;\n\t\t\t}\n\n\t\t\tconst trackedHandler = this._trackedContextHandlers[contextTypeName].find(\n\t\t\t\t(entry) => entry.clientIdentity.endpointId === clientIdentity.endpointId\n\t\t\t);\n\n\t\t\tif (isEmpty(trackedHandler)) {\n\t\t\t\tthis._logger.info(\n\t\t\t\t\t`contextHandler endpoint not registered. Registering ${clientIdentity.endpointId} against context handler for context type ${contextTypeName} and looking up app name.`\n\t\t\t\t);\n\t\t\t\tconst appId = await this._lookupAppId(clientIdentity);\n\n\t\t\t\tif (isEmpty(appId)) {\n\t\t\t\t\tthis._logger.warn(\n\t\t\t\t\t\t\"Unable to determine app id based on name. This app will not be tracked via context handler registration.\"\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._trackedContextHandlers[contextTypeName].push({\n\t\t\t\t\tclientIdentity,\n\t\t\t\t\tappId,\n\t\t\t\t\thandlerId\n\t\t\t\t});\n\t\t\t\tthis._logger.info(\n\t\t\t\t\t`contextHandler endpoint: ${clientIdentity.endpointId} registered against context type: ${contextTypeName} and app Id: ${appId}.`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst clientReadyKey = this.getClientReadyKey(clientIdentity, \"context\", contextTypeName);\n\t\t\tif (!isEmpty(this._clientReadyRequests[clientReadyKey])) {\n\t\t\t\tthis._logger.info(\"Resolving client ready request.\");\n\t\t\t\tthis._clientReadyRequests[clientReadyKey](clientIdentity.endpointId);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Capture the connection and API version.\n\t * @param id The client identity to capture from.\n\t * @param payload The payload.\n\t */\n\tpublic async clientConnectionRegistered(\n\t\tid: OpenFin.ClientIdentity & { connectionUrl?: string; entityType?: string },\n\t\tpayload?: CaptureApiPayload\n\t): Promise<void> {\n\t\tconst key = `${id.uuid}-${id.name}`;\n\t\tlet apiVersion: ApiMetadata | undefined;\n\t\tif (isEmpty(this._trackedClientConnections[key])) {\n\t\t\tif (id.uuid !== fin.me.identity.uuid) {\n\t\t\t\tconst payloadApiVersion = payload?.apiVersion;\n\t\t\t\tif (!isEmpty(payloadApiVersion) && !isEmpty(payloadApiVersion?.type)) {\n\t\t\t\t\tapiVersion = payloadApiVersion;\n\t\t\t\t} else if (isStringValue(id.connectionUrl)) {\n\t\t\t\t\t// if they haven't specified apiVersion meta data and it is external and has a url then we will assume fdc3 2.0\n\t\t\t\t\tapiVersion = { type: \"fdc3\", version: \"2.0\" };\n\t\t\t\t} else {\n\t\t\t\t\t// if a native app has specified a preference through apiVersion then we assume interop\n\t\t\t\t\tapiVersion = { type: \"interop\" };\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst entityType = id.entityType;\n\t\t\t\tif (!isEmpty(entityType)) {\n\t\t\t\t\tswitch (entityType) {\n\t\t\t\t\t\tcase \"window\": {\n\t\t\t\t\t\t\tapiVersion = await this.captureWindowApiUsage(id);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"view\": {\n\t\t\t\t\t\t\tapiVersion = await this.captureViewApiUsage(id);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tthis._logger.warn(\n\t\t\t\t\t\t\t\t`We currently do not check for entity types that are not views or windows. Entity type: ${entityType}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tapiVersion = await this.captureViewApiUsage(id);\n\t\t\t\t\tif (isEmpty(apiVersion)) {\n\t\t\t\t\t\t// perhaps it is a window\n\t\t\t\t\t\tapiVersion = await this.captureWindowApiUsage(id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst brokerClientConnection: BrokerClientConnection = {\n\t\t\t\tclientIdentity: id,\n\t\t\t\tapiMetadata: apiVersion\n\t\t\t};\n\n\t\t\tthis._trackedClientConnections[key] = brokerClientConnection;\n\t\t\tconst clientReadyKey = this.getClientReadyKey(id, \"connection\");\n\t\t\tif (!isEmpty(this._clientReadyRequests[clientReadyKey])) {\n\t\t\t\tthis._logger.info(\"Resolving client ready request.\");\n\t\t\t\tthis._clientReadyRequests[clientReadyKey](id.endpointId);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get a context handler that matches the context type name and instance id.\n\t * @param contextTypeName the name of the context the listener is registered for.\n\t * @param instanceId the instanceId you wish to check for.\n\t * @returns The ContextRegistrationEntry or undefined.\n\t */\n\tpublic getRegisteredContextHandler(\n\t\tcontextTypeName: string,\n\t\tinstanceId: string\n\t): ContextRegistrationEntry | undefined {\n\t\tconst trackedHandler = this._trackedContextHandlers[contextTypeName]?.find(\n\t\t\t(entry) => entry.clientIdentity.endpointId === instanceId\n\t\t);\n\t\treturn trackedHandler;\n\t}\n\n\t/**\n\t * Handle FDC3 find instances for app instances that have registered for an intent.\n\t * @param app The app identifier to find.\n\t * @param clientIdentity The client identity.\n\t * @param type the type of app instances you are after. CONNECTED = anything that has connected to the broker and INTENT means an APP that has registered an Intent Handler.\n\t * @returns The instance of the app.\n\t */\n\tpublic async findAppInstances(\n\t\tapp: AppIdentifier,\n\t\tclientIdentity: OpenFin.ClientIdentity,\n\t\ttype: \"connected\" | \"intent\" = \"connected\"\n\t): Promise<AppIdentifier[]> {\n\t\tconst endpointApps: { [key: string]: AppIdentifier } = {};\n\n\t\tif (type === \"intent\") {\n\t\t\tfor (const [, value] of Object.entries(this._trackedIntentHandlers)) {\n\t\t\t\tconst entries = value.filter((entry) => entry.appId === app.appId);\n\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\tendpointApps[entry.clientIdentity.endpointId] = {\n\t\t\t\t\t\tappId: entry.appId ?? \"\",\n\t\t\t\t\t\tinstanceId: entry.clientIdentity.endpointId\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Object.values(endpointApps);\n\t\t}\n\n\t\tfor (const [, value] of Object.entries(this._trackedClientConnections)) {\n\t\t\tconst trackedAppId = await this._lookupAppId(value.clientIdentity);\n\t\t\tif (trackedAppId === app.appId && isEmpty(endpointApps[value.clientIdentity.endpointId])) {\n\t\t\t\tendpointApps[value.clientIdentity.endpointId] = {\n\t\t\t\t\tappId: app.appId ?? \"\",\n\t\t\t\t\tinstanceId: value.clientIdentity.endpointId\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn Object.values(endpointApps);\n\t}\n\n\t/**\n\t * Get the api version for the identity.\n\t * @param id The identity to get the api version for.\n\t * @returns The api metadata.\n\t */\n\tpublic getApiVersion(id: OpenFin.Identity): ApiMetadata | undefined {\n\t\tconst key = `${id.uuid}-${id.name}`;\n\t\tconst apiVersion: ApiMetadata | undefined = this._trackedClientConnections[key]?.apiMetadata;\n\t\treturn apiVersion;\n\t}\n\n\t/**\n\t * Handle client ready event for opening and awaiting a connection to the broker.\n\t * @param identity The identity of the client.\n\t * @param timeout The timeout to wait for the client.\n\t * @returns The instance id.\n\t */\n\tpublic async onConnectionClientReady(identity: OpenFin.Identity, timeout: number = 15000): Promise<string> {\n\t\treturn new Promise<string>((resolve, reject) => {\n\t\t\tconst clientIdentity = this.getClientIdentity(identity);\n\t\t\tif (!isEmpty(clientIdentity)) {\n\t\t\t\tresolve(clientIdentity.endpointId);\n\t\t\t}\n\t\t\tconst key = this.getClientReadyKey(identity, \"connection\");\n\t\t\tconst timerId = setTimeout(() => {\n\t\t\t\tif (!isEmpty(this._clientReadyRequests[key])) {\n\t\t\t\t\tdelete this._clientReadyRequests[key];\n\t\t\t\t\treject(ResolveError.TargetInstanceUnavailable);\n\t\t\t\t}\n\t\t\t}, timeout);\n\t\t\tthis._clientReadyRequests[key] = (instanceId: string): void => {\n\t\t\t\tclearTimeout(timerId);\n\t\t\t\t// clear the callback asynchronously\n\t\t\t\tdelete this._clientReadyRequests[key];\n\t\t\t\tresolve(instanceId);\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Handle client ready event for intent handling.\n\t * @param identity The identity of the client.\n\t * @param intentName The intent name.\n\t * @param timeout The timeout to wait for the client.\n\t * @returns The instance id.\n\t */\n\tpublic async onIntentClientReady(\n\t\tidentity: OpenFin.Identity,\n\t\tintentName: string,\n\t\ttimeout: number = 15000\n\t): Promise<string> {\n\t\treturn new Promise<string>((resolve, reject) => {\n\t\t\tconst registeredHandlers = this._trackedIntentHandlers[intentName];\n\t\t\tlet existingInstanceId: string | undefined;\n\t\t\tif (!isEmpty(registeredHandlers)) {\n\t\t\t\tfor (const handler of registeredHandlers) {\n\t\t\t\t\tif (\n\t\t\t\t\t\thandler.clientIdentity.uuid === identity.uuid &&\n\t\t\t\t\t\thandler.clientIdentity.name === identity.name\n\t\t\t\t\t) {\n\t\t\t\t\t\texistingInstanceId = handler.clientIdentity.endpointId;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isEmpty(existingInstanceId)) {\n\t\t\t\tresolve(existingInstanceId);\n\t\t\t}\n\t\t\tconst key = this.getClientReadyKey(identity, \"intent\", intentName);\n\t\t\tconst timerId = setTimeout(() => {\n\t\t\t\tif (!isEmpty(this._clientReadyRequests[key])) {\n\t\t\t\t\tdelete this._clientReadyRequests[key];\n\t\t\t\t\treject(ResolveError.IntentDeliveryFailed);\n\t\t\t\t}\n\t\t\t}, timeout);\n\t\t\tthis._clientReadyRequests[key] = (instanceId: string): void => {\n\t\t\t\tclearTimeout(timerId);\n\t\t\t\t// clear the callback asynchronously\n\t\t\t\tdelete this._clientReadyRequests[key];\n\t\t\t\tresolve(instanceId);\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Handle client ready event for context handling.\n\t * @param identity The identity of the client.\n\t * @param contextTypeName The contextType name.\n\t * @param timeout The timeout to wait for the client.\n\t * @returns The instance id.\n\t */\n\tpublic async onContextClientReady(\n\t\tidentity: OpenFin.Identity,\n\t\tcontextTypeName: string,\n\t\ttimeout: number = 15000\n\t): Promise<string> {\n\t\treturn new Promise<string>((resolve, reject) => {\n\t\t\tconst contextRegisteredHandlers = this._trackedContextHandlers[contextTypeName];\n\t\t\tconst globalRegisteredHandlers = this._trackedContextHandlers[\"*\"];\n\t\t\tlet existingContextHandlerInstanceId: string | undefined;\n\n\t\t\tif (!isEmpty(contextRegisteredHandlers)) {\n\t\t\t\tfor (const handler of contextRegisteredHandlers) {\n\t\t\t\t\tif (\n\t\t\t\t\t\thandler.clientIdentity.uuid === identity.uuid &&\n\t\t\t\t\t\thandler.clientIdentity.name === identity.name\n\t\t\t\t\t) {\n\t\t\t\t\t\texistingContextHandlerInstanceId = handler.clientIdentity.endpointId;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isEmpty(globalRegisteredHandlers) && isEmpty(existingContextHandlerInstanceId)) {\n\t\t\t\tfor (const handler of globalRegisteredHandlers) {\n\t\t\t\t\tif (\n\t\t\t\t\t\thandler.clientIdentity.uuid === identity.uuid &&\n\t\t\t\t\t\thandler.clientIdentity.name === identity.name\n\t\t\t\t\t) {\n\t\t\t\t\t\texistingContextHandlerInstanceId = handler.clientIdentity.endpointId;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isEmpty(existingContextHandlerInstanceId)) {\n\t\t\t\tresolve(existingContextHandlerInstanceId);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst contextKey = this.getClientReadyKey(identity, \"context\", contextTypeName);\n\t\t\tconst globalKey = this.getClientReadyKey(identity, \"context\", \"*\");\n\t\t\tconst timerId = setTimeout(() => {\n\t\t\t\tconst hasContextRequest = !isEmpty(this._clientReadyRequests[contextKey]);\n\t\t\t\tconst hasGlobalRequest = !isEmpty(this._clientReadyRequests[globalKey]);\n\n\t\t\t\tif (hasContextRequest || hasGlobalRequest) {\n\t\t\t\t\tdelete this._clientReadyRequests[contextKey];\n\t\t\t\t\tdelete this._clientReadyRequests[globalKey];\n\t\t\t\t\treject(OpenError.AppTimeout);\n\t\t\t\t}\n\t\t\t}, timeout);\n\t\t\tlet isResolved = false;\n\t\t\tthis._clientReadyRequests[contextKey] = (instanceId: string): void => {\n\t\t\t\tclearTimeout(timerId);\n\t\t\t\tif (!isResolved) {\n\t\t\t\t\tisResolved = true;\n\t\t\t\t\t// clear the callback asynchronously\n\t\t\t\t\tdelete this._clientReadyRequests[contextKey];\n\t\t\t\t\tdelete this._clientReadyRequests[globalKey];\n\t\t\t\t\tresolve(instanceId);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._clientReadyRequests[globalKey] = (instanceId: string): void => {\n\t\t\t\tclearTimeout(timerId);\n\t\t\t\tif (!isResolved) {\n\t\t\t\t\tisResolved = true;\n\t\t\t\t\t// clear the callback asynchronously\n\t\t\t\t\tdelete this._clientReadyRequests[contextKey];\n\t\t\t\t\tdelete this._clientReadyRequests[globalKey];\n\t\t\t\t\tresolve(instanceId);\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Get the client identity given a standard identity.\n\t * @param id The identity to get the client identity for.\n\t * @returns The client identity if available.\n\t */\n\tprivate getClientIdentity(id: OpenFin.Identity): OpenFin.ClientIdentity | undefined {\n\t\tconst key = `${id.uuid}-${id.name}`;\n\t\tconst clientIdentity: OpenFin.ClientIdentity | undefined =\n\t\t\tthis._trackedClientConnections[key]?.clientIdentity;\n\t\treturn clientIdentity;\n\t}\n\n\t/**\n\t * Remove the tracking for the identity.\n\t * @param id The identity to remove the connection information for.\n\t */\n\tprivate removeTrackedClientConnection(id: OpenFin.Identity): void {\n\t\tconst key = `${id.uuid}-${id.name}`;\n\t\tdelete this._trackedClientConnections[key];\n\t}\n\n\t/**\n\t * Get the fdc3 usage from a window.\n\t * @param id The if of the view to get the info from.\n\t * @returns The api metadata.\n\t */\n\tprivate async captureWindowApiUsage(id: OpenFin.ClientIdentity): Promise<ApiMetadata | undefined> {\n\t\ttry {\n\t\t\tconst target = fin.Window.wrapSync(id);\n\t\t\tconst options = await target.getOptions();\n\t\t\tif (!isEmpty(options.fdc3InteropApi)) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"fdc3\",\n\t\t\t\t\tversion: options.fdc3InteropApi\n\t\t\t\t};\n\t\t\t}\n\t\t} catch {}\n\t}\n\n\t/**\n\t * Get the dc3 usage from a view.\n\t * @param id The id of the window to get the info from.\n\t * @returns The api metadata.\n\t */\n\tprivate async captureViewApiUsage(id: OpenFin.ClientIdentity): Promise<ApiMetadata | undefined> {\n\t\ttry {\n\t\t\tconst target = fin.View.wrapSync(id);\n\t\t\tconst options = await target.getOptions();\n\t\t\tif (!isEmpty(options.fdc3InteropApi)) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"fdc3\",\n\t\t\t\t\tversion: options.fdc3InteropApi\n\t\t\t\t};\n\t\t\t}\n\t\t} catch {}\n\t}\n\n\t/**\n\t * Get a key that can be used for an identity and client.\n\t * @param identity The identity to use in the key.\n\t * @param type The type of ready event you are looking for\n\t * @param name The name of the type if required to use in the key\n\t * @returns The key.\n\t */\n\tprivate getClientReadyKey(\n\t\tidentity: OpenFin.Identity,\n\t\ttype: \"connection\" | \"context\" | \"intent\",\n\t\tname?: string\n\t): string {\n\t\tif (isEmpty(name)) {\n\t\t\treturn `${identity.uuid}/${identity.name}/${type}`;\n\t\t}\n\t\treturn `${identity.uuid}/${identity.name}/${type}/${name}`;\n\t}\n}\n","import type OpenFin from \"@openfin/core\";\nimport type { BrowserProviderOptions, WindowPositioningOptions } from \"./shapes/browser-shapes\";\nimport { isEmpty } from \"./utils\";\n\n/**\n * Provides x and y co-ordinates to position a window of a given size in relation to another window/view.\n * @param clientIdentity The identity of the view/window these x/y co-ordinates should be in relation to.\n * @param dimensions The dimensions of the window that will be placed in the center of the screen.\n * @param dimensions.width The width of the window that is going to be placed.\n * @param dimensions.height The height of the window that is going to be placed.\n * @returns The x, y co-ordinates to position the window\n */\nexport async function centerContentInIdentity(\n\tclientIdentity: OpenFin.Identity,\n\tdimensions: { width: number; height: number }\n): Promise<{ x: number; y: number } | undefined> {\n\tconst bounds = await getIdentityBounds(clientIdentity);\n\tconst boundsCenter = getBoundsCenter(bounds);\n\tconst monitorInfo = await findMonitorContainingPoint(boundsCenter);\n\treturn centerContentInRect(monitorInfo.availableRect, dimensions);\n}\n\n/**\n * Provides x and y co-ordinates to position content of a given size in relation to a rect.\n * @param availableRect The available rect to position the content in.\n * @param availableRect.left The available rect left to position the content in.\n * @param availableRect.top The available rect top to position the content in.\n * @param availableRect.right The available rect right to position the content in.\n * @param availableRect.bottom The available rect bottom to position the content in.\n * @param contentDimensions The dimensions of the content that will be placed in the center of the screen.\n * @param contentDimensions.width The width of the content that is going to be placed.\n * @param contentDimensions.height The height of the content that is going to be placed.\n * @returns The x, y co-ordinates to position the content\n */\nexport function centerContentInRect(\n\tavailableRect: { left: number; top: number; right: number; bottom: number },\n\tcontentDimensions: { width: number; height: number }\n): { x: number; y: number } {\n\tconst height = availableRect.bottom - availableRect.top;\n\tconst width = availableRect.right - availableRect.left;\n\tconst dividedRectWidth = width / 2;\n\tconst dividedRectHeight = height / 2;\n\tconst dividedDimensionWidth = contentDimensions.width / 2;\n\tconst dividedDimensionHeight = contentDimensions.height / 2;\n\tconst x = availableRect.left + dividedRectWidth - dividedDimensionWidth;\n\tconst y = availableRect.top + dividedRectHeight - dividedDimensionHeight;\n\n\treturn { x: Math.round(x), y: Math.round(y) };\n}\n\n/**\n * Returns the monitor details for the monitor a view/window is placed on.\n * @param clientIdentity The identity of the view/window to check against.\n * @returns The monitor the view/window lives on or undefined if no match was found.\n */\nexport async function getIdentityBounds(\n\tclientIdentity: OpenFin.Identity\n): Promise<OpenFin.Bounds | undefined> {\n\tlet bounds: OpenFin.Bounds | undefined;\n\tlet currentWindow: OpenFin.Window | undefined;\n\n\ttry {\n\t\tconst targetView = fin.View.wrapSync(clientIdentity);\n\t\tcurrentWindow = await targetView.getCurrentWindow();\n\t} catch {\n\t\t// we were not passed a view.\n\t}\n\n\tif (isEmpty(bounds)) {\n\t\ttry {\n\t\t\tconst targetWindow = currentWindow ?? fin.Window.wrapSync(clientIdentity);\n\t\t\tbounds = await targetWindow.getBounds();\n\t\t} catch {\n\t\t\t// it wasn't a window\n\t\t}\n\t}\n\n\tif (isEmpty(bounds)) {\n\t\ttry {\n\t\t\tbounds = await fin.me.getBounds();\n\t\t} catch {\n\t\t\t// unable to get own bounds\n\t\t}\n\t}\n\n\treturn bounds;\n}\n\n/**\n * Find the monitor which contains the point and returns it.\n * @param point The point coord to locate.\n * @param point.x The x coord\n * @param point.y The y coord\n * @returns The monitor containing the point.\n */\nexport async function findMonitorContainingPoint(point: {\n\tx?: number;\n\ty?: number;\n}): Promise<OpenFin.MonitorDetails> {\n\tconst monitorInfo = await fin.System.getMonitorInfo();\n\n\tconst x = point.x;\n\tconst y = point.y;\n\tif (!isEmpty(x) && !isEmpty(y)) {\n\t\tfor (const monitor of monitorInfo.nonPrimaryMonitors) {\n\t\t\tif (pointInRect({ x, y }, monitor.monitorRect)) {\n\t\t\t\treturn monitor;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn monitorInfo.primaryMonitor;\n}\n\n/**\n * Is the point in the rectangle.\n * @param point The coord to match.\n * @param point.x The x coord.\n * @param point.y The y coord.\n * @param rect The rect.\n * @param rect.top The rect top.\n * @param rect.left The rect left.\n * @param rect.bottom The rect bottom.\n * @param rect.right The rect right.\n * @returns True if the point is in the rect.\n */\nexport function pointInRect(\n\tpoint: { x: number; y: number },\n\trect: {\n\t\ttop: number;\n\t\tleft: number;\n\t\tbottom: number;\n\t\tright: number;\n\t}\n): boolean {\n\treturn point.x >= rect.left && point.x <= rect.right && point.y >= rect.top && point.y <= rect.bottom;\n}\n\n/**\n * Get the center for a bounding rectangle.\n * @param bounds The rect\n * @param bounds.top The rect top\n * @param bounds.left The rect left\n * @param bounds.width The rect width\n * @param bounds.height The rect height\n * @returns the x and y of the bounds center or an object not containing x or y.\n */\nexport function getBoundsCenter(bounds?: OpenFin.Bounds): { x?: number; y?: number } {\n\tlet boundsCenterX: number | undefined;\n\tlet boundsCenterY: number | undefined;\n\tif (!isEmpty(bounds)) {\n\t\tconst halfWidth = bounds.width / 2;\n\t\tconst halfHeight = bounds.height / 2;\n\t\tboundsCenterX = bounds.left + halfWidth;\n\t\tboundsCenterY = bounds.top + halfHeight;\n\t\treturn { x: Math.round(boundsCenterX), y: Math.round(boundsCenterY) };\n\t}\n\treturn {};\n}\n\n/**\n * Given browser settings what window positioning options should be used?\n * @param settings The browser settings that have been provided.\n * @returns a set of window positioning options.\n */\nexport async function getWindowPositionOptions(\n\tsettings?: BrowserProviderOptions\n): Promise<WindowPositioningOptions> {\n\tconst windowPositioningOptions: WindowPositioningOptions = {};\n\twindowPositioningOptions.defaults = {};\n\tif (!isEmpty(settings)) {\n\t\twindowPositioningOptions.windowPositioningStrategy = settings.windowPositioningStrategy;\n\t\twindowPositioningOptions.disableWindowPositioningStrategy = settings.disableWindowPositioningStrategy;\n\t\tif (!isEmpty(settings?.defaultWindowOptions?.defaultLeft)) {\n\t\t\twindowPositioningOptions.defaults.left = settings.defaultWindowOptions.defaultLeft;\n\t\t}\n\t\tif (!isEmpty(settings?.defaultWindowOptions?.defaultTop)) {\n\t\t\twindowPositioningOptions.defaults.top = settings.defaultWindowOptions.defaultTop;\n\t\t}\n\t}\n\tif (isEmpty(windowPositioningOptions.defaults.left) || isEmpty(windowPositioningOptions.defaults.top)) {\n\t\tconst app = await fin.Application.getCurrent();\n\t\tconst platformManifest: OpenFin.Manifest = await app.getManifest();\n\t\tif (!isEmpty(platformManifest?.platform?.defaultWindowOptions?.defaultLeft)) {\n\t\t\twindowPositioningOptions.defaults.left = platformManifest.platform.defaultWindowOptions.defaultLeft;\n\t\t}\n\t\tif (!isEmpty(platformManifest?.platform?.defaultWindowOptions?.defaultTop)) {\n\t\t\twindowPositioningOptions.defaults.top = platformManifest.platform.defaultWindowOptions.defaultTop;\n\t\t}\n\t}\n\treturn windowPositioningOptions;\n}\n\n/**\n * Get the window position using a strategy.\n * @param windowPositioningOptions The options for window positioning.\n * @param windowPositioningOptions.windowPositioningStrategy The strategy for window positioning.\n * @param windowPositioningOptions.windowPositioningStrategy.x The x coordinate.\n * @param windowPositioningOptions.windowPositioningStrategy.y The y coordinate.\n * @param windowPositioningOptions.disableWindowPositioningStrategy Whether to disable the window positioning strategy.\n * @param relatedTo The related monitor or identity or x/y position.\n * @returns The x and y coordinates of the window position.\n */\nexport async function getWindowPositionUsingStrategy(\n\twindowPositioningOptions?: WindowPositioningOptions,\n\trelatedTo?: OpenFin.MonitorDetails | OpenFin.Identity | { x: number; y: number }\n): Promise<{ left: number; top: number } | undefined> {\n\tif (windowPositioningOptions?.disableWindowPositioningStrategy === true) {\n\t\treturn;\n\t}\n\tlet targetMonitor: OpenFin.MonitorDetails | undefined;\n\n\tif (isEmpty(relatedTo)) {\n\t\tconst monitors = await fin.System.getMonitorInfo();\n\t\ttargetMonitor = monitors.primaryMonitor;\n\t} else if (!isEmpty(relatedTo) && \"monitorRect\" in relatedTo) {\n\t\ttargetMonitor = relatedTo;\n\t} else if (!isEmpty(relatedTo) && \"x\" in relatedTo) {\n\t\ttargetMonitor = await findMonitorContainingPoint(relatedTo);\n\t} else {\n\t\tconst bounds = await getIdentityBounds(relatedTo);\n\t\tif (isEmpty(bounds)) {\n\t\t\tconst monitors = await fin.System.getMonitorInfo();\n\t\t\ttargetMonitor = monitors.primaryMonitor;\n\t\t} else {\n\t\t\ttargetMonitor = await findMonitorContainingPoint({ x: bounds.left, y: bounds.top });\n\t\t}\n\t}\n\tconst windowDefaultLeft = windowPositioningOptions?.defaults?.left ?? 0;\n\tconst windowDefaultTop = windowPositioningOptions?.defaults?.top ?? 0;\n\n\t// Get the available rect for the display so we can take in to account\n\t// OS menus, task bar etc\n\tconst availableLeft = targetMonitor.availableRect.left;\n\tconst availableTop = targetMonitor.availableRect.top;\n\tconst windowOffsetsX: number = windowPositioningOptions?.windowPositioningStrategy?.x ?? 30;\n\tconst windowOffsetsY: number = windowPositioningOptions?.windowPositioningStrategy?.y ?? 30;\n\tconst windowOffsetsMaxIncrements: number =\n\t\twindowPositioningOptions?.windowPositioningStrategy?.maxIncrements ?? 8;\n\tconst visibleWindows = await getAllVisibleWindows();\n\t// Get the top left bounds for all the visible windows\n\tconst topLeftBounds = await Promise.all(\n\t\tvisibleWindows.map(async (win) => {\n\t\t\ttry {\n\t\t\t\tconst bounds = await win.getBounds();\n\t\t\t\treturn {\n\t\t\t\t\tleft: bounds.left,\n\t\t\t\t\ttop: bounds.top,\n\t\t\t\t\tright: bounds.left + windowOffsetsX,\n\t\t\t\t\tbottom: bounds.top + windowOffsetsY\n\t\t\t\t};\n\t\t\t} catch {\n\t\t\t\t// return a dummy entry.\n\t\t\t\treturn {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\tbottom: 0\n\t\t\t\t};\n\t\t\t}\n\t\t})\n\t);\n\n\tlet minCountVal: number = 1000;\n\tlet minCountIndex = windowOffsetsMaxIncrements;\n\n\t// Now see how many windows appear in each increment slot\n\tfor (let i = 0; i < windowOffsetsMaxIncrements; i++) {\n\t\tconst xPos = i * windowOffsetsX;\n\t\tconst yPos = i * windowOffsetsY;\n\t\tconst leftPos = windowDefaultLeft + xPos;\n\t\tconst topPos = windowDefaultTop + yPos;\n\t\tconst foundWins = topLeftBounds.filter(\n\t\t\t(topLeftWinBounds) =>\n\t\t\t\ttopLeftWinBounds.left >= leftPos + availableLeft &&\n\t\t\t\ttopLeftWinBounds.right <= leftPos + windowOffsetsX + availableLeft &&\n\t\t\t\ttopLeftWinBounds.top >= topPos + availableTop &&\n\t\t\t\ttopLeftWinBounds.bottom <= topPos + windowOffsetsY + availableTop\n\t\t);\n\t\t// If this slot has less than the current minimum use this slot\n\t\tif (foundWins.length < minCountVal) {\n\t\t\tminCountVal = foundWins.length;\n\t\t\tminCountIndex = i;\n\t\t}\n\t}\n\n\tconst xOffset = minCountIndex * windowOffsetsX;\n\tconst x = windowDefaultLeft + xOffset + availableLeft;\n\tconst yOffset = minCountIndex * windowOffsetsY;\n\tconst y = windowDefaultTop + yOffset + availableTop;\n\n\treturn { left: x, top: y };\n}\n\n/**\n * Get a list of all the visible windows in the platform.\n * @returns The list of visible windows.\n */\nexport async function getAllVisibleWindows(): Promise<OpenFin.Window[]> {\n\tconst platform = fin.Platform.getCurrentSync();\n\tconst windows = await platform.Application.getChildWindows();\n\tconst availableWindows: OpenFin.Window[] = [];\n\tfor (const currentWindow of windows) {\n\t\ttry {\n\t\t\tconst isShowing = await currentWindow.isShowing();\n\t\t\tif (isShowing) {\n\t\t\t\tavailableWindows.push(currentWindow);\n\t\t\t}\n\t\t} catch {\n\t\t\t// if the window is destroyed before determining if it is showing then\n\t\t\t// we should move to the next window but not throw.\n\t\t}\n\t}\n\treturn availableWindows;\n}\n","import type OpenFin from \"@openfin/core\";\nimport type { AppIntent } from \"@openfin/workspace-platform\";\nimport { RESOLVE_ERROR as ResolveError } from \"workspace-platform-starter/fdc3/errors\";\nimport type { PlatformApp } from \"workspace-platform-starter/shapes/app-shapes\";\nimport type {\n\tIntentResolverResponse,\n\tIntentResolverOptions\n} from \"workspace-platform-starter/shapes/interopbroker-shapes\";\nimport type { Logger } from \"workspace-platform-starter/shapes/logger-shapes\";\nimport { formatError, isEmpty } from \"workspace-platform-starter/utils\";\nimport { centerContentInIdentity } from \"workspace-platform-starter/utils-position\";\n\n/**\n * An Intent Resolver Used for resolving intent selection.\n */\nexport class IntentResolverHelper {\n\tprivate readonly _logger: Logger;\n\n\tprivate readonly _intentResolverOptions?: IntentResolverOptions;\n\n\tprivate readonly _unregisteredAppId?: string;\n\n\tprivate readonly _defaultIntentResolverHeight: number;\n\n\tprivate readonly _defaultIntentResolverWidth: number;\n\n\t/**\n\t * Create an instance of the Intent Resolver Helper.\n\t * @param intentResolverOptions options for the helper\n\t * @param logger the logger to use.\n\t * @param unregisteredAppId if you support unregistered apps what Id should they be assigned against.\n\t */\n\tconstructor(intentResolverOptions: IntentResolverOptions, logger: Logger, unregisteredAppId?: string) {\n\t\tthis._defaultIntentResolverHeight = 715;\n\t\tthis._defaultIntentResolverWidth = 665;\n\t\tthis._intentResolverOptions = {\n\t\t\theight: this._defaultIntentResolverHeight,\n\t\t\twidth: this._defaultIntentResolverWidth,\n\t\t\tfdc3InteropApi: \"2.0\",\n\t\t\ttitle: \"Intent Resolver\",\n\t\t\t...intentResolverOptions\n\t\t};\n\t\tthis._logger = logger;\n\t}\n\n\t/**\n\t * Launch the intent resolver.\n\t * @param launchOptions The options for launching the resolver.\n\t * @param launchOptions.apps The apps to pick from.\n\t * @param launchOptions.intent The intent to pick.\n\t * @param launchOptions.intents The intents to pick from.\n\t * @param clientIdentity The client that triggered this request.\n\t * @returns The response from the intent resolver.\n\t */\n\tpublic async launchIntentResolver(\n\t\tlaunchOptions: {\n\t\t\tapps?: PlatformApp[];\n\t\t\tintent?: Partial<AppIntent>;\n\t\t\tintents?: { intent: Partial<AppIntent>; apps: PlatformApp[] }[];\n\t\t},\n\t\tclientIdentity: OpenFin.ClientIdentity\n\t): Promise<IntentResolverResponse> {\n\t\t// launch a new window and optionally pass the available intents as customData.apps as part of the window\n\t\t// options the window can then use raiseIntent against a specific app (the selected one). this logic runs in\n\t\t// the provider so we are using it as a way of determining the root (so it works with root hosting and\n\t\t// subdirectory based hosting if a url is not provided)\n\t\ttry {\n\t\t\tconst position = await centerContentInIdentity(clientIdentity, {\n\t\t\t\theight: this._intentResolverOptions?.height ?? this._defaultIntentResolverHeight,\n\t\t\t\twidth: this._intentResolverOptions?.width ?? this._defaultIntentResolverWidth\n\t\t\t});\n\n\t\t\tconst winOption: OpenFin.WindowCreationOptions = {\n\t\t\t\tname: \"intent-picker\",\n\t\t\t\tincludeInSnapshots: false,\n\t\t\t\tfdc3InteropApi: this._intentResolverOptions?.fdc3InteropApi,\n\t\t\t\tdefaultWidth: this._intentResolverOptions?.width,\n\t\t\t\tdefaultHeight: this._intentResolverOptions?.height,\n\t\t\t\tshowTaskbarIcon: false,\n\t\t\t\tsaveWindowState: false,\n\t\t\t\tcustomData: {\n\t\t\t\t\ttitle: this._intentResolverOptions?.title,\n\t\t\t\t\tapps: launchOptions.apps,\n\t\t\t\t\tintent: launchOptions.intent,\n\t\t\t\t\tintents: launchOptions.intents,\n\t\t\t\t\tunregisteredAppId: this._unregisteredAppId\n\t\t\t\t},\n\t\t\t\turl: this._intentResolverOptions?.url,\n\t\t\t\tframe: false,\n\t\t\t\tautoShow: true,\n\t\t\t\talwaysOnTop: true\n\t\t\t};\n\t\t\tif (!isEmpty(position)) {\n\t\t\t\twinOption.defaultLeft = position.x;\n\t\t\t\twinOption.defaultTop = position.y;\n\t\t\t} else {\n\t\t\t\twinOption.defaultCentered = true;\n\t\t\t}\n\n\t\t\tconst win = await fin.Window.create(winOption);\n\t\t\tconst webWindow = win.getWebWindow();\n\t\t\tconst webWindowResolver = webWindow as unknown as {\n\t\t\t\tgetIntentSelection: () => Promise<IntentResolverResponse>;\n\t\t\t};\n\t\t\tconst selectedAppId: IntentResolverResponse = await webWindowResolver.getIntentSelection();\n\t\t\treturn selectedAppId;\n\t\t} catch (error) {\n\t\t\tconst message = formatError(error);\n\n\t\t\tif (message?.includes(ResolveError.UserCancelled)) {\n\t\t\t\tthis._logger.info(\"App for intent not selected/launched by user\", launchOptions.intent);\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t\tthis._logger.error(\"Unexpected error from intent picker/resolver for intent\", launchOptions.intent);\n\t\t\tthrow new Error(ResolveError.ResolverUnavailable);\n\t\t}\n\t}\n}\n","import type { ModuleImplementation, ModuleTypes } from \"workspace-platform-starter/shapes/module-shapes\";\nimport { WpsInteropOverride } from \"./interop-override\";\n\n/**\n * Define the entry points for the module.\n */\nexport const entryPoints: { [type in ModuleTypes]?: ModuleImplementation } = {\n\tinteropOverride: new WpsInteropOverride()\n};\n","// eslint-disable-next-line max-classes-per-file\nimport type OpenFin from \"@openfin/core\";\nimport type {\n\tPlatformInteropOverride,\n\tPlatformInteropOverrideOptions,\n\tPlatformInteropBrokerHelpers\n} from \"workspace-platform-starter/shapes/interopbroker-shapes\";\nimport type { Logger, LoggerCreator } from \"workspace-platform-starter/shapes/logger-shapes\";\nimport type { ModuleDefinition } from \"workspace-platform-starter/shapes/module-shapes\";\nimport { getConstructorOverride as wpsConstructorOverride } from \"./broker/wps-interop-override\";\nimport type { WpsInteropOverrideOptions } from \"./shapes\";\n/**\n * Implementation for the wps interop override interop override.\n */\nexport class WpsInteropOverride implements PlatformInteropOverride<WpsInteropOverrideOptions> {\n\t/**\n\t * The module definition including settings.\n\t * @internal\n\t */\n\tprivate _definition: ModuleDefinition<WpsInteropOverrideOptions> | undefined;\n\n\t/**\n\t * The logger for displaying information from the module.\n\t * @internal\n\t */\n\tprivate _logger?: Logger;\n\n\t/**\n\t * Helper methods for the module.\n\t * @internal\n\t */\n\tprivate _helpers: PlatformInteropBrokerHelpers | undefined;\n\n\t/**\n\t * Initialize the module.\n\t * @param definition The definition of the module from configuration include custom options.\n\t * @param loggerCreator For logging entries.\n\t * @param helpers Helper methods for the module to interact with the application core.\n\t * @returns Nothing.\n\t */\n\tpublic async initialize(\n\t\tdefinition: ModuleDefinition<WpsInteropOverrideOptions>,\n\t\tloggerCreator: LoggerCreator,\n\t\thelpers: PlatformInteropBrokerHelpers\n\t): Promise<void> {\n\t\tthis._definition = definition;\n\t\tconst loggerName = definition.data?.loggerName ?? \"WpsInteropOverride\";\n\t\tthis._logger = loggerCreator(loggerName);\n\t\tthis._helpers = helpers;\n\n\t\tthis._logger.info(\"Initializing\");\n\t}\n\n\t/**\n\t * Close down any resources being used by the module.\n\t * @returns Nothing.\n\t */\n\tpublic async closedown(): Promise<void> {\n\t\tthis._logger?.info(\"Closedown\");\n\t}\n\n\t/**\n\t * Get the override constructor for the interop broker (useful if you wish this implementation to be layered with other implementations and passed to the platform's initialization object as part of an array).\n\t * @param options The options for the interop broker defined as part of the platform.\n\t * @returns The override constructor to be used in an array.\n\t */\n\tpublic async getConstructorOverride(\n\t\toptions: PlatformInteropOverrideOptions\n\t): Promise<OpenFin.ConstructorOverride<OpenFin.InteropBroker>> {\n\t\tif (!this._helpers || !this._logger) {\n\t\t\tthrow new Error(\"Module not initialized\");\n\t\t}\n\t\treturn wpsConstructorOverride(options, this._logger, this._helpers);\n\t}\n}\n","import type {\n\tAppIdentifier,\n\tAppMetadata,\n\tImplementationMetadata,\n\tIntentResolution,\n\tContextMetadata\n} from \"@finos/fdc3\";\nimport type OpenFin from \"@openfin/core\";\n\nimport { mapToAppMetaData as mapTo12AppMetaData } from \"workspace-platform-starter/fdc3/1.2/mapper\";\nimport { mapToAppMetaData as mapTo20AppMetaData } from \"workspace-platform-starter/fdc3/2.0/mapper\";\nimport {\n\tOPEN_ERROR as OpenError,\n\tRESOLVE_ERROR as ResolveError\n} from \"workspace-platform-starter/fdc3/errors\";\nimport { MANIFEST_TYPES } from \"workspace-platform-starter/manifest-types\";\nimport type { ConnectionClient, EndpointClient } from \"workspace-platform-starter/shapes\";\nimport type {\n\tAppsForIntent,\n\tPlatformApp,\n\tPlatformAppIdentifier\n} from \"workspace-platform-starter/shapes/app-shapes\";\nimport type { AppMetadata as AppMetadataV1Point2 } from \"workspace-platform-starter/shapes/fdc3-1-2-shapes\";\nimport type {\n\tApiMetadata,\n\tCaptureApiPayload,\n\tContextToProcess,\n\tOpenOptions,\n\tIntentResolverResponse,\n\tIntentRegistrationPayload,\n\tIntentTargetMetaData,\n\tProcessedContext,\n\tPlatformInteropOverrideOptions,\n\tPlatformInteropBrokerHelpers,\n\tContextOptions,\n\tGetInfoOptions\n} from \"workspace-platform-starter/shapes/interopbroker-shapes\";\nimport type { Logger } from \"workspace-platform-starter/shapes/logger-shapes\";\nimport {\n\tformatError,\n\tisEmpty,\n\tisString,\n\tisStringValue,\n\trandomUUID,\n\tsanitizeString\n} from \"workspace-platform-starter/utils\";\nimport { AppIdHelper } from \"./app-id-helper\";\nimport { AppIntentHelper } from \"./app-intent-helper\";\nimport { getAppsMetaData } from \"./app-meta-data-helper\";\nimport { ClientRegistrationHelper } from \"./client-registration-helper\";\nimport { IntentResolverHelper } from \"./intent-resolver-helper\";\n\n/**\n * Get the override constructor for the interop broker (useful if you wish this implementation to be layered with other implementations and passed to the platform's initialization object as part of an array).\n * @param options The options for the interop broker defined as part of the platform.\n * @param logger The logger to use.\n * @param helpers A collection of helper methods.\n * @returns The override constructor to be used in an array.\n */\nexport async function getConstructorOverride(\n\toptions: PlatformInteropOverrideOptions,\n\tlogger: Logger,\n\thelpers: PlatformInteropBrokerHelpers\n): Promise<OpenFin.ConstructorOverride<OpenFin.InteropBroker>> {\n\tif (!helpers?.getApp || !helpers?.getApps || !helpers.launchApp) {\n\t\tthrow new Error(\n\t\t\t\"Interop Broker Constructor is missing required helpers. The broker will not function correctly so this error is to flag the issue.\"\n\t\t);\n\t}\n\tconst getApp = helpers.getApp;\n\tconst getApps = helpers.getApps;\n\tlet endpointClient: EndpointClient | undefined;\n\tif (helpers?.getEndpointClient) {\n\t\tendpointClient = await helpers?.getEndpointClient();\n\t}\n\tconst launch = helpers.launchApp;\n\n\tlet connectionsClient: ConnectionClient | undefined;\n\n\tif (helpers?.getConnectionClient) {\n\t\tconnectionsClient = await helpers.getConnectionClient();\n\t}\n\n\treturn (Base: OpenFin.Constructor<OpenFin.InteropBroker>) =>\n\t\t/**\n\t\t * Extend the InteropBroker to handle intents.\n\t\t */\n\t\tclass InteropOverride extends Base {\n\t\t\tprivate readonly _openOptions?: OpenOptions;\n\n\t\t\tprivate readonly _unregisteredApp: PlatformApp | undefined;\n\n\t\t\tprivate readonly _appIntentHelper: AppIntentHelper;\n\n\t\t\tprivate readonly _clientRegistrationHelper: ClientRegistrationHelper;\n\n\t\t\tprivate readonly _intentResolverHelper?: IntentResolverHelper;\n\n\t\t\tprivate readonly _metadataKey: Readonly<string>;\n\n\t\t\tprivate readonly _appIdHelper: AppIdHelper;\n\n\t\t\tprivate readonly _contextOptions?: ContextOptions;\n\n\t\t\tprivate readonly _getInfoOptions?: GetInfoOptions;\n\n\t\t\t/**\n\t\t\t * Create a new instance of InteropBroker.\n\t\t\t */\n\t\t\tconstructor() {\n\t\t\t\tsuper();\n\t\t\t\tlogger.info(\"Interop Broker Constructor applying settings.\");\n\t\t\t\tthis._appIntentHelper = new AppIntentHelper(getApps, logger);\n\t\t\t\tthis._metadataKey = `_metadata_${randomUUID()}`;\n\t\t\t\tif (options.intentResolver) {\n\t\t\t\t\tthis._intentResolverHelper = new IntentResolverHelper(\n\t\t\t\t\t\toptions.intentResolver,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\toptions?.unregisteredApp?.appId\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis._openOptions = options?.openOptions;\n\t\t\t\tthis._unregisteredApp = options?.unregisteredApp;\n\t\t\t\tthis._contextOptions = options?.contextOptions;\n\t\t\t\tthis._getInfoOptions = options?.getInfoOptions;\n\n\t\t\t\tif (!isEmpty(this._unregisteredApp)) {\n\t\t\t\t\tthis._unregisteredApp.manifestType = MANIFEST_TYPES.UnregisteredApp.id;\n\t\t\t\t}\n\t\t\t\tthis._appIdHelper = new AppIdHelper(getApp, fin.me.identity.uuid, logger, this._unregisteredApp);\n\t\t\t\tthis._clientRegistrationHelper = new ClientRegistrationHelper(\n\t\t\t\t\tasync (clientIdentity: OpenFin.ClientIdentity) => this._appIdHelper.lookupAppId(clientIdentity),\n\t\t\t\t\tlogger\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Is the connection authorized.\n\t\t\t * @param id The id of the client identity to check.\n\t\t\t * @param payload The payload to send with the authorization check.\n\t\t\t * @returns True if the connection is authorized.\n\t\t\t */\n\t\t\tpublic async isConnectionAuthorized(id: OpenFin.ClientIdentity, payload?: unknown): Promise<boolean> {\n\t\t\t\tlogger.info(\n\t\t\t\t\t\"Interop connection being made by the following identity. About to verify connection\",\n\t\t\t\t\tid\n\t\t\t\t);\n\t\t\t\tconst apiPayload: CaptureApiPayload = payload as CaptureApiPayload;\n\t\t\t\tif (!isEmpty(connectionsClient)) {\n\t\t\t\t\tconst response = await connectionsClient.isConnectionValid(id, payload, { type: \"broker\" });\n\t\t\t\t\tif (response.isValid) {\n\t\t\t\t\t\tlogger.info(\"Connection validation request was validated and is valid.\");\n\t\t\t\t\t\tawait this._clientRegistrationHelper.clientConnectionRegistered(id, apiPayload);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.warn(`Connection request from ${JSON.stringify(id)} was validated and rejected.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn response.isValid;\n\t\t\t\t}\n\t\t\t\t// we have not been provided with a means to validate the connection so fallback to default behavior and register the connection\n\t\t\t\tconst isValid = await super.isConnectionAuthorized(id, payload);\n\t\t\t\tif (isValid) {\n\t\t\t\t\tawait this._clientRegistrationHelper.clientConnectionRegistered(id, apiPayload);\n\t\t\t\t}\n\t\t\t\treturn isValid;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Sets a context for the context group of the incoming current entity.\n\t\t\t * @param sentContext New context to set.\n\t\t\t * @param sentContext.context The context to send.\n\t\t\t * @param clientIdentity Identity of the client sender.\n\t\t\t */\n\t\t\tpublic async setContext(\n\t\t\t\tsentContext: { context: OpenFin.Context },\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<void> {\n\t\t\t\tsentContext.context = await this.processContext(sentContext.context);\n\t\t\t\tconst contextMetadata = await this.getContextMetadata(clientIdentity);\n\n\t\t\t\tsentContext.context = {\n\t\t\t\t\t...sentContext.context,\n\t\t\t\t\t[this._metadataKey]: contextMetadata\n\t\t\t\t} as unknown as OpenFin.Context;\n\t\t\t\tsuper.setContext(sentContext, clientIdentity);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Invokes the context handler.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @param handlerId The handler ID.\n\t\t\t * @param context The context to invoke.\n\t\t\t * @returns A promise that resolves when the context handler is invoked.\n\t\t\t */\n\t\t\tpublic async invokeContextHandler(\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity,\n\t\t\t\thandlerId: string,\n\t\t\t\tcontext: OpenFin.Context\n\t\t\t): Promise<void> {\n\t\t\t\tconst passedContext: { [key: string]: unknown } = { ...context };\n\t\t\t\tconst contextMetadata = passedContext[this._metadataKey] as ContextMetadata;\n\t\t\t\tif (!isEmpty(contextMetadata)) {\n\t\t\t\t\tdelete passedContext[this._metadataKey];\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tthis._contextOptions?.includeOriginator === false &&\n\t\t\t\t\tcontextMetadata?.source.instanceId === clientIdentity.endpointId\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn super.invokeContextHandler(clientIdentity, handlerId, {\n\t\t\t\t\t...passedContext,\n\t\t\t\t\tcontextMetadata\n\t\t\t\t} as unknown as OpenFin.Context);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle the information for intents by context.\n\t\t\t * @param contextOptions The context options.\n\t\t\t * @param clientIdentity The client.\n\t\t\t * @returns The intents mapped to app metadata.\n\t\t\t */\n\t\t\tpublic async handleInfoForIntentsByContext(\n\t\t\t\tcontextOptions: OpenFin.Context | OpenFin.FindIntentsByContextOptions,\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<\n\t\t\t\t{\n\t\t\t\t\tintent: { name: string; displayName?: string };\n\t\t\t\t\tapps: (AppMetadataV1Point2 | AppMetadata)[];\n\t\t\t\t}[]\n\t\t\t> {\n\t\t\t\tlet requestedContextType: string;\n\t\t\t\tlet requestedResultType: string | undefined;\n\t\t\t\tlet request: { context: { type: string }; metadata: { resultType: string } };\n\t\t\t\tconst apiVersion: ApiMetadata | undefined =\n\t\t\t\t\tthis._clientRegistrationHelper.getApiVersion(clientIdentity);\n\n\t\t\t\tif (\"type\" in contextOptions) {\n\t\t\t\t\trequestedContextType = contextOptions.type;\n\t\t\t\t} else {\n\t\t\t\t\trequest = contextOptions as { context: { type: string }; metadata: { resultType: string } };\n\t\t\t\t\trequestedContextType = request.context.type;\n\t\t\t\t\trequestedResultType = request.metadata.resultType;\n\t\t\t\t}\n\t\t\t\tconst intents = await this._appIntentHelper.getIntentsByContext(\n\t\t\t\t\trequestedContextType,\n\t\t\t\t\trequestedResultType\n\t\t\t\t);\n\n\t\t\t\tif (intents.length === 0) {\n\t\t\t\t\tthrow new Error(ResolveError.NoAppsFound);\n\t\t\t\t}\n\n\t\t\t\tconst mappedIntents: {\n\t\t\t\t\tintent: { name: string; displayName?: string };\n\t\t\t\t\tapps: (AppMetadataV1Point2 | AppMetadata)[];\n\t\t\t\t}[] = [];\n\n\t\t\t\tfor (const entry of intents) {\n\t\t\t\t\tconst appMetaData = await getAppsMetaData(\n\t\t\t\t\t\tentry.apps,\n\t\t\t\t\t\tapiVersion?.version ?? \"2.0\",\n\t\t\t\t\t\tmapTo12AppMetaData,\n\t\t\t\t\t\tmapTo20AppMetaData,\n\t\t\t\t\t\tasync (appId: string) =>\n\t\t\t\t\t\t\tthis._clientRegistrationHelper.findAppInstances({ appId }, clientIdentity, \"intent\")\n\t\t\t\t\t);\n\t\t\t\t\tmappedIntents.push({ intent: entry.intent, apps: appMetaData });\n\t\t\t\t}\n\n\t\t\t\treturn mappedIntents;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle the information for and intent.\n\t\t\t * @param intentOptions The intent options.\n\t\t\t * @param clientIdentity The client.\n\t\t\t * @returns The intents mapped to app metadata.\n\t\t\t */\n\t\t\tpublic async handleInfoForIntent(\n\t\t\t\tintentOptions: OpenFin.InfoForIntentOptions,\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<{\n\t\t\t\tintent: { name: string; displayName?: string };\n\t\t\t\tapps: (AppMetadataV1Point2 | AppMetadata)[];\n\t\t\t}> {\n\t\t\t\tconst apiVersion: ApiMetadata | undefined =\n\t\t\t\t\tthis._clientRegistrationHelper.getApiVersion(clientIdentity);\n\t\t\t\tlet contextType: string | undefined;\n\n\t\t\t\tconst optContextType = intentOptions?.context?.type;\n\t\t\t\tif (!isEmpty(optContextType) && optContextType !== \"fdc3.nothing\") {\n\t\t\t\t\tcontextType = optContextType;\n\t\t\t\t}\n\n\t\t\t\tconst result = await this._appIntentHelper.getIntent(\n\t\t\t\t\tintentOptions.name,\n\t\t\t\t\tcontextType,\n\t\t\t\t\tintentOptions?.metadata?.resultType\n\t\t\t\t);\n\t\t\t\tif (isEmpty(result)) {\n\t\t\t\t\tthrow new Error(ResolveError.NoAppsFound);\n\t\t\t\t}\n\t\t\t\tconst response = {\n\t\t\t\t\tintent: result.intent,\n\t\t\t\t\tapps: await getAppsMetaData(\n\t\t\t\t\t\tresult.apps,\n\t\t\t\t\t\tapiVersion?.version ?? \"2.0\",\n\t\t\t\t\t\tmapTo12AppMetaData,\n\t\t\t\t\t\tmapTo20AppMetaData,\n\t\t\t\t\t\tasync (appId: string) =>\n\t\t\t\t\t\t\tthis._clientRegistrationHelper.findAppInstances({ appId }, clientIdentity, \"intent\")\n\t\t\t\t\t)\n\t\t\t\t};\n\n\t\t\t\treturn response;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle the fired intent for context.\n\t\t\t * @param contextForIntent The context for the intent.\n\t\t\t * @param contextForIntent.type The type of the intent.\n\t\t\t * @param contextForIntent.metadata The metadata for the intent.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @returns The intent resolution.\n\t\t\t */\n\t\t\tpublic async handleFiredIntentForContext(\n\t\t\t\tcontextForIntent: { type: string; metadata?: OpenFin.IntentMetadata<IntentTargetMetaData> },\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<Omit<IntentResolution, \"getResult\"> | { source: string; version?: string }> {\n\t\t\t\tconst targetAppIdentifier = this.getApplicationIdentity(contextForIntent.metadata);\n\t\t\t\tconst usesAppIdentity = this.usesApplicationIdentity(clientIdentity);\n\t\t\t\tconst intent: Partial<OpenFin.Intent & { displayName?: string }> = {\n\t\t\t\t\tcontext: contextForIntent\n\t\t\t\t};\n\n\t\t\t\tconst intentsForSelection: AppsForIntent[] = await this._appIntentHelper.getIntentsByContext(\n\t\t\t\t\tcontextForIntent.type\n\t\t\t\t);\n\n\t\t\t\t// app specified flow\n\t\t\t\tif (!isEmpty(targetAppIdentifier)) {\n\t\t\t\t\tconst targetApp = await getApp(targetAppIdentifier.appId);\n\n\t\t\t\t\tif (isEmpty(targetApp)) {\n\t\t\t\t\t\tthrow new Error(ResolveError.TargetAppUnavailable);\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\t!targetApp?.interop?.intents?.listensFor ||\n\t\t\t\t\t\t!Object.values(targetApp.interop.intents.listensFor).some((listenedForIntent) =>\n\t\t\t\t\t\t\tlistenedForIntent.contexts.includes(contextForIntent.type)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthrow new Error(ResolveError.NoAppsFound);\n\t\t\t\t\t}\n\t\t\t\t\tconst intentResolver = await this.handleTargetedIntent(\n\t\t\t\t\t\ttargetAppIdentifier,\n\t\t\t\t\t\tintent as OpenFin.Intent,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t);\n\t\t\t\t\treturn this.shapeIntentResolver(intentResolver, usesAppIdentity);\n\t\t\t\t}\n\n\t\t\t\t// check for unregistered app intent handlers (if enabled)\n\t\t\t\tconst unregisteredAppIntents = await this.getUnregisteredAppIntentByContext(\n\t\t\t\t\tcontextForIntent.type,\n\t\t\t\t\tclientIdentity\n\t\t\t\t);\n\n\t\t\t\tif (unregisteredAppIntents.length > 0 && !isEmpty(this._unregisteredApp)) {\n\t\t\t\t\tconst matchedIntents: string[] = [];\n\t\t\t\t\tfor (const intentForSelection of intentsForSelection) {\n\t\t\t\t\t\tif (unregisteredAppIntents.includes(intentForSelection.intent.name)) {\n\t\t\t\t\t\t\tintentForSelection.apps.push(this._unregisteredApp);\n\t\t\t\t\t\t\tmatchedIntents.push(intentForSelection.intent.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst missingIntentMatches = unregisteredAppIntents.filter(\n\t\t\t\t\t\t(intentName) => !matchedIntents.includes(intentName)\n\t\t\t\t\t);\n\n\t\t\t\t\tfor (const missingIntentMatch of missingIntentMatches) {\n\t\t\t\t\t\tconst missingIntent = this._unregisteredApp.intents?.find(\n\t\t\t\t\t\t\t(entry) => entry.name === missingIntentMatch\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (missingIntent) {\n\t\t\t\t\t\t\tintentsForSelection.push({\n\t\t\t\t\t\t\t\tintent: { name: missingIntent.name, displayName: missingIntent.displayName },\n\t\t\t\t\t\t\t\tapps: [this._unregisteredApp]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet userSelection: IntentResolverResponse | undefined;\n\n\t\t\t\tif (intentsForSelection.length === 1) {\n\t\t\t\t\tconst intentForSelection = intentsForSelection[0];\n\t\t\t\t\t// only one intent matches the passed context\n\t\t\t\t\tintent.name = intentForSelection.intent.name;\n\t\t\t\t\tintent.displayName = intentForSelection.intent.displayName;\n\n\t\t\t\t\tif (intentForSelection.apps.length === 1) {\n\t\t\t\t\t\tconst appInstances = await this._clientRegistrationHelper.findAppInstances(\n\t\t\t\t\t\t\tintentForSelection.apps[0],\n\t\t\t\t\t\t\tclientIdentity,\n\t\t\t\t\t\t\t\"intent\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// if there are no instances launch a new one otherwise present the choice to the user\n\t\t\t\t\t\t// by falling through to the next code block\n\t\t\t\t\t\tif (appInstances.length === 0 || this.createNewInstance(intentForSelection.apps[0])) {\n\t\t\t\t\t\t\tconst intentResolver = await this.launchAppWithIntent(\n\t\t\t\t\t\t\t\tintentForSelection.apps[0],\n\t\t\t\t\t\t\t\tintent as OpenFin.Intent,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (isEmpty(intentResolver)) {\n\t\t\t\t\t\t\t\tthrow new Error(ResolveError.NoAppsFound);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn this.shapeIntentResolver(intentResolver, usesAppIdentity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tuserSelection = await this._intentResolverHelper?.launchIntentResolver(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tapps: intentsForSelection[0].apps,\n\t\t\t\t\t\t\tintent\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tuserSelection = await this._intentResolverHelper?.launchIntentResolver(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tintent,\n\t\t\t\t\t\t\tintents: intentsForSelection\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// update intent with user selection\n\t\t\t\tif (isEmpty(userSelection)) {\n\t\t\t\t\tthrow new Error(ResolveError.ResolverUnavailable);\n\t\t\t\t}\n\t\t\t\tintent.displayName = userSelection.intent.displayName;\n\t\t\t\tintent.name = userSelection.intent.name;\n\t\t\t\tconst intentResolver = await this.handleIntentPickerSelection(\n\t\t\t\t\tuserSelection,\n\t\t\t\t\tintent as OpenFin.Intent,\n\t\t\t\t\tclientIdentity\n\t\t\t\t);\n\t\t\t\treturn this.shapeIntentResolver(intentResolver, usesAppIdentity);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle a fired intent.\n\t\t\t * @param intent The intent to handle.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @returns The intent resolution.\n\t\t\t */\n\t\t\tpublic async handleFiredIntent(\n\t\t\t\tintent: OpenFin.Intent<OpenFin.IntentMetadata<IntentTargetMetaData>>,\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<Omit<IntentResolution, \"getResult\"> | { source: string; version?: string }> {\n\t\t\t\tlogger.info(\"Received request for a raised intent\", intent);\n\t\t\t\tconst targetAppIdentifier = this.getApplicationIdentity(intent.metadata);\n\t\t\t\tconst usesAppIdentifier = this.usesApplicationIdentity(clientIdentity);\n\n\t\t\t\tconst matchedIntents = await this._appIntentHelper.getIntent(intent.name, intent?.context?.type);\n\t\t\t\tconst intentApps: PlatformApp[] = [];\n\n\t\t\t\tif (!isEmpty(matchedIntents)) {\n\t\t\t\t\tintentApps.push(...matchedIntents.apps);\n\t\t\t\t}\n\t\t\t\tif (!isEmpty(targetAppIdentifier)) {\n\t\t\t\t\tconst targetApp = await getApp(targetAppIdentifier.appId);\n\t\t\t\t\tif (isEmpty(targetApp)) {\n\t\t\t\t\t\tthrow new Error(ResolveError.TargetAppUnavailable);\n\t\t\t\t\t}\n\t\t\t\t\t// ensure that the specified app is one of the intent apps\n\t\t\t\t\tif (!intentApps.some((app) => app.appId === targetAppIdentifier.appId)) {\n\t\t\t\t\t\tthrow new Error(ResolveError.NoAppsFound);\n\t\t\t\t\t}\n\t\t\t\t\tconst intentResolver = await this.handleTargetedIntent(\n\t\t\t\t\t\ttargetAppIdentifier,\n\t\t\t\t\t\tintent,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t);\n\t\t\t\t\treturn this.shapeIntentResolver(intentResolver, usesAppIdentifier);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tthis._unregisteredApp &&\n\t\t\t\t\t(await this.canAddUnregisteredApp(clientIdentity, intent.name, intent?.context?.type))\n\t\t\t\t) {\n\t\t\t\t\t// We have unregistered app instances that support this intent and support for unregistered instances is enabled\n\t\t\t\t\tintentApps.push(this._unregisteredApp);\n\t\t\t\t}\n\n\t\t\t\tif (intentApps.length === 0) {\n\t\t\t\t\tlogger.info(\"No apps support this intent\");\n\t\t\t\t\tthrow new Error(ResolveError.NoAppsFound);\n\t\t\t\t}\n\n\t\t\t\tif (intentApps.length === 1) {\n\t\t\t\t\t// handle single entry\n\t\t\t\t\tconst appInstances = await this._clientRegistrationHelper.findAppInstances(\n\t\t\t\t\t\tintentApps[0],\n\t\t\t\t\t\tclientIdentity,\n\t\t\t\t\t\t\"intent\"\n\t\t\t\t\t);\n\t\t\t\t\t// if there are no instances launch a new one otherwise present the choice to the user\n\t\t\t\t\t// by falling through to the next code block\n\t\t\t\t\tlet appInstanceId: string | undefined;\n\t\t\t\t\tif (appInstances.length === 1) {\n\t\t\t\t\t\tappInstanceId = appInstances[0].instanceId;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tappInstances.length === 0 ||\n\t\t\t\t\t\tthis.useSingleInstance(intentApps[0]) ||\n\t\t\t\t\t\tthis.createNewInstance(intentApps[0])\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst intentResolver = await this.launchAppWithIntent(\n\t\t\t\t\t\t\tintentApps[0],\n\t\t\t\t\t\t\tintent,\n\t\t\t\t\t\t\tappInstanceId,\n\t\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (isEmpty(intentResolver)) {\n\t\t\t\t\t\t\tthrow new Error(ResolveError.NoAppsFound);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this.shapeIntentResolver(intentResolver, usesAppIdentifier);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst userSelection = await this._intentResolverHelper?.launchIntentResolver(\n\t\t\t\t\t{\n\t\t\t\t\t\tapps: intentApps,\n\t\t\t\t\t\tintent\n\t\t\t\t\t},\n\t\t\t\t\tclientIdentity\n\t\t\t\t);\n\n\t\t\t\tif (isEmpty(userSelection)) {\n\t\t\t\t\tthrow new Error(ResolveError.ResolverUnavailable);\n\t\t\t\t}\n\n\t\t\t\tconst intentResolver = await this.handleIntentPickerSelection(userSelection, intent, clientIdentity);\n\t\t\t\treturn this.shapeIntentResolver(intentResolver, usesAppIdentifier);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Invoke the intent handler.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @param handlerId The handler ID.\n\t\t\t * @param intent The intent to invoke.\n\t\t\t * @returns A promise that resolves when the intent handler is invoked.\n\t\t\t */\n\t\t\tpublic async invokeIntentHandler(\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity,\n\t\t\t\thandlerId: string,\n\t\t\t\tintent: OpenFin.Intent\n\t\t\t): Promise<void> {\n\t\t\t\tconst { context } = intent;\n\t\t\t\tlet contextMetadata: ContextMetadata | undefined;\n\t\t\t\tlet passedContext: { [key: string]: unknown } | undefined;\n\t\t\t\tif (!isEmpty(context)) {\n\t\t\t\t\tpassedContext = { ...context };\n\t\t\t\t\tcontextMetadata = passedContext[this._metadataKey] as ContextMetadata;\n\t\t\t\t\tif (!isEmpty(contextMetadata)) {\n\t\t\t\t\t\tdelete passedContext[this._metadataKey];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn super.invokeIntentHandler(clientIdentity, handlerId, {\n\t\t\t\t\t...intent,\n\t\t\t\t\tcontext: {\n\t\t\t\t\t\t...passedContext,\n\t\t\t\t\t\tcontextMetadata\n\t\t\t\t\t} as unknown as OpenFin.Context\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle the FDC3 open.\n\t\t\t * @param fdc3OpenOptions The options for the open.\n\t\t\t * @param fdc3OpenOptions.app The platform app or its id.\n\t\t\t * @param fdc3OpenOptions.context The context being opened.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @returns The application identifier.\n\t\t\t */\n\t\t\tpublic async fdc3HandleOpen(\n\t\t\t\tfdc3OpenOptions: { app: (PlatformApp & AppIdentifier) | string; context: OpenFin.Context },\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<AppIdentifier> {\n\t\t\t\tif (isEmpty(fdc3OpenOptions?.app)) {\n\t\t\t\t\tlogger.error(\"A request to fdc3.open did not pass an fdc3OpenOptions object\");\n\t\t\t\t\tthrow new Error(ResolveError.NoAppsFound);\n\t\t\t\t}\n\n\t\t\t\tlogger.info(\n\t\t\t\t\t`A request to Open has been sent to the platform by uuid: ${clientIdentity?.uuid}, name: ${clientIdentity?.name}, endpointId: ${clientIdentity.endpointId} with passed context:`,\n\t\t\t\t\tfdc3OpenOptions.context\n\t\t\t\t);\n\t\t\t\ttry {\n\t\t\t\t\tlet requestedId: string;\n\t\t\t\t\tlet instanceId: string | undefined;\n\t\t\t\t\tlet platformIdentities: PlatformAppIdentifier[] | undefined;\n\t\t\t\t\tlet focusApp = false;\n\t\t\t\t\tlet appId: string | undefined;\n\n\t\t\t\t\tif (isString(fdc3OpenOptions.app)) {\n\t\t\t\t\t\trequestedId = fdc3OpenOptions.app;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trequestedId = fdc3OpenOptions.app.appId ?? fdc3OpenOptions.app.name;\n\t\t\t\t\t\tinstanceId = fdc3OpenOptions.app.instanceId;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst requestedApp = await getApp(requestedId);\n\t\t\t\t\tif (isEmpty(requestedApp)) {\n\t\t\t\t\t\tthrow new Error(OpenError.AppNotFound);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!isEmpty(instanceId)) {\n\t\t\t\t\t\t// an instance of an application was selected now look up the uuid and name\n\t\t\t\t\t\tconst allConnectedClients = await this.getAllClientInfo();\n\t\t\t\t\t\tconst clientInfo = allConnectedClients.find(\n\t\t\t\t\t\t\t(connectedClient) => connectedClient.endpointId === instanceId\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!isEmpty(clientInfo)) {\n\t\t\t\t\t\t\tlogger.info(`App Id: ${requestedId} and instance Id: ${instanceId} was provided and found.`);\n\t\t\t\t\t\t\t// the connected instance is available\n\t\t\t\t\t\t\tplatformIdentities = [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuuid: clientInfo.uuid,\n\t\t\t\t\t\t\t\t\tname: clientInfo.name,\n\t\t\t\t\t\t\t\t\tappId: requestedId,\n\t\t\t\t\t\t\t\t\tinstanceId\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error(ResolveError.TargetInstanceUnavailable);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst isOpenByIntent = this._openOptions?.openStrategy === \"intent\";\n\n\t\t\t\t\tif (isOpenByIntent) {\n\t\t\t\t\t\tconst openAppIntent: OpenFin.Intent = {\n\t\t\t\t\t\t\tcontext: fdc3OpenOptions.context,\n\t\t\t\t\t\t\tname: \"OpenApp\",\n\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\ttarget: { appId: requestedId }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst result = await this.launchAppWithIntent(\n\t\t\t\t\t\t\trequestedApp,\n\t\t\t\t\t\t\topenAppIntent,\n\t\t\t\t\t\t\tinstanceId,\n\t\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (isString(result.source)) {\n\t\t\t\t\t\t\tappId = result.source;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tappId = result.source.appId;\n\t\t\t\t\t\t\tinstanceId = result.source.instanceId;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (isEmpty(platformIdentities)) {\n\t\t\t\t\t\t\tplatformIdentities = await launch(requestedApp?.appId, undefined, clientIdentity);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfocusApp = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!isEmpty(platformIdentities) && platformIdentities?.length > 0) {\n\t\t\t\t\t\t\tappId = platformIdentities[0].appId;\n\t\t\t\t\t\t\tlet multiInstance = true;\n\t\t\t\t\t\t\tif (platformIdentities.length === 1) {\n\t\t\t\t\t\t\t\tmultiInstance = false;\n\t\t\t\t\t\t\t\t// if there is only one instance then we can wait for it to be ready and return\n\t\t\t\t\t\t\t\t// an instance id. Otherwise there will be multiple instances and just returning the\n\t\t\t\t\t\t\t\t// first in the list may not be correct.\n\t\t\t\t\t\t\t\tconst openTimeout: number | undefined = this._openOptions?.connectionTimeout;\n\t\t\t\t\t\t\t\t// if we have a snapshot and multiple identities we will not wait as not all of them might not support intents.\n\t\t\t\t\t\t\t\tinstanceId = await this._clientRegistrationHelper.onConnectionClientReady(\n\t\t\t\t\t\t\t\t\tplatformIdentities[0],\n\t\t\t\t\t\t\t\t\topenTimeout\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\t\t`Multiple instances of the app ${appId} have been launched. We are assuming this is a composite app/snapshot. We are not returning an instance id as you can only return one and a composite app will be made up of many.`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!isEmpty(fdc3OpenOptions?.context)) {\n\t\t\t\t\t\t\t\tconst contextTimeout = options?.openOptions?.connectionTimeout;\n\t\t\t\t\t\t\t\tconst contextToPass = await this.processContext(fdc3OpenOptions.context);\n\t\t\t\t\t\t\t\tconst contextMetadata = await this.getContextMetadata(clientIdentity);\n\t\t\t\t\t\t\t\tconst updatedContext: OpenFin.Context = {\n\t\t\t\t\t\t\t\t\t...contextToPass,\n\t\t\t\t\t\t\t\t\t[this._metadataKey]: contextMetadata\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tconst contextSharing = platformIdentities.map(async (platformIdentity) =>\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line max-len\n\t\t\t\t\t\t\t\t\tthis.processOpenContext(platformIdentity, updatedContext, contextTimeout, multiInstance)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t// Initiate all promises concurrently without waiting for them to resolve\n\t\t\t\t\t\t\t\tPromise.allSettled(contextSharing)\n\t\t\t\t\t\t\t\t\t.then((results) => {\n\t\t\t\t\t\t\t\t\t\tconst anyFulfilled = results.some((result) => result.status === \"fulfilled\");\n\n\t\t\t\t\t\t\t\t\t\tif (anyFulfilled) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\t\t\t\t\t\"Multi Instance open context sharing has been initiated and at least one entry supported receiving a context.\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\t\t\t\t\t\"Multi Instance open context sharing was done but there were no context listeners registered.\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn anyFulfilled;\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\t\t\t\t\tlogger.error(`Context sharing for fdc3 open of ${appId} failed`, error);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!isEmpty(appId)) {\n\t\t\t\t\t\tif (focusApp && !isEmpty(platformIdentities) && !isEmpty(helpers?.bringAppToFront)) {\n\t\t\t\t\t\t\tawait helpers.bringAppToFront(requestedApp, platformIdentities);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { appId, instanceId };\n\t\t\t\t\t}\n\n\t\t\t\t\t// if no id returned then the likelihood is that there was a problem launching the application as a result of the open request.\n\t\t\t\t\tthrow new Error(OpenError.ErrorOnLaunch);\n\t\t\t\t} catch (openError) {\n\t\t\t\t\tconst error = formatError(openError);\n\t\t\t\t\tif (\n\t\t\t\t\t\terror === ResolveError.TargetInstanceUnavailable ||\n\t\t\t\t\t\terror === ResolveError.IntentDeliveryFailed ||\n\t\t\t\t\t\terror === ResolveError.TargetInstanceUnavailable ||\n\t\t\t\t\t\terror === OpenError.AppTimeout\n\t\t\t\t\t) {\n\t\t\t\t\t\tthrow new Error(OpenError.AppTimeout);\n\t\t\t\t\t}\n\t\t\t\t\tthrow openError;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * The client has disconnected form the broker.\n\t\t\t * @param clientIdentity The identity of the client that disconnected.\n\t\t\t */\n\t\t\tpublic async clientDisconnected(clientIdentity: OpenFin.ClientIdentity): Promise<void> {\n\t\t\t\tawait this._clientRegistrationHelper.clientDisconnected(clientIdentity);\n\t\t\t\tawait super.clientDisconnected(clientIdentity);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle FDC3 find instances.\n\t\t\t * @param app The app identifier to find.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @returns The instance of the app.\n\t\t\t */\n\t\t\tpublic async fdc3HandleFindInstances(\n\t\t\t\tapp: AppIdentifier,\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<AppIdentifier[]> {\n\t\t\t\treturn this._clientRegistrationHelper.findAppInstances(app, clientIdentity);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle request to get FDC3 app metadata.\n\t\t\t * @param app The app to get the metadata for.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @returns The app metadata.\n\t\t\t */\n\t\t\tpublic async fdc3HandleGetAppMetadata(\n\t\t\t\tapp: AppIdentifier,\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<AppMetadata> {\n\t\t\t\tlogger.info(\"fdc3HandleGetAppMetadata call received.\", app, clientIdentity);\n\t\t\t\t// this will only be called by FDC3 2.0+\n\t\t\t\tlet platformApp = await getApp(app.appId);\n\t\t\t\tif (isEmpty(platformApp) && app.appId === this._unregisteredApp?.appId) {\n\t\t\t\t\tplatformApp = this._unregisteredApp;\n\t\t\t\t}\n\t\t\t\tif (!isEmpty(platformApp)) {\n\t\t\t\t\tconst appMetaData: AppMetadata = mapTo20AppMetaData(platformApp);\n\t\t\t\t\tif (!isEmpty(app.instanceId)) {\n\t\t\t\t\t\tconst allConnectedClients = await this.getAllClientInfo();\n\t\t\t\t\t\tconst connectedClient = allConnectedClients.find(\n\t\t\t\t\t\t\t(client) => client.endpointId === app.instanceId\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!isEmpty(connectedClient) && connectedClient.uuid === fin.me.identity.uuid) {\n\t\t\t\t\t\t\tconst identity = { uuid: connectedClient.uuid, name: connectedClient.name };\n\t\t\t\t\t\t\tlet title: string | undefined;\n\t\t\t\t\t\t\tlet preview: string | undefined;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tif (connectedClient.entityType === \"window\") {\n\t\t\t\t\t\t\t\t\tconst instanceWindow = fin.Window.wrapSync(identity);\n\t\t\t\t\t\t\t\t\tconst isVisibleUserWindow = await instanceWindow.isShowing();\n\t\t\t\t\t\t\t\t\tif (isVisibleUserWindow) {\n\t\t\t\t\t\t\t\t\t\tconst windowInfo = await instanceWindow.getInfo();\n\t\t\t\t\t\t\t\t\t\ttitle = windowInfo.title;\n\t\t\t\t\t\t\t\t\t\tpreview = await this.getPreviewImage(instanceWindow);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst instanceView = fin.View.wrapSync(identity);\n\t\t\t\t\t\t\t\t\tconst viewInfo = await instanceView.getInfo();\n\t\t\t\t\t\t\t\t\ttitle = viewInfo.title;\n\t\t\t\t\t\t\t\t\tpreview = await this.getPreviewImage(instanceView);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t`A connected client could not be queried for data. It could be it hasn't unregistered itself from the broker. AppId: ${app.appId}, instanceId: ${app.instanceId}, name: ${identity.name}`,\n\t\t\t\t\t\t\t\t\terror\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!isEmpty(title)) {\n\t\t\t\t\t\t\t\t// ensure no element tags are provided in the title\n\t\t\t\t\t\t\t\t// we don't know how this information will be used\n\t\t\t\t\t\t\t\t// and title hasn't come from the app directory\n\t\t\t\t\t\t\t\ttitle = sanitizeString(title);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst instanceAppMeta: AppMetadata = {\n\t\t\t\t\t\t\t\t...appMetaData,\n\t\t\t\t\t\t\t\tinstanceId: app.instanceId,\n\t\t\t\t\t\t\t\tinstanceMetadata: { title, preview }\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\treturn instanceAppMeta;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn appMetaData;\n\t\t\t\t}\n\t\t\t\tthrow new Error(\"TargetAppUnavailable\");\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle the request to get FDC3 info.\n\t\t\t * @param payload The payload.\n\t\t\t * @param payload.fdc3Version The version info to get.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @returns The info.\n\t\t\t */\n\t\t\tpublic async fdc3HandleGetInfo(\n\t\t\t\tpayload: {\n\t\t\t\t\tfdc3Version: string;\n\t\t\t\t},\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<unknown> {\n\t\t\t\tlogger.info(\"fdc3HandleGetInfo\", payload, clientIdentity);\n\t\t\t\tif (payload?.fdc3Version === \"2.0\") {\n\t\t\t\t\tconst response: ImplementationMetadata = (await super.fdc3HandleGetInfo(\n\t\t\t\t\t\tpayload,\n\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t)) as ImplementationMetadata;\n\t\t\t\t\tconst appId = await this._appIdHelper.lookupAppId(clientIdentity);\n\t\t\t\t\tlet appMetadata: AppMetadata | undefined;\n\t\t\t\t\tconst includeAllAppMetadataInfo = this._getInfoOptions?.includeAllAppMetadataInfo === true;\n\t\t\t\t\tconst includeAppInteropInfo = this._getInfoOptions?.includeAppInteropInfo === true;\n\t\t\t\t\tif (!isEmpty(appId) && (includeAllAppMetadataInfo || includeAppInteropInfo)) {\n\t\t\t\t\t\tconst app = await getApp(appId);\n\t\t\t\t\t\tappMetadata = { appId, instanceId: clientIdentity.endpointId };\n\t\t\t\t\t\tif (!isEmpty(app)) {\n\t\t\t\t\t\t\tif (includeAllAppMetadataInfo) {\n\t\t\t\t\t\t\t\tappMetadata = {\n\t\t\t\t\t\t\t\t\t...appMetadata,\n\t\t\t\t\t\t\t\t\t...mapTo20AppMetaData(app)\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (includeAppInteropInfo && !isEmpty(app.interop)) {\n\t\t\t\t\t\t\t\tappMetadata = {\n\t\t\t\t\t\t\t\t\t...appMetadata,\n\t\t\t\t\t\t\t\t\tinstanceMetadata: { interop: app.interop }\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst updatedResponse = {\n\t\t\t\t\t\t...response,\n\t\t\t\t\t\toptionalFeatures: {\n\t\t\t\t\t\t\t...response.optionalFeatures,\n\t\t\t\t\t\t\tOriginatingAppMetadata: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\tappMetadata\n\t\t\t\t\t};\n\t\t\t\t\treturn updatedResponse;\n\t\t\t\t}\n\t\t\t\treturn super.fdc3HandleGetInfo(payload, clientIdentity);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle an intent handler being registered.\n\t\t\t * @param payload The payload.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @returns Nothing.\n\t\t\t */\n\t\t\tpublic async intentHandlerRegistered(\n\t\t\t\tpayload: IntentRegistrationPayload,\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<void> {\n\t\t\t\tawait this._clientRegistrationHelper.intentHandlerRegistered(payload, clientIdentity);\n\t\t\t\tawait super.intentHandlerRegistered(payload, clientIdentity);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * A context handler has been registered against the broker.\n\t\t\t * @param payload The payload from a context listener registration.\n\t\t\t * @param payload.contextType The context type that the client is listening for.\n\t\t\t * @param payload.handlerId The handler Id for this listener.\n\t\t\t * @param clientIdentity The identity of the application that is adding the context handler.\n\t\t\t */\n\t\t\tpublic async contextHandlerRegistered(\n\t\t\t\tpayload: { contextType: string | undefined; handlerId: string },\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<void> {\n\t\t\t\tawait this._clientRegistrationHelper.contextHandlerRegistered(payload, clientIdentity);\n\t\t\t\tsuper.contextHandlerRegistered(payload, clientIdentity);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Launch an app with intent.\n\t\t\t * @param app The application to launch.\n\t\t\t * @param intent The intent to open it with.\n\t\t\t * @param instanceId The instance of the app.\n\t\t\t * @param clientIdentity The identity of the source of the request.\n\t\t\t * @returns The intent resolution.\n\t\t\t */\n\t\t\tprivate async launchAppWithIntent(\n\t\t\t\tapp: PlatformApp,\n\t\t\t\tintent: OpenFin.Intent,\n\t\t\t\tinstanceId?: string,\n\t\t\t\tclientIdentity?: OpenFin.ClientIdentity\n\t\t\t): Promise<Omit<IntentResolution, \"getResult\">> {\n\t\t\t\tlogger.info(\"Launching app with intent\");\n\t\t\t\tlet platformIdentities: PlatformAppIdentifier[] | undefined = [];\n\t\t\t\tlet existingInstance = true;\n\t\t\t\tlet contextMetadata: ContextMetadata | undefined;\n\n\t\t\t\tif (!isEmpty(intent?.context)) {\n\t\t\t\t\tintent.context = await this.processContext(intent.context);\n\t\t\t\t\tif (!isEmpty(clientIdentity)) {\n\t\t\t\t\t\tcontextMetadata = await this.getContextMetadata(clientIdentity);\n\t\t\t\t\t\tintent.context = { ...intent.context, [this._metadataKey]: contextMetadata };\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!isEmpty(instanceId)) {\n\t\t\t\t\t// an instance of an application was selected\n\t\t\t\t\tconst allConnectedClients = await this.getAllClientInfo();\n\t\t\t\t\tconst clientInfo = allConnectedClients.find(\n\t\t\t\t\t\t(connectedClient) => connectedClient.endpointId === instanceId\n\t\t\t\t\t);\n\t\t\t\t\tif (!isEmpty(clientInfo)) {\n\t\t\t\t\t\tlogger.info(`App Id: ${app.appId} and instance Id: ${instanceId} was provided and found.`);\n\t\t\t\t\t\t// the connected instance is available\n\t\t\t\t\t\tplatformIdentities.push({\n\t\t\t\t\t\t\tuuid: clientInfo.uuid,\n\t\t\t\t\t\t\tname: clientInfo.name,\n\t\t\t\t\t\t\tappId: app.appId,\n\t\t\t\t\t\t\tinstanceId: clientInfo.endpointId\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(ResolveError.TargetInstanceUnavailable);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (platformIdentities.length === 0) {\n\t\t\t\t\tplatformIdentities = await launch(app.appId, undefined, clientIdentity);\n\t\t\t\t\tif (!platformIdentities?.length) {\n\t\t\t\t\t\tthrow new Error(ResolveError.IntentDeliveryFailed);\n\t\t\t\t\t}\n\t\t\t\t\texistingInstance = false;\n\t\t\t\t}\n\t\t\t\tconst intentTimeout: number | undefined = options?.intentOptions?.intentTimeout;\n\t\t\t\t// how many instances do we have?\n\t\t\t\tif (platformIdentities.length === 1) {\n\t\t\t\t\tinstanceId = await this.processSetIntentTarget(platformIdentities[0], intent, intentTimeout, false);\n\t\t\t\t} else {\n\t\t\t\t\tconst intentSharing = platformIdentities.map(async (platformIdentity) =>\n\t\t\t\t\t\tthis.processSetIntentTarget(platformIdentity, intent, intentTimeout, true)\n\t\t\t\t\t);\n\t\t\t\t\t// Initiate all promises concurrently without waiting for them to resolve\n\t\t\t\t\tPromise.allSettled(intentSharing)\n\t\t\t\t\t\t.then((results) => {\n\t\t\t\t\t\t\tconst anyFulfilled = results.some((result) => result.status === \"fulfilled\");\n\n\t\t\t\t\t\t\tif (anyFulfilled) {\n\t\t\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\t\t\"Multi Instance intents target sharing has been initiated and at least one entry supported intents.\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\t\t\"All intent sharing promises were rejected so not even one identity supported intents in time.\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn anyFulfilled;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\t\tlogger.error(`Intent raising of multiple identities for app: ${app.appId} failed`, error);\n\t\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (existingInstance) {\n\t\t\t\t\tfor (const target of platformIdentities) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (helpers.bringAppToFront) {\n\t\t\t\t\t\t\t\tawait helpers.bringAppToFront(app, [target]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (bringToFrontError) {\n\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t`There was an error bringing app: ${target.appId}, and instance ${target.instanceId} with name: ${target.name} to front.`,\n\t\t\t\t\t\t\t\tbringToFrontError\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tsource: { appId: app.appId, instanceId },\n\t\t\t\t\tversion: app.version,\n\t\t\t\t\tintent: intent.name\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle the intent picker selection.\n\t\t\t * @param userSelection The user selection from the intent picker.\n\t\t\t * @param intent The intent.\n\t\t\t * @param clientIdentity The source of the request.\n\t\t\t * @returns The intent resolution.\n\t\t\t */\n\t\t\tprivate async handleIntentPickerSelection(\n\t\t\t\tuserSelection: IntentResolverResponse,\n\t\t\t\tintent: OpenFin.Intent<OpenFin.IntentMetadata<IntentTargetMetaData>>,\n\t\t\t\tclientIdentity?: OpenFin.ClientIdentity\n\t\t\t): Promise<Omit<IntentResolution, \"getResult\">> {\n\t\t\t\tlet selectedApp = await getApp(userSelection.appId);\n\t\t\t\tif (isEmpty(selectedApp) && !isEmpty(this._unregisteredApp)) {\n\t\t\t\t\tselectedApp = this._unregisteredApp;\n\t\t\t\t}\n\t\t\t\tif (isEmpty(selectedApp)) {\n\t\t\t\t\tthrow new Error(ResolveError.NoAppsFound);\n\t\t\t\t}\n\t\t\t\tconst instanceId: string | undefined = userSelection.instanceId;\n\t\t\t\tconst intentResolver = await this.launchAppWithIntent(\n\t\t\t\t\tselectedApp,\n\t\t\t\t\tintent,\n\t\t\t\t\tinstanceId,\n\t\t\t\t\tclientIdentity\n\t\t\t\t);\n\t\t\t\tif (isEmpty(intentResolver)) {\n\t\t\t\t\tthrow new Error(ResolveError.NoAppsFound);\n\t\t\t\t}\n\t\t\t\treturn intentResolver;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Handle a targeted intent.\n\t\t\t * @param targetAppIdentifier The identifier for the target app.\n\t\t\t * @param intent The intent.\n\t\t\t * @param targetByContext Perform the target by context.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @returns The intent resolution.\n\t\t\t */\n\t\t\tprivate async handleTargetedIntent(\n\t\t\t\ttargetAppIdentifier: AppIdentifier,\n\t\t\t\tintent: OpenFin.Intent,\n\t\t\t\ttargetByContext: boolean,\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<Omit<IntentResolution, \"getResult\">> {\n\t\t\t\t// app specified flow\n\t\t\t\tconst intentsForSelection: AppsForIntent[] = [];\n\t\t\t\tlet targetApp = await getApp(targetAppIdentifier.appId);\n\n\t\t\t\t// if the specified app isn't available then let the caller know\n\t\t\t\tif (isEmpty(targetApp)) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!isEmpty(targetAppIdentifier.instanceId) &&\n\t\t\t\t\t\ttargetAppIdentifier.appId === this._unregisteredApp?.appId\n\t\t\t\t\t) {\n\t\t\t\t\t\ttargetApp = this._unregisteredApp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(ResolveError.TargetAppUnavailable);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if an instanceId is specified then check to see if it is valid and if it isn't inform the caller\n\t\t\t\tif (!isEmpty(targetAppIdentifier.instanceId)) {\n\t\t\t\t\tconst availableAppInstances = await this._clientRegistrationHelper.findAppInstances(\n\t\t\t\t\t\ttargetAppIdentifier,\n\t\t\t\t\t\tclientIdentity,\n\t\t\t\t\t\t\"intent\"\n\t\t\t\t\t);\n\t\t\t\t\tif (\n\t\t\t\t\t\tavailableAppInstances.length === 0 ||\n\t\t\t\t\t\t!availableAppInstances.some(\n\t\t\t\t\t\t\t(entry) =>\n\t\t\t\t\t\t\t\t// eslint-disable-next-line max-len\n\t\t\t\t\t\t\t\tentry.appId === targetAppIdentifier.appId &&\n\t\t\t\t\t\t\t\tentry.instanceId === targetAppIdentifier.instanceId\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthrow new Error(ResolveError.TargetInstanceUnavailable);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!Array.isArray(targetApp.intents) || targetApp.intents.length === 0) {\n\t\t\t\t\t// an app was specified but it doesn't have any intents. Indicate that something is wrong\n\t\t\t\t\tthrow new Error(ResolveError.TargetAppUnavailable);\n\t\t\t\t}\n\n\t\t\t\tconst supportedIntents = targetApp.intents.filter((intentEntry) => {\n\t\t\t\t\tlet contextMatch: boolean = true;\n\t\t\t\t\tconst contextType = intent.context?.type;\n\t\t\t\t\tif (!isEmpty(contextType)) {\n\t\t\t\t\t\tcontextMatch = intentEntry.contexts?.includes(contextType);\n\t\t\t\t\t\tif (targetByContext) {\n\t\t\t\t\t\t\treturn contextMatch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn intentEntry.name === intent.name && contextMatch;\n\t\t\t\t});\n\n\t\t\t\tif (supportedIntents.length === 0) {\n\t\t\t\t\t// the specified app does have intent support but just none that support this context type\n\t\t\t\t\tthrow new Error(ResolveError.TargetAppUnavailable);\n\t\t\t\t}\n\n\t\t\t\tif (supportedIntents.length === 1) {\n\t\t\t\t\t// a preferred name for an app was given with the context object\n\t\t\t\t\t// the app existed and it supported the context type and there was only one intent that supported\n\t\t\t\t\t// that context type. Launch the app with that intent otherwise present the user with a list of\n\t\t\t\t\t// everything that supports that context type\n\t\t\t\t\tintent.name = supportedIntents[0].name;\n\t\t\t\t\t// check for instances\n\t\t\t\t\tif (!isEmpty(targetAppIdentifier.instanceId)) {\n\t\t\t\t\t\tconst intentResolver = await this.launchAppWithIntent(\n\t\t\t\t\t\t\ttargetApp,\n\t\t\t\t\t\t\tintent,\n\t\t\t\t\t\t\ttargetAppIdentifier.instanceId,\n\t\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn intentResolver;\n\t\t\t\t\t}\n\t\t\t\t\tconst specifiedAppInstances = await this._clientRegistrationHelper.findAppInstances(\n\t\t\t\t\t\ttargetApp,\n\t\t\t\t\t\tclientIdentity,\n\t\t\t\t\t\t\"intent\"\n\t\t\t\t\t);\n\t\t\t\t\t// the launch logic is single instance aware but can also bring content to front where possible\n\t\t\t\t\t// this will let the context be set and the content brought to front.\n\t\t\t\t\tconst launchSingleInstanceApp =\n\t\t\t\t\t\tspecifiedAppInstances.length === 1 && this.useSingleInstance(targetApp);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tspecifiedAppInstances.length === 0 ||\n\t\t\t\t\t\tthis.createNewInstance(targetApp) ||\n\t\t\t\t\t\tlaunchSingleInstanceApp\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst intentResolver = await this.launchAppWithIntent(\n\t\t\t\t\t\t\ttargetApp,\n\t\t\t\t\t\t\tintent,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (isEmpty(intentResolver)) {\n\t\t\t\t\t\t\tthrow new Error(ResolveError.IntentDeliveryFailed);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn intentResolver;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const supportedIntent of supportedIntents) {\n\t\t\t\t\tconst appForIntent: AppsForIntent = {\n\t\t\t\t\t\tapps: [targetApp],\n\t\t\t\t\t\tintent: { name: supportedIntent.name, displayName: supportedIntent.displayName }\n\t\t\t\t\t};\n\t\t\t\t\tintentsForSelection.push(appForIntent);\n\t\t\t\t}\n\t\t\t\tlet userSelection: IntentResolverResponse | undefined;\n\t\t\t\tif (intentsForSelection.length === 1) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!isStringValue(intent.name) &&\n\t\t\t\t\t\t!isEmpty(intentsForSelection[0]?.intent?.name) &&\n\t\t\t\t\t\t!isEmpty(intent?.context) &&\n\t\t\t\t\t\t!isEmpty(intent?.context?.type)\n\t\t\t\t\t) {\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t`A request to raise an intent was passed and the intent name was not passed but a context was ${intent?.context?.type} with 1 matching intent. Name: ${intentsForSelection[0]?.intent?.name},  Display Name: ${intentsForSelection[0]?.intent?.displayName}. Updating intent object.`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tintent.name = intentsForSelection[0]?.intent?.name;\n\t\t\t\t\t}\n\t\t\t\t\tuserSelection = await this._intentResolverHelper?.launchIntentResolver(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tapps: intentsForSelection[0].apps,\n\t\t\t\t\t\t\tintent\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tuserSelection = await this._intentResolverHelper?.launchIntentResolver(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tintent,\n\t\t\t\t\t\t\tintents: intentsForSelection\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclientIdentity\n\t\t\t\t\t);\n\t\t\t\t\tif (!isStringValue(intent.name) && !isEmpty(userSelection?.intent?.name)) {\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t`A request to raise an intent was passed and the following intent was selected (from a selection of ${intentsForSelection.length}). Name: ${userSelection?.intent?.name},  Display Name: ${userSelection?.intent?.displayName}. Updating intent object.`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tintent.name = userSelection?.intent?.name ?? intent.name;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isEmpty(userSelection)) {\n\t\t\t\t\tthrow new Error(ResolveError.ResolverUnavailable);\n\t\t\t\t}\n\n\t\t\t\treturn this.handleIntentPickerSelection(userSelection, intent, clientIdentity);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Waits for a context handler to be registered for an app that was opened with a context.\n\t\t\t * @param platformIdentity The platform identity of the app that was opened.\n\t\t\t * @param context The context that was opened with the app.\n\t\t\t * @param contextTimeout The timeout for the context.\n\t\t\t * @param multiInstance Is this being called as part of targeting multiple identities.\n\t\t\t */\n\t\t\tprivate async processOpenContext(\n\t\t\t\tplatformIdentity: PlatformAppIdentifier,\n\t\t\t\tcontext: OpenFin.Context,\n\t\t\t\tcontextTimeout: number | undefined,\n\t\t\t\tmultiInstance: boolean\n\t\t\t): Promise<void> {\n\t\t\t\tconst contextTypeName = context.type;\n\t\t\t\tconst appId = platformIdentity.appId;\n\t\t\t\tconst clientReadyInstanceId = await this._clientRegistrationHelper.onContextClientReady(\n\t\t\t\t\tplatformIdentity,\n\t\t\t\t\tcontextTypeName,\n\t\t\t\t\tcontextTimeout\n\t\t\t\t);\n\n\t\t\t\tlet trackedHandler = this._clientRegistrationHelper.getRegisteredContextHandler(\n\t\t\t\t\tcontextTypeName,\n\t\t\t\t\tclientReadyInstanceId\n\t\t\t\t);\n\n\t\t\t\tif (isEmpty(trackedHandler)) {\n\t\t\t\t\ttrackedHandler = this._clientRegistrationHelper.getRegisteredContextHandler(\n\t\t\t\t\t\t\"*\",\n\t\t\t\t\t\tclientReadyInstanceId\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!isEmpty(trackedHandler)) {\n\t\t\t\t\tawait this.invokeContextHandler(trackedHandler.clientIdentity, trackedHandler.handlerId, context);\n\t\t\t\t} else if (multiInstance) {\n\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t`Unable to send context of type ${contextTypeName} opened app ${appId} with instanceId of ${clientReadyInstanceId} as we cannot find a tracked context handler. This is likely a composite app and this app might not register a context handler.`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Unable to send context of type ${contextTypeName} opened app ${appId} with instanceId of ${clientReadyInstanceId} as we cannot find a tracked context handler.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Waits for a intent handler to be registered for an app and fires the intent at it.\n\t\t\t * @param platformIdentity The platform identity of the app that was shown.\n\t\t\t * @param intent The intent that was specified.\n\t\t\t * @param intentTimeout The timeout for the intent.\n\t\t\t * @param multiInstance Is this being called as part of targeting multiple identities.\n\t\t\t * @returns The instance id of the identity that was targeted.\n\t\t\t */\n\t\t\tprivate async processSetIntentTarget(\n\t\t\t\tplatformIdentity: PlatformAppIdentifier,\n\t\t\t\tintent: OpenFin.Intent,\n\t\t\t\tintentTimeout: number | undefined,\n\t\t\t\tmultiInstance: boolean\n\t\t\t): Promise<string> {\n\t\t\t\ttry {\n\t\t\t\t\tconst instanceId = await this._clientRegistrationHelper.onIntentClientReady(\n\t\t\t\t\t\tplatformIdentity,\n\t\t\t\t\t\tintent.name,\n\t\t\t\t\t\tintentTimeout\n\t\t\t\t\t);\n\t\t\t\t\tawait super.setIntentTarget(intent, platformIdentity);\n\t\t\t\t\treturn instanceId;\n\t\t\t\t} catch (intentReadyError) {\n\t\t\t\t\tif (multiInstance) {\n\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t`An error occurred while getting a instance to target an intent at. If multiple views were launched as part of a composite and some of them do not register intent handlers then this may explain it.that may explain this warning. AppId: ${platformIdentity.appId}, Name: ${platformIdentity.name}`,\n\t\t\t\t\t\t\tintentReadyError\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t`An error occurred while getting a instance to target an intent at. AppId: ${platformIdentity.appId}, Name: ${platformIdentity.name}`,\n\t\t\t\t\t\t\tintentReadyError\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(ResolveError.IntentDeliveryFailed);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Shape the intent resolver.\n\t\t\t * @param intentResolver The intent resolver to shape.\n\t\t\t * @param usesAppIdentifier Should it use the app identifier.\n\t\t\t * @returns The shaped intent resolver.\n\t\t\t */\n\t\t\tprivate shapeIntentResolver(\n\t\t\t\tintentResolver: Omit<IntentResolution, \"getResult\">,\n\t\t\t\tusesAppIdentifier: boolean\n\t\t\t): Omit<IntentResolution, \"getResult\"> | { source: string; version?: string } {\n\t\t\t\tif (usesAppIdentifier) {\n\t\t\t\t\treturn intentResolver;\n\t\t\t\t}\n\t\t\t\treturn { source: intentResolver.source.appId, version: intentResolver.version };\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Should we use a single instance of the app.\n\t\t\t * @param app The app to check.\n\t\t\t * @returns True if we should use a single instance.\n\t\t\t */\n\t\t\tprivate useSingleInstance(app: PlatformApp): boolean {\n\t\t\t\treturn app?.instanceMode === \"single\";\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Should we always use a new instance of the app.\n\t\t\t * @param app The app to check.\n\t\t\t * @returns True if we should always use a new instance.\n\t\t\t */\n\t\t\tprivate createNewInstance(app: PlatformApp): boolean {\n\t\t\t\treturn app?.instanceMode === \"new\";\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get a preview image for a window/view.\n\t\t\t * @param target The target identity to capture.\n\t\t\t * @param target.capturePage The capture page method of the entity.\n\t\t\t * @param target.identity The identity of the entity being captured.\n\t\t\t * @returns The captured preview image.\n\t\t\t */\n\t\t\tprivate async getPreviewImage(target: {\n\t\t\t\tcapturePage: (options?: OpenFin.CapturePageOptions) => Promise<string>;\n\t\t\t\tidentity: OpenFin.Identity;\n\t\t\t}): Promise<string | undefined> {\n\t\t\t\ttry {\n\t\t\t\t\tconst preview = await target.capturePage({ format: \"jpg\", quality: 85 });\n\t\t\t\t\tif (isStringValue(preview)) {\n\t\t\t\t\t\treturn preview;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t`Error while trying to capture a preview image of the view/window: ${target.identity.name}`,\n\t\t\t\t\t\terror\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get the unregistered app intent by context.\n\t\t\t * @param type The context type to get.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @returns The list of supported intents.\n\t\t\t */\n\t\t\tprivate async getUnregisteredAppIntentByContext(\n\t\t\t\ttype: string,\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity\n\t\t\t): Promise<string[]> {\n\t\t\t\tconst intentNames: string[] = [];\n\t\t\t\tconst supportedIntentNames: string[] = [];\n\t\t\t\tif (isEmpty(this?._unregisteredApp)) {\n\t\t\t\t\treturn intentNames;\n\t\t\t\t}\n\t\t\t\tif (Array.isArray(this?._unregisteredApp?.intents)) {\n\t\t\t\t\tfor (const intent of this._unregisteredApp.intents) {\n\t\t\t\t\t\tif (intent.contexts.includes(type)) {\n\t\t\t\t\t\t\tconst intentName: string = intent.name;\n\t\t\t\t\t\t\tintentNames.push(intentName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (intentNames.length > 0) {\n\t\t\t\t\t// now we need to check if there are any instances as this app can not be launched as it is a placeholder for unregistered instances\n\t\t\t\t\tfor (const intentName of intentNames) {\n\t\t\t\t\t\tif (await this.canAddUnregisteredApp(clientIdentity, intentName)) {\n\t\t\t\t\t\t\tsupportedIntentNames.push(intentName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// the unregisteredAppMeta data lists the supported intents but we only want to return intents that have active instances ready\n\t\t\t\treturn supportedIntentNames;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Can we add an unregistered app.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @param intentName The intent name.\n\t\t\t * @param contextType The context type.\n\t\t\t * @returns True if we can add the app.\n\t\t\t */\n\t\t\tprivate async canAddUnregisteredApp(\n\t\t\t\tclientIdentity: OpenFin.ClientIdentity,\n\t\t\t\tintentName?: string,\n\t\t\t\tcontextType?: string\n\t\t\t): Promise<boolean> {\n\t\t\t\tif (isEmpty(this?._unregisteredApp)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst listensFor = this._unregisteredApp?.interop?.intents?.listensFor;\n\n\t\t\t\tif (!isEmpty(intentName) && (isEmpty(listensFor) || isEmpty(listensFor[intentName]))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!isEmpty(contextType) &&\n\t\t\t\t\t!isEmpty(listensFor) &&\n\t\t\t\t\t!isEmpty(intentName) &&\n\t\t\t\t\t!listensFor[intentName].contexts.includes(contextType)\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst instances = await this._clientRegistrationHelper.findAppInstances(\n\t\t\t\t\t{ appId: this._unregisteredApp.appId },\n\t\t\t\t\tclientIdentity,\n\t\t\t\t\t\"intent\"\n\t\t\t\t);\n\n\t\t\t\treturn instances.length > 0;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get an application identity.\n\t\t\t * @param metadata The metadata for the app.\n\t\t\t * @returns The app identifier.\n\t\t\t */\n\t\t\tprivate getApplicationIdentity(\n\t\t\t\tmetadata: OpenFin.IntentMetadata<IntentTargetMetaData> | undefined\n\t\t\t): AppIdentifier | undefined {\n\t\t\t\tconst target = metadata?.target;\n\t\t\t\tif (isEmpty(target)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (isString(target)) {\n\t\t\t\t\tif (target.trim().length === 0) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t\treturn { appId: target };\n\t\t\t\t}\n\n\t\t\t\tif (isEmpty(target.appId)) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\treturn { appId: target.appId, instanceId: target.instanceId };\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Does the app use application identity.\n\t\t\t * @param clientIdentity The client app to check.\n\t\t\t * @returns True if the app uses application identity.\n\t\t\t */\n\t\t\tprivate usesApplicationIdentity(clientIdentity: OpenFin.ClientIdentity): boolean {\n\t\t\t\tconst apiMetadata = this._clientRegistrationHelper.getApiVersion(clientIdentity);\n\t\t\t\tif (isEmpty(apiMetadata)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn apiMetadata.type === \"fdc3\" && apiMetadata.version === \"2.0\";\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process a context.\n\t\t\t * @param context The context to process.\n\t\t\t * @returns The processed context.\n\t\t\t */\n\t\t\tprivate async processContext(context: OpenFin.Context): Promise<OpenFin.Context> {\n\t\t\t\tif (isEmpty(endpointClient)) {\n\t\t\t\t\treturn context;\n\t\t\t\t}\n\t\t\t\tconst endpointId = `interopbroker.process.${context.type}`;\n\t\t\t\tif (endpointClient.hasEndpoint(endpointId)) {\n\t\t\t\t\tlogger.info(`Processing context ${context.type} with endpoint ${endpointId}`);\n\t\t\t\t\tconst processedContext = await endpointClient.requestResponse<ContextToProcess, ProcessedContext>(\n\t\t\t\t\t\tendpointId,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontext\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tif (processedContext?.context) {\n\t\t\t\t\t\treturn processedContext?.context;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn context;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get the context metadata for a client identity.\n\t\t\t * @param clientIdentity The client identity.\n\t\t\t * @returns The context metadata.\n\t\t\t */\n\t\t\tprivate async getContextMetadata(clientIdentity: OpenFin.ClientIdentity): Promise<ContextMetadata> {\n\t\t\t\tconst appId = (await this._appIdHelper.lookupAppId(clientIdentity)) ?? \"unknown\";\n\t\t\t\treturn {\n\t\t\t\t\tsource: {\n\t\t\t\t\t\tappId,\n\t\t\t\t\t\tinstanceId: clientIdentity.endpointId\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n}\n"],"names":["value","isString","trim","length","formatError","err","Error","message","Array","isArray","JSON","stringify","mapToAppMetaData","app","icons","images","icon","src","push","image","appId","description","name","title","tooltip","version","resultType","screenshots","OPEN_ERROR","RESOLVE_ERROR","MANIFEST_TYPES","AppIdHelper","constructor","getApp","platformId","logger","unregisteredApp","_validatedAppIds","_invalidAppIds","this","_unregisteredApp","_logger","_getApp","_platformId","lookupAppId","clientIdentity","startsWith","uuid","debug","nameParts","split","includes","warn","AppIntentHelper","getApps","_getApps","getAppsByIntent","intent","filter","listensFor","interop","intents","intentNames","Object","keys","intentName","toLowerCase","getIntent","contextType","apps","intentsMap","appIntent","appIntentContains","updateAppIntentsMap","displayName","results","values","info","getIntentsByContext","supportedIntents","supportedIntent","contexts","async","getAppsMetaData","appToV1Point2","appTpV2Point0","findInstances","appsMetaData","appsMetaDataV1Point2","appData","instances","instance","instanceAppEntry","instanceId","ClientRegistrationHelper","_lookupAppId","_clientReadyRequests","_trackedClientConnections","_trackedContextHandlers","_trackedIntentHandlers","clientDisconnected","key","entries","entry","endpointId","removeTrackedClientConnection","intentHandlerRegistered","payload","handlerId","replace","trackedIntentHandler","find","fdc3Version","clientReadyKey","getClientReadyKey","contextHandlerRegistered","contextTypeName","trackedContextHandler","clientConnectionRegistered","id","apiVersion","fin","me","identity","payloadApiVersion","type","connectionUrl","entityType","captureViewApiUsage","captureWindowApiUsage","brokerClientConnection","apiMetadata","getRegisteredContextHandler","trackedHandler","findAppInstances","endpointApps","getApiVersion","onConnectionClientReady","timeout","Promise","resolve","reject","getClientIdentity","timerId","setTimeout","clearTimeout","onIntentClientReady","registeredHandlers","existingInstanceId","handler","onContextClientReady","contextRegisteredHandlers","globalRegisteredHandlers","existingContextHandlerInstanceId","contextKey","globalKey","hasContextRequest","hasGlobalRequest","isResolved","target","Window","wrapSync","options","getOptions","fdc3InteropApi","View","centerContentInIdentity","dimensions","boundsCenter","bounds","boundsCenterX","boundsCenterY","halfWidth","width","halfHeight","height","left","top","x","Math","round","y","getBoundsCenter","currentWindow","targetView","getCurrentWindow","targetWindow","getBounds","getIdentityBounds","availableRect","contentDimensions","bottom","dividedRectWidth","right","dividedRectHeight","dividedDimensionWidth","dividedDimensionHeight","centerContentInRect","point","monitorInfo","System","getMonitorInfo","monitor","nonPrimaryMonitors","pointInRect","monitorRect","primaryMonitor","findMonitorContainingPoint","rect","IntentResolverHelper","intentResolverOptions","unregisteredAppId","_defaultIntentResolverHeight","_defaultIntentResolverWidth","_intentResolverOptions","launchIntentResolver","launchOptions","position","winOption","includeInSnapshots","defaultWidth","defaultHeight","showTaskbarIcon","saveWindowState","customData","_unregisteredAppId","url","frame","autoShow","alwaysOnTop","defaultCentered","defaultLeft","defaultTop","webWindowResolver","create","getWebWindow","getIntentSelection","error","entryPoints","interopOverride","initialize","definition","loggerCreator","helpers","_definition","loggerName","data","_helpers","closedown","getConstructorOverride","launchApp","endpointClient","getEndpointClient","launch","connectionsClient","getConnectionClient","Base","super","_appIntentHelper","_metadataKey","globalThis","crypto","randomUUID","c","rnd","getRandomValues","Uint8Array","Number","toString","intentResolver","_intentResolverHelper","_openOptions","openOptions","_contextOptions","contextOptions","_getInfoOptions","getInfoOptions","manifestType","_appIdHelper","_clientRegistrationHelper","isConnectionAuthorized","apiPayload","response","isConnectionValid","isValid","setContext","sentContext","context","processContext","contextMetadata","getContextMetadata","invokeContextHandler","passedContext","includeOriginator","source","handleInfoForIntentsByContext","requestedContextType","requestedResultType","request","metadata","mappedIntents","appMetaData","handleInfoForIntent","intentOptions","optContextType","result","handleFiredIntentForContext","contextForIntent","targetAppIdentifier","getApplicationIdentity","usesAppIdentity","usesApplicationIdentity","intentsForSelection","targetApp","some","listenedForIntent","handleTargetedIntent","shapeIntentResolver","unregisteredAppIntents","getUnregisteredAppIntentByContext","matchedIntents","intentForSelection","missingIntentMatches","missingIntentMatch","missingIntent","userSelection","createNewInstance","launchAppWithIntent","undefined","handleIntentPickerSelection","handleFiredIntent","usesAppIdentifier","intentApps","canAddUnregisteredApp","appInstances","appInstanceId","useSingleInstance","invokeIntentHandler","fdc3HandleOpen","fdc3OpenOptions","requestedId","platformIdentities","focusApp","requestedApp","clientInfo","getAllClientInfo","connectedClient","openStrategy","openAppIntent","multiInstance","openTimeout","connectionTimeout","contextTimeout","contextToPass","updatedContext","contextSharing","map","platformIdentity","processOpenContext","allSettled","then","anyFulfilled","status","catch","bringAppToFront","openError","fdc3HandleFindInstances","fdc3HandleGetAppMetadata","platformApp","client","preview","instanceWindow","isShowing","getInfo","getPreviewImage","instanceView","content","instanceMetadata","fdc3HandleGetInfo","appMetadata","includeAllAppMetadataInfo","includeAppInteropInfo","optionalFeatures","OriginatingAppMetadata","existingInstance","intentTimeout","processSetIntentTarget","intentSharing","bringToFrontError","selectedApp","targetByContext","availableAppInstances","intentEntry","contextMatch","specifiedAppInstances","launchSingleInstanceApp","appForIntent","clientReadyInstanceId","setIntentTarget","intentReadyError","instanceMode","capturePage","format","quality","supportedIntentNames","hasEndpoint","processedContext","requestResponse"],"sourceRoot":""}