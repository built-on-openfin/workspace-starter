/******/ var __webpack_modules__ = ({

/***/ "./client/src/framework/utils.ts":
/*!***************************************!*\
  !*** ./client/src/framework/utils.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatError: () => (/* binding */ formatError),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isInteger: () => (/* binding */ isInteger),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isNumberValue: () => (/* binding */ isNumberValue),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isStringValue: () => (/* binding */ isStringValue),
/* harmony export */   objectClone: () => (/* binding */ objectClone),
/* harmony export */   randomUUID: () => (/* binding */ randomUUID),
/* harmony export */   sanitizeString: () => (/* binding */ sanitizeString)
/* harmony export */ });
/**
 * Test if a value is a undefined or null.
 * @param value The value to test.
 * @returns True if the value is null or undefined.
 */
function isEmpty(value) {
    // eslint-disable-next-line no-restricted-syntax
    return value === undefined || value === null;
}
/**
 * Test if a value is an object.
 * @param value The value to test.
 * @returns True if the value is an object.
 */
function isObject(value) {
    // eslint-disable-next-line no-restricted-syntax
    return value !== undefined && value !== null && typeof value === "object" && !Array.isArray(value);
}
/**
 * Test if a value is a string.
 * @param value The value to test.
 * @returns True if the value is a string.
 */
function isString(value) {
    // eslint-disable-next-line no-restricted-syntax
    return value !== undefined && value !== null && typeof value === "string";
}
/**
 * Test if a value is a string that is not empty.
 * @param value The value to test.
 * @returns True if the value is a string that is not empty.
 */
function isStringValue(value) {
    return isString(value) && value.trim().length > 0;
}
/**
 * Test if a value is a number.
 * @param value The value to test.
 * @returns True if the value is a number.
 */
function isNumber(value) {
    // eslint-disable-next-line no-restricted-syntax
    return value !== undefined && value !== null && typeof value === "number";
}
/**
 * Test if a value is a number with a real value i.e. not NaN or Infinite.
 * @param value The value to test.
 * @returns True if the value is a number.
 */
function isNumberValue(value) {
    return isNumber(value) && !Number.isNaN(value) && Number.isFinite(value);
}
/**
 * Test if a value is a boolean.
 * @param value The value to test.
 * @returns True if the value is a boolean.
 */
function isBoolean(value) {
    // eslint-disable-next-line no-restricted-syntax
    return value !== undefined && value !== null && typeof value === "boolean";
}
/**
 * Test if a value is an integer.
 * @param value The value to test.
 * @returns True if the value is an integer.
 */
function isInteger(value) {
    return isNumber(value) && Number.isInteger(value);
}
/**
 * Deep clone an object.
 * @param obj The object to clone.
 * @returns The clone of the object.
 */
function objectClone(obj) {
    // eslint-disable-next-line no-restricted-syntax
    return obj === undefined ? undefined : JSON.parse(JSON.stringify(obj));
}
/**
 * Polyfills randomUUID if running in a non-secure context.
 * @returns The random UUID.
 */
function randomUUID() {
    if ("randomUUID" in globalThis.crypto) {
        // eslint-disable-next-line no-restricted-syntax
        return globalThis.crypto.randomUUID();
    }
    // Polyfill the window.crypto.randomUUID if we are running in a non secure context that doesn't have it
    // we are still using window.crypto.getRandomValues which is always available
    // https://stackoverflow.com/a/2117523/2800218
    /**
     * Get random hex value.
     * @param c The number to base the random value on.
     * @returns The random value.
     */
    function getRandomHex(c) {
        // eslint-disable-next-line no-bitwise
        const rnd = globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (Number(c) / 4));
        return (
        // eslint-disable-next-line no-bitwise
        (Number(c) ^ rnd).toString(16));
    }
    return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, getRandomHex);
}
/**
 * Format an error to a readable string.
 * @param err The error to format.
 * @returns The formatted error.
 */
function formatError(err) {
    if (isEmpty(err)) {
        return "";
    }
    else if (err instanceof Error) {
        return err.message;
    }
    else if (isStringValue(err)) {
        return err;
    }
    else if (isObject(err) && "message" in err && isString(err.message)) {
        return err.message;
    }
    return JSON.stringify(err);
}
/**
 * A basic string sanitize function that removes angle brackets <> from a string.
 * @param content the content to sanitize
 * @returns a string without angle brackets <>
 */
function sanitizeString(content) {
    if (isStringValue(content)) {
        return content
            .replace(/<[^>]*>?/gm, "")
            .replace(/&gt;/g, ">")
            .replace(/&lt;/g, "<")
            .replace(/&amp;/g, "&")
            .replace(/&nbsp;/g, " ")
            .replace(/\n\s*\n/g, "\n");
    }
    return "";
}


/***/ }),

/***/ "./client/src/modules/auth/openid-connect/auth.ts":
/*!********************************************************!*\
  !*** ./client/src/modules/auth/openid-connect/auth.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OpenIdConnectProvider: () => (/* binding */ OpenIdConnectProvider)
/* harmony export */ });
/* harmony import */ var _openfin_openid_connect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @openfin/openid-connect */ "../../node_modules/@openfin/openid-connect/openfin.openid-connect.mjs");
/* harmony import */ var workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workspace-platform-starter/utils */ "./client/src/framework/utils.ts");


/**
 * Implementation for the openid connect auth provider.
 */
class OpenIdConnectProvider {
    /**
     * Create a new instance of OpenIdConnectProvider.
     */
    constructor() {
        this._subscribeIdMap = {};
        this._eventSubscribers = {};
    }
    /**
     * Initialize the module.
     * @param definition The definition of the module from configuration include custom options.
     * @param loggerCreator For logging entries.
     * @param helpers Helper methods for the module to interact with the application core.
     * @returns Nothing.
     */
    async initialize(definition, loggerCreator, helpers) {
        this._definition = definition;
        this._logger = loggerCreator("OpenIdConnectProvider");
        this._logger.info("Initializing");
        if (this._definition.data?.enableLogging) {
            (0,_openfin_openid_connect__WEBPACK_IMPORTED_MODULE_0__.enableLogging)();
        }
        const providerUrl = this._definition.data?.providerUrl;
        const clientId = this._definition.data?.clientId;
        const loginRedirectUrl = this._definition.data?.loginRedirectUrl;
        const logoutRedirectUrl = this._definition.data?.logoutRedirectUrl;
        if (!(0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(providerUrl)) {
            this._logger.error("providerUrl is not configured");
        }
        if (!(0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(clientId)) {
            this._logger.error("ClientId is not configured");
        }
        if (!(0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(loginRedirectUrl)) {
            this._logger.error("loginRedirectUrl is not configured");
        }
        if (!(0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(logoutRedirectUrl)) {
            this._logger.error("logoutRedirectUrl is not configured");
        }
    }
    /**
     * Close down any resources being used by the module.
     * @returns Nothing.
     */
    async closedown() {
        this._logger?.info("Closedown");
        if (this._sessionExpiryTimerId) {
            window.clearTimeout(this._sessionExpiryTimerId);
            this._sessionExpiryTimerId = undefined;
        }
    }
    /**
     * Subscribe to one of the auth events.
     * @param to The event to subscribe to.
     * @param callback The callback to fire when the event occurs.
     * @returns Subscription id for unsubscribing or undefined if event type is not available.
     */
    subscribe(to, callback) {
        const subscriptionId = (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.randomUUID)();
        const toMap = this._eventSubscribers[to] ?? {};
        toMap[subscriptionId] = callback;
        this._eventSubscribers[to] = toMap;
        this._subscribeIdMap[subscriptionId] = to;
        this._logger?.info(`Subscription to ${to} events registered. Subscription Id: ${subscriptionId}`);
        return subscriptionId;
    }
    /**
     * Unsubscribe from an already subscribed event.
     * @param subscriptionId The id of the subscription returned from subscribe.
     * @returns True if the unsubscribe was successful.
     */
    unsubscribe(subscriptionId) {
        const eventType = this._subscribeIdMap[subscriptionId];
        if ((0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(eventType)) {
            this._logger?.warn(`You have tried to unsubscribe with a key ${subscriptionId} that is invalid`);
            return false;
        }
        const eventSubscribers = this._eventSubscribers[eventType];
        if (!(0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(eventSubscribers)) {
            delete eventSubscribers[subscriptionId];
        }
        if (this._subscribeIdMap[subscriptionId]) {
            delete this._subscribeIdMap[subscriptionId];
            this._logger?.info(`Subscription to ${eventType} events with subscription Id: ${subscriptionId} has been cleared`);
            return true;
        }
        this._logger?.warn(`Subscription to ${eventType} events with subscription Id: ${subscriptionId} could not be cleared as we do not have a register of that event type.`);
        return false;
    }
    /**
     * Does the auth provider require authentication.
     * @returns True if authentication is required.
     */
    async isAuthenticationRequired() {
        return (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this._authResult);
    }
    /**
     * Perform the login operation on the auth provider.
     * @returns True if the login was successful.
     */
    async login() {
        const providerUrl = this._definition?.data?.providerUrl;
        const clientId = this._definition?.data?.clientId;
        const loginRedirectUrl = this._definition?.data?.loginRedirectUrl;
        const scopes = this._definition?.data?.scopes;
        if ((0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(providerUrl) && (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(clientId) && (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(loginRedirectUrl)) {
            try {
                this._authResult = await (0,_openfin_openid_connect__WEBPACK_IMPORTED_MODULE_0__.authenticate)(providerUrl, clientId, loginRedirectUrl, scopes);
                await this.notifySubscribers("logged-in");
                this.checkForSessionExpiry();
                return true;
            }
            catch (err) {
                this._logger?.error("Authentication failed", (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.formatError)(err));
            }
        }
        return false;
    }
    /**
     * Perform the logout operation on the auth provider.
     * @returns True if the logout was successful.
     */
    async logout() {
        if (this._authResult) {
            if (this._sessionExpiryTimerId) {
                window.clearTimeout(this._sessionExpiryTimerId);
                this._sessionExpiryTimerId = undefined;
            }
            const logoutRedirectUrl = this._definition?.data?.logoutRedirectUrl;
            if ((0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(logoutRedirectUrl)) {
                try {
                    await this.notifySubscribers("before-logged-out");
                    await this._authResult.logout(logoutRedirectUrl);
                }
                catch (err) {
                    this._logger?.error("Logout failed", (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.formatError)(err));
                }
                finally {
                    await this.notifySubscribers("logged-out");
                }
            }
            this._authResult = undefined;
        }
        return true;
    }
    /**
     * Get user information from the auth provider.
     * @returns The user information, the type is unknown as it is dependent on the auth provider.
     */
    async getUserInfo() {
        if (this._authResult) {
            return this._authResult.userInfo;
        }
    }
    /**
     * Notify subscribers of an event change.
     * @param authEventType The type of authentication event to send to.
     */
    async notifySubscribers(authEventType) {
        const subscribers = this._eventSubscribers[authEventType];
        if (subscribers) {
            const subscriberIds = Object.keys(subscribers);
            subscriberIds.reverse();
            for (const subscriberId of subscriberIds) {
                this._logger?.info(`Notifying subscriber with subscription Id: ${subscriberId} of event type: ${authEventType}`);
                await subscribers[subscriberId]();
            }
        }
    }
    /**
     * Check to see if a session has expired.
     */
    checkForSessionExpiry() {
        const validity = this._definition?.data?.checkSessionValidityInSeconds;
        if ((0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isNumber)(validity) && validity > 0 && (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this._sessionExpiryTimerId)) {
            this._sessionExpiryTimerId = window.setTimeout(async () => {
                this._sessionExpiryTimerId = undefined;
                const idToken = this._authResult?.idToken;
                const providerUrl = this._definition?.data?.providerUrl;
                const clientId = this._definition?.data?.clientId;
                let isValid = false;
                if ((0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(idToken) && (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(providerUrl) && (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.isStringValue)(clientId)) {
                    try {
                        const result = await (0,_openfin_openid_connect__WEBPACK_IMPORTED_MODULE_0__.validateIdToken)(idToken, clientId, providerUrl);
                        isValid = result.valid;
                    }
                    catch (err) {
                        this._logger?.error("Failed validating token", (0,workspace_platform_starter_utils__WEBPACK_IMPORTED_MODULE_1__.formatError)(err));
                    }
                }
                if (isValid) {
                    this._logger?.info("Session Still Active");
                    this.checkForSessionExpiry();
                }
                else {
                    this._logger?.info("Session not valid");
                    this._authResult = undefined;
                    await this.notifySubscribers("session-expired");
                }
            }, validity * 1000);
        }
    }
}


/***/ }),

/***/ "../../node_modules/@openfin/openid-connect/openfin.openid-connect.mjs":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@openfin/openid-connect/openfin.openid-connect.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApiError: () => (/* binding */ Ve),
/* harmony export */   AuthenticationError: () => (/* binding */ Be),
/* harmony export */   InitializationError: () => (/* binding */ Xe),
/* harmony export */   LogoutError: () => (/* binding */ Ye),
/* harmony export */   ParameterError: () => (/* binding */ Qe),
/* harmony export */   ValidationError: () => (/* binding */ Ze),
/* harmony export */   authenticate: () => (/* binding */ et),
/* harmony export */   disableLogging: () => (/* binding */ tt),
/* harmony export */   enableLogging: () => (/* binding */ rt),
/* harmony export */   validateIdToken: () => (/* binding */ ot)
/* harmony export */ });
var e={d:(t,r)=>{for(var o in r)e.o(r,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:r[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{MS:()=>R,_7:()=>AuthenticationError,cX:()=>P,zL:()=>LogoutError,_W:()=>x,p8:()=>j,YR:()=>ze,U$:()=>Je,U7:()=>Ue,OF:()=>He});var r={d:(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},o={};r.d(o,{MS:()=>ApiError,cF:()=>ApiRequestError,AK:()=>AuthTokenExpiredError,M_:()=>AuthorizationError,cX:()=>InitializationError,Yd:()=>w,O4:()=>T,_W:()=>ParameterError,p8:()=>ValidationError,m$:()=>s,U$:()=>u,U7:()=>h,OV:()=>d,N7:()=>A,HP:()=>n,Rp:()=>O});class ApiError extends Error{constructor(e,t){var r,o;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"An unexpected error has occurred"),this.name=this.constructor.name,this.stack=(e?this.stack:null!==(o=null==t?void 0:t.stack)&&void 0!==o?o:this.stack).replace(/^(\w*Error)/,`${this.constructor.name}`)}}class ApiRequestError extends ApiError{constructor(e,t,r){var o;super(e=null!==(o=null!=e?e:null==r?void 0:r.message)&&void 0!==o?o:"An error occurred when executing the API request",r),this.status=t}}class AuthorizationError extends ApiError{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"An authorization error occurred",t)}}class AuthTokenExpiredError extends ApiError{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"The API request failed as the authorization tokens have expired",t)}}class InitializationError extends ApiError{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"An initialization error occurred",t)}}class ParameterError extends ApiError{constructor(e){super(e=null!=e?e:"Invalid parameter detected")}}class ValidationError extends ApiError{constructor(e,t){var r;super(e=null!==(r=null!=e?e:null==t?void 0:t.message)&&void 0!==r?r:"A token validation error occurred",t)}}const n=()=>void 0!==crypto.randomUUID?crypto.randomUUID():"10000000-1000-4000-8000-100000000000".replace(/[018]/g,(e=>{const t=window.crypto.getRandomValues(new Uint8Array(1))[0]&15>>Number(e)/4;return(Number(e)^t).toString(16)})),a="oauth-api-auth-flow",i=(e,t,r,o,n,a,i,s)=>async c=>{const d=new URL(c);if(0!==d.href.toLowerCase().indexOf(n.toLowerCase()))return!1;if(window.clearInterval(s),window.clearTimeout(t),window.clearTimeout(r),e.removeAllListeners(),e.close(!0),d.searchParams.get("error")){const e=new AuthorizationError("Authorization error");return e.data=d.toString(),i(e),!0}if(d.searchParams.get("state")!==o){const e=new AuthorizationError("State mismatch");return e.data=d.toString(),i(e),!0}const l=d.searchParams.get("code");if(!l){const e=new AuthorizationError("Authorization code missing");return e.data=d.toString(),i(e),!0}return a(l),!0},s=async(e,t,r={})=>{const{defaultHeight:o,defaultWidth:n}=r;return t(await fin.Window.create(Object.assign({alwaysOnTop:!0,maximizable:!1,minimizable:!1,autoShow:!1,defaultCentered:!0,defaultHeight:null!=o?o:750,defaultWidth:null!=n?n:600,includeInSnapshots:!1,name:a,resizable:!1,saveWindowState:!1,showTaskbarIcon:!1,url:e},r)))},c=(e,t,r)=>o=>new Promise(((n,a)=>{let s;const c=window.setTimeout((()=>{window.clearInterval(s),window.clearTimeout(c),o.removeAllListeners(),o.close(!0),a(new AuthorizationError("Authorization timed out"))}),3e5);o.addListener("closing",(async()=>{r.logInfo("User closed auth window"),window.clearInterval(s),window.clearTimeout(c),o.removeAllListeners(),a(new AuthorizationError("Failed to complete authorization code flow"))}));const d=window.setTimeout((async()=>{try{await o.isShowing()||(r.logInfo("Showing auth window"),await o.show(!0),await o.focus())}catch(e){r.logWarning("Unable to show auth window")}}),2e3);(async()=>{const{version:l}=await fin.System.getRuntimeInfo();parseInt(l.split(".")[0],10)>=30?await i(o,c,d,e,t,n,a)((await o.getInfo()).url)||await o.addListener("url-changed",(s=>{r.logInfo("Auth window navigated to",s.url),i(o,c,d,e,t,n,a)(s.url)})):s=window.setInterval((()=>(async(e,t,r,o,n,a,s,c)=>{let d;try{d=await e.getInfo()}catch(e){return window.clearInterval(t),window.clearTimeout(r),window.clearTimeout(o),c(new AuthorizationError("Could not locate auth window")),!1}return i(e,r,o,n,a,s,c,t)(d.url)})(o,s,c,d,e,t,n,a)),500)})()})),d=async(e,t)=>{let r;null==t||t.logInfo("Retrieving authorization server metadata",e);try{r=new URL(e)}catch(e){throw new ParameterError("Unexpected invalid discovery URL")}const o=await fetch(r,{headers:{Accept:"application/json"}});if(!o.ok)throw new Error("Failed to retrieve authorization server metadata");const n=await o.json();if(!n)throw new Error("Unexpected empty authorization server metadata response");return null==t||t.logInfo("Retrieved authorization server metadata",n),n},l=e=>{let t=fin.Integrations;t||(fin.Integrations={},t=fin.Integrations);let r=t[e];return r||(t[e]={},r=t[e]),r},u=e=>{l(e).loggingEnabled=!1},h=(e,t="0.0.0")=>{l(e).loggingEnabled=!0,console.log(p(e),`v${t}`)},p=e=>`[@openfin/${e.toLowerCase()}]`;class w{constructor(e){this.name=e,this.prefix=p(e),this.isLoggingEnabled=this.isLoggingEnabled.bind(this),this.logError=this.logError.bind(this),this.logInfo=this.logInfo.bind(this),this.logWarning=this.logWarning.bind(this)}isLoggingEnabled(){return l(this.name).loggingEnabled}logError(e){this.isLoggingEnabled()&&(e.innerError?console.error(this.prefix,e,"\n\n(inner)",e.innerError):console.error(this.prefix,e))}logInfo(...e){this.isLoggingEnabled()&&console.log(this.prefix,...e)}logWarning(...e){this.isLoggingEnabled()&&console.warn(this.prefix,...e)}}const g=()=>{let e,t,r,o,n;const a=async(t,r=!1)=>{const{command:o,data:n,id:s}=t,c={command:o,id:s};try{if(!e)throw new Error("Access token not found");const{apiRequestUrl:o,data:s,headers:d,httpMethod:l,includeAuthorization:u}=n,h=await(async(t,r,o,n,a)=>{var i,s;const c=Object.assign({Accept:"application/json"},n);"PATCH"!==r&&"POST"!==r&&"PUT"!==r||/content-type/i.test(Object.keys(c).join(","))||(c["Content-Type"]="application/json"),a&&(c.Authorization=`Bearer ${e}`);const d=await fetch(t,{body:"object"==typeof o?JSON.stringify(o):o,headers:c,method:r});if(!d.ok){const e={message:"Failed to execute API request"};return(null===(i=d.headers.get("Content-Type"))||void 0===i?void 0:i.includes("application/json"))&&(e.data=await d.json()),[d.status,void 0,void 0,e]}let l;const u=null!==(s=d.headers.get("Content-Type"))&&void 0!==s?s:"";switch(!0){case!u:break;case/^application\/(\w+\+)?json/i.test(u):l=await d.json();break;case/^multipart\/form-?data|^application\/x-?www-?form-?urlencoded/i.test(u):l=await d.formData();break;case/^application\/(([^/]+)?xml|vnd\.openxmlformats)|^text\/|^image\/svg/i.test(u):l=await d.text();break;default:l=await d.arrayBuffer()}return[d.status,l,u,void 0]})(o,l,s,d,u),[p,w,g,f]=h;if(c.status=p,f){if(!r&&401===p){const[e,r]=await i();return r?(c.status=e,c.error=r,c):await a(t,!0)}c.error=f}else w&&(c.data=w,c.type=g)}catch(e){e instanceof Error?c.error={message:e.message}:c.error={message:"Failed to execute API request"}}return Promise.resolve(c)},i=async()=>{var r;if(!o)throw new Error("Authorization server metadata not set");if(!t)throw new Error("Client ID not set");const a=`grant_type=refresh_token&client_id=${t}&refresh_token=${n}`,i=await fetch(o.token_endpoint,{body:a,headers:{Accept:"application/json","Content-Type":"application/x-www-form-urlencoded"},method:"POST"});if(!i.ok){const e={message:"Failed to refresh access token"};return(null===(r=i.headers.get("Content-Type"))||void 0===r?void 0:r.includes("application/json"))&&(e.data=await i.json()),[i.status,e]}const s=await i.json();return e=s.access_token,[i.status]};self.onmessage=async i=>{const{command:s,id:c}=i.data;let d={command:s,id:c};switch(s){case"API_REQUEST":d=await a(i.data);break;case"CODE_EXCHANGE":d=await(async a=>{var i;const{command:s,data:c,id:d}=a,l={command:s,id:d};try{if(!o)throw new Error("Authorization server metadata not set");if(!t)throw new Error("Client ID not set");const{code:a,codeVerifier:s,redirectUri:d}=c,u=`grant_type=authorization_code&client_id=${t}&code=${a}&code_verifier=${s}&redirect_uri=${d}`,h=await fetch(o.token_endpoint,{body:u,headers:{Accept:"application/json","Content-Type":"application/x-www-form-urlencoded"},method:"POST"});if(h.ok){const t=await h.json();e=t.access_token,r=t.id_token,n=t.refresh_token}else{const e={message:"Failed to retrieve tokens"};(null===(i=h.headers.get("Content-Type"))||void 0===i?void 0:i.includes("application/json"))&&(e.data=await h.json()),l.error=e}}catch(e){e instanceof Error?l.error={message:e.message}:l.error={message:"Failed to retrieve tokens"}}return Promise.resolve(l)})(i.data);break;case"EXPIRE_TOKENS":d=await(async r=>{var a;const{command:i,expireAccessTokenOnly:s,id:c}=r,d={command:i,id:c};try{if(!o)throw new Error("Authorization server metadata not set");if(!o.revocation_endpoint)throw new Error("Revocation endpoint missing in authorization server metadata");if(!s&&!n)throw new Error("Refresh token not found");const r=o.revocation_endpoint;let i,c=!1;const l={body:`client_id=${t}`,headers:{Accept:"application/json","Content-Type":"application/x-www-form-urlencoded"},method:"POST"};if(s){const t=await fetch(r,Object.assign(Object.assign({},l),{body:`${l.body}&token=${e}&token_type_hint=access_token`}));t.ok||(c=!0,(null===(a=t.headers.get("Content-Type"))||void 0===a?void 0:a.includes("application/json"))&&(i=await t.json()))}else{const t=(await Promise.all([await fetch(r,Object.assign(Object.assign({},l),{body:`${l.body}&token=${e}&token_type_hint=access_token`})),await fetch(r,Object.assign(Object.assign({},l),{body:`${l.body}&token=${n}&token_type_hint=refresh_token`}))])).filter((e=>!e.ok));t.length&&(c=!0,i=await t[0].json())}if(c){const e={data:i,message:"Failed to expire tokens"};d.error=e}}catch(e){e instanceof Error?d.error={message:e.message}:d.error={message:"Failed to expire tokens"}}return Promise.resolve(d)})(i.data);break;case"GET_ID_TOKEN":l=i.data,d=Object.assign(Object.assign({},l),{idToken:r});break;case"INIT":d=await(async e=>{const{command:r,data:n,id:a}=e,i={command:r,id:a};return t=n.clientId,o=n.metadata,Promise.resolve(i)})(i.data);break;default:d.error=new Error(`Unexpected oauth worker command: ${s}`)}var l;self.postMessage(d)}};var f;!function(e){e.ApiRequest="API_REQUEST",e.CodeExchange="CODE_EXCHANGE",e.ExpireTokens="EXPIRE_TOKENS",e.GetIdToken="GET_ID_TOKEN",e.Init="INIT"}(f||(f={}));const m=[],y=e=>{m.push(e)},E=(e,t)=>(r,o,a)=>new Promise(((i,s)=>{const c={command:f.CodeExchange,data:{code:r,codeVerifier:o,redirectUri:a},id:n()},{command:d,id:l}=c;y({command:d,id:l,reject:s,resolve:i}),e.postMessage(c),t.logInfo("Worker request sent",c)})),v=(e,t,r)=>(o,a,i,s,c)=>new Promise(((d,l)=>{const u={command:f.ApiRequest,data:{apiRequestUrl:o,clientId:e,data:i,headers:s,httpMethod:a,includeAuthorization:c},id:n()},{command:h,id:p}=u;y({command:h,id:p,reject:l,resolve:d}),t.postMessage(u),r.logInfo("Worker request sent",u)})),S=(e,t)=>r=>new Promise(((o,a)=>{const i={command:f.ExpireTokens,expireAccessTokenOnly:r,id:n()},{command:s,id:c}=i;y({command:s,id:c,reject:a,resolve:o}),e.postMessage(i),t.logInfo("Worker request sent",i)})),b=(e,t)=>async()=>(await new Promise(((r,o)=>{const a={command:f.GetIdToken,id:n()},{command:i,id:s}=a;y({command:i,id:s,reject:o,resolve:r}),e.postMessage(a),t.logInfo("Worker request sent",a)}))).idToken,A=async(e,t,r)=>{const o=new Blob([`(${g})()`],{type:"text/javascript"}),a=URL.createObjectURL(o),i=new Worker(a);return i.onmessage=_(r),await((e,t,r,o)=>new Promise(((a,i)=>{const s={command:f.Init,data:{clientId:t,metadata:e},id:n()},{command:c,id:d}=s;y({command:c,id:d,reject:i,resolve:a}),r.postMessage(s),o.logInfo("Worker request sent",s)})))(e,t,i,r),{exchangeCodeForTokens:E(i,r),executeApiRequest:v(t,i,r),expireTokens:S(i,r),getIdToken:b(i,r),terminate:I(i,r)}},_=e=>t=>{e.logInfo("Worker response received",t.data);const r=t.data,{command:o,error:n,id:a}=r,i=function(e,t){var r={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(r[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(o=Object.getOwnPropertySymbols(e);n<o.length;n++)t.indexOf(o[n])<0&&Object.prototype.propertyIsEnumerable.call(e,o[n])&&(r[o[n]]=e[o[n]])}return r}(r,["command","error","id"]),s=((e,t)=>m.find((r=>r.command===t&&r.id===e)))(a,o);s?(n?("status"in i&&void 0!==i.status&&(n.status=i.status),s.reject(n)):s.resolve(i),k(a,o)):e.logError(new Error("Unable to locate awaited request"))},k=(e,t)=>{const r=m.findIndex((r=>r.command===t&&r.id===e));r>=0&&m.splice(r,1)},I=(e,t)=>async()=>{try{await S(e,t)(!1)}catch(e){t.logWarning(e.message)}e.terminate(),t.logInfo("Worker terminated")};class T{get apiOrigin(){return this._apiOrigin}get clientId(){return this._clientId}get logger(){return this._logger}get metadata(){return this._metadata}get worker(){return this._worker}constructor(e,t,r,o,n){if(this.executeApiRequest=async(e,t="GET",r,o,n=!0,a=!1)=>{this._logger.logInfo("ExecuteApiRequest started",e,t,r,o);try{const a=await((e,t)=>async(r,o,n,a,i)=>{try{return await t.executeApiRequest(`${e}${r}`,o,n,a,i)}catch(e){let t;const{data:r,message:o,status:n}=e;throw t=e instanceof Error?new ApiRequestError(o,n):"Failed to refresh access token"===o?new AuthTokenExpiredError(o):new ApiRequestError(o,n),t.data=r,t}})(this._apiOrigin,this._worker)(e,t,r,o,n);return this._logger.logInfo("ExecuteApiRequest completed",a),a}catch(e){if(e instanceof ApiRequestError){const{data:t,message:r,name:o,stack:n}=e,a=this.getErrorMessageFromServerResponse(t);a&&(e.message=a,e.stack=null==n?void 0:n.replace(`${o}: ${r}`,`${o}: ${a}`))}throw a&&this.logger.logError(e),e}},!(t&&r&&o&&n))throw new InitializationError("Provider has not been properly initialized (call init to create new instances)");this._apiOrigin=null!=e?e:"",this._clientId=t,this._metadata=r,this._worker=o,this._logger=n,this.authorize=this.authorize.bind(this),this.close=this.close.bind(this),this.executeApiRequest=this.executeApiRequest.bind(this),this.expireTokens=this.expireTokens.bind(this),this.getErrorMessageFromServerResponse=this.getErrorMessageFromServerResponse.bind(this),this.getIdToken=this.getIdToken.bind(this)}async authorize(e,t,r){this._logger.logInfo("Authorize started",e,t,r);try{await(o=this._metadata,i=this._clientId,d=this._worker,l=this._logger,async(e,t={},r={})=>{const{authorization_endpoint:u}=o,h=fin.Application.getCurrentSync(),p=(await h.getChildWindows()).find((e=>e.identity.name===a));p&&await p.close(!0);const w=n(),g=(()=>{const e=new Uint32Array(64);return window.crypto.getRandomValues(e),Array.from(e,(e=>`0${e.toString(16)}`.slice(-2))).join("")})(),f=(await(async e=>{const t=(new TextEncoder).encode(e),r=await window.crypto.subtle.digest("SHA-256",t),o=await(e=>new Promise(((t,r)=>{try{const o=new Blob([e]),n=new FileReader;n.onload=e=>{var o,n;const a=null===(o=e.target)||void 0===o?void 0:o.result;if(a){const[,e]=Array.from(null!==(n=a.match(/base64,(.*)$/i))&&void 0!==n?n:[]);t(null!=e?e:"")}r(new Error("Unexpected empty result"))},n.readAsDataURL(o)}catch(e){r(e)}})))(r);return o.replace(/\+/g,"-").replace(/\//g,"_")})(g)).replace(/=+$/,""),m=new URL(u);m.searchParams.set("client_id",i),m.searchParams.set("redirect_uri",e),m.searchParams.set("response_type","code"),m.searchParams.set("state",w),m.searchParams.set("code_challenge",f),m.searchParams.set("code_challenge_method","S256"),Object.entries(t).forEach((e=>m.searchParams.set(e[0],e[1]))),l.logInfo("Starting OAuth flow",m,r);const y=await s(m.toString(),c(w,e,l),r);l.logInfo("Received authorization code"),await d.exchangeCodeForTokens(y,g,e),l.logInfo("Received tokens")})(e,t,r),this._logger.logInfo("Authorize completed")}catch(e){let t;if(e instanceof ApiError){const{data:r}=e,o=this.getErrorMessageFromServerResponse(r);t=new AuthorizationError(o,e),t.data=r}else t=new AuthorizationError(void 0,e);throw this.logger.logError(t),t}var o,i,d,l}async close(){var e;this._logger.logInfo("Close started");try{await(null===(e=this._worker)||void 0===e?void 0:e.terminate()),this._worker=void 0,this._apiOrigin=void 0,this._clientId=void 0,this._metadata=void 0,this._logger.logInfo("Close completed")}catch(e){const t=new ApiError(void 0,e);throw this._logger.logError(t),t}}async expireTokens(e=!1){var t;this._logger.logInfo("ExpireTokens started");try{await(null===(t=this._worker)||void 0===t?void 0:t.expireTokens(e)),this._logger.logInfo("ExpireTokens completed")}catch(e){const t=new ApiError(void 0,e);throw this._logger.logError(t),t}}getErrorMessageFromServerResponse(e){e&&this._logger.logWarning(e)}async getIdToken(){var e;this._logger.logInfo("GetIdToken started");try{const t=await(null===(e=this._worker)||void 0===e?void 0:e.getIdToken());return this._logger.logInfo("GetIdToken completed",t),t}catch(e){const t=new ApiError(void 0,e);throw this._logger.logError(t),t}}static async init(e,t,r,o,...n){const a=new w(o);a.logInfo("Init started",e,t,r);try{let o;if("discoveryEndpoint"in e){const{additionalMetadata:t,discoveryEndpoint:r}=e;o=Object.assign(Object.assign({},await d(r)),null!=t?t:{})}else o=e;if(!o.response_types_supported.find((e=>"code"===e.toLowerCase())))throw new InitializationError("Authorization server does not support the authorization code response type");const n=await A(o,r,a),i=new T(t,r,o,n,a);return a.logInfo("Init completed",i),i}catch(e){let t;throw t=e instanceof ApiError?e:new InitializationError(void 0,e),a.logError(t),t}}}const O=e=>async(t,r,o)=>{let n;null==e||e.logInfo("Validating token against introspection endpoint",t,r,o);try{n=await fetch(o,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:`token=${t}&client_id=${r}`})}catch(e){throw new ValidationError(void 0,e)}if(n.ok){const t=await n.json(),{active:r}=t,o=function(e,t){var r={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(r[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(o=Object.getOwnPropertySymbols(e);n<o.length;n++)t.indexOf(o[n])<0&&Object.prototype.propertyIsEnumerable.call(e,o[n])&&(r[o[n]]=e[o[n]])}return r}(t,["active"]),a=Object.assign({valid:r},o);return null==e||e.logInfo("Token validation result",a),a}const a=await n.json();throw null==e||e.logWarning("Token Validation failed",a),new ValidationError};var R=o.MS,P=o.cX,C=o.Yd,W=o.O4,x=o._W,j=o.p8,$=o.m$,J=o.U$,U=o.U7,K=o.OV,D=o.N7,L=o.Rp;const H=new TextEncoder,M=new TextDecoder;function z(...e){const t=e.reduce(((e,{length:t})=>e+t),0),r=new Uint8Array(t);let o=0;return e.forEach((e=>{r.set(e,o),o+=e.length})),r}const N=e=>{let t=e;t instanceof Uint8Array&&(t=M.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r})(t)}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};class JOSEError extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){var t;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,null===(t=Error.captureStackTrace)||void 0===t||t.call(Error,this,this.constructor)}}class F extends JOSEError{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=t,this.reason=r}}class q extends JOSEError{static get code(){return"ERR_JWT_EXPIRED"}constructor(e,t="unspecified",r="unspecified"){super(e),this.code="ERR_JWT_EXPIRED",this.claim=t,this.reason=r}}class G extends JOSEError{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class V extends JOSEError{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class B extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class X extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class Y extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}static get code(){return"ERR_JWKS_INVALID"}}class Q extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWKS_NO_MATCHING_KEY",this.message="no applicable key found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_NO_MATCHING_KEY"}}class Z extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS",this.message="multiple matching keys found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}Symbol.asyncIterator;class ee extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWKS_TIMEOUT",this.message="request timed out"}static get code(){return"ERR_JWKS_TIMEOUT"}}class te extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}const re=crypto,oe=e=>e instanceof CryptoKey;re.getRandomValues.bind(re);const ne=async e=>{var t,r;if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:o,keyUsages:n}=function(e){let t,r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.slice(-3)}`},r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new V(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"},r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"},r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"},r=["deriveBits"];break;default:throw new V('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new V('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new V('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new V('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new V('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}(e),a=[o,null!==(t=e.ext)&&void 0!==t&&t,null!==(r=e.key_ops)&&void 0!==r?r:n];if("PBKDF2"===o.name)return re.subtle.importKey("raw",N(e.k),...a);const i={...e};return delete i.alg,delete i.use,re.subtle.importKey("jwk",i,...a)};function ae(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let r=e;for(;null!==Object.getPrototypeOf(r);)r=Object.getPrototypeOf(r);return Object.getPrototypeOf(e)===r}const ie=function(e,t,r,o,n){if(void 0!==n.crit&&void 0===o.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!o||void 0===o.crit)return new Set;if(!Array.isArray(o.crit)||0===o.crit.length||o.crit.some((e=>"string"!=typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let a;a=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of o.crit){if(!a.has(t))throw new V(`Extension Header Parameter "${t}" is not recognized`);if(void 0===n[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(a.get(t)&&void 0===o[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(o.crit)};Symbol();function se(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function ce(e,t){return e.name===t}function de(e){return parseInt(e.name.slice(4),10)}function le(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function ue(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!ce(e.algorithm,"HMAC"))throw se("HMAC");const r=parseInt(t.slice(2),10);if(de(e.algorithm.hash)!==r)throw se(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!ce(e.algorithm,"RSASSA-PKCS1-v1_5"))throw se("RSASSA-PKCS1-v1_5");const r=parseInt(t.slice(2),10);if(de(e.algorithm.hash)!==r)throw se(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!ce(e.algorithm,"RSA-PSS"))throw se("RSA-PSS");const r=parseInt(t.slice(2),10);if(de(e.algorithm.hash)!==r)throw se(`SHA-${r}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw se("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!ce(e.algorithm,"ECDSA"))throw se("ECDSA");const r=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==r)throw se(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}le(e,r)}function he(e,t,...r){if(r.length>2){const t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else 2===r.length?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor&&t.constructor.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const pe=(e,...t)=>he("Key must be ",e,...t);function we(e,t,...r){return he(`Key for the ${e} algorithm must be `,t,...r)}const ge=e=>oe(e),fe=["CryptoKey"];const me=async(e,t,r,o)=>{const n=await function(e,t,r){if(oe(t))return ue(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(pe(t,...fe));return re.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(pe(t,...fe,"Uint8Array"))}(e,t,"verify");((e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!=typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}})(e,n);const a=function(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new V(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}(e,n.algorithm);try{return await re.subtle.verify(a,n,r,o)}catch(e){return!1}},ye=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return!1;r.add(e)}else r=new Set(t)}return!0},Ee=(e,t,r)=>{e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?((e,t)=>{if(!(t instanceof Uint8Array)){if(!ge(t))throw new TypeError(we(e,t,...fe,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${fe.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(e,t):((e,t,r)=>{if(!ge(t))throw new TypeError(we(e,t,...fe));if("secret"===t.type)throw new TypeError(`${fe.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===r&&"public"===t.type)throw new TypeError(`${fe.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===r&&"public"===t.type)throw new TypeError(`${fe.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===r&&"private"===t.type)throw new TypeError(`${fe.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===r&&"private"===t.type)throw new TypeError(`${fe.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(e,t,r)},ve=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!=typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function Se(e,t,r){if(e instanceof Uint8Array&&(e=M.decode(e)),"string"!=typeof e)throw new B("Compact JWS must be a string or Uint8Array");const{0:o,1:n,2:a,length:i}=e.split(".");if(3!==i)throw new B("Invalid Compact JWS");const s=await async function(e,t,r){var o;if(!ae(e))throw new B("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new B('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new B("JWS Protected Header incorrect type");if(void 0===e.payload)throw new B("JWS Payload missing");if("string"!=typeof e.signature)throw new B("JWS Signature missing or incorrect type");if(void 0!==e.header&&!ae(e.header))throw new B("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const t=N(e.protected);n=JSON.parse(M.decode(t))}catch(e){throw new B("JWS Protected Header is invalid")}if(!ye(n,e.header))throw new B("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...n,...e.header};let i=!0;if(ie(B,new Map([["b64",!0]]),null==r?void 0:r.crit,n,a).has("b64")&&(i=n.b64,"boolean"!=typeof i))throw new B('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=a;if("string"!=typeof s||!s)throw new B('JWS "alg" (Algorithm) Header Parameter missing or invalid');const c=r&&ve("algorithms",r.algorithms);if(c&&!c.has(s))throw new G('"alg" (Algorithm) Header Parameter not allowed');if(i){if("string"!=typeof e.payload)throw new B("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new B("JWS Payload must be a string or an Uint8Array instance");let d=!1;"function"==typeof t&&(t=await t(n,e),d=!0),Ee(s,t,"verify");const l=z(H.encode(null!==(o=e.protected)&&void 0!==o?o:""),H.encode("."),"string"==typeof e.payload?H.encode(e.payload):e.payload),u=N(e.signature);if(!await me(s,t,u,l))throw new te;let h;h=i?N(e.payload):"string"==typeof e.payload?H.encode(e.payload):e.payload;const p={payload:h};return void 0!==e.protected&&(p.protectedHeader=n),void 0!==e.header&&(p.unprotectedHeader=e.header),d?{...p,key:t}:p}({payload:n,protected:o,signature:a},t,r),c={payload:s.payload,protectedHeader:s.protectedHeader};return"function"==typeof t?{...c,key:s.key}:c}const be=86400,Ae=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i,_e=e=>{const t=Ae.exec(e);if(!t)throw new TypeError("Invalid time period format");const r=parseFloat(t[1]);switch(t[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(60*r);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(3600*r);case"day":case"days":case"d":return Math.round(r*be);case"week":case"weeks":case"w":return Math.round(604800*r);default:return Math.round(31557600*r)}},ke=e=>e.toLowerCase().replace(/^application\//,""),Ie=(e,t,r={})=>{const{typ:o}=r;if(o&&("string"!=typeof e.typ||ke(e.typ)!==ke(o)))throw new F('unexpected "typ" JWT header value',"typ","check_failed");let n;try{n=JSON.parse(M.decode(t))}catch(e){}if(!ae(n))throw new X("JWT Claims Set must be a top-level JSON object");const{requiredClaims:a=[],issuer:i,subject:s,audience:c,maxTokenAge:d}=r;void 0!==d&&a.push("iat"),void 0!==c&&a.push("aud"),void 0!==s&&a.push("sub"),void 0!==i&&a.push("iss");for(const e of new Set(a.reverse()))if(!(e in n))throw new F(`missing required "${e}" claim`,e,"missing");if(i&&!(Array.isArray(i)?i:[i]).includes(n.iss))throw new F('unexpected "iss" claim value',"iss","check_failed");if(s&&n.sub!==s)throw new F('unexpected "sub" claim value',"sub","check_failed");if(c&&(l=n.aud,u="string"==typeof c?[c]:c,!("string"==typeof l?u.includes(l):Array.isArray(l)&&u.some(Set.prototype.has.bind(new Set(l))))))throw new F('unexpected "aud" claim value',"aud","check_failed");var l,u;let h;switch(typeof r.clockTolerance){case"string":h=_e(r.clockTolerance);break;case"number":h=r.clockTolerance;break;case"undefined":h=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:p}=r,w=(g=p||new Date,Math.floor(g.getTime()/1e3));var g;if((void 0!==n.iat||d)&&"number"!=typeof n.iat)throw new F('"iat" claim must be a number',"iat","invalid");if(void 0!==n.nbf){if("number"!=typeof n.nbf)throw new F('"nbf" claim must be a number',"nbf","invalid");if(n.nbf>w+h)throw new F('"nbf" claim timestamp check failed',"nbf","check_failed")}if(void 0!==n.exp){if("number"!=typeof n.exp)throw new F('"exp" claim must be a number',"exp","invalid");if(n.exp<=w-h)throw new q('"exp" claim timestamp check failed',"exp","check_failed")}if(d){const e=w-n.iat;if(e-h>("number"==typeof d?d:_e(d)))throw new q('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(e<0-h)throw new F('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return n};function Te(e){return e&&"object"==typeof e&&Array.isArray(e.keys)&&e.keys.every(Oe)}function Oe(e){return ae(e)}class Re{constructor(e){if(this._cached=new WeakMap,!Te(e))throw new Y("JSON Web Key Set malformed");var t;this._jwks=(t=e,"function"==typeof structuredClone?structuredClone(t):JSON.parse(JSON.stringify(t)))}async getKey(e,t){const{alg:r,kid:o}={...e,...null==t?void 0:t.header},n=function(e){switch("string"==typeof e&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new V('Unsupported "alg" value for a JSON Web Key Set')}}(r),a=this._jwks.keys.filter((e=>{let t=n===e.kty;if(t&&"string"==typeof o&&(t=o===e.kid),t&&"string"==typeof e.alg&&(t=r===e.alg),t&&"string"==typeof e.use&&(t="sig"===e.use),t&&Array.isArray(e.key_ops)&&(t=e.key_ops.includes("verify")),t&&"EdDSA"===r&&(t="Ed25519"===e.crv||"Ed448"===e.crv),t)switch(r){case"ES256":t="P-256"===e.crv;break;case"ES256K":t="secp256k1"===e.crv;break;case"ES384":t="P-384"===e.crv;break;case"ES512":t="P-521"===e.crv}return t})),{0:i,length:s}=a;if(0===s)throw new Q;if(1!==s){const e=new Z,{_cached:t}=this;throw e[Symbol.asyncIterator]=async function*(){for(const e of a)try{yield await Pe(t,e,r)}catch(e){continue}},e}return Pe(this._cached,i,r)}}async function Pe(e,t,r){const o=e.get(t)||e.set(t,{}).get(t);if(void 0===o[r]){const e=await async function(e,t,r){var o;if(!ae(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return null!=r||(r=!0!==e.ext),r?ne({...e,alg:t,ext:null!==(o=e.ext)&&void 0!==o&&o}):N(e.k);case"RSA":if(void 0!==e.oth)throw new V('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return ne({...e,alg:t});default:throw new V('Unsupported "kty" (Key Type) Parameter value')}}({...t,ext:!0},r);if(e instanceof Uint8Array||"public"!==e.type)throw new Y("JSON Web Key Set members must be public keys");o[r]=e}return o[r]}const Ce=async(e,t,r)=>{let o,n,a=!1;"function"==typeof AbortController&&(o=new AbortController,n=setTimeout((()=>{a=!0,o.abort()}),t));const i=await fetch(e.href,{signal:o?o.signal:void 0,redirect:"manual",headers:r.headers}).catch((e=>{if(a)throw new ee;throw e}));if(void 0!==n&&clearTimeout(n),200!==i.status)throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await i.json()}catch(e){throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON")}};class We extends Re{constructor(e,t){if(super({keys:[]}),this._jwks=void 0,!(e instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(e.href),this._options={agent:null==t?void 0:t.agent,headers:null==t?void 0:t.headers},this._timeoutDuration="number"==typeof(null==t?void 0:t.timeoutDuration)?null==t?void 0:t.timeoutDuration:5e3,this._cooldownDuration="number"==typeof(null==t?void 0:t.cooldownDuration)?null==t?void 0:t.cooldownDuration:3e4,this._cacheMaxAge="number"==typeof(null==t?void 0:t.cacheMaxAge)?null==t?void 0:t.cacheMaxAge:6e5}coolingDown(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cooldownDuration}fresh(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cacheMaxAge}async getKey(e,t){this._jwks&&this.fresh()||await this.reload();try{return await super.getKey(e,t)}catch(r){if(r instanceof Q&&!1===this.coolingDown())return await this.reload(),super.getKey(e,t);throw r}}async reload(){this._pendingFetch&&("undefined"!=typeof WebSocketPair||"undefined"!=typeof navigator&&"Cloudflare-Workers"===navigator.userAgent||"undefined"!=typeof EdgeRuntime&&"vercel"===EdgeRuntime)&&(this._pendingFetch=void 0),this._pendingFetch||(this._pendingFetch=Ce(this._url,this._timeoutDuration,this._options).then((e=>{if(!Te(e))throw new Y("JSON Web Key Set malformed");this._jwks={keys:e.keys},this._jwksTimestamp=Date.now(),this._pendingFetch=void 0})).catch((e=>{throw this._pendingFetch=void 0,e}))),await this._pendingFetch}}const xe=N;class AuthenticationError extends R{constructor(e,t){super(e=e??t?.message??"An error occurred during authentication",t)}}class LogoutError extends R{constructor(e,t){super(e=e??t?.message??"An error occurred during logout",t)}}const je="1.0.0",$e="OIDC",Je=()=>{J($e)},Ue=()=>{U($e,je)};"undefined"!=typeof window&&("undefined"==typeof fin&&Object.assign(window,{fin:{}}),Object.assign(fin,{Integrations:{OIDC:{enableLogging:Ue,disableLogging:Je}}}));const Ke=e=>`${e.replace(/\/$/,"")}/.well-known/openid-configuration`;var De;!function(e){e.OpenIdConnect="OpenID-Connect"}(De||(De={}));class Le extends W{get idToken(){return this._idToken}get openIdProviderUrl(){return this._openIdProviderUrl}get redirectUri(){return this._redirectUri}get scope(){return this._scope}get userInfo(){return this._userInfo}async authorize(e,t,r){await super.authorize(e,t,r),this._idToken=await this.getIdToken(),this._userInfo=await(async e=>{const t=e.metadata?.userinfo_endpoint;if(!t)return;const{data:r}=await e.executeApiRequest(t);return r})(this)}async close(){await super.close(),this._idToken=void 0,this._openIdProviderUrl=void 0,this._redirectUri=void 0,this._scope=void 0,this._userInfo=void 0}getErrorMessageFromServerResponse(e){return e}static async init(e,t,r,o,n,a,i){const s=new C(o);s.logInfo("Init started",e,t,r,o,n,a,i);try{const{additionalMetadata:t,discoveryEndpoint:o}=e,c={...await K(o),...t??{}};if(!c.response_types_supported.find((e=>"code"===e.toLowerCase())))throw new P("OpenID Provider does not support the authorization code response type");const d=await D(c,r,s),l=new Le(void 0,r,c,d,s);return l._openIdProviderUrl=n,l._redirectUri=a,l._scope=i,s.logInfo("Init completed",l),(async(e,t)=>{try{await fin.System.registerUsage({type:"integration-feature",data:{apiVersion:je,componentName:e}})}catch(r){t.logWarning(`Unable to register usage for feature ${e}: ${r?.message}`)}})(De.OpenIdConnect,s),l}catch(e){let t;throw t=e instanceof R?e:new P(void 0,e),s.logError(t),t}}}const He=async(e,t,r)=>{const o=new C($e),n=Ke(r);let a;try{a=await K(n)}catch(e){const t=new j(`Failed to retrieve OpenID Connect metadata from ${n}`);throw o.logError(t),t}const{introspection_endpoint:i,jwks_uri:s}=a;if(i)try{return await L(o)(e,t,i)}catch(e){}else o?.logWarning("No introspection endpoint found in OpenID Connect metadata");if(!s){const e=new j(`Failed to retrieve JSON Web Key Set (JWKS) from ${s}`);throw o.logError(e),e}o?.logInfo("Validating id token against JWKS endpoint",s);try{const{payload:n}=await async function(e,t,r){var o;const n=await Se(e,t,r);if((null===(o=n.protectedHeader.crit)||void 0===o?void 0:o.includes("b64"))&&!1===n.protectedHeader.b64)throw new X("JWTs MUST NOT use unencoded payload");const a={payload:Ie(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return"function"==typeof t?{...a,key:n.key}:a}(e,function(e,t){const r=new We(e,t);return async function(e,t){return r.getKey(e,t)}}(new URL(s)),{audience:t,issuer:r});return o?.logInfo("ID token validation successful",n),{valid:!0,...n}}catch(e){if(!(e instanceof F||e instanceof q||e instanceof X||e instanceof te)){const t=new j(void 0,e);throw o.logError(t),t}return o.logWarning(`ID token validation failed: ${e.message}`),{valid:!1}}},Me=["openid","profile","email"],ze=async(e,t,r,o=[],n,a,i)=>{if(e=e?.trim().replace(/\/$/,""),!e)throw new x("OpenID Provider URL must be a non-empty string");if(!t)throw new x("Client Identifier must be a non-empty string");if(!r)throw new x("Redirection URI must be a non-empty string");const s=await Fe(e,t,r,o,n);if(!s)throw new P("Provider not initialized");const c=s.metadata?.scopes_supported;if(!c){const e=new AuthenticationError("OpenID Provider metadata does not define supported scopes");throw s.logger.logError(e),e}const d=Me.filter((e=>!c.includes(e)));if(d.length>0){const e=new AuthenticationError(`OpenID Provider does not support required scopes: ${d.join(", ")}`);throw s.logger.logError(e),e}const l=new Set([...Me,...o]);await s.authorize(r,{display:"popup",scope:[...l].join(" "),...a},i);const{idToken:u}=s;if(!u){const e=new AuthenticationError("No ID token returned");throw s.logger.logError(e),e}const h=function(e){if("string"!=typeof e)throw new X("JWTs must use Compact JWS serialization, JWT must be a string");const{1:t,length:r}=e.split(".");if(5===r)throw new X("Only JWTs using Compact JWS serialization can be decoded");if(3!==r)throw new X("Invalid JWT");if(!t)throw new X("JWTs must contain a payload");let o,n;try{o=xe(t)}catch(e){throw new X("Failed to parse the base64url encoded payload")}try{n=JSON.parse(M.decode(o))}catch(e){throw new X("Failed to parse the decoded payload as JSON")}if(!ae(n))throw new X("Invalid JWT Claims Set");return n}(u);if(!h){const e=new AuthenticationError("Failed to decode ID token");throw s.logger.logError(e),e}const{aud:p,iss:w}=h;return await He(u,Array.isArray(p)?p[0]:p,w),{claims:h,clientId:t,idToken:u,logout:qe(t,u,s),openIdProviderUrl:e,userInfo:s.userInfo}},Ne=(e,t,r,o,n,a)=>async n=>{if(0!==new URL(n).href.toLowerCase().indexOf(r.toLowerCase()))return!1;window.clearInterval(a),window.clearTimeout(t);try{e.removeAllListeners(),e.close(!0)}catch(e){}return o(),!0},Fe=async(e,t,r,o,n)=>{const a={additionalMetadata:n,discoveryEndpoint:Ke(e)};return Le.init(a,void 0,t,$e,e,r,o)},qe=(e,t,r)=>async(o,n)=>{if(!o)throw new x("Logout Redirection URI must be a non-empty string");const{logger:a,metadata:i}=r;a.logInfo("Logout started",e,t,o,n);const{end_session_endpoint:s}=i??{};if(!s){const e=new LogoutError("OpenID Provider metadata does not define end session endpoint");throw a.logError(e),e}const c=`${s}?id_token_hint=${t}&client_id=${e}&post_logout_redirect_uri=${encodeURIComponent(o)}${n?`&logout_hint=${encodeURIComponent(n)}`:""}`;await $(c,Ge(o,a)),await(r?.close()),a.logInfo("Logout completed")},Ge=(e,t)=>r=>new Promise(((o,n)=>{let a;r.addListener("closing",(async()=>{t.logInfo("User closed auth window"),window.clearInterval(a),r.removeAllListeners(),n(new LogoutError("Failed to complete logout process"))}));const i=window.setTimeout((async()=>{try{await r.isShowing()||(t.logInfo("Showing auth window"),await r.show(!0),await r.focus())}catch{t.logWarning("Unable to show auth window")}}),2e3);(async()=>{const{version:s}=await fin.System.getRuntimeInfo();if(parseInt(s.split(".")[0],10)>=30){await Ne(r,i,e,o,n)((await r.getInfo()).url)||await r.addListener("url-changed",(a=>{t.logInfo("Auth window navigated to",a.url),Ne(r,i,e,o,n)(a.url)}))}else a=window.setInterval((()=>(async(e,t,r,o,n,a)=>{let i;try{i=await e.getInfo()}catch(e){return window.clearInterval(t),window.clearTimeout(r),a(new LogoutError("Could not locate auth window")),!1}return Ne(e,r,o,n,a,t)(i.url)})(r,a,i,e,o,n)),500)})()}));var Ve=t.MS,Be=t._7,Xe=t.cX,Ye=t.zL,Qe=t._W,Ze=t.p8,et=t.YR,tt=t.U$,rt=t.U7,ot=t.OF;

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*********************************************************!*\
  !*** ./client/src/modules/auth/openid-connect/index.ts ***!
  \*********************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   entryPoints: () => (/* binding */ entryPoints)
/* harmony export */ });
/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auth */ "./client/src/modules/auth/openid-connect/auth.ts");

/**
 * Define the entry points for the module.
 */
const entryPoints = {
    auth: new _auth__WEBPACK_IMPORTED_MODULE_0__.OpenIdConnectProvider()
};

})();

var __webpack_exports__entryPoints = __webpack_exports__.entryPoints;
export { __webpack_exports__entryPoints as entryPoints };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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U0FBUyxJQUFJLE9BQU8sNkRBQTZELDZCQUE2QixNQUFNLFlBQVksR0FBRyw4Q0FBOEMsd0ZBQXdGLDZCQUE2Qix1RUFBdUUsK0NBQStDLElBQUksbUNBQW1DLFVBQVUsY0FBYyx1QkFBdUIsU0FBUyw4Q0FBOEMsb0NBQW9DLDBCQUEwQix1RUFBdUUsTUFBTSxvQkFBb0IsR0FBRyxvQ0FBb0MsTUFBTSx1QkFBdUIsT0FBTyxPQUFPLHlGQUF5RixzQkFBc0IsV0FBVyxFQUFFLGlCQUFpQixFQUFFLGFBQWEsRUFBRSw0QkFBNEIsc0JBQXNCLEVBQUUsa0JBQWtCLHNCQUFzQixLQUFLLEVBQUUsbUVBQW1FLG1DQUFtQyxNQUFNLG1DQUFtQyw0SUFBNEksR0FBRyxxQ0FBcUMsSUFBSSx5RkFBeUYsTUFBTSw0Q0FBNEMsT0FBTyxXQUFXLE1BQU0sVUFBVSxtQ0FBbUMscUNBQXFDLHFGQUFxRixpRUFBaUUsR0FBRyxxREFBcUQsTUFBTSxJQUFJLG9CQUFvQixTQUFTLDRHQUE0Ryw4QkFBOEIscUJBQXFCLElBQUksR0FBRzs7Ozs7O1NDQTVtNUM7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTs7U0FFQTtTQUNBOztTQUVBO1NBQ0E7U0FDQTs7Ozs7VUN0QkE7VUFDQTtVQUNBO1VBQ0E7VUFDQSx5Q0FBeUMsd0NBQXdDO1VBQ2pGO1VBQ0E7VUFDQTs7Ozs7VUNQQTs7Ozs7VUNBQTtVQUNBO1VBQ0E7VUFDQSx1REFBdUQsaUJBQWlCO1VBQ3hFO1VBQ0EsZ0RBQWdELGFBQWE7VUFDN0Q7Ozs7Ozs7Ozs7Ozs7OztBQ0wrQztBQUUvQzs7R0FFRztBQUNJLE1BQU0sV0FBVyxHQUFxRDtJQUM1RSxJQUFJLEVBQUUsSUFBSSx3REFBcUIsRUFBRTtDQUNqQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLXdvcmtzcGFjZS1wbGF0Zm9ybS1zdGFydGVyLy4vY2xpZW50L3NyYy9mcmFtZXdvcmsvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vb3BlbmZpbi13b3Jrc3BhY2UtLXdvcmtzcGFjZS1wbGF0Zm9ybS1zdGFydGVyLy4vY2xpZW50L3NyYy9tb2R1bGVzL2F1dGgvb3BlbmlkLWNvbm5lY3QvYXV0aC50cyIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0td29ya3NwYWNlLXBsYXRmb3JtLXN0YXJ0ZXIvLi4vLi4vbm9kZV9tb2R1bGVzL0BvcGVuZmluL29wZW5pZC1jb25uZWN0L29wZW5maW4ub3BlbmlkLWNvbm5lY3QubWpzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS13b3Jrc3BhY2UtcGxhdGZvcm0tc3RhcnRlci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9vcGVuZmluLXdvcmtzcGFjZS0td29ya3NwYWNlLXBsYXRmb3JtLXN0YXJ0ZXIvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS13b3Jrc3BhY2UtcGxhdGZvcm0tc3RhcnRlci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS13b3Jrc3BhY2UtcGxhdGZvcm0tc3RhcnRlci93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL29wZW5maW4td29ya3NwYWNlLS13b3Jrc3BhY2UtcGxhdGZvcm0tc3RhcnRlci8uL2NsaWVudC9zcmMvbW9kdWxlcy9hdXRoL29wZW5pZC1jb25uZWN0L2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdCBpZiBhIHZhbHVlIGlzIGEgdW5kZWZpbmVkIG9yIG51bGwuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudWxsIHwgdW5kZWZpbmVkIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsO1xufVxuXG4vKipcbiAqIFRlc3QgaWYgYSB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG9iamVjdCB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuXHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuXG4vKipcbiAqIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBzdHJpbmcge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuXG4vKipcbiAqIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyB0aGF0IGlzIG5vdCBlbXB0eS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nIHRoYXQgaXMgbm90IGVtcHR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmdWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIHN0cmluZyB7XG5cdHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUudHJpbSgpLmxlbmd0aCA+IDA7XG59XG5cbi8qKlxuICogVGVzdCBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bWJlciB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuXHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59XG5cbi8qKlxuICogVGVzdCBpZiBhIHZhbHVlIGlzIGEgbnVtYmVyIHdpdGggYSByZWFsIHZhbHVlIGkuZS4gbm90IE5hTiBvciBJbmZpbml0ZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXJWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bWJlciB7XG5cdHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgIU51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUZXN0IGlmIGEgdmFsdWUgaXMgYSBib29sZWFuLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgYm9vbGVhbiB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuXHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiO1xufVxuXG4vKipcbiAqIFRlc3QgaWYgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bWJlciB7XG5cdHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59XG5cbi8qKlxuICogRGVlcCBjbG9uZSBhbiBvYmplY3QuXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyBUaGUgY2xvbmUgb2YgdGhlIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdENsb25lPFQ+KG9iajogVCk6IFQge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0cmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cblxuLyoqXG4gKiBQb2x5ZmlsbHMgcmFuZG9tVVVJRCBpZiBydW5uaW5nIGluIGEgbm9uLXNlY3VyZSBjb250ZXh0LlxuICogQHJldHVybnMgVGhlIHJhbmRvbSBVVUlELlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVVVJRCgpOiBzdHJpbmcge1xuXHRpZiAoXCJyYW5kb21VVUlEXCIgaW4gZ2xvYmFsVGhpcy5jcnlwdG8pIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblx0XHRyZXR1cm4gZ2xvYmFsVGhpcy5jcnlwdG8ucmFuZG9tVVVJRCgpO1xuXHR9XG5cdC8vIFBvbHlmaWxsIHRoZSB3aW5kb3cuY3J5cHRvLnJhbmRvbVVVSUQgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gYSBub24gc2VjdXJlIGNvbnRleHQgdGhhdCBkb2Vzbid0IGhhdmUgaXRcblx0Ly8gd2UgYXJlIHN0aWxsIHVzaW5nIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHdoaWNoIGlzIGFsd2F5cyBhdmFpbGFibGVcblx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjMvMjgwMDIxOFxuXHQvKipcblx0ICogR2V0IHJhbmRvbSBoZXggdmFsdWUuXG5cdCAqIEBwYXJhbSBjIFRoZSBudW1iZXIgdG8gYmFzZSB0aGUgcmFuZG9tIHZhbHVlIG9uLlxuXHQgKiBAcmV0dXJucyBUaGUgcmFuZG9tIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UmFuZG9tSGV4KGM6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2Vcblx0XHRjb25zdCBybmQgPSBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMSkpWzBdICYgKDE1ID4+IChOdW1iZXIoYykgLyA0KSk7XG5cdFx0cmV0dXJuIChcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG5cdFx0XHQoTnVtYmVyKGMpIF4gcm5kKS50b1N0cmluZygxNilcblx0XHQpO1xuXHR9XG5cdHJldHVybiBcIjEwMDAwMDAwLTEwMDAtNDAwMC04MDAwLTEwMDAwMDAwMDAwMFwiLnJlcGxhY2UoL1swMThdL2csIGdldFJhbmRvbUhleCk7XG59XG5cbi8qKlxuICogRm9ybWF0IGFuIGVycm9yIHRvIGEgcmVhZGFibGUgc3RyaW5nLlxuICogQHBhcmFtIGVyciBUaGUgZXJyb3IgdG8gZm9ybWF0LlxuICogQHJldHVybnMgVGhlIGZvcm1hdHRlZCBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEVycm9yKGVycjogdW5rbm93bik6IHN0cmluZyB7XG5cdGlmIChpc0VtcHR5KGVycikpIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fSBlbHNlIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdHJldHVybiBlcnIubWVzc2FnZTtcblx0fSBlbHNlIGlmIChpc1N0cmluZ1ZhbHVlKGVycikpIHtcblx0XHRyZXR1cm4gZXJyO1xuXHR9IGVsc2UgaWYgKGlzT2JqZWN0KGVycikgJiYgXCJtZXNzYWdlXCIgaW4gZXJyICYmIGlzU3RyaW5nKGVyci5tZXNzYWdlKSkge1xuXHRcdHJldHVybiBlcnIubWVzc2FnZTtcblx0fVxuXHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyKTtcbn1cblxuLyoqXG4gKiBBIGJhc2ljIHN0cmluZyBzYW5pdGl6ZSBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgYW5nbGUgYnJhY2tldHMgPD4gZnJvbSBhIHN0cmluZy5cbiAqIEBwYXJhbSBjb250ZW50IHRoZSBjb250ZW50IHRvIHNhbml0aXplXG4gKiBAcmV0dXJucyBhIHN0cmluZyB3aXRob3V0IGFuZ2xlIGJyYWNrZXRzIDw+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZVN0cmluZyhjb250ZW50OiB1bmtub3duKTogc3RyaW5nIHtcblx0aWYgKGlzU3RyaW5nVmFsdWUoY29udGVudCkpIHtcblx0XHRyZXR1cm4gY29udGVudFxuXHRcdFx0LnJlcGxhY2UoLzxbXj5dKj4/L2dtLCBcIlwiKVxuXHRcdFx0LnJlcGxhY2UoLyZndDsvZywgXCI+XCIpXG5cdFx0XHQucmVwbGFjZSgvJmx0Oy9nLCBcIjxcIilcblx0XHRcdC5yZXBsYWNlKC8mYW1wOy9nLCBcIiZcIilcblx0XHRcdC5yZXBsYWNlKC8mbmJzcDsvZywgXCIgXCIpXG5cdFx0XHQucmVwbGFjZSgvXFxuXFxzKlxcbi9nLCBcIlxcblwiKTtcblx0fVxuXHRyZXR1cm4gXCJcIjtcbn1cbiIsImltcG9ydCB7XG5cdGF1dGhlbnRpY2F0ZSxcblx0ZW5hYmxlTG9nZ2luZyxcblx0dmFsaWRhdGVJZFRva2VuLFxuXHR0eXBlIE9pZGNBdXRoZW50aWNhdGlvblJlc3VsdCxcblx0dHlwZSBVc2VySW5mb0NsYWltc1xufSBmcm9tIFwiQG9wZW5maW4vb3BlbmlkLWNvbm5lY3RcIjtcbmltcG9ydCB0eXBlIHsgQXV0aEV2ZW50VHlwZXMsIEF1dGhQcm92aWRlciB9IGZyb20gXCJ3b3Jrc3BhY2UtcGxhdGZvcm0tc3RhcnRlci9zaGFwZXMvYXV0aC1zaGFwZXNcIjtcbmltcG9ydCB0eXBlIHsgTG9nZ2VyLCBMb2dnZXJDcmVhdG9yIH0gZnJvbSBcIndvcmtzcGFjZS1wbGF0Zm9ybS1zdGFydGVyL3NoYXBlcy9sb2dnZXItc2hhcGVzXCI7XG5pbXBvcnQgdHlwZSB7IE1vZHVsZURlZmluaXRpb24sIE1vZHVsZUhlbHBlcnMgfSBmcm9tIFwid29ya3NwYWNlLXBsYXRmb3JtLXN0YXJ0ZXIvc2hhcGVzL21vZHVsZS1zaGFwZXNcIjtcbmltcG9ydCB7IGZvcm1hdEVycm9yLCBpc0VtcHR5LCBpc051bWJlciwgaXNTdHJpbmdWYWx1ZSwgcmFuZG9tVVVJRCB9IGZyb20gXCJ3b3Jrc3BhY2UtcGxhdGZvcm0tc3RhcnRlci91dGlsc1wiO1xuaW1wb3J0IHR5cGUgeyBPcGVuSWRDb25uZWN0UHJvdmlkZXJPcHRpb25zIH0gZnJvbSBcIi4vc2hhcGVzXCI7XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gZm9yIHRoZSBvcGVuaWQgY29ubmVjdCBhdXRoIHByb3ZpZGVyLlxuICovXG5leHBvcnQgY2xhc3MgT3BlbklkQ29ubmVjdFByb3ZpZGVyIGltcGxlbWVudHMgQXV0aFByb3ZpZGVyPE9wZW5JZENvbm5lY3RQcm92aWRlck9wdGlvbnM+IHtcblx0LyoqXG5cdCAqIFRoZSBtb2R1bGUgZGVmaW5pdGlvbiBpbmNsdWRpbmcgc2V0dGluZ3MuXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0cHJpdmF0ZSBfZGVmaW5pdGlvbjogTW9kdWxlRGVmaW5pdGlvbjxPcGVuSWRDb25uZWN0UHJvdmlkZXJPcHRpb25zPiB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogVGhlIGxvZ2dlciBmb3IgZGlzcGxheWluZyBpbmZvcm1hdGlvbiBmcm9tIHRoZSBtb2R1bGUuXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0cHJpdmF0ZSBfbG9nZ2VyPzogTG9nZ2VyO1xuXG5cdC8qKlxuXHQgKiBNYXAgYSBzdWJzY3JpcHRpb24gaWQgdG8gYW4gZXZlbnQuXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi9cblx0cHJpdmF0ZSByZWFkb25seSBfc3Vic2NyaWJlSWRNYXA6IHsgW2tleTogc3RyaW5nXTogQXV0aEV2ZW50VHlwZXMgfTtcblxuXHQvKipcblx0ICogQ2FsbGJhY2tzIGZvciBldmVudCBzdWJzY3JpYmVycy5cblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRwcml2YXRlIHJlYWRvbmx5IF9ldmVudFN1YnNjcmliZXJzOiB7IFtldmVudCBpbiBBdXRoRXZlbnRUeXBlc10/OiB7IFtpZDogc3RyaW5nXTogKCkgPT4gUHJvbWlzZTx2b2lkPiB9IH07XG5cblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgb2YgdGhlIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QuXG5cdCAqL1xuXHRwcml2YXRlIF9hdXRoUmVzdWx0OiBPaWRjQXV0aGVudGljYXRpb25SZXN1bHQgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFNlc3Npb24gZXhwaXJ5IHRpbWVyLlxuXHQgKi9cblx0cHJpdmF0ZSBfc2Vzc2lvbkV4cGlyeVRpbWVySWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIE9wZW5JZENvbm5lY3RQcm92aWRlci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX3N1YnNjcmliZUlkTWFwID0ge307XG5cdFx0dGhpcy5fZXZlbnRTdWJzY3JpYmVycyA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIG1vZHVsZS5cblx0ICogQHBhcmFtIGRlZmluaXRpb24gVGhlIGRlZmluaXRpb24gb2YgdGhlIG1vZHVsZSBmcm9tIGNvbmZpZ3VyYXRpb24gaW5jbHVkZSBjdXN0b20gb3B0aW9ucy5cblx0ICogQHBhcmFtIGxvZ2dlckNyZWF0b3IgRm9yIGxvZ2dpbmcgZW50cmllcy5cblx0ICogQHBhcmFtIGhlbHBlcnMgSGVscGVyIG1ldGhvZHMgZm9yIHRoZSBtb2R1bGUgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgYXBwbGljYXRpb24gY29yZS5cblx0ICogQHJldHVybnMgTm90aGluZy5cblx0ICovXG5cdHB1YmxpYyBhc3luYyBpbml0aWFsaXplKFxuXHRcdGRlZmluaXRpb246IE1vZHVsZURlZmluaXRpb248T3BlbklkQ29ubmVjdFByb3ZpZGVyT3B0aW9ucz4sXG5cdFx0bG9nZ2VyQ3JlYXRvcjogTG9nZ2VyQ3JlYXRvcixcblx0XHRoZWxwZXJzOiBNb2R1bGVIZWxwZXJzXG5cdCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHRoaXMuX2RlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuXHRcdHRoaXMuX2xvZ2dlciA9IGxvZ2dlckNyZWF0b3IoXCJPcGVuSWRDb25uZWN0UHJvdmlkZXJcIik7XG5cblx0XHR0aGlzLl9sb2dnZXIuaW5mbyhcIkluaXRpYWxpemluZ1wiKTtcblxuXHRcdGlmICh0aGlzLl9kZWZpbml0aW9uLmRhdGE/LmVuYWJsZUxvZ2dpbmcpIHtcblx0XHRcdGVuYWJsZUxvZ2dpbmcoKTtcblx0XHR9XG5cblx0XHRjb25zdCBwcm92aWRlclVybCA9IHRoaXMuX2RlZmluaXRpb24uZGF0YT8ucHJvdmlkZXJVcmw7XG5cdFx0Y29uc3QgY2xpZW50SWQgPSB0aGlzLl9kZWZpbml0aW9uLmRhdGE/LmNsaWVudElkO1xuXHRcdGNvbnN0IGxvZ2luUmVkaXJlY3RVcmwgPSB0aGlzLl9kZWZpbml0aW9uLmRhdGE/LmxvZ2luUmVkaXJlY3RVcmw7XG5cdFx0Y29uc3QgbG9nb3V0UmVkaXJlY3RVcmwgPSB0aGlzLl9kZWZpbml0aW9uLmRhdGE/LmxvZ291dFJlZGlyZWN0VXJsO1xuXG5cdFx0aWYgKCFpc1N0cmluZ1ZhbHVlKHByb3ZpZGVyVXJsKSkge1xuXHRcdFx0dGhpcy5fbG9nZ2VyLmVycm9yKFwicHJvdmlkZXJVcmwgaXMgbm90IGNvbmZpZ3VyZWRcIik7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc1N0cmluZ1ZhbHVlKGNsaWVudElkKSkge1xuXHRcdFx0dGhpcy5fbG9nZ2VyLmVycm9yKFwiQ2xpZW50SWQgaXMgbm90IGNvbmZpZ3VyZWRcIik7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc1N0cmluZ1ZhbHVlKGxvZ2luUmVkaXJlY3RVcmwpKSB7XG5cdFx0XHR0aGlzLl9sb2dnZXIuZXJyb3IoXCJsb2dpblJlZGlyZWN0VXJsIGlzIG5vdCBjb25maWd1cmVkXCIpO1xuXHRcdH1cblxuXHRcdGlmICghaXNTdHJpbmdWYWx1ZShsb2dvdXRSZWRpcmVjdFVybCkpIHtcblx0XHRcdHRoaXMuX2xvZ2dlci5lcnJvcihcImxvZ291dFJlZGlyZWN0VXJsIGlzIG5vdCBjb25maWd1cmVkXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9zZSBkb3duIGFueSByZXNvdXJjZXMgYmVpbmcgdXNlZCBieSB0aGUgbW9kdWxlLlxuXHQgKiBAcmV0dXJucyBOb3RoaW5nLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGNsb3NlZG93bigpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0aGlzLl9sb2dnZXI/LmluZm8oXCJDbG9zZWRvd25cIik7XG5cblx0XHRpZiAodGhpcy5fc2Vzc2lvbkV4cGlyeVRpbWVySWQpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fc2Vzc2lvbkV4cGlyeVRpbWVySWQpO1xuXHRcdFx0dGhpcy5fc2Vzc2lvbkV4cGlyeVRpbWVySWQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnNjcmliZSB0byBvbmUgb2YgdGhlIGF1dGggZXZlbnRzLlxuXHQgKiBAcGFyYW0gdG8gVGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0by5cblx0ICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cblx0ICogQHJldHVybnMgU3Vic2NyaXB0aW9uIGlkIGZvciB1bnN1YnNjcmliaW5nIG9yIHVuZGVmaW5lZCBpZiBldmVudCB0eXBlIGlzIG5vdCBhdmFpbGFibGUuXG5cdCAqL1xuXHRwdWJsaWMgc3Vic2NyaWJlKHRvOiBBdXRoRXZlbnRUeXBlcywgY2FsbGJhY2s6ICgpID0+IFByb21pc2U8dm9pZD4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuXHRcdGNvbnN0IHN1YnNjcmlwdGlvbklkID0gcmFuZG9tVVVJRCgpO1xuXG5cdFx0Y29uc3QgdG9NYXAgPSB0aGlzLl9ldmVudFN1YnNjcmliZXJzW3RvXSA/PyB7fTtcblx0XHR0b01hcFtzdWJzY3JpcHRpb25JZF0gPSBjYWxsYmFjaztcblx0XHR0aGlzLl9ldmVudFN1YnNjcmliZXJzW3RvXSA9IHRvTWFwO1xuXG5cdFx0dGhpcy5fc3Vic2NyaWJlSWRNYXBbc3Vic2NyaXB0aW9uSWRdID0gdG87XG5cdFx0dGhpcy5fbG9nZ2VyPy5pbmZvKGBTdWJzY3JpcHRpb24gdG8gJHt0b30gZXZlbnRzIHJlZ2lzdGVyZWQuIFN1YnNjcmlwdGlvbiBJZDogJHtzdWJzY3JpcHRpb25JZH1gKTtcblxuXHRcdHJldHVybiBzdWJzY3JpcHRpb25JZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBVbnN1YnNjcmliZSBmcm9tIGFuIGFscmVhZHkgc3Vic2NyaWJlZCBldmVudC5cblx0ICogQHBhcmFtIHN1YnNjcmlwdGlvbklkIFRoZSBpZCBvZiB0aGUgc3Vic2NyaXB0aW9uIHJldHVybmVkIGZyb20gc3Vic2NyaWJlLlxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB1bnN1YnNjcmliZSB3YXMgc3VjY2Vzc2Z1bC5cblx0ICovXG5cdHB1YmxpYyB1bnN1YnNjcmliZShzdWJzY3JpcHRpb25JZDogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0Y29uc3QgZXZlbnRUeXBlID0gdGhpcy5fc3Vic2NyaWJlSWRNYXBbc3Vic2NyaXB0aW9uSWRdO1xuXHRcdGlmIChpc0VtcHR5KGV2ZW50VHlwZSkpIHtcblx0XHRcdHRoaXMuX2xvZ2dlcj8ud2FybihgWW91IGhhdmUgdHJpZWQgdG8gdW5zdWJzY3JpYmUgd2l0aCBhIGtleSAke3N1YnNjcmlwdGlvbklkfSB0aGF0IGlzIGludmFsaWRgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBldmVudFN1YnNjcmliZXJzID0gdGhpcy5fZXZlbnRTdWJzY3JpYmVyc1tldmVudFR5cGVdO1xuXHRcdGlmICghaXNFbXB0eShldmVudFN1YnNjcmliZXJzKSkge1xuXHRcdFx0ZGVsZXRlIGV2ZW50U3Vic2NyaWJlcnNbc3Vic2NyaXB0aW9uSWRdO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9zdWJzY3JpYmVJZE1hcFtzdWJzY3JpcHRpb25JZF0pIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9zdWJzY3JpYmVJZE1hcFtzdWJzY3JpcHRpb25JZF07XG5cdFx0XHR0aGlzLl9sb2dnZXI/LmluZm8oXG5cdFx0XHRcdGBTdWJzY3JpcHRpb24gdG8gJHtldmVudFR5cGV9IGV2ZW50cyB3aXRoIHN1YnNjcmlwdGlvbiBJZDogJHtzdWJzY3JpcHRpb25JZH0gaGFzIGJlZW4gY2xlYXJlZGBcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLl9sb2dnZXI/Lndhcm4oXG5cdFx0XHRgU3Vic2NyaXB0aW9uIHRvICR7ZXZlbnRUeXBlfSBldmVudHMgd2l0aCBzdWJzY3JpcHRpb24gSWQ6ICR7c3Vic2NyaXB0aW9uSWR9IGNvdWxkIG5vdCBiZSBjbGVhcmVkIGFzIHdlIGRvIG5vdCBoYXZlIGEgcmVnaXN0ZXIgb2YgdGhhdCBldmVudCB0eXBlLmBcblx0XHQpO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEb2VzIHRoZSBhdXRoIHByb3ZpZGVyIHJlcXVpcmUgYXV0aGVudGljYXRpb24uXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgYXV0aGVudGljYXRpb24gaXMgcmVxdWlyZWQuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgaXNBdXRoZW50aWNhdGlvblJlcXVpcmVkKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdHJldHVybiBpc0VtcHR5KHRoaXMuX2F1dGhSZXN1bHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm0gdGhlIGxvZ2luIG9wZXJhdGlvbiBvbiB0aGUgYXV0aCBwcm92aWRlci5cblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbG9naW4gd2FzIHN1Y2Nlc3NmdWwuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgbG9naW4oKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0Y29uc3QgcHJvdmlkZXJVcmwgPSB0aGlzLl9kZWZpbml0aW9uPy5kYXRhPy5wcm92aWRlclVybDtcblx0XHRjb25zdCBjbGllbnRJZCA9IHRoaXMuX2RlZmluaXRpb24/LmRhdGE/LmNsaWVudElkO1xuXHRcdGNvbnN0IGxvZ2luUmVkaXJlY3RVcmwgPSB0aGlzLl9kZWZpbml0aW9uPy5kYXRhPy5sb2dpblJlZGlyZWN0VXJsO1xuXHRcdGNvbnN0IHNjb3BlcyA9IHRoaXMuX2RlZmluaXRpb24/LmRhdGE/LnNjb3BlcztcblxuXHRcdGlmIChpc1N0cmluZ1ZhbHVlKHByb3ZpZGVyVXJsKSAmJiBpc1N0cmluZ1ZhbHVlKGNsaWVudElkKSAmJiBpc1N0cmluZ1ZhbHVlKGxvZ2luUmVkaXJlY3RVcmwpKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLl9hdXRoUmVzdWx0ID0gYXdhaXQgYXV0aGVudGljYXRlKHByb3ZpZGVyVXJsLCBjbGllbnRJZCwgbG9naW5SZWRpcmVjdFVybCwgc2NvcGVzKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyhcImxvZ2dlZC1pblwiKTtcblx0XHRcdFx0dGhpcy5jaGVja0ZvclNlc3Npb25FeHBpcnkoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0dGhpcy5fbG9nZ2VyPy5lcnJvcihcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiLCBmb3JtYXRFcnJvcihlcnIpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybSB0aGUgbG9nb3V0IG9wZXJhdGlvbiBvbiB0aGUgYXV0aCBwcm92aWRlci5cblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbG9nb3V0IHdhcyBzdWNjZXNzZnVsLlxuXHQgKi9cblx0cHVibGljIGFzeW5jIGxvZ291dCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRpZiAodGhpcy5fYXV0aFJlc3VsdCkge1xuXHRcdFx0aWYgKHRoaXMuX3Nlc3Npb25FeHBpcnlUaW1lcklkKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fc2Vzc2lvbkV4cGlyeVRpbWVySWQpO1xuXHRcdFx0XHR0aGlzLl9zZXNzaW9uRXhwaXJ5VGltZXJJZCA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbG9nb3V0UmVkaXJlY3RVcmwgPSB0aGlzLl9kZWZpbml0aW9uPy5kYXRhPy5sb2dvdXRSZWRpcmVjdFVybDtcblx0XHRcdGlmIChpc1N0cmluZ1ZhbHVlKGxvZ291dFJlZGlyZWN0VXJsKSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoXCJiZWZvcmUtbG9nZ2VkLW91dFwiKTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLl9hdXRoUmVzdWx0LmxvZ291dChsb2dvdXRSZWRpcmVjdFVybCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdHRoaXMuX2xvZ2dlcj8uZXJyb3IoXCJMb2dvdXQgZmFpbGVkXCIsIGZvcm1hdEVycm9yKGVycikpO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoXCJsb2dnZWQtb3V0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hdXRoUmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdXNlciBpbmZvcm1hdGlvbiBmcm9tIHRoZSBhdXRoIHByb3ZpZGVyLlxuXHQgKiBAcmV0dXJucyBUaGUgdXNlciBpbmZvcm1hdGlvbiwgdGhlIHR5cGUgaXMgdW5rbm93biBhcyBpdCBpcyBkZXBlbmRlbnQgb24gdGhlIGF1dGggcHJvdmlkZXIuXG5cdCAqL1xuXHRwdWJsaWMgYXN5bmMgZ2V0VXNlckluZm8oKTogUHJvbWlzZTxVc2VySW5mb0NsYWltcyB8IHVuZGVmaW5lZD4ge1xuXHRcdGlmICh0aGlzLl9hdXRoUmVzdWx0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYXV0aFJlc3VsdC51c2VySW5mbztcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTm90aWZ5IHN1YnNjcmliZXJzIG9mIGFuIGV2ZW50IGNoYW5nZS5cblx0ICogQHBhcmFtIGF1dGhFdmVudFR5cGUgVGhlIHR5cGUgb2YgYXV0aGVudGljYXRpb24gZXZlbnQgdG8gc2VuZCB0by5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgbm90aWZ5U3Vic2NyaWJlcnMoYXV0aEV2ZW50VHlwZTogQXV0aEV2ZW50VHlwZXMpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMuX2V2ZW50U3Vic2NyaWJlcnNbYXV0aEV2ZW50VHlwZV07XG5cblx0XHRpZiAoc3Vic2NyaWJlcnMpIHtcblx0XHRcdGNvbnN0IHN1YnNjcmliZXJJZHMgPSBPYmplY3Qua2V5cyhzdWJzY3JpYmVycyk7XG5cdFx0XHRzdWJzY3JpYmVySWRzLnJldmVyc2UoKTtcblxuXHRcdFx0Zm9yIChjb25zdCBzdWJzY3JpYmVySWQgb2Ygc3Vic2NyaWJlcklkcykge1xuXHRcdFx0XHR0aGlzLl9sb2dnZXI/LmluZm8oXG5cdFx0XHRcdFx0YE5vdGlmeWluZyBzdWJzY3JpYmVyIHdpdGggc3Vic2NyaXB0aW9uIElkOiAke3N1YnNjcmliZXJJZH0gb2YgZXZlbnQgdHlwZTogJHthdXRoRXZlbnRUeXBlfWBcblx0XHRcdFx0KTtcblx0XHRcdFx0YXdhaXQgc3Vic2NyaWJlcnNbc3Vic2NyaWJlcklkXSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayB0byBzZWUgaWYgYSBzZXNzaW9uIGhhcyBleHBpcmVkLlxuXHQgKi9cblx0cHJpdmF0ZSBjaGVja0ZvclNlc3Npb25FeHBpcnkoKTogdm9pZCB7XG5cdFx0Y29uc3QgdmFsaWRpdHkgPSB0aGlzLl9kZWZpbml0aW9uPy5kYXRhPy5jaGVja1Nlc3Npb25WYWxpZGl0eUluU2Vjb25kcztcblx0XHRpZiAoaXNOdW1iZXIodmFsaWRpdHkpICYmIHZhbGlkaXR5ID4gMCAmJiBpc0VtcHR5KHRoaXMuX3Nlc3Npb25FeHBpcnlUaW1lcklkKSkge1xuXHRcdFx0dGhpcy5fc2Vzc2lvbkV4cGlyeVRpbWVySWQgPSB3aW5kb3cuc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX3Nlc3Npb25FeHBpcnlUaW1lcklkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdGNvbnN0IGlkVG9rZW4gPSB0aGlzLl9hdXRoUmVzdWx0Py5pZFRva2VuO1xuXHRcdFx0XHRjb25zdCBwcm92aWRlclVybCA9IHRoaXMuX2RlZmluaXRpb24/LmRhdGE/LnByb3ZpZGVyVXJsO1xuXHRcdFx0XHRjb25zdCBjbGllbnRJZCA9IHRoaXMuX2RlZmluaXRpb24/LmRhdGE/LmNsaWVudElkO1xuXG5cdFx0XHRcdGxldCBpc1ZhbGlkID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKGlzU3RyaW5nVmFsdWUoaWRUb2tlbikgJiYgaXNTdHJpbmdWYWx1ZShwcm92aWRlclVybCkgJiYgaXNTdHJpbmdWYWx1ZShjbGllbnRJZCkpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVJZFRva2VuKGlkVG9rZW4sIGNsaWVudElkLCBwcm92aWRlclVybCk7XG5cblx0XHRcdFx0XHRcdGlzVmFsaWQgPSByZXN1bHQudmFsaWQ7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9sb2dnZXI/LmVycm9yKFwiRmFpbGVkIHZhbGlkYXRpbmcgdG9rZW5cIiwgZm9ybWF0RXJyb3IoZXJyKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzVmFsaWQpIHtcblx0XHRcdFx0XHR0aGlzLl9sb2dnZXI/LmluZm8oXCJTZXNzaW9uIFN0aWxsIEFjdGl2ZVwiKTtcblx0XHRcdFx0XHR0aGlzLmNoZWNrRm9yU2Vzc2lvbkV4cGlyeSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2xvZ2dlcj8uaW5mbyhcIlNlc3Npb24gbm90IHZhbGlkXCIpO1xuXHRcdFx0XHRcdHRoaXMuX2F1dGhSZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5ub3RpZnlTdWJzY3JpYmVycyhcInNlc3Npb24tZXhwaXJlZFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdmFsaWRpdHkgKiAxMDAwKTtcblx0XHR9XG5cdH1cbn1cbiIsInZhciBlPXtkOih0LHIpPT57Zm9yKHZhciBvIGluIHIpZS5vKHIsbykmJiFlLm8odCxvKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbyx7ZW51bWVyYWJsZTohMCxnZXQ6cltvXX0pfSxvOihlLHQpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sdD17fTtlLmQodCx7TVM6KCk9PlIsXzc6KCk9PkF1dGhlbnRpY2F0aW9uRXJyb3IsY1g6KCk9PlAsekw6KCk9PkxvZ291dEVycm9yLF9XOigpPT54LHA4OigpPT5qLFlSOigpPT56ZSxVJDooKT0+SmUsVTc6KCk9PlVlLE9GOigpPT5IZX0pO3ZhciByPXtkOihlLHQpPT57Zm9yKHZhciBvIGluIHQpci5vKHQsbykmJiFyLm8oZSxvKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbyx7ZW51bWVyYWJsZTohMCxnZXQ6dFtvXX0pfSxvOihlLHQpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sbz17fTtyLmQobyx7TVM6KCk9PkFwaUVycm9yLGNGOigpPT5BcGlSZXF1ZXN0RXJyb3IsQUs6KCk9PkF1dGhUb2tlbkV4cGlyZWRFcnJvcixNXzooKT0+QXV0aG9yaXphdGlvbkVycm9yLGNYOigpPT5Jbml0aWFsaXphdGlvbkVycm9yLFlkOigpPT53LE80OigpPT5ULF9XOigpPT5QYXJhbWV0ZXJFcnJvcixwODooKT0+VmFsaWRhdGlvbkVycm9yLG0kOigpPT5zLFUkOigpPT51LFU3OigpPT5oLE9WOigpPT5kLE43OigpPT5BLEhQOigpPT5uLFJwOigpPT5PfSk7Y2xhc3MgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihlLHQpe3ZhciByLG87c3VwZXIoZT1udWxsIT09KHI9bnVsbCE9ZT9lOm51bGw9PXQ/dm9pZCAwOnQubWVzc2FnZSkmJnZvaWQgMCE9PXI/cjpcIkFuIHVuZXhwZWN0ZWQgZXJyb3IgaGFzIG9jY3VycmVkXCIpLHRoaXMubmFtZT10aGlzLmNvbnN0cnVjdG9yLm5hbWUsdGhpcy5zdGFjaz0oZT90aGlzLnN0YWNrOm51bGwhPT0obz1udWxsPT10P3ZvaWQgMDp0LnN0YWNrKSYmdm9pZCAwIT09bz9vOnRoaXMuc3RhY2spLnJlcGxhY2UoL14oXFx3KkVycm9yKS8sYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApfX1jbGFzcyBBcGlSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBBcGlFcnJvcntjb25zdHJ1Y3RvcihlLHQscil7dmFyIG87c3VwZXIoZT1udWxsIT09KG89bnVsbCE9ZT9lOm51bGw9PXI/dm9pZCAwOnIubWVzc2FnZSkmJnZvaWQgMCE9PW8/bzpcIkFuIGVycm9yIG9jY3VycmVkIHdoZW4gZXhlY3V0aW5nIHRoZSBBUEkgcmVxdWVzdFwiLHIpLHRoaXMuc3RhdHVzPXR9fWNsYXNzIEF1dGhvcml6YXRpb25FcnJvciBleHRlbmRzIEFwaUVycm9ye2NvbnN0cnVjdG9yKGUsdCl7dmFyIHI7c3VwZXIoZT1udWxsIT09KHI9bnVsbCE9ZT9lOm51bGw9PXQ/dm9pZCAwOnQubWVzc2FnZSkmJnZvaWQgMCE9PXI/cjpcIkFuIGF1dGhvcml6YXRpb24gZXJyb3Igb2NjdXJyZWRcIix0KX19Y2xhc3MgQXV0aFRva2VuRXhwaXJlZEVycm9yIGV4dGVuZHMgQXBpRXJyb3J7Y29uc3RydWN0b3IoZSx0KXt2YXIgcjtzdXBlcihlPW51bGwhPT0ocj1udWxsIT1lP2U6bnVsbD09dD92b2lkIDA6dC5tZXNzYWdlKSYmdm9pZCAwIT09cj9yOlwiVGhlIEFQSSByZXF1ZXN0IGZhaWxlZCBhcyB0aGUgYXV0aG9yaXphdGlvbiB0b2tlbnMgaGF2ZSBleHBpcmVkXCIsdCl9fWNsYXNzIEluaXRpYWxpemF0aW9uRXJyb3IgZXh0ZW5kcyBBcGlFcnJvcntjb25zdHJ1Y3RvcihlLHQpe3ZhciByO3N1cGVyKGU9bnVsbCE9PShyPW51bGwhPWU/ZTpudWxsPT10P3ZvaWQgMDp0Lm1lc3NhZ2UpJiZ2b2lkIDAhPT1yP3I6XCJBbiBpbml0aWFsaXphdGlvbiBlcnJvciBvY2N1cnJlZFwiLHQpfX1jbGFzcyBQYXJhbWV0ZXJFcnJvciBleHRlbmRzIEFwaUVycm9ye2NvbnN0cnVjdG9yKGUpe3N1cGVyKGU9bnVsbCE9ZT9lOlwiSW52YWxpZCBwYXJhbWV0ZXIgZGV0ZWN0ZWRcIil9fWNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEFwaUVycm9ye2NvbnN0cnVjdG9yKGUsdCl7dmFyIHI7c3VwZXIoZT1udWxsIT09KHI9bnVsbCE9ZT9lOm51bGw9PXQ/dm9pZCAwOnQubWVzc2FnZSkmJnZvaWQgMCE9PXI/cjpcIkEgdG9rZW4gdmFsaWRhdGlvbiBlcnJvciBvY2N1cnJlZFwiLHQpfX1jb25zdCBuPSgpPT52b2lkIDAhPT1jcnlwdG8ucmFuZG9tVVVJRD9jcnlwdG8ucmFuZG9tVVVJRCgpOlwiMTAwMDAwMDAtMTAwMC00MDAwLTgwMDAtMTAwMDAwMDAwMDAwXCIucmVwbGFjZSgvWzAxOF0vZywoZT0+e2NvbnN0IHQ9d2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMSkpWzBdJjE1Pj5OdW1iZXIoZSkvNDtyZXR1cm4oTnVtYmVyKGUpXnQpLnRvU3RyaW5nKDE2KX0pKSxhPVwib2F1dGgtYXBpLWF1dGgtZmxvd1wiLGk9KGUsdCxyLG8sbixhLGkscyk9PmFzeW5jIGM9Pntjb25zdCBkPW5ldyBVUkwoYyk7aWYoMCE9PWQuaHJlZi50b0xvd2VyQ2FzZSgpLmluZGV4T2Yobi50b0xvd2VyQ2FzZSgpKSlyZXR1cm4hMTtpZih3aW5kb3cuY2xlYXJJbnRlcnZhbChzKSx3aW5kb3cuY2xlYXJUaW1lb3V0KHQpLHdpbmRvdy5jbGVhclRpbWVvdXQociksZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKSxlLmNsb3NlKCEwKSxkLnNlYXJjaFBhcmFtcy5nZXQoXCJlcnJvclwiKSl7Y29uc3QgZT1uZXcgQXV0aG9yaXphdGlvbkVycm9yKFwiQXV0aG9yaXphdGlvbiBlcnJvclwiKTtyZXR1cm4gZS5kYXRhPWQudG9TdHJpbmcoKSxpKGUpLCEwfWlmKGQuc2VhcmNoUGFyYW1zLmdldChcInN0YXRlXCIpIT09byl7Y29uc3QgZT1uZXcgQXV0aG9yaXphdGlvbkVycm9yKFwiU3RhdGUgbWlzbWF0Y2hcIik7cmV0dXJuIGUuZGF0YT1kLnRvU3RyaW5nKCksaShlKSwhMH1jb25zdCBsPWQuc2VhcmNoUGFyYW1zLmdldChcImNvZGVcIik7aWYoIWwpe2NvbnN0IGU9bmV3IEF1dGhvcml6YXRpb25FcnJvcihcIkF1dGhvcml6YXRpb24gY29kZSBtaXNzaW5nXCIpO3JldHVybiBlLmRhdGE9ZC50b1N0cmluZygpLGkoZSksITB9cmV0dXJuIGEobCksITB9LHM9YXN5bmMoZSx0LHI9e30pPT57Y29uc3R7ZGVmYXVsdEhlaWdodDpvLGRlZmF1bHRXaWR0aDpufT1yO3JldHVybiB0KGF3YWl0IGZpbi5XaW5kb3cuY3JlYXRlKE9iamVjdC5hc3NpZ24oe2Fsd2F5c09uVG9wOiEwLG1heGltaXphYmxlOiExLG1pbmltaXphYmxlOiExLGF1dG9TaG93OiExLGRlZmF1bHRDZW50ZXJlZDohMCxkZWZhdWx0SGVpZ2h0Om51bGwhPW8/bzo3NTAsZGVmYXVsdFdpZHRoOm51bGwhPW4/bjo2MDAsaW5jbHVkZUluU25hcHNob3RzOiExLG5hbWU6YSxyZXNpemFibGU6ITEsc2F2ZVdpbmRvd1N0YXRlOiExLHNob3dUYXNrYmFySWNvbjohMSx1cmw6ZX0scikpKX0sYz0oZSx0LHIpPT5vPT5uZXcgUHJvbWlzZSgoKG4sYSk9PntsZXQgcztjb25zdCBjPXdpbmRvdy5zZXRUaW1lb3V0KCgoKT0+e3dpbmRvdy5jbGVhckludGVydmFsKHMpLHdpbmRvdy5jbGVhclRpbWVvdXQoYyksby5yZW1vdmVBbGxMaXN0ZW5lcnMoKSxvLmNsb3NlKCEwKSxhKG5ldyBBdXRob3JpemF0aW9uRXJyb3IoXCJBdXRob3JpemF0aW9uIHRpbWVkIG91dFwiKSl9KSwzZTUpO28uYWRkTGlzdGVuZXIoXCJjbG9zaW5nXCIsKGFzeW5jKCk9PntyLmxvZ0luZm8oXCJVc2VyIGNsb3NlZCBhdXRoIHdpbmRvd1wiKSx3aW5kb3cuY2xlYXJJbnRlcnZhbChzKSx3aW5kb3cuY2xlYXJUaW1lb3V0KGMpLG8ucmVtb3ZlQWxsTGlzdGVuZXJzKCksYShuZXcgQXV0aG9yaXphdGlvbkVycm9yKFwiRmFpbGVkIHRvIGNvbXBsZXRlIGF1dGhvcml6YXRpb24gY29kZSBmbG93XCIpKX0pKTtjb25zdCBkPXdpbmRvdy5zZXRUaW1lb3V0KChhc3luYygpPT57dHJ5e2F3YWl0IG8uaXNTaG93aW5nKCl8fChyLmxvZ0luZm8oXCJTaG93aW5nIGF1dGggd2luZG93XCIpLGF3YWl0IG8uc2hvdyghMCksYXdhaXQgby5mb2N1cygpKX1jYXRjaChlKXtyLmxvZ1dhcm5pbmcoXCJVbmFibGUgdG8gc2hvdyBhdXRoIHdpbmRvd1wiKX19KSwyZTMpOyhhc3luYygpPT57Y29uc3R7dmVyc2lvbjpsfT1hd2FpdCBmaW4uU3lzdGVtLmdldFJ1bnRpbWVJbmZvKCk7cGFyc2VJbnQobC5zcGxpdChcIi5cIilbMF0sMTApPj0zMD9hd2FpdCBpKG8sYyxkLGUsdCxuLGEpKChhd2FpdCBvLmdldEluZm8oKSkudXJsKXx8YXdhaXQgby5hZGRMaXN0ZW5lcihcInVybC1jaGFuZ2VkXCIsKHM9PntyLmxvZ0luZm8oXCJBdXRoIHdpbmRvdyBuYXZpZ2F0ZWQgdG9cIixzLnVybCksaShvLGMsZCxlLHQsbixhKShzLnVybCl9KSk6cz13aW5kb3cuc2V0SW50ZXJ2YWwoKCgpPT4oYXN5bmMoZSx0LHIsbyxuLGEscyxjKT0+e2xldCBkO3RyeXtkPWF3YWl0IGUuZ2V0SW5mbygpfWNhdGNoKGUpe3JldHVybiB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0KSx3aW5kb3cuY2xlYXJUaW1lb3V0KHIpLHdpbmRvdy5jbGVhclRpbWVvdXQobyksYyhuZXcgQXV0aG9yaXphdGlvbkVycm9yKFwiQ291bGQgbm90IGxvY2F0ZSBhdXRoIHdpbmRvd1wiKSksITF9cmV0dXJuIGkoZSxyLG8sbixhLHMsYyx0KShkLnVybCl9KShvLHMsYyxkLGUsdCxuLGEpKSw1MDApfSkoKX0pKSxkPWFzeW5jKGUsdCk9PntsZXQgcjtudWxsPT10fHx0LmxvZ0luZm8oXCJSZXRyaWV2aW5nIGF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhXCIsZSk7dHJ5e3I9bmV3IFVSTChlKX1jYXRjaChlKXt0aHJvdyBuZXcgUGFyYW1ldGVyRXJyb3IoXCJVbmV4cGVjdGVkIGludmFsaWQgZGlzY292ZXJ5IFVSTFwiKX1jb25zdCBvPWF3YWl0IGZldGNoKHIse2hlYWRlcnM6e0FjY2VwdDpcImFwcGxpY2F0aW9uL2pzb25cIn19KTtpZighby5vayl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcmV0cmlldmUgYXV0aG9yaXphdGlvbiBzZXJ2ZXIgbWV0YWRhdGFcIik7Y29uc3Qgbj1hd2FpdCBvLmpzb24oKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVtcHR5IGF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhIHJlc3BvbnNlXCIpO3JldHVybiBudWxsPT10fHx0LmxvZ0luZm8oXCJSZXRyaWV2ZWQgYXV0aG9yaXphdGlvbiBzZXJ2ZXIgbWV0YWRhdGFcIixuKSxufSxsPWU9PntsZXQgdD1maW4uSW50ZWdyYXRpb25zO3R8fChmaW4uSW50ZWdyYXRpb25zPXt9LHQ9ZmluLkludGVncmF0aW9ucyk7bGV0IHI9dFtlXTtyZXR1cm4gcnx8KHRbZV09e30scj10W2VdKSxyfSx1PWU9PntsKGUpLmxvZ2dpbmdFbmFibGVkPSExfSxoPShlLHQ9XCIwLjAuMFwiKT0+e2woZSkubG9nZ2luZ0VuYWJsZWQ9ITAsY29uc29sZS5sb2cocChlKSxgdiR7dH1gKX0scD1lPT5gW0BvcGVuZmluLyR7ZS50b0xvd2VyQ2FzZSgpfV1gO2NsYXNzIHd7Y29uc3RydWN0b3IoZSl7dGhpcy5uYW1lPWUsdGhpcy5wcmVmaXg9cChlKSx0aGlzLmlzTG9nZ2luZ0VuYWJsZWQ9dGhpcy5pc0xvZ2dpbmdFbmFibGVkLmJpbmQodGhpcyksdGhpcy5sb2dFcnJvcj10aGlzLmxvZ0Vycm9yLmJpbmQodGhpcyksdGhpcy5sb2dJbmZvPXRoaXMubG9nSW5mby5iaW5kKHRoaXMpLHRoaXMubG9nV2FybmluZz10aGlzLmxvZ1dhcm5pbmcuYmluZCh0aGlzKX1pc0xvZ2dpbmdFbmFibGVkKCl7cmV0dXJuIGwodGhpcy5uYW1lKS5sb2dnaW5nRW5hYmxlZH1sb2dFcnJvcihlKXt0aGlzLmlzTG9nZ2luZ0VuYWJsZWQoKSYmKGUuaW5uZXJFcnJvcj9jb25zb2xlLmVycm9yKHRoaXMucHJlZml4LGUsXCJcXG5cXG4oaW5uZXIpXCIsZS5pbm5lckVycm9yKTpjb25zb2xlLmVycm9yKHRoaXMucHJlZml4LGUpKX1sb2dJbmZvKC4uLmUpe3RoaXMuaXNMb2dnaW5nRW5hYmxlZCgpJiZjb25zb2xlLmxvZyh0aGlzLnByZWZpeCwuLi5lKX1sb2dXYXJuaW5nKC4uLmUpe3RoaXMuaXNMb2dnaW5nRW5hYmxlZCgpJiZjb25zb2xlLndhcm4odGhpcy5wcmVmaXgsLi4uZSl9fWNvbnN0IGc9KCk9PntsZXQgZSx0LHIsbyxuO2NvbnN0IGE9YXN5bmModCxyPSExKT0+e2NvbnN0e2NvbW1hbmQ6byxkYXRhOm4saWQ6c309dCxjPXtjb21tYW5kOm8saWQ6c307dHJ5e2lmKCFlKXRocm93IG5ldyBFcnJvcihcIkFjY2VzcyB0b2tlbiBub3QgZm91bmRcIik7Y29uc3R7YXBpUmVxdWVzdFVybDpvLGRhdGE6cyxoZWFkZXJzOmQsaHR0cE1ldGhvZDpsLGluY2x1ZGVBdXRob3JpemF0aW9uOnV9PW4saD1hd2FpdChhc3luYyh0LHIsbyxuLGEpPT57dmFyIGkscztjb25zdCBjPU9iamVjdC5hc3NpZ24oe0FjY2VwdDpcImFwcGxpY2F0aW9uL2pzb25cIn0sbik7XCJQQVRDSFwiIT09ciYmXCJQT1NUXCIhPT1yJiZcIlBVVFwiIT09cnx8L2NvbnRlbnQtdHlwZS9pLnRlc3QoT2JqZWN0LmtleXMoYykuam9pbihcIixcIikpfHwoY1tcIkNvbnRlbnQtVHlwZVwiXT1cImFwcGxpY2F0aW9uL2pzb25cIiksYSYmKGMuQXV0aG9yaXphdGlvbj1gQmVhcmVyICR7ZX1gKTtjb25zdCBkPWF3YWl0IGZldGNoKHQse2JvZHk6XCJvYmplY3RcIj09dHlwZW9mIG8/SlNPTi5zdHJpbmdpZnkobyk6byxoZWFkZXJzOmMsbWV0aG9kOnJ9KTtpZighZC5vayl7Y29uc3QgZT17bWVzc2FnZTpcIkZhaWxlZCB0byBleGVjdXRlIEFQSSByZXF1ZXN0XCJ9O3JldHVybihudWxsPT09KGk9ZC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSl8fHZvaWQgMD09PWk/dm9pZCAwOmkuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSYmKGUuZGF0YT1hd2FpdCBkLmpzb24oKSksW2Quc3RhdHVzLHZvaWQgMCx2b2lkIDAsZV19bGV0IGw7Y29uc3QgdT1udWxsIT09KHM9ZC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSkmJnZvaWQgMCE9PXM/czpcIlwiO3N3aXRjaCghMCl7Y2FzZSF1OmJyZWFrO2Nhc2UvXmFwcGxpY2F0aW9uXFwvKFxcdytcXCspP2pzb24vaS50ZXN0KHUpOmw9YXdhaXQgZC5qc29uKCk7YnJlYWs7Y2FzZS9ebXVsdGlwYXJ0XFwvZm9ybS0/ZGF0YXxeYXBwbGljYXRpb25cXC94LT93d3ctP2Zvcm0tP3VybGVuY29kZWQvaS50ZXN0KHUpOmw9YXdhaXQgZC5mb3JtRGF0YSgpO2JyZWFrO2Nhc2UvXmFwcGxpY2F0aW9uXFwvKChbXi9dKyk/eG1sfHZuZFxcLm9wZW54bWxmb3JtYXRzKXxedGV4dFxcL3xeaW1hZ2VcXC9zdmcvaS50ZXN0KHUpOmw9YXdhaXQgZC50ZXh0KCk7YnJlYWs7ZGVmYXVsdDpsPWF3YWl0IGQuYXJyYXlCdWZmZXIoKX1yZXR1cm5bZC5zdGF0dXMsbCx1LHZvaWQgMF19KShvLGwscyxkLHUpLFtwLHcsZyxmXT1oO2lmKGMuc3RhdHVzPXAsZil7aWYoIXImJjQwMT09PXApe2NvbnN0W2Uscl09YXdhaXQgaSgpO3JldHVybiByPyhjLnN0YXR1cz1lLGMuZXJyb3I9cixjKTphd2FpdCBhKHQsITApfWMuZXJyb3I9Zn1lbHNlIHcmJihjLmRhdGE9dyxjLnR5cGU9Zyl9Y2F0Y2goZSl7ZSBpbnN0YW5jZW9mIEVycm9yP2MuZXJyb3I9e21lc3NhZ2U6ZS5tZXNzYWdlfTpjLmVycm9yPXttZXNzYWdlOlwiRmFpbGVkIHRvIGV4ZWN1dGUgQVBJIHJlcXVlc3RcIn19cmV0dXJuIFByb21pc2UucmVzb2x2ZShjKX0saT1hc3luYygpPT57dmFyIHI7aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiQXV0aG9yaXphdGlvbiBzZXJ2ZXIgbWV0YWRhdGEgbm90IHNldFwiKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnQgSUQgbm90IHNldFwiKTtjb25zdCBhPWBncmFudF90eXBlPXJlZnJlc2hfdG9rZW4mY2xpZW50X2lkPSR7dH0mcmVmcmVzaF90b2tlbj0ke259YCxpPWF3YWl0IGZldGNoKG8udG9rZW5fZW5kcG9pbnQse2JvZHk6YSxoZWFkZXJzOntBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uXCIsXCJDb250ZW50LVR5cGVcIjpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwifSxtZXRob2Q6XCJQT1NUXCJ9KTtpZighaS5vayl7Y29uc3QgZT17bWVzc2FnZTpcIkZhaWxlZCB0byByZWZyZXNoIGFjY2VzcyB0b2tlblwifTtyZXR1cm4obnVsbD09PShyPWkuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikpfHx2b2lkIDA9PT1yP3ZvaWQgMDpyLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkmJihlLmRhdGE9YXdhaXQgaS5qc29uKCkpLFtpLnN0YXR1cyxlXX1jb25zdCBzPWF3YWl0IGkuanNvbigpO3JldHVybiBlPXMuYWNjZXNzX3Rva2VuLFtpLnN0YXR1c119O3NlbGYub25tZXNzYWdlPWFzeW5jIGk9Pntjb25zdHtjb21tYW5kOnMsaWQ6Y309aS5kYXRhO2xldCBkPXtjb21tYW5kOnMsaWQ6Y307c3dpdGNoKHMpe2Nhc2VcIkFQSV9SRVFVRVNUXCI6ZD1hd2FpdCBhKGkuZGF0YSk7YnJlYWs7Y2FzZVwiQ09ERV9FWENIQU5HRVwiOmQ9YXdhaXQoYXN5bmMgYT0+e3ZhciBpO2NvbnN0e2NvbW1hbmQ6cyxkYXRhOmMsaWQ6ZH09YSxsPXtjb21tYW5kOnMsaWQ6ZH07dHJ5e2lmKCFvKXRocm93IG5ldyBFcnJvcihcIkF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhIG5vdCBzZXRcIik7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiQ2xpZW50IElEIG5vdCBzZXRcIik7Y29uc3R7Y29kZTphLGNvZGVWZXJpZmllcjpzLHJlZGlyZWN0VXJpOmR9PWMsdT1gZ3JhbnRfdHlwZT1hdXRob3JpemF0aW9uX2NvZGUmY2xpZW50X2lkPSR7dH0mY29kZT0ke2F9JmNvZGVfdmVyaWZpZXI9JHtzfSZyZWRpcmVjdF91cmk9JHtkfWAsaD1hd2FpdCBmZXRjaChvLnRva2VuX2VuZHBvaW50LHtib2R5OnUsaGVhZGVyczp7QWNjZXB0OlwiYXBwbGljYXRpb24vanNvblwiLFwiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIn0sbWV0aG9kOlwiUE9TVFwifSk7aWYoaC5vayl7Y29uc3QgdD1hd2FpdCBoLmpzb24oKTtlPXQuYWNjZXNzX3Rva2VuLHI9dC5pZF90b2tlbixuPXQucmVmcmVzaF90b2tlbn1lbHNle2NvbnN0IGU9e21lc3NhZ2U6XCJGYWlsZWQgdG8gcmV0cmlldmUgdG9rZW5zXCJ9OyhudWxsPT09KGk9aC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSl8fHZvaWQgMD09PWk/dm9pZCAwOmkuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSYmKGUuZGF0YT1hd2FpdCBoLmpzb24oKSksbC5lcnJvcj1lfX1jYXRjaChlKXtlIGluc3RhbmNlb2YgRXJyb3I/bC5lcnJvcj17bWVzc2FnZTplLm1lc3NhZ2V9OmwuZXJyb3I9e21lc3NhZ2U6XCJGYWlsZWQgdG8gcmV0cmlldmUgdG9rZW5zXCJ9fXJldHVybiBQcm9taXNlLnJlc29sdmUobCl9KShpLmRhdGEpO2JyZWFrO2Nhc2VcIkVYUElSRV9UT0tFTlNcIjpkPWF3YWl0KGFzeW5jIHI9Pnt2YXIgYTtjb25zdHtjb21tYW5kOmksZXhwaXJlQWNjZXNzVG9rZW5Pbmx5OnMsaWQ6Y309cixkPXtjb21tYW5kOmksaWQ6Y307dHJ5e2lmKCFvKXRocm93IG5ldyBFcnJvcihcIkF1dGhvcml6YXRpb24gc2VydmVyIG1ldGFkYXRhIG5vdCBzZXRcIik7aWYoIW8ucmV2b2NhdGlvbl9lbmRwb2ludCl0aHJvdyBuZXcgRXJyb3IoXCJSZXZvY2F0aW9uIGVuZHBvaW50IG1pc3NpbmcgaW4gYXV0aG9yaXphdGlvbiBzZXJ2ZXIgbWV0YWRhdGFcIik7aWYoIXMmJiFuKXRocm93IG5ldyBFcnJvcihcIlJlZnJlc2ggdG9rZW4gbm90IGZvdW5kXCIpO2NvbnN0IHI9by5yZXZvY2F0aW9uX2VuZHBvaW50O2xldCBpLGM9ITE7Y29uc3QgbD17Ym9keTpgY2xpZW50X2lkPSR7dH1gLGhlYWRlcnM6e0FjY2VwdDpcImFwcGxpY2F0aW9uL2pzb25cIixcIkNvbnRlbnQtVHlwZVwiOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJ9LG1ldGhvZDpcIlBPU1RcIn07aWYocyl7Y29uc3QgdD1hd2FpdCBmZXRjaChyLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSx7Ym9keTpgJHtsLmJvZHl9JnRva2VuPSR7ZX0mdG9rZW5fdHlwZV9oaW50PWFjY2Vzc190b2tlbmB9KSk7dC5va3x8KGM9ITAsKG51bGw9PT0oYT10LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpKXx8dm9pZCAwPT09YT92b2lkIDA6YS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpJiYoaT1hd2FpdCB0Lmpzb24oKSkpfWVsc2V7Y29uc3QgdD0oYXdhaXQgUHJvbWlzZS5hbGwoW2F3YWl0IGZldGNoKHIsT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGwpLHtib2R5OmAke2wuYm9keX0mdG9rZW49JHtlfSZ0b2tlbl90eXBlX2hpbnQ9YWNjZXNzX3Rva2VuYH0pKSxhd2FpdCBmZXRjaChyLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSx7Ym9keTpgJHtsLmJvZHl9JnRva2VuPSR7bn0mdG9rZW5fdHlwZV9oaW50PXJlZnJlc2hfdG9rZW5gfSkpXSkpLmZpbHRlcigoZT0+IWUub2spKTt0Lmxlbmd0aCYmKGM9ITAsaT1hd2FpdCB0WzBdLmpzb24oKSl9aWYoYyl7Y29uc3QgZT17ZGF0YTppLG1lc3NhZ2U6XCJGYWlsZWQgdG8gZXhwaXJlIHRva2Vuc1wifTtkLmVycm9yPWV9fWNhdGNoKGUpe2UgaW5zdGFuY2VvZiBFcnJvcj9kLmVycm9yPXttZXNzYWdlOmUubWVzc2FnZX06ZC5lcnJvcj17bWVzc2FnZTpcIkZhaWxlZCB0byBleHBpcmUgdG9rZW5zXCJ9fXJldHVybiBQcm9taXNlLnJlc29sdmUoZCl9KShpLmRhdGEpO2JyZWFrO2Nhc2VcIkdFVF9JRF9UT0tFTlwiOmw9aS5kYXRhLGQ9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGwpLHtpZFRva2VuOnJ9KTticmVhaztjYXNlXCJJTklUXCI6ZD1hd2FpdChhc3luYyBlPT57Y29uc3R7Y29tbWFuZDpyLGRhdGE6bixpZDphfT1lLGk9e2NvbW1hbmQ6cixpZDphfTtyZXR1cm4gdD1uLmNsaWVudElkLG89bi5tZXRhZGF0YSxQcm9taXNlLnJlc29sdmUoaSl9KShpLmRhdGEpO2JyZWFrO2RlZmF1bHQ6ZC5lcnJvcj1uZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb2F1dGggd29ya2VyIGNvbW1hbmQ6ICR7c31gKX12YXIgbDtzZWxmLnBvc3RNZXNzYWdlKGQpfX07dmFyIGY7IWZ1bmN0aW9uKGUpe2UuQXBpUmVxdWVzdD1cIkFQSV9SRVFVRVNUXCIsZS5Db2RlRXhjaGFuZ2U9XCJDT0RFX0VYQ0hBTkdFXCIsZS5FeHBpcmVUb2tlbnM9XCJFWFBJUkVfVE9LRU5TXCIsZS5HZXRJZFRva2VuPVwiR0VUX0lEX1RPS0VOXCIsZS5Jbml0PVwiSU5JVFwifShmfHwoZj17fSkpO2NvbnN0IG09W10seT1lPT57bS5wdXNoKGUpfSxFPShlLHQpPT4ocixvLGEpPT5uZXcgUHJvbWlzZSgoKGkscyk9Pntjb25zdCBjPXtjb21tYW5kOmYuQ29kZUV4Y2hhbmdlLGRhdGE6e2NvZGU6cixjb2RlVmVyaWZpZXI6byxyZWRpcmVjdFVyaTphfSxpZDpuKCl9LHtjb21tYW5kOmQsaWQ6bH09Yzt5KHtjb21tYW5kOmQsaWQ6bCxyZWplY3Q6cyxyZXNvbHZlOml9KSxlLnBvc3RNZXNzYWdlKGMpLHQubG9nSW5mbyhcIldvcmtlciByZXF1ZXN0IHNlbnRcIixjKX0pKSx2PShlLHQscik9PihvLGEsaSxzLGMpPT5uZXcgUHJvbWlzZSgoKGQsbCk9Pntjb25zdCB1PXtjb21tYW5kOmYuQXBpUmVxdWVzdCxkYXRhOnthcGlSZXF1ZXN0VXJsOm8sY2xpZW50SWQ6ZSxkYXRhOmksaGVhZGVyczpzLGh0dHBNZXRob2Q6YSxpbmNsdWRlQXV0aG9yaXphdGlvbjpjfSxpZDpuKCl9LHtjb21tYW5kOmgsaWQ6cH09dTt5KHtjb21tYW5kOmgsaWQ6cCxyZWplY3Q6bCxyZXNvbHZlOmR9KSx0LnBvc3RNZXNzYWdlKHUpLHIubG9nSW5mbyhcIldvcmtlciByZXF1ZXN0IHNlbnRcIix1KX0pKSxTPShlLHQpPT5yPT5uZXcgUHJvbWlzZSgoKG8sYSk9Pntjb25zdCBpPXtjb21tYW5kOmYuRXhwaXJlVG9rZW5zLGV4cGlyZUFjY2Vzc1Rva2VuT25seTpyLGlkOm4oKX0se2NvbW1hbmQ6cyxpZDpjfT1pO3koe2NvbW1hbmQ6cyxpZDpjLHJlamVjdDphLHJlc29sdmU6b30pLGUucG9zdE1lc3NhZ2UoaSksdC5sb2dJbmZvKFwiV29ya2VyIHJlcXVlc3Qgc2VudFwiLGkpfSkpLGI9KGUsdCk9PmFzeW5jKCk9Pihhd2FpdCBuZXcgUHJvbWlzZSgoKHIsbyk9Pntjb25zdCBhPXtjb21tYW5kOmYuR2V0SWRUb2tlbixpZDpuKCl9LHtjb21tYW5kOmksaWQ6c309YTt5KHtjb21tYW5kOmksaWQ6cyxyZWplY3Q6byxyZXNvbHZlOnJ9KSxlLnBvc3RNZXNzYWdlKGEpLHQubG9nSW5mbyhcIldvcmtlciByZXF1ZXN0IHNlbnRcIixhKX0pKSkuaWRUb2tlbixBPWFzeW5jKGUsdCxyKT0+e2NvbnN0IG89bmV3IEJsb2IoW2AoJHtnfSkoKWBdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSxhPVVSTC5jcmVhdGVPYmplY3RVUkwobyksaT1uZXcgV29ya2VyKGEpO3JldHVybiBpLm9ubWVzc2FnZT1fKHIpLGF3YWl0KChlLHQscixvKT0+bmV3IFByb21pc2UoKChhLGkpPT57Y29uc3Qgcz17Y29tbWFuZDpmLkluaXQsZGF0YTp7Y2xpZW50SWQ6dCxtZXRhZGF0YTplfSxpZDpuKCl9LHtjb21tYW5kOmMsaWQ6ZH09czt5KHtjb21tYW5kOmMsaWQ6ZCxyZWplY3Q6aSxyZXNvbHZlOmF9KSxyLnBvc3RNZXNzYWdlKHMpLG8ubG9nSW5mbyhcIldvcmtlciByZXF1ZXN0IHNlbnRcIixzKX0pKSkoZSx0LGkscikse2V4Y2hhbmdlQ29kZUZvclRva2VuczpFKGksciksZXhlY3V0ZUFwaVJlcXVlc3Q6dih0LGksciksZXhwaXJlVG9rZW5zOlMoaSxyKSxnZXRJZFRva2VuOmIoaSxyKSx0ZXJtaW5hdGU6SShpLHIpfX0sXz1lPT50PT57ZS5sb2dJbmZvKFwiV29ya2VyIHJlc3BvbnNlIHJlY2VpdmVkXCIsdC5kYXRhKTtjb25zdCByPXQuZGF0YSx7Y29tbWFuZDpvLGVycm9yOm4saWQ6YX09cixpPWZ1bmN0aW9uKGUsdCl7dmFyIHI9e307Zm9yKHZhciBvIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbykmJnQuaW5kZXhPZihvKTwwJiYocltvXT1lW29dKTtpZihudWxsIT1lJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj0wO2ZvcihvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bjxvLmxlbmd0aDtuKyspdC5pbmRleE9mKG9bbl0pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLG9bbl0pJiYocltvW25dXT1lW29bbl1dKX1yZXR1cm4gcn0ocixbXCJjb21tYW5kXCIsXCJlcnJvclwiLFwiaWRcIl0pLHM9KChlLHQpPT5tLmZpbmQoKHI9PnIuY29tbWFuZD09PXQmJnIuaWQ9PT1lKSkpKGEsbyk7cz8obj8oXCJzdGF0dXNcImluIGkmJnZvaWQgMCE9PWkuc3RhdHVzJiYobi5zdGF0dXM9aS5zdGF0dXMpLHMucmVqZWN0KG4pKTpzLnJlc29sdmUoaSksayhhLG8pKTplLmxvZ0Vycm9yKG5ldyBFcnJvcihcIlVuYWJsZSB0byBsb2NhdGUgYXdhaXRlZCByZXF1ZXN0XCIpKX0saz0oZSx0KT0+e2NvbnN0IHI9bS5maW5kSW5kZXgoKHI9PnIuY29tbWFuZD09PXQmJnIuaWQ9PT1lKSk7cj49MCYmbS5zcGxpY2UociwxKX0sST0oZSx0KT0+YXN5bmMoKT0+e3RyeXthd2FpdCBTKGUsdCkoITEpfWNhdGNoKGUpe3QubG9nV2FybmluZyhlLm1lc3NhZ2UpfWUudGVybWluYXRlKCksdC5sb2dJbmZvKFwiV29ya2VyIHRlcm1pbmF0ZWRcIil9O2NsYXNzIFR7Z2V0IGFwaU9yaWdpbigpe3JldHVybiB0aGlzLl9hcGlPcmlnaW59Z2V0IGNsaWVudElkKCl7cmV0dXJuIHRoaXMuX2NsaWVudElkfWdldCBsb2dnZXIoKXtyZXR1cm4gdGhpcy5fbG9nZ2VyfWdldCBtZXRhZGF0YSgpe3JldHVybiB0aGlzLl9tZXRhZGF0YX1nZXQgd29ya2VyKCl7cmV0dXJuIHRoaXMuX3dvcmtlcn1jb25zdHJ1Y3RvcihlLHQscixvLG4pe2lmKHRoaXMuZXhlY3V0ZUFwaVJlcXVlc3Q9YXN5bmMoZSx0PVwiR0VUXCIscixvLG49ITAsYT0hMSk9Pnt0aGlzLl9sb2dnZXIubG9nSW5mbyhcIkV4ZWN1dGVBcGlSZXF1ZXN0IHN0YXJ0ZWRcIixlLHQscixvKTt0cnl7Y29uc3QgYT1hd2FpdCgoZSx0KT0+YXN5bmMocixvLG4sYSxpKT0+e3RyeXtyZXR1cm4gYXdhaXQgdC5leGVjdXRlQXBpUmVxdWVzdChgJHtlfSR7cn1gLG8sbixhLGkpfWNhdGNoKGUpe2xldCB0O2NvbnN0e2RhdGE6cixtZXNzYWdlOm8sc3RhdHVzOm59PWU7dGhyb3cgdD1lIGluc3RhbmNlb2YgRXJyb3I/bmV3IEFwaVJlcXVlc3RFcnJvcihvLG4pOlwiRmFpbGVkIHRvIHJlZnJlc2ggYWNjZXNzIHRva2VuXCI9PT1vP25ldyBBdXRoVG9rZW5FeHBpcmVkRXJyb3Iobyk6bmV3IEFwaVJlcXVlc3RFcnJvcihvLG4pLHQuZGF0YT1yLHR9fSkodGhpcy5fYXBpT3JpZ2luLHRoaXMuX3dvcmtlcikoZSx0LHIsbyxuKTtyZXR1cm4gdGhpcy5fbG9nZ2VyLmxvZ0luZm8oXCJFeGVjdXRlQXBpUmVxdWVzdCBjb21wbGV0ZWRcIixhKSxhfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBBcGlSZXF1ZXN0RXJyb3Ipe2NvbnN0e2RhdGE6dCxtZXNzYWdlOnIsbmFtZTpvLHN0YWNrOm59PWUsYT10aGlzLmdldEVycm9yTWVzc2FnZUZyb21TZXJ2ZXJSZXNwb25zZSh0KTthJiYoZS5tZXNzYWdlPWEsZS5zdGFjaz1udWxsPT1uP3ZvaWQgMDpuLnJlcGxhY2UoYCR7b306ICR7cn1gLGAke299OiAke2F9YCkpfXRocm93IGEmJnRoaXMubG9nZ2VyLmxvZ0Vycm9yKGUpLGV9fSwhKHQmJnImJm8mJm4pKXRocm93IG5ldyBJbml0aWFsaXphdGlvbkVycm9yKFwiUHJvdmlkZXIgaGFzIG5vdCBiZWVuIHByb3Blcmx5IGluaXRpYWxpemVkIChjYWxsIGluaXQgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMpXCIpO3RoaXMuX2FwaU9yaWdpbj1udWxsIT1lP2U6XCJcIix0aGlzLl9jbGllbnRJZD10LHRoaXMuX21ldGFkYXRhPXIsdGhpcy5fd29ya2VyPW8sdGhpcy5fbG9nZ2VyPW4sdGhpcy5hdXRob3JpemU9dGhpcy5hdXRob3JpemUuYmluZCh0aGlzKSx0aGlzLmNsb3NlPXRoaXMuY2xvc2UuYmluZCh0aGlzKSx0aGlzLmV4ZWN1dGVBcGlSZXF1ZXN0PXRoaXMuZXhlY3V0ZUFwaVJlcXVlc3QuYmluZCh0aGlzKSx0aGlzLmV4cGlyZVRva2Vucz10aGlzLmV4cGlyZVRva2Vucy5iaW5kKHRoaXMpLHRoaXMuZ2V0RXJyb3JNZXNzYWdlRnJvbVNlcnZlclJlc3BvbnNlPXRoaXMuZ2V0RXJyb3JNZXNzYWdlRnJvbVNlcnZlclJlc3BvbnNlLmJpbmQodGhpcyksdGhpcy5nZXRJZFRva2VuPXRoaXMuZ2V0SWRUb2tlbi5iaW5kKHRoaXMpfWFzeW5jIGF1dGhvcml6ZShlLHQscil7dGhpcy5fbG9nZ2VyLmxvZ0luZm8oXCJBdXRob3JpemUgc3RhcnRlZFwiLGUsdCxyKTt0cnl7YXdhaXQobz10aGlzLl9tZXRhZGF0YSxpPXRoaXMuX2NsaWVudElkLGQ9dGhpcy5fd29ya2VyLGw9dGhpcy5fbG9nZ2VyLGFzeW5jKGUsdD17fSxyPXt9KT0+e2NvbnN0e2F1dGhvcml6YXRpb25fZW5kcG9pbnQ6dX09byxoPWZpbi5BcHBsaWNhdGlvbi5nZXRDdXJyZW50U3luYygpLHA9KGF3YWl0IGguZ2V0Q2hpbGRXaW5kb3dzKCkpLmZpbmQoKGU9PmUuaWRlbnRpdHkubmFtZT09PWEpKTtwJiZhd2FpdCBwLmNsb3NlKCEwKTtjb25zdCB3PW4oKSxnPSgoKT0+e2NvbnN0IGU9bmV3IFVpbnQzMkFycmF5KDY0KTtyZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoZSksQXJyYXkuZnJvbShlLChlPT5gMCR7ZS50b1N0cmluZygxNil9YC5zbGljZSgtMikpKS5qb2luKFwiXCIpfSkoKSxmPShhd2FpdChhc3luYyBlPT57Y29uc3QgdD0obmV3IFRleHRFbmNvZGVyKS5lbmNvZGUoZSkscj1hd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtMjU2XCIsdCksbz1hd2FpdChlPT5uZXcgUHJvbWlzZSgoKHQscik9Pnt0cnl7Y29uc3Qgbz1uZXcgQmxvYihbZV0pLG49bmV3IEZpbGVSZWFkZXI7bi5vbmxvYWQ9ZT0+e3ZhciBvLG47Y29uc3QgYT1udWxsPT09KG89ZS50YXJnZXQpfHx2b2lkIDA9PT1vP3ZvaWQgMDpvLnJlc3VsdDtpZihhKXtjb25zdFssZV09QXJyYXkuZnJvbShudWxsIT09KG49YS5tYXRjaCgvYmFzZTY0LCguKikkL2kpKSYmdm9pZCAwIT09bj9uOltdKTt0KG51bGwhPWU/ZTpcIlwiKX1yKG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZW1wdHkgcmVzdWx0XCIpKX0sbi5yZWFkQXNEYXRhVVJMKG8pfWNhdGNoKGUpe3IoZSl9fSkpKShyKTtyZXR1cm4gby5yZXBsYWNlKC9cXCsvZyxcIi1cIikucmVwbGFjZSgvXFwvL2csXCJfXCIpfSkoZykpLnJlcGxhY2UoLz0rJC8sXCJcIiksbT1uZXcgVVJMKHUpO20uc2VhcmNoUGFyYW1zLnNldChcImNsaWVudF9pZFwiLGkpLG0uc2VhcmNoUGFyYW1zLnNldChcInJlZGlyZWN0X3VyaVwiLGUpLG0uc2VhcmNoUGFyYW1zLnNldChcInJlc3BvbnNlX3R5cGVcIixcImNvZGVcIiksbS5zZWFyY2hQYXJhbXMuc2V0KFwic3RhdGVcIix3KSxtLnNlYXJjaFBhcmFtcy5zZXQoXCJjb2RlX2NoYWxsZW5nZVwiLGYpLG0uc2VhcmNoUGFyYW1zLnNldChcImNvZGVfY2hhbGxlbmdlX21ldGhvZFwiLFwiUzI1NlwiKSxPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKChlPT5tLnNlYXJjaFBhcmFtcy5zZXQoZVswXSxlWzFdKSkpLGwubG9nSW5mbyhcIlN0YXJ0aW5nIE9BdXRoIGZsb3dcIixtLHIpO2NvbnN0IHk9YXdhaXQgcyhtLnRvU3RyaW5nKCksYyh3LGUsbCkscik7bC5sb2dJbmZvKFwiUmVjZWl2ZWQgYXV0aG9yaXphdGlvbiBjb2RlXCIpLGF3YWl0IGQuZXhjaGFuZ2VDb2RlRm9yVG9rZW5zKHksZyxlKSxsLmxvZ0luZm8oXCJSZWNlaXZlZCB0b2tlbnNcIil9KShlLHQsciksdGhpcy5fbG9nZ2VyLmxvZ0luZm8oXCJBdXRob3JpemUgY29tcGxldGVkXCIpfWNhdGNoKGUpe2xldCB0O2lmKGUgaW5zdGFuY2VvZiBBcGlFcnJvcil7Y29uc3R7ZGF0YTpyfT1lLG89dGhpcy5nZXRFcnJvck1lc3NhZ2VGcm9tU2VydmVyUmVzcG9uc2Uocik7dD1uZXcgQXV0aG9yaXphdGlvbkVycm9yKG8sZSksdC5kYXRhPXJ9ZWxzZSB0PW5ldyBBdXRob3JpemF0aW9uRXJyb3Iodm9pZCAwLGUpO3Rocm93IHRoaXMubG9nZ2VyLmxvZ0Vycm9yKHQpLHR9dmFyIG8saSxkLGx9YXN5bmMgY2xvc2UoKXt2YXIgZTt0aGlzLl9sb2dnZXIubG9nSW5mbyhcIkNsb3NlIHN0YXJ0ZWRcIik7dHJ5e2F3YWl0KG51bGw9PT0oZT10aGlzLl93b3JrZXIpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnRlcm1pbmF0ZSgpKSx0aGlzLl93b3JrZXI9dm9pZCAwLHRoaXMuX2FwaU9yaWdpbj12b2lkIDAsdGhpcy5fY2xpZW50SWQ9dm9pZCAwLHRoaXMuX21ldGFkYXRhPXZvaWQgMCx0aGlzLl9sb2dnZXIubG9nSW5mbyhcIkNsb3NlIGNvbXBsZXRlZFwiKX1jYXRjaChlKXtjb25zdCB0PW5ldyBBcGlFcnJvcih2b2lkIDAsZSk7dGhyb3cgdGhpcy5fbG9nZ2VyLmxvZ0Vycm9yKHQpLHR9fWFzeW5jIGV4cGlyZVRva2VucyhlPSExKXt2YXIgdDt0aGlzLl9sb2dnZXIubG9nSW5mbyhcIkV4cGlyZVRva2VucyBzdGFydGVkXCIpO3RyeXthd2FpdChudWxsPT09KHQ9dGhpcy5fd29ya2VyKXx8dm9pZCAwPT09dD92b2lkIDA6dC5leHBpcmVUb2tlbnMoZSkpLHRoaXMuX2xvZ2dlci5sb2dJbmZvKFwiRXhwaXJlVG9rZW5zIGNvbXBsZXRlZFwiKX1jYXRjaChlKXtjb25zdCB0PW5ldyBBcGlFcnJvcih2b2lkIDAsZSk7dGhyb3cgdGhpcy5fbG9nZ2VyLmxvZ0Vycm9yKHQpLHR9fWdldEVycm9yTWVzc2FnZUZyb21TZXJ2ZXJSZXNwb25zZShlKXtlJiZ0aGlzLl9sb2dnZXIubG9nV2FybmluZyhlKX1hc3luYyBnZXRJZFRva2VuKCl7dmFyIGU7dGhpcy5fbG9nZ2VyLmxvZ0luZm8oXCJHZXRJZFRva2VuIHN0YXJ0ZWRcIik7dHJ5e2NvbnN0IHQ9YXdhaXQobnVsbD09PShlPXRoaXMuX3dvcmtlcil8fHZvaWQgMD09PWU/dm9pZCAwOmUuZ2V0SWRUb2tlbigpKTtyZXR1cm4gdGhpcy5fbG9nZ2VyLmxvZ0luZm8oXCJHZXRJZFRva2VuIGNvbXBsZXRlZFwiLHQpLHR9Y2F0Y2goZSl7Y29uc3QgdD1uZXcgQXBpRXJyb3Iodm9pZCAwLGUpO3Rocm93IHRoaXMuX2xvZ2dlci5sb2dFcnJvcih0KSx0fX1zdGF0aWMgYXN5bmMgaW5pdChlLHQscixvLC4uLm4pe2NvbnN0IGE9bmV3IHcobyk7YS5sb2dJbmZvKFwiSW5pdCBzdGFydGVkXCIsZSx0LHIpO3RyeXtsZXQgbztpZihcImRpc2NvdmVyeUVuZHBvaW50XCJpbiBlKXtjb25zdHthZGRpdGlvbmFsTWV0YWRhdGE6dCxkaXNjb3ZlcnlFbmRwb2ludDpyfT1lO289T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGF3YWl0IGQocikpLG51bGwhPXQ/dDp7fSl9ZWxzZSBvPWU7aWYoIW8ucmVzcG9uc2VfdHlwZXNfc3VwcG9ydGVkLmZpbmQoKGU9PlwiY29kZVwiPT09ZS50b0xvd2VyQ2FzZSgpKSkpdGhyb3cgbmV3IEluaXRpYWxpemF0aW9uRXJyb3IoXCJBdXRob3JpemF0aW9uIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBhdXRob3JpemF0aW9uIGNvZGUgcmVzcG9uc2UgdHlwZVwiKTtjb25zdCBuPWF3YWl0IEEobyxyLGEpLGk9bmV3IFQodCxyLG8sbixhKTtyZXR1cm4gYS5sb2dJbmZvKFwiSW5pdCBjb21wbGV0ZWRcIixpKSxpfWNhdGNoKGUpe2xldCB0O3Rocm93IHQ9ZSBpbnN0YW5jZW9mIEFwaUVycm9yP2U6bmV3IEluaXRpYWxpemF0aW9uRXJyb3Iodm9pZCAwLGUpLGEubG9nRXJyb3IodCksdH19fWNvbnN0IE89ZT0+YXN5bmModCxyLG8pPT57bGV0IG47bnVsbD09ZXx8ZS5sb2dJbmZvKFwiVmFsaWRhdGluZyB0b2tlbiBhZ2FpbnN0IGludHJvc3BlY3Rpb24gZW5kcG9pbnRcIix0LHIsbyk7dHJ5e249YXdhaXQgZmV0Y2gobyx7bWV0aG9kOlwiUE9TVFwiLGhlYWRlcnM6e1wiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIn0sYm9keTpgdG9rZW49JHt0fSZjbGllbnRfaWQ9JHtyfWB9KX1jYXRjaChlKXt0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHZvaWQgMCxlKX1pZihuLm9rKXtjb25zdCB0PWF3YWl0IG4uanNvbigpLHthY3RpdmU6cn09dCxvPWZ1bmN0aW9uKGUsdCl7dmFyIHI9e307Zm9yKHZhciBvIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbykmJnQuaW5kZXhPZihvKTwwJiYocltvXT1lW29dKTtpZihudWxsIT1lJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj0wO2ZvcihvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bjxvLmxlbmd0aDtuKyspdC5pbmRleE9mKG9bbl0pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLG9bbl0pJiYocltvW25dXT1lW29bbl1dKX1yZXR1cm4gcn0odCxbXCJhY3RpdmVcIl0pLGE9T2JqZWN0LmFzc2lnbih7dmFsaWQ6cn0sbyk7cmV0dXJuIG51bGw9PWV8fGUubG9nSW5mbyhcIlRva2VuIHZhbGlkYXRpb24gcmVzdWx0XCIsYSksYX1jb25zdCBhPWF3YWl0IG4uanNvbigpO3Rocm93IG51bGw9PWV8fGUubG9nV2FybmluZyhcIlRva2VuIFZhbGlkYXRpb24gZmFpbGVkXCIsYSksbmV3IFZhbGlkYXRpb25FcnJvcn07dmFyIFI9by5NUyxQPW8uY1gsQz1vLllkLFc9by5PNCx4PW8uX1csaj1vLnA4LCQ9by5tJCxKPW8uVSQsVT1vLlU3LEs9by5PVixEPW8uTjcsTD1vLlJwO2NvbnN0IEg9bmV3IFRleHRFbmNvZGVyLE09bmV3IFRleHREZWNvZGVyO2Z1bmN0aW9uIHooLi4uZSl7Y29uc3QgdD1lLnJlZHVjZSgoKGUse2xlbmd0aDp0fSk9PmUrdCksMCkscj1uZXcgVWludDhBcnJheSh0KTtsZXQgbz0wO3JldHVybiBlLmZvckVhY2goKGU9PntyLnNldChlLG8pLG8rPWUubGVuZ3RofSkpLHJ9Y29uc3QgTj1lPT57bGV0IHQ9ZTt0IGluc3RhbmNlb2YgVWludDhBcnJheSYmKHQ9TS5kZWNvZGUodCkpLHQ9dC5yZXBsYWNlKC8tL2csXCIrXCIpLnJlcGxhY2UoL18vZyxcIi9cIikucmVwbGFjZSgvXFxzL2csXCJcIik7dHJ5e3JldHVybihlPT57Y29uc3QgdD1hdG9iKGUpLHI9bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXJbZV09dC5jaGFyQ29kZUF0KGUpO3JldHVybiByfSkodCl9Y2F0Y2goZSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBpbnB1dCB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC5cIil9fTtjbGFzcyBKT1NFRXJyb3IgZXh0ZW5kcyBFcnJvcntzdGF0aWMgZ2V0IGNvZGUoKXtyZXR1cm5cIkVSUl9KT1NFX0dFTkVSSUNcIn1jb25zdHJ1Y3RvcihlKXt2YXIgdDtzdXBlcihlKSx0aGlzLmNvZGU9XCJFUlJfSk9TRV9HRU5FUklDXCIsdGhpcy5uYW1lPXRoaXMuY29uc3RydWN0b3IubmFtZSxudWxsPT09KHQ9RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpfHx2b2lkIDA9PT10fHx0LmNhbGwoRXJyb3IsdGhpcyx0aGlzLmNvbnN0cnVjdG9yKX19Y2xhc3MgRiBleHRlbmRzIEpPU0VFcnJvcntzdGF0aWMgZ2V0IGNvZGUoKXtyZXR1cm5cIkVSUl9KV1RfQ0xBSU1fVkFMSURBVElPTl9GQUlMRURcIn1jb25zdHJ1Y3RvcihlLHQ9XCJ1bnNwZWNpZmllZFwiLHI9XCJ1bnNwZWNpZmllZFwiKXtzdXBlcihlKSx0aGlzLmNvZGU9XCJFUlJfSldUX0NMQUlNX1ZBTElEQVRJT05fRkFJTEVEXCIsdGhpcy5jbGFpbT10LHRoaXMucmVhc29uPXJ9fWNsYXNzIHEgZXh0ZW5kcyBKT1NFRXJyb3J7c3RhdGljIGdldCBjb2RlKCl7cmV0dXJuXCJFUlJfSldUX0VYUElSRURcIn1jb25zdHJ1Y3RvcihlLHQ9XCJ1bnNwZWNpZmllZFwiLHI9XCJ1bnNwZWNpZmllZFwiKXtzdXBlcihlKSx0aGlzLmNvZGU9XCJFUlJfSldUX0VYUElSRURcIix0aGlzLmNsYWltPXQsdGhpcy5yZWFzb249cn19Y2xhc3MgRyBleHRlbmRzIEpPU0VFcnJvcntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5jb2RlPVwiRVJSX0pPU0VfQUxHX05PVF9BTExPV0VEXCJ9c3RhdGljIGdldCBjb2RlKCl7cmV0dXJuXCJFUlJfSk9TRV9BTEdfTk9UX0FMTE9XRURcIn19Y2xhc3MgViBleHRlbmRzIEpPU0VFcnJvcntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5jb2RlPVwiRVJSX0pPU0VfTk9UX1NVUFBPUlRFRFwifXN0YXRpYyBnZXQgY29kZSgpe3JldHVyblwiRVJSX0pPU0VfTk9UX1NVUFBPUlRFRFwifX1jbGFzcyBCIGV4dGVuZHMgSk9TRUVycm9ye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLmNvZGU9XCJFUlJfSldTX0lOVkFMSURcIn1zdGF0aWMgZ2V0IGNvZGUoKXtyZXR1cm5cIkVSUl9KV1NfSU5WQUxJRFwifX1jbGFzcyBYIGV4dGVuZHMgSk9TRUVycm9ye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLmNvZGU9XCJFUlJfSldUX0lOVkFMSURcIn1zdGF0aWMgZ2V0IGNvZGUoKXtyZXR1cm5cIkVSUl9KV1RfSU5WQUxJRFwifX1jbGFzcyBZIGV4dGVuZHMgSk9TRUVycm9ye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLmNvZGU9XCJFUlJfSldLU19JTlZBTElEXCJ9c3RhdGljIGdldCBjb2RlKCl7cmV0dXJuXCJFUlJfSldLU19JTlZBTElEXCJ9fWNsYXNzIFEgZXh0ZW5kcyBKT1NFRXJyb3J7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuY29kZT1cIkVSUl9KV0tTX05PX01BVENISU5HX0tFWVwiLHRoaXMubWVzc2FnZT1cIm5vIGFwcGxpY2FibGUga2V5IGZvdW5kIGluIHRoZSBKU09OIFdlYiBLZXkgU2V0XCJ9c3RhdGljIGdldCBjb2RlKCl7cmV0dXJuXCJFUlJfSldLU19OT19NQVRDSElOR19LRVlcIn19Y2xhc3MgWiBleHRlbmRzIEpPU0VFcnJvcntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5jb2RlPVwiRVJSX0pXS1NfTVVMVElQTEVfTUFUQ0hJTkdfS0VZU1wiLHRoaXMubWVzc2FnZT1cIm11bHRpcGxlIG1hdGNoaW5nIGtleXMgZm91bmQgaW4gdGhlIEpTT04gV2ViIEtleSBTZXRcIn1zdGF0aWMgZ2V0IGNvZGUoKXtyZXR1cm5cIkVSUl9KV0tTX01VTFRJUExFX01BVENISU5HX0tFWVNcIn19U3ltYm9sLmFzeW5jSXRlcmF0b3I7Y2xhc3MgZWUgZXh0ZW5kcyBKT1NFRXJyb3J7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuY29kZT1cIkVSUl9KV0tTX1RJTUVPVVRcIix0aGlzLm1lc3NhZ2U9XCJyZXF1ZXN0IHRpbWVkIG91dFwifXN0YXRpYyBnZXQgY29kZSgpe3JldHVyblwiRVJSX0pXS1NfVElNRU9VVFwifX1jbGFzcyB0ZSBleHRlbmRzIEpPU0VFcnJvcntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5jb2RlPVwiRVJSX0pXU19TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxFRFwiLHRoaXMubWVzc2FnZT1cInNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkXCJ9c3RhdGljIGdldCBjb2RlKCl7cmV0dXJuXCJFUlJfSldTX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTEVEXCJ9fWNvbnN0IHJlPWNyeXB0byxvZT1lPT5lIGluc3RhbmNlb2YgQ3J5cHRvS2V5O3JlLmdldFJhbmRvbVZhbHVlcy5iaW5kKHJlKTtjb25zdCBuZT1hc3luYyBlPT57dmFyIHQscjtpZighZS5hbGcpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbGdcIiBhcmd1bWVudCBpcyByZXF1aXJlZCB3aGVuIFwiandrLmFsZ1wiIGlzIG5vdCBwcmVzZW50Jyk7Y29uc3R7YWxnb3JpdGhtOm8sa2V5VXNhZ2VzOm59PWZ1bmN0aW9uKGUpe2xldCB0LHI7c3dpdGNoKGUua3R5KXtjYXNlXCJvY3RcIjpzd2l0Y2goZS5hbGcpe2Nhc2VcIkhTMjU2XCI6Y2FzZVwiSFMzODRcIjpjYXNlXCJIUzUxMlwiOnQ9e25hbWU6XCJITUFDXCIsaGFzaDpgU0hBLSR7ZS5hbGcuc2xpY2UoLTMpfWB9LHI9W1wic2lnblwiLFwidmVyaWZ5XCJdO2JyZWFrO2Nhc2VcIkExMjhDQkMtSFMyNTZcIjpjYXNlXCJBMTkyQ0JDLUhTMzg0XCI6Y2FzZVwiQTI1NkNCQy1IUzUxMlwiOnRocm93IG5ldyBWKGAke2UuYWxnfSBrZXlzIGNhbm5vdCBiZSBpbXBvcnRlZCBhcyBDcnlwdG9LZXkgaW5zdGFuY2VzYCk7Y2FzZVwiQTEyOEdDTVwiOmNhc2VcIkExOTJHQ01cIjpjYXNlXCJBMjU2R0NNXCI6Y2FzZVwiQTEyOEdDTUtXXCI6Y2FzZVwiQTE5MkdDTUtXXCI6Y2FzZVwiQTI1NkdDTUtXXCI6dD17bmFtZTpcIkFFUy1HQ01cIn0scj1bXCJlbmNyeXB0XCIsXCJkZWNyeXB0XCJdO2JyZWFrO2Nhc2VcIkExMjhLV1wiOmNhc2VcIkExOTJLV1wiOmNhc2VcIkEyNTZLV1wiOnQ9e25hbWU6XCJBRVMtS1dcIn0scj1bXCJ3cmFwS2V5XCIsXCJ1bndyYXBLZXlcIl07YnJlYWs7Y2FzZVwiUEJFUzItSFMyNTYrQTEyOEtXXCI6Y2FzZVwiUEJFUzItSFMzODQrQTE5MktXXCI6Y2FzZVwiUEJFUzItSFM1MTIrQTI1NktXXCI6dD17bmFtZTpcIlBCS0RGMlwifSxyPVtcImRlcml2ZUJpdHNcIl07YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgVignSW52YWxpZCBvciB1bnN1cHBvcnRlZCBKV0sgXCJhbGdcIiAoQWxnb3JpdGhtKSBQYXJhbWV0ZXIgdmFsdWUnKX1icmVhaztjYXNlXCJSU0FcIjpzd2l0Y2goZS5hbGcpe2Nhc2VcIlBTMjU2XCI6Y2FzZVwiUFMzODRcIjpjYXNlXCJQUzUxMlwiOnQ9e25hbWU6XCJSU0EtUFNTXCIsaGFzaDpgU0hBLSR7ZS5hbGcuc2xpY2UoLTMpfWB9LHI9ZS5kP1tcInNpZ25cIl06W1widmVyaWZ5XCJdO2JyZWFrO2Nhc2VcIlJTMjU2XCI6Y2FzZVwiUlMzODRcIjpjYXNlXCJSUzUxMlwiOnQ9e25hbWU6XCJSU0FTU0EtUEtDUzEtdjFfNVwiLGhhc2g6YFNIQS0ke2UuYWxnLnNsaWNlKC0zKX1gfSxyPWUuZD9bXCJzaWduXCJdOltcInZlcmlmeVwiXTticmVhaztjYXNlXCJSU0EtT0FFUFwiOmNhc2VcIlJTQS1PQUVQLTI1NlwiOmNhc2VcIlJTQS1PQUVQLTM4NFwiOmNhc2VcIlJTQS1PQUVQLTUxMlwiOnQ9e25hbWU6XCJSU0EtT0FFUFwiLGhhc2g6YFNIQS0ke3BhcnNlSW50KGUuYWxnLnNsaWNlKC0zKSwxMCl8fDF9YH0scj1lLmQ/W1wiZGVjcnlwdFwiLFwidW53cmFwS2V5XCJdOltcImVuY3J5cHRcIixcIndyYXBLZXlcIl07YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgVignSW52YWxpZCBvciB1bnN1cHBvcnRlZCBKV0sgXCJhbGdcIiAoQWxnb3JpdGhtKSBQYXJhbWV0ZXIgdmFsdWUnKX1icmVhaztjYXNlXCJFQ1wiOnN3aXRjaChlLmFsZyl7Y2FzZVwiRVMyNTZcIjp0PXtuYW1lOlwiRUNEU0FcIixuYW1lZEN1cnZlOlwiUC0yNTZcIn0scj1lLmQ/W1wic2lnblwiXTpbXCJ2ZXJpZnlcIl07YnJlYWs7Y2FzZVwiRVMzODRcIjp0PXtuYW1lOlwiRUNEU0FcIixuYW1lZEN1cnZlOlwiUC0zODRcIn0scj1lLmQ/W1wic2lnblwiXTpbXCJ2ZXJpZnlcIl07YnJlYWs7Y2FzZVwiRVM1MTJcIjp0PXtuYW1lOlwiRUNEU0FcIixuYW1lZEN1cnZlOlwiUC01MjFcIn0scj1lLmQ/W1wic2lnblwiXTpbXCJ2ZXJpZnlcIl07YnJlYWs7Y2FzZVwiRUNESC1FU1wiOmNhc2VcIkVDREgtRVMrQTEyOEtXXCI6Y2FzZVwiRUNESC1FUytBMTkyS1dcIjpjYXNlXCJFQ0RILUVTK0EyNTZLV1wiOnQ9e25hbWU6XCJFQ0RIXCIsbmFtZWRDdXJ2ZTplLmNydn0scj1lLmQ/W1wiZGVyaXZlQml0c1wiXTpbXTticmVhaztkZWZhdWx0OnRocm93IG5ldyBWKCdJbnZhbGlkIG9yIHVuc3VwcG9ydGVkIEpXSyBcImFsZ1wiIChBbGdvcml0aG0pIFBhcmFtZXRlciB2YWx1ZScpfWJyZWFrO2Nhc2VcIk9LUFwiOnN3aXRjaChlLmFsZyl7Y2FzZVwiRWREU0FcIjp0PXtuYW1lOmUuY3J2fSxyPWUuZD9bXCJzaWduXCJdOltcInZlcmlmeVwiXTticmVhaztjYXNlXCJFQ0RILUVTXCI6Y2FzZVwiRUNESC1FUytBMTI4S1dcIjpjYXNlXCJFQ0RILUVTK0ExOTJLV1wiOmNhc2VcIkVDREgtRVMrQTI1NktXXCI6dD17bmFtZTplLmNydn0scj1lLmQ/W1wiZGVyaXZlQml0c1wiXTpbXTticmVhaztkZWZhdWx0OnRocm93IG5ldyBWKCdJbnZhbGlkIG9yIHVuc3VwcG9ydGVkIEpXSyBcImFsZ1wiIChBbGdvcml0aG0pIFBhcmFtZXRlciB2YWx1ZScpfWJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IFYoJ0ludmFsaWQgb3IgdW5zdXBwb3J0ZWQgSldLIFwia3R5XCIgKEtleSBUeXBlKSBQYXJhbWV0ZXIgdmFsdWUnKX1yZXR1cm57YWxnb3JpdGhtOnQsa2V5VXNhZ2VzOnJ9fShlKSxhPVtvLG51bGwhPT0odD1lLmV4dCkmJnZvaWQgMCE9PXQmJnQsbnVsbCE9PShyPWUua2V5X29wcykmJnZvaWQgMCE9PXI/cjpuXTtpZihcIlBCS0RGMlwiPT09by5uYW1lKXJldHVybiByZS5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsTihlLmspLC4uLmEpO2NvbnN0IGk9ey4uLmV9O3JldHVybiBkZWxldGUgaS5hbGcsZGVsZXRlIGkudXNlLHJlLnN1YnRsZS5pbXBvcnRLZXkoXCJqd2tcIixpLC4uLmEpfTtmdW5jdGlvbiBhZShlKXtpZihcIm9iamVjdFwiIT10eXBlb2YodD1lKXx8bnVsbD09PXR8fFwiW29iamVjdCBPYmplY3RdXCIhPT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpcmV0dXJuITE7dmFyIHQ7aWYobnVsbD09PU9iamVjdC5nZXRQcm90b3R5cGVPZihlKSlyZXR1cm4hMDtsZXQgcj1lO2Zvcig7bnVsbCE9PU9iamVjdC5nZXRQcm90b3R5cGVPZihyKTspcj1PYmplY3QuZ2V0UHJvdG90eXBlT2Yocik7cmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihlKT09PXJ9Y29uc3QgaWU9ZnVuY3Rpb24oZSx0LHIsbyxuKXtpZih2b2lkIDAhPT1uLmNyaXQmJnZvaWQgMD09PW8uY3JpdCl0aHJvdyBuZXcgZSgnXCJjcml0XCIgKENyaXRpY2FsKSBIZWFkZXIgUGFyYW1ldGVyIE1VU1QgYmUgaW50ZWdyaXR5IHByb3RlY3RlZCcpO2lmKCFvfHx2b2lkIDA9PT1vLmNyaXQpcmV0dXJuIG5ldyBTZXQ7aWYoIUFycmF5LmlzQXJyYXkoby5jcml0KXx8MD09PW8uY3JpdC5sZW5ndGh8fG8uY3JpdC5zb21lKChlPT5cInN0cmluZ1wiIT10eXBlb2YgZXx8MD09PWUubGVuZ3RoKSkpdGhyb3cgbmV3IGUoJ1wiY3JpdFwiIChDcml0aWNhbCkgSGVhZGVyIFBhcmFtZXRlciBNVVNUIGJlIGFuIGFycmF5IG9mIG5vbi1lbXB0eSBzdHJpbmdzIHdoZW4gcHJlc2VudCcpO2xldCBhO2E9dm9pZCAwIT09cj9uZXcgTWFwKFsuLi5PYmplY3QuZW50cmllcyhyKSwuLi50LmVudHJpZXMoKV0pOnQ7Zm9yKGNvbnN0IHQgb2Ygby5jcml0KXtpZighYS5oYXModCkpdGhyb3cgbmV3IFYoYEV4dGVuc2lvbiBIZWFkZXIgUGFyYW1ldGVyIFwiJHt0fVwiIGlzIG5vdCByZWNvZ25pemVkYCk7aWYodm9pZCAwPT09blt0XSl0aHJvdyBuZXcgZShgRXh0ZW5zaW9uIEhlYWRlciBQYXJhbWV0ZXIgXCIke3R9XCIgaXMgbWlzc2luZ2ApO2lmKGEuZ2V0KHQpJiZ2b2lkIDA9PT1vW3RdKXRocm93IG5ldyBlKGBFeHRlbnNpb24gSGVhZGVyIFBhcmFtZXRlciBcIiR7dH1cIiBNVVNUIGJlIGludGVncml0eSBwcm90ZWN0ZWRgKX1yZXR1cm4gbmV3IFNldChvLmNyaXQpfTtTeW1ib2woKTtmdW5jdGlvbiBzZShlLHQ9XCJhbGdvcml0aG0ubmFtZVwiKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgQ3J5cHRvS2V5IGRvZXMgbm90IHN1cHBvcnQgdGhpcyBvcGVyYXRpb24sIGl0cyAke3R9IG11c3QgYmUgJHtlfWApfWZ1bmN0aW9uIGNlKGUsdCl7cmV0dXJuIGUubmFtZT09PXR9ZnVuY3Rpb24gZGUoZSl7cmV0dXJuIHBhcnNlSW50KGUubmFtZS5zbGljZSg0KSwxMCl9ZnVuY3Rpb24gbGUoZSx0KXtpZih0Lmxlbmd0aCYmIXQuc29tZSgodD0+ZS51c2FnZXMuaW5jbHVkZXModCkpKSl7bGV0IGU9XCJDcnlwdG9LZXkgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIG9wZXJhdGlvbiwgaXRzIHVzYWdlcyBtdXN0IGluY2x1ZGUgXCI7aWYodC5sZW5ndGg+Mil7Y29uc3Qgcj10LnBvcCgpO2UrPWBvbmUgb2YgJHt0LmpvaW4oXCIsIFwiKX0sIG9yICR7cn0uYH1lbHNlIDI9PT10Lmxlbmd0aD9lKz1gb25lIG9mICR7dFswXX0gb3IgJHt0WzFdfS5gOmUrPWAke3RbMF19LmA7dGhyb3cgbmV3IFR5cGVFcnJvcihlKX19ZnVuY3Rpb24gdWUoZSx0LC4uLnIpe3N3aXRjaCh0KXtjYXNlXCJIUzI1NlwiOmNhc2VcIkhTMzg0XCI6Y2FzZVwiSFM1MTJcIjp7aWYoIWNlKGUuYWxnb3JpdGhtLFwiSE1BQ1wiKSl0aHJvdyBzZShcIkhNQUNcIik7Y29uc3Qgcj1wYXJzZUludCh0LnNsaWNlKDIpLDEwKTtpZihkZShlLmFsZ29yaXRobS5oYXNoKSE9PXIpdGhyb3cgc2UoYFNIQS0ke3J9YCxcImFsZ29yaXRobS5oYXNoXCIpO2JyZWFrfWNhc2VcIlJTMjU2XCI6Y2FzZVwiUlMzODRcIjpjYXNlXCJSUzUxMlwiOntpZighY2UoZS5hbGdvcml0aG0sXCJSU0FTU0EtUEtDUzEtdjFfNVwiKSl0aHJvdyBzZShcIlJTQVNTQS1QS0NTMS12MV81XCIpO2NvbnN0IHI9cGFyc2VJbnQodC5zbGljZSgyKSwxMCk7aWYoZGUoZS5hbGdvcml0aG0uaGFzaCkhPT1yKXRocm93IHNlKGBTSEEtJHtyfWAsXCJhbGdvcml0aG0uaGFzaFwiKTticmVha31jYXNlXCJQUzI1NlwiOmNhc2VcIlBTMzg0XCI6Y2FzZVwiUFM1MTJcIjp7aWYoIWNlKGUuYWxnb3JpdGhtLFwiUlNBLVBTU1wiKSl0aHJvdyBzZShcIlJTQS1QU1NcIik7Y29uc3Qgcj1wYXJzZUludCh0LnNsaWNlKDIpLDEwKTtpZihkZShlLmFsZ29yaXRobS5oYXNoKSE9PXIpdGhyb3cgc2UoYFNIQS0ke3J9YCxcImFsZ29yaXRobS5oYXNoXCIpO2JyZWFrfWNhc2VcIkVkRFNBXCI6aWYoXCJFZDI1NTE5XCIhPT1lLmFsZ29yaXRobS5uYW1lJiZcIkVkNDQ4XCIhPT1lLmFsZ29yaXRobS5uYW1lKXRocm93IHNlKFwiRWQyNTUxOSBvciBFZDQ0OFwiKTticmVhaztjYXNlXCJFUzI1NlwiOmNhc2VcIkVTMzg0XCI6Y2FzZVwiRVM1MTJcIjp7aWYoIWNlKGUuYWxnb3JpdGhtLFwiRUNEU0FcIikpdGhyb3cgc2UoXCJFQ0RTQVwiKTtjb25zdCByPWZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlXCJFUzI1NlwiOnJldHVyblwiUC0yNTZcIjtjYXNlXCJFUzM4NFwiOnJldHVyblwiUC0zODRcIjtjYXNlXCJFUzUxMlwiOnJldHVyblwiUC01MjFcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpfX0odCk7aWYoZS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSE9PXIpdGhyb3cgc2UocixcImFsZ29yaXRobS5uYW1lZEN1cnZlXCIpO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNyeXB0b0tleSBkb2VzIG5vdCBzdXBwb3J0IHRoaXMgb3BlcmF0aW9uXCIpfWxlKGUscil9ZnVuY3Rpb24gaGUoZSx0LC4uLnIpe2lmKHIubGVuZ3RoPjIpe2NvbnN0IHQ9ci5wb3AoKTtlKz1gb25lIG9mIHR5cGUgJHtyLmpvaW4oXCIsIFwiKX0sIG9yICR7dH0uYH1lbHNlIDI9PT1yLmxlbmd0aD9lKz1gb25lIG9mIHR5cGUgJHtyWzBdfSBvciAke3JbMV19LmA6ZSs9YG9mIHR5cGUgJHtyWzBdfS5gO3JldHVybiBudWxsPT10P2UrPWAgUmVjZWl2ZWQgJHt0fWA6XCJmdW5jdGlvblwiPT10eXBlb2YgdCYmdC5uYW1lP2UrPWAgUmVjZWl2ZWQgZnVuY3Rpb24gJHt0Lm5hbWV9YDpcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9dCYmdC5jb25zdHJ1Y3RvciYmdC5jb25zdHJ1Y3Rvci5uYW1lJiYoZSs9YCBSZWNlaXZlZCBhbiBpbnN0YW5jZSBvZiAke3QuY29uc3RydWN0b3IubmFtZX1gKSxlfWNvbnN0IHBlPShlLC4uLnQpPT5oZShcIktleSBtdXN0IGJlIFwiLGUsLi4udCk7ZnVuY3Rpb24gd2UoZSx0LC4uLnIpe3JldHVybiBoZShgS2V5IGZvciB0aGUgJHtlfSBhbGdvcml0aG0gbXVzdCBiZSBgLHQsLi4ucil9Y29uc3QgZ2U9ZT0+b2UoZSksZmU9W1wiQ3J5cHRvS2V5XCJdO2NvbnN0IG1lPWFzeW5jKGUsdCxyLG8pPT57Y29uc3Qgbj1hd2FpdCBmdW5jdGlvbihlLHQscil7aWYob2UodCkpcmV0dXJuIHVlKHQsZSxyKSx0O2lmKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtpZighZS5zdGFydHNXaXRoKFwiSFNcIikpdGhyb3cgbmV3IFR5cGVFcnJvcihwZSh0LC4uLmZlKSk7cmV0dXJuIHJlLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIix0LHtoYXNoOmBTSEEtJHtlLnNsaWNlKC0zKX1gLG5hbWU6XCJITUFDXCJ9LCExLFtyXSl9dGhyb3cgbmV3IFR5cGVFcnJvcihwZSh0LC4uLmZlLFwiVWludDhBcnJheVwiKSl9KGUsdCxcInZlcmlmeVwiKTsoKGUsdCk9PntpZihlLnN0YXJ0c1dpdGgoXCJSU1wiKXx8ZS5zdGFydHNXaXRoKFwiUFNcIikpe2NvbnN0e21vZHVsdXNMZW5ndGg6cn09dC5hbGdvcml0aG07aWYoXCJudW1iZXJcIiE9dHlwZW9mIHJ8fHI8MjA0OCl0aHJvdyBuZXcgVHlwZUVycm9yKGAke2V9IHJlcXVpcmVzIGtleSBtb2R1bHVzTGVuZ3RoIHRvIGJlIDIwNDggYml0cyBvciBsYXJnZXJgKX19KShlLG4pO2NvbnN0IGE9ZnVuY3Rpb24oZSx0KXtjb25zdCByPWBTSEEtJHtlLnNsaWNlKC0zKX1gO3N3aXRjaChlKXtjYXNlXCJIUzI1NlwiOmNhc2VcIkhTMzg0XCI6Y2FzZVwiSFM1MTJcIjpyZXR1cm57aGFzaDpyLG5hbWU6XCJITUFDXCJ9O2Nhc2VcIlBTMjU2XCI6Y2FzZVwiUFMzODRcIjpjYXNlXCJQUzUxMlwiOnJldHVybntoYXNoOnIsbmFtZTpcIlJTQS1QU1NcIixzYWx0TGVuZ3RoOmUuc2xpY2UoLTMpPj4zfTtjYXNlXCJSUzI1NlwiOmNhc2VcIlJTMzg0XCI6Y2FzZVwiUlM1MTJcIjpyZXR1cm57aGFzaDpyLG5hbWU6XCJSU0FTU0EtUEtDUzEtdjFfNVwifTtjYXNlXCJFUzI1NlwiOmNhc2VcIkVTMzg0XCI6Y2FzZVwiRVM1MTJcIjpyZXR1cm57aGFzaDpyLG5hbWU6XCJFQ0RTQVwiLG5hbWVkQ3VydmU6dC5uYW1lZEN1cnZlfTtjYXNlXCJFZERTQVwiOnJldHVybntuYW1lOnQubmFtZX07ZGVmYXVsdDp0aHJvdyBuZXcgVihgYWxnICR7ZX0gaXMgbm90IHN1cHBvcnRlZCBlaXRoZXIgYnkgSk9TRSBvciB5b3VyIGphdmFzY3JpcHQgcnVudGltZWApfX0oZSxuLmFsZ29yaXRobSk7dHJ5e3JldHVybiBhd2FpdCByZS5zdWJ0bGUudmVyaWZ5KGEsbixyLG8pfWNhdGNoKGUpe3JldHVybiExfX0seWU9KC4uLmUpPT57Y29uc3QgdD1lLmZpbHRlcihCb29sZWFuKTtpZigwPT09dC5sZW5ndGh8fDE9PT10Lmxlbmd0aClyZXR1cm4hMDtsZXQgcjtmb3IoY29uc3QgZSBvZiB0KXtjb25zdCB0PU9iamVjdC5rZXlzKGUpO2lmKHImJjAhPT1yLnNpemUpZm9yKGNvbnN0IGUgb2YgdCl7aWYoci5oYXMoZSkpcmV0dXJuITE7ci5hZGQoZSl9ZWxzZSByPW5ldyBTZXQodCl9cmV0dXJuITB9LEVlPShlLHQscik9PntlLnN0YXJ0c1dpdGgoXCJIU1wiKXx8XCJkaXJcIj09PWV8fGUuc3RhcnRzV2l0aChcIlBCRVMyXCIpfHwvXkFcXGR7M30oPzpHQ00pP0tXJC8udGVzdChlKT8oKGUsdCk9PntpZighKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSl7aWYoIWdlKHQpKXRocm93IG5ldyBUeXBlRXJyb3Iod2UoZSx0LC4uLmZlLFwiVWludDhBcnJheVwiKSk7aWYoXCJzZWNyZXRcIiE9PXQudHlwZSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke2ZlLmpvaW4oXCIgb3IgXCIpfSBpbnN0YW5jZXMgZm9yIHN5bW1ldHJpYyBhbGdvcml0aG1zIG11c3QgYmUgb2YgdHlwZSBcInNlY3JldFwiYCl9fSkoZSx0KTooKGUsdCxyKT0+e2lmKCFnZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKHdlKGUsdCwuLi5mZSkpO2lmKFwic2VjcmV0XCI9PT10LnR5cGUpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmZS5qb2luKFwiIG9yIFwiKX0gaW5zdGFuY2VzIGZvciBhc3ltbWV0cmljIGFsZ29yaXRobXMgbXVzdCBub3QgYmUgb2YgdHlwZSBcInNlY3JldFwiYCk7aWYoXCJzaWduXCI9PT1yJiZcInB1YmxpY1wiPT09dC50eXBlKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZmUuam9pbihcIiBvciBcIil9IGluc3RhbmNlcyBmb3IgYXN5bW1ldHJpYyBhbGdvcml0aG0gc2lnbmluZyBtdXN0IGJlIG9mIHR5cGUgXCJwcml2YXRlXCJgKTtpZihcImRlY3J5cHRcIj09PXImJlwicHVibGljXCI9PT10LnR5cGUpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmZS5qb2luKFwiIG9yIFwiKX0gaW5zdGFuY2VzIGZvciBhc3ltbWV0cmljIGFsZ29yaXRobSBkZWNyeXB0aW9uIG11c3QgYmUgb2YgdHlwZSBcInByaXZhdGVcImApO2lmKHQuYWxnb3JpdGhtJiZcInZlcmlmeVwiPT09ciYmXCJwcml2YXRlXCI9PT10LnR5cGUpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmZS5qb2luKFwiIG9yIFwiKX0gaW5zdGFuY2VzIGZvciBhc3ltbWV0cmljIGFsZ29yaXRobSB2ZXJpZnlpbmcgbXVzdCBiZSBvZiB0eXBlIFwicHVibGljXCJgKTtpZih0LmFsZ29yaXRobSYmXCJlbmNyeXB0XCI9PT1yJiZcInByaXZhdGVcIj09PXQudHlwZSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke2ZlLmpvaW4oXCIgb3IgXCIpfSBpbnN0YW5jZXMgZm9yIGFzeW1tZXRyaWMgYWxnb3JpdGhtIGVuY3J5cHRpb24gbXVzdCBiZSBvZiB0eXBlIFwicHVibGljXCJgKX0pKGUsdCxyKX0sdmU9KGUsdCk9PntpZih2b2lkIDAhPT10JiYoIUFycmF5LmlzQXJyYXkodCl8fHQuc29tZSgoZT0+XCJzdHJpbmdcIiE9dHlwZW9mIGUpKSkpdGhyb3cgbmV3IFR5cGVFcnJvcihgXCIke2V9XCIgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nc2ApO2lmKHQpcmV0dXJuIG5ldyBTZXQodCl9O2FzeW5jIGZ1bmN0aW9uIFNlKGUsdCxyKXtpZihlIGluc3RhbmNlb2YgVWludDhBcnJheSYmKGU9TS5kZWNvZGUoZSkpLFwic3RyaW5nXCIhPXR5cGVvZiBlKXRocm93IG5ldyBCKFwiQ29tcGFjdCBKV1MgbXVzdCBiZSBhIHN0cmluZyBvciBVaW50OEFycmF5XCIpO2NvbnN0ezA6bywxOm4sMjphLGxlbmd0aDppfT1lLnNwbGl0KFwiLlwiKTtpZigzIT09aSl0aHJvdyBuZXcgQihcIkludmFsaWQgQ29tcGFjdCBKV1NcIik7Y29uc3Qgcz1hd2FpdCBhc3luYyBmdW5jdGlvbihlLHQscil7dmFyIG87aWYoIWFlKGUpKXRocm93IG5ldyBCKFwiRmxhdHRlbmVkIEpXUyBtdXN0IGJlIGFuIG9iamVjdFwiKTtpZih2b2lkIDA9PT1lLnByb3RlY3RlZCYmdm9pZCAwPT09ZS5oZWFkZXIpdGhyb3cgbmV3IEIoJ0ZsYXR0ZW5lZCBKV1MgbXVzdCBoYXZlIGVpdGhlciBvZiB0aGUgXCJwcm90ZWN0ZWRcIiBvciBcImhlYWRlclwiIG1lbWJlcnMnKTtpZih2b2lkIDAhPT1lLnByb3RlY3RlZCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUucHJvdGVjdGVkKXRocm93IG5ldyBCKFwiSldTIFByb3RlY3RlZCBIZWFkZXIgaW5jb3JyZWN0IHR5cGVcIik7aWYodm9pZCAwPT09ZS5wYXlsb2FkKXRocm93IG5ldyBCKFwiSldTIFBheWxvYWQgbWlzc2luZ1wiKTtpZihcInN0cmluZ1wiIT10eXBlb2YgZS5zaWduYXR1cmUpdGhyb3cgbmV3IEIoXCJKV1MgU2lnbmF0dXJlIG1pc3Npbmcgb3IgaW5jb3JyZWN0IHR5cGVcIik7aWYodm9pZCAwIT09ZS5oZWFkZXImJiFhZShlLmhlYWRlcikpdGhyb3cgbmV3IEIoXCJKV1MgVW5wcm90ZWN0ZWQgSGVhZGVyIGluY29ycmVjdCB0eXBlXCIpO2xldCBuPXt9O2lmKGUucHJvdGVjdGVkKXRyeXtjb25zdCB0PU4oZS5wcm90ZWN0ZWQpO249SlNPTi5wYXJzZShNLmRlY29kZSh0KSl9Y2F0Y2goZSl7dGhyb3cgbmV3IEIoXCJKV1MgUHJvdGVjdGVkIEhlYWRlciBpcyBpbnZhbGlkXCIpfWlmKCF5ZShuLGUuaGVhZGVyKSl0aHJvdyBuZXcgQihcIkpXUyBQcm90ZWN0ZWQgYW5kIEpXUyBVbnByb3RlY3RlZCBIZWFkZXIgUGFyYW1ldGVyIG5hbWVzIG11c3QgYmUgZGlzam9pbnRcIik7Y29uc3QgYT17Li4ubiwuLi5lLmhlYWRlcn07bGV0IGk9ITA7aWYoaWUoQixuZXcgTWFwKFtbXCJiNjRcIiwhMF1dKSxudWxsPT1yP3ZvaWQgMDpyLmNyaXQsbixhKS5oYXMoXCJiNjRcIikmJihpPW4uYjY0LFwiYm9vbGVhblwiIT10eXBlb2YgaSkpdGhyb3cgbmV3IEIoJ1RoZSBcImI2NFwiIChiYXNlNjR1cmwtZW5jb2RlIHBheWxvYWQpIEhlYWRlciBQYXJhbWV0ZXIgbXVzdCBiZSBhIGJvb2xlYW4nKTtjb25zdHthbGc6c309YTtpZihcInN0cmluZ1wiIT10eXBlb2Ygc3x8IXMpdGhyb3cgbmV3IEIoJ0pXUyBcImFsZ1wiIChBbGdvcml0aG0pIEhlYWRlciBQYXJhbWV0ZXIgbWlzc2luZyBvciBpbnZhbGlkJyk7Y29uc3QgYz1yJiZ2ZShcImFsZ29yaXRobXNcIixyLmFsZ29yaXRobXMpO2lmKGMmJiFjLmhhcyhzKSl0aHJvdyBuZXcgRygnXCJhbGdcIiAoQWxnb3JpdGhtKSBIZWFkZXIgUGFyYW1ldGVyIG5vdCBhbGxvd2VkJyk7aWYoaSl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUucGF5bG9hZCl0aHJvdyBuZXcgQihcIkpXUyBQYXlsb2FkIG11c3QgYmUgYSBzdHJpbmdcIil9ZWxzZSBpZihcInN0cmluZ1wiIT10eXBlb2YgZS5wYXlsb2FkJiYhKGUucGF5bG9hZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXRocm93IG5ldyBCKFwiSldTIFBheWxvYWQgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBVaW50OEFycmF5IGluc3RhbmNlXCIpO2xldCBkPSExO1wiZnVuY3Rpb25cIj09dHlwZW9mIHQmJih0PWF3YWl0IHQobixlKSxkPSEwKSxFZShzLHQsXCJ2ZXJpZnlcIik7Y29uc3QgbD16KEguZW5jb2RlKG51bGwhPT0obz1lLnByb3RlY3RlZCkmJnZvaWQgMCE9PW8/bzpcIlwiKSxILmVuY29kZShcIi5cIiksXCJzdHJpbmdcIj09dHlwZW9mIGUucGF5bG9hZD9ILmVuY29kZShlLnBheWxvYWQpOmUucGF5bG9hZCksdT1OKGUuc2lnbmF0dXJlKTtpZighYXdhaXQgbWUocyx0LHUsbCkpdGhyb3cgbmV3IHRlO2xldCBoO2g9aT9OKGUucGF5bG9hZCk6XCJzdHJpbmdcIj09dHlwZW9mIGUucGF5bG9hZD9ILmVuY29kZShlLnBheWxvYWQpOmUucGF5bG9hZDtjb25zdCBwPXtwYXlsb2FkOmh9O3JldHVybiB2b2lkIDAhPT1lLnByb3RlY3RlZCYmKHAucHJvdGVjdGVkSGVhZGVyPW4pLHZvaWQgMCE9PWUuaGVhZGVyJiYocC51bnByb3RlY3RlZEhlYWRlcj1lLmhlYWRlciksZD97Li4ucCxrZXk6dH06cH0oe3BheWxvYWQ6bixwcm90ZWN0ZWQ6byxzaWduYXR1cmU6YX0sdCxyKSxjPXtwYXlsb2FkOnMucGF5bG9hZCxwcm90ZWN0ZWRIZWFkZXI6cy5wcm90ZWN0ZWRIZWFkZXJ9O3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/ey4uLmMsa2V5OnMua2V5fTpjfWNvbnN0IGJlPTg2NDAwLEFlPS9eKFxcZCt8XFxkK1xcLlxcZCspID8oc2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KSQvaSxfZT1lPT57Y29uc3QgdD1BZS5leGVjKGUpO2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRpbWUgcGVyaW9kIGZvcm1hdFwiKTtjb25zdCByPXBhcnNlRmxvYXQodFsxXSk7c3dpdGNoKHRbMl0udG9Mb3dlckNhc2UoKSl7Y2FzZVwic2VjXCI6Y2FzZVwic2Vjc1wiOmNhc2VcInNlY29uZFwiOmNhc2VcInNlY29uZHNcIjpjYXNlXCJzXCI6cmV0dXJuIE1hdGgucm91bmQocik7Y2FzZVwibWludXRlXCI6Y2FzZVwibWludXRlc1wiOmNhc2VcIm1pblwiOmNhc2VcIm1pbnNcIjpjYXNlXCJtXCI6cmV0dXJuIE1hdGgucm91bmQoNjAqcik7Y2FzZVwiaG91clwiOmNhc2VcImhvdXJzXCI6Y2FzZVwiaHJcIjpjYXNlXCJocnNcIjpjYXNlXCJoXCI6cmV0dXJuIE1hdGgucm91bmQoMzYwMCpyKTtjYXNlXCJkYXlcIjpjYXNlXCJkYXlzXCI6Y2FzZVwiZFwiOnJldHVybiBNYXRoLnJvdW5kKHIqYmUpO2Nhc2VcIndlZWtcIjpjYXNlXCJ3ZWVrc1wiOmNhc2VcIndcIjpyZXR1cm4gTWF0aC5yb3VuZCg2MDQ4MDAqcik7ZGVmYXVsdDpyZXR1cm4gTWF0aC5yb3VuZCgzMTU1NzYwMCpyKX19LGtlPWU9PmUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eYXBwbGljYXRpb25cXC8vLFwiXCIpLEllPShlLHQscj17fSk9Pntjb25zdHt0eXA6b309cjtpZihvJiYoXCJzdHJpbmdcIiE9dHlwZW9mIGUudHlwfHxrZShlLnR5cCkhPT1rZShvKSkpdGhyb3cgbmV3IEYoJ3VuZXhwZWN0ZWQgXCJ0eXBcIiBKV1QgaGVhZGVyIHZhbHVlJyxcInR5cFwiLFwiY2hlY2tfZmFpbGVkXCIpO2xldCBuO3RyeXtuPUpTT04ucGFyc2UoTS5kZWNvZGUodCkpfWNhdGNoKGUpe31pZighYWUobikpdGhyb3cgbmV3IFgoXCJKV1QgQ2xhaW1zIFNldCBtdXN0IGJlIGEgdG9wLWxldmVsIEpTT04gb2JqZWN0XCIpO2NvbnN0e3JlcXVpcmVkQ2xhaW1zOmE9W10saXNzdWVyOmksc3ViamVjdDpzLGF1ZGllbmNlOmMsbWF4VG9rZW5BZ2U6ZH09cjt2b2lkIDAhPT1kJiZhLnB1c2goXCJpYXRcIiksdm9pZCAwIT09YyYmYS5wdXNoKFwiYXVkXCIpLHZvaWQgMCE9PXMmJmEucHVzaChcInN1YlwiKSx2b2lkIDAhPT1pJiZhLnB1c2goXCJpc3NcIik7Zm9yKGNvbnN0IGUgb2YgbmV3IFNldChhLnJldmVyc2UoKSkpaWYoIShlIGluIG4pKXRocm93IG5ldyBGKGBtaXNzaW5nIHJlcXVpcmVkIFwiJHtlfVwiIGNsYWltYCxlLFwibWlzc2luZ1wiKTtpZihpJiYhKEFycmF5LmlzQXJyYXkoaSk/aTpbaV0pLmluY2x1ZGVzKG4uaXNzKSl0aHJvdyBuZXcgRigndW5leHBlY3RlZCBcImlzc1wiIGNsYWltIHZhbHVlJyxcImlzc1wiLFwiY2hlY2tfZmFpbGVkXCIpO2lmKHMmJm4uc3ViIT09cyl0aHJvdyBuZXcgRigndW5leHBlY3RlZCBcInN1YlwiIGNsYWltIHZhbHVlJyxcInN1YlwiLFwiY2hlY2tfZmFpbGVkXCIpO2lmKGMmJihsPW4uYXVkLHU9XCJzdHJpbmdcIj09dHlwZW9mIGM/W2NdOmMsIShcInN0cmluZ1wiPT10eXBlb2YgbD91LmluY2x1ZGVzKGwpOkFycmF5LmlzQXJyYXkobCkmJnUuc29tZShTZXQucHJvdG90eXBlLmhhcy5iaW5kKG5ldyBTZXQobCkpKSkpKXRocm93IG5ldyBGKCd1bmV4cGVjdGVkIFwiYXVkXCIgY2xhaW0gdmFsdWUnLFwiYXVkXCIsXCJjaGVja19mYWlsZWRcIik7dmFyIGwsdTtsZXQgaDtzd2l0Y2godHlwZW9mIHIuY2xvY2tUb2xlcmFuY2Upe2Nhc2VcInN0cmluZ1wiOmg9X2Uoci5jbG9ja1RvbGVyYW5jZSk7YnJlYWs7Y2FzZVwibnVtYmVyXCI6aD1yLmNsb2NrVG9sZXJhbmNlO2JyZWFrO2Nhc2VcInVuZGVmaW5lZFwiOmg9MDticmVhaztkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGNsb2NrVG9sZXJhbmNlIG9wdGlvbiB0eXBlXCIpfWNvbnN0e2N1cnJlbnREYXRlOnB9PXIsdz0oZz1wfHxuZXcgRGF0ZSxNYXRoLmZsb29yKGcuZ2V0VGltZSgpLzFlMykpO3ZhciBnO2lmKCh2b2lkIDAhPT1uLmlhdHx8ZCkmJlwibnVtYmVyXCIhPXR5cGVvZiBuLmlhdCl0aHJvdyBuZXcgRignXCJpYXRcIiBjbGFpbSBtdXN0IGJlIGEgbnVtYmVyJyxcImlhdFwiLFwiaW52YWxpZFwiKTtpZih2b2lkIDAhPT1uLm5iZil7aWYoXCJudW1iZXJcIiE9dHlwZW9mIG4ubmJmKXRocm93IG5ldyBGKCdcIm5iZlwiIGNsYWltIG11c3QgYmUgYSBudW1iZXInLFwibmJmXCIsXCJpbnZhbGlkXCIpO2lmKG4ubmJmPncraCl0aHJvdyBuZXcgRignXCJuYmZcIiBjbGFpbSB0aW1lc3RhbXAgY2hlY2sgZmFpbGVkJyxcIm5iZlwiLFwiY2hlY2tfZmFpbGVkXCIpfWlmKHZvaWQgMCE9PW4uZXhwKXtpZihcIm51bWJlclwiIT10eXBlb2Ygbi5leHApdGhyb3cgbmV3IEYoJ1wiZXhwXCIgY2xhaW0gbXVzdCBiZSBhIG51bWJlcicsXCJleHBcIixcImludmFsaWRcIik7aWYobi5leHA8PXctaCl0aHJvdyBuZXcgcSgnXCJleHBcIiBjbGFpbSB0aW1lc3RhbXAgY2hlY2sgZmFpbGVkJyxcImV4cFwiLFwiY2hlY2tfZmFpbGVkXCIpfWlmKGQpe2NvbnN0IGU9dy1uLmlhdDtpZihlLWg+KFwibnVtYmVyXCI9PXR5cGVvZiBkP2Q6X2UoZCkpKXRocm93IG5ldyBxKCdcImlhdFwiIGNsYWltIHRpbWVzdGFtcCBjaGVjayBmYWlsZWQgKHRvbyBmYXIgaW4gdGhlIHBhc3QpJyxcImlhdFwiLFwiY2hlY2tfZmFpbGVkXCIpO2lmKGU8MC1oKXRocm93IG5ldyBGKCdcImlhdFwiIGNsYWltIHRpbWVzdGFtcCBjaGVjayBmYWlsZWQgKGl0IHNob3VsZCBiZSBpbiB0aGUgcGFzdCknLFwiaWF0XCIsXCJjaGVja19mYWlsZWRcIil9cmV0dXJuIG59O2Z1bmN0aW9uIFRlKGUpe3JldHVybiBlJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmQXJyYXkuaXNBcnJheShlLmtleXMpJiZlLmtleXMuZXZlcnkoT2UpfWZ1bmN0aW9uIE9lKGUpe3JldHVybiBhZShlKX1jbGFzcyBSZXtjb25zdHJ1Y3RvcihlKXtpZih0aGlzLl9jYWNoZWQ9bmV3IFdlYWtNYXAsIVRlKGUpKXRocm93IG5ldyBZKFwiSlNPTiBXZWIgS2V5IFNldCBtYWxmb3JtZWRcIik7dmFyIHQ7dGhpcy5fandrcz0odD1lLFwiZnVuY3Rpb25cIj09dHlwZW9mIHN0cnVjdHVyZWRDbG9uZT9zdHJ1Y3R1cmVkQ2xvbmUodCk6SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0KSkpfWFzeW5jIGdldEtleShlLHQpe2NvbnN0e2FsZzpyLGtpZDpvfT17Li4uZSwuLi5udWxsPT10P3ZvaWQgMDp0LmhlYWRlcn0sbj1mdW5jdGlvbihlKXtzd2l0Y2goXCJzdHJpbmdcIj09dHlwZW9mIGUmJmUuc2xpY2UoMCwyKSl7Y2FzZVwiUlNcIjpjYXNlXCJQU1wiOnJldHVyblwiUlNBXCI7Y2FzZVwiRVNcIjpyZXR1cm5cIkVDXCI7Y2FzZVwiRWRcIjpyZXR1cm5cIk9LUFwiO2RlZmF1bHQ6dGhyb3cgbmV3IFYoJ1Vuc3VwcG9ydGVkIFwiYWxnXCIgdmFsdWUgZm9yIGEgSlNPTiBXZWIgS2V5IFNldCcpfX0ociksYT10aGlzLl9qd2tzLmtleXMuZmlsdGVyKChlPT57bGV0IHQ9bj09PWUua3R5O2lmKHQmJlwic3RyaW5nXCI9PXR5cGVvZiBvJiYodD1vPT09ZS5raWQpLHQmJlwic3RyaW5nXCI9PXR5cGVvZiBlLmFsZyYmKHQ9cj09PWUuYWxnKSx0JiZcInN0cmluZ1wiPT10eXBlb2YgZS51c2UmJih0PVwic2lnXCI9PT1lLnVzZSksdCYmQXJyYXkuaXNBcnJheShlLmtleV9vcHMpJiYodD1lLmtleV9vcHMuaW5jbHVkZXMoXCJ2ZXJpZnlcIikpLHQmJlwiRWREU0FcIj09PXImJih0PVwiRWQyNTUxOVwiPT09ZS5jcnZ8fFwiRWQ0NDhcIj09PWUuY3J2KSx0KXN3aXRjaChyKXtjYXNlXCJFUzI1NlwiOnQ9XCJQLTI1NlwiPT09ZS5jcnY7YnJlYWs7Y2FzZVwiRVMyNTZLXCI6dD1cInNlY3AyNTZrMVwiPT09ZS5jcnY7YnJlYWs7Y2FzZVwiRVMzODRcIjp0PVwiUC0zODRcIj09PWUuY3J2O2JyZWFrO2Nhc2VcIkVTNTEyXCI6dD1cIlAtNTIxXCI9PT1lLmNydn1yZXR1cm4gdH0pKSx7MDppLGxlbmd0aDpzfT1hO2lmKDA9PT1zKXRocm93IG5ldyBRO2lmKDEhPT1zKXtjb25zdCBlPW5ldyBaLHtfY2FjaGVkOnR9PXRoaXM7dGhyb3cgZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl09YXN5bmMgZnVuY3Rpb24qKCl7Zm9yKGNvbnN0IGUgb2YgYSl0cnl7eWllbGQgYXdhaXQgUGUodCxlLHIpfWNhdGNoKGUpe2NvbnRpbnVlfX0sZX1yZXR1cm4gUGUodGhpcy5fY2FjaGVkLGkscil9fWFzeW5jIGZ1bmN0aW9uIFBlKGUsdCxyKXtjb25zdCBvPWUuZ2V0KHQpfHxlLnNldCh0LHt9KS5nZXQodCk7aWYodm9pZCAwPT09b1tyXSl7Y29uc3QgZT1hd2FpdCBhc3luYyBmdW5jdGlvbihlLHQscil7dmFyIG87aWYoIWFlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJKV0sgbXVzdCBiZSBhbiBvYmplY3RcIik7c3dpdGNoKHR8fCh0PWUuYWxnKSxlLmt0eSl7Y2FzZVwib2N0XCI6aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUua3x8IWUuayl0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIFwia1wiIChLZXkgVmFsdWUpIFBhcmFtZXRlciB2YWx1ZScpO3JldHVybiBudWxsIT1yfHwocj0hMCE9PWUuZXh0KSxyP25lKHsuLi5lLGFsZzp0LGV4dDpudWxsIT09KG89ZS5leHQpJiZ2b2lkIDAhPT1vJiZvfSk6TihlLmspO2Nhc2VcIlJTQVwiOmlmKHZvaWQgMCE9PWUub3RoKXRocm93IG5ldyBWKCdSU0EgSldLIFwib3RoXCIgKE90aGVyIFByaW1lcyBJbmZvKSBQYXJhbWV0ZXIgdmFsdWUgaXMgbm90IHN1cHBvcnRlZCcpO2Nhc2VcIkVDXCI6Y2FzZVwiT0tQXCI6cmV0dXJuIG5lKHsuLi5lLGFsZzp0fSk7ZGVmYXVsdDp0aHJvdyBuZXcgVignVW5zdXBwb3J0ZWQgXCJrdHlcIiAoS2V5IFR5cGUpIFBhcmFtZXRlciB2YWx1ZScpfX0oey4uLnQsZXh0OiEwfSxyKTtpZihlIGluc3RhbmNlb2YgVWludDhBcnJheXx8XCJwdWJsaWNcIiE9PWUudHlwZSl0aHJvdyBuZXcgWShcIkpTT04gV2ViIEtleSBTZXQgbWVtYmVycyBtdXN0IGJlIHB1YmxpYyBrZXlzXCIpO29bcl09ZX1yZXR1cm4gb1tyXX1jb25zdCBDZT1hc3luYyhlLHQscik9PntsZXQgbyxuLGE9ITE7XCJmdW5jdGlvblwiPT10eXBlb2YgQWJvcnRDb250cm9sbGVyJiYobz1uZXcgQWJvcnRDb250cm9sbGVyLG49c2V0VGltZW91dCgoKCk9PnthPSEwLG8uYWJvcnQoKX0pLHQpKTtjb25zdCBpPWF3YWl0IGZldGNoKGUuaHJlZix7c2lnbmFsOm8/by5zaWduYWw6dm9pZCAwLHJlZGlyZWN0OlwibWFudWFsXCIsaGVhZGVyczpyLmhlYWRlcnN9KS5jYXRjaCgoZT0+e2lmKGEpdGhyb3cgbmV3IGVlO3Rocm93IGV9KSk7aWYodm9pZCAwIT09biYmY2xlYXJUaW1lb3V0KG4pLDIwMCE9PWkuc3RhdHVzKXRocm93IG5ldyBKT1NFRXJyb3IoXCJFeHBlY3RlZCAyMDAgT0sgZnJvbSB0aGUgSlNPTiBXZWIgS2V5IFNldCBIVFRQIHJlc3BvbnNlXCIpO3RyeXtyZXR1cm4gYXdhaXQgaS5qc29uKCl9Y2F0Y2goZSl7dGhyb3cgbmV3IEpPU0VFcnJvcihcIkZhaWxlZCB0byBwYXJzZSB0aGUgSlNPTiBXZWIgS2V5IFNldCBIVFRQIHJlc3BvbnNlIGFzIEpTT05cIil9fTtjbGFzcyBXZSBleHRlbmRzIFJle2NvbnN0cnVjdG9yKGUsdCl7aWYoc3VwZXIoe2tleXM6W119KSx0aGlzLl9qd2tzPXZvaWQgMCwhKGUgaW5zdGFuY2VvZiBVUkwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJ1cmwgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBVUkxcIik7dGhpcy5fdXJsPW5ldyBVUkwoZS5ocmVmKSx0aGlzLl9vcHRpb25zPXthZ2VudDpudWxsPT10P3ZvaWQgMDp0LmFnZW50LGhlYWRlcnM6bnVsbD09dD92b2lkIDA6dC5oZWFkZXJzfSx0aGlzLl90aW1lb3V0RHVyYXRpb249XCJudW1iZXJcIj09dHlwZW9mKG51bGw9PXQ/dm9pZCAwOnQudGltZW91dER1cmF0aW9uKT9udWxsPT10P3ZvaWQgMDp0LnRpbWVvdXREdXJhdGlvbjo1ZTMsdGhpcy5fY29vbGRvd25EdXJhdGlvbj1cIm51bWJlclwiPT10eXBlb2YobnVsbD09dD92b2lkIDA6dC5jb29sZG93bkR1cmF0aW9uKT9udWxsPT10P3ZvaWQgMDp0LmNvb2xkb3duRHVyYXRpb246M2U0LHRoaXMuX2NhY2hlTWF4QWdlPVwibnVtYmVyXCI9PXR5cGVvZihudWxsPT10P3ZvaWQgMDp0LmNhY2hlTWF4QWdlKT9udWxsPT10P3ZvaWQgMDp0LmNhY2hlTWF4QWdlOjZlNX1jb29saW5nRG93bigpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLl9qd2tzVGltZXN0YW1wJiZEYXRlLm5vdygpPHRoaXMuX2p3a3NUaW1lc3RhbXArdGhpcy5fY29vbGRvd25EdXJhdGlvbn1mcmVzaCgpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLl9qd2tzVGltZXN0YW1wJiZEYXRlLm5vdygpPHRoaXMuX2p3a3NUaW1lc3RhbXArdGhpcy5fY2FjaGVNYXhBZ2V9YXN5bmMgZ2V0S2V5KGUsdCl7dGhpcy5fandrcyYmdGhpcy5mcmVzaCgpfHxhd2FpdCB0aGlzLnJlbG9hZCgpO3RyeXtyZXR1cm4gYXdhaXQgc3VwZXIuZ2V0S2V5KGUsdCl9Y2F0Y2gocil7aWYociBpbnN0YW5jZW9mIFEmJiExPT09dGhpcy5jb29saW5nRG93bigpKXJldHVybiBhd2FpdCB0aGlzLnJlbG9hZCgpLHN1cGVyLmdldEtleShlLHQpO3Rocm93IHJ9fWFzeW5jIHJlbG9hZCgpe3RoaXMuX3BlbmRpbmdGZXRjaCYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBXZWJTb2NrZXRQYWlyfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZcIkNsb3VkZmxhcmUtV29ya2Vyc1wiPT09bmF2aWdhdG9yLnVzZXJBZ2VudHx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEVkZ2VSdW50aW1lJiZcInZlcmNlbFwiPT09RWRnZVJ1bnRpbWUpJiYodGhpcy5fcGVuZGluZ0ZldGNoPXZvaWQgMCksdGhpcy5fcGVuZGluZ0ZldGNofHwodGhpcy5fcGVuZGluZ0ZldGNoPUNlKHRoaXMuX3VybCx0aGlzLl90aW1lb3V0RHVyYXRpb24sdGhpcy5fb3B0aW9ucykudGhlbigoZT0+e2lmKCFUZShlKSl0aHJvdyBuZXcgWShcIkpTT04gV2ViIEtleSBTZXQgbWFsZm9ybWVkXCIpO3RoaXMuX2p3a3M9e2tleXM6ZS5rZXlzfSx0aGlzLl9qd2tzVGltZXN0YW1wPURhdGUubm93KCksdGhpcy5fcGVuZGluZ0ZldGNoPXZvaWQgMH0pKS5jYXRjaCgoZT0+e3Rocm93IHRoaXMuX3BlbmRpbmdGZXRjaD12b2lkIDAsZX0pKSksYXdhaXQgdGhpcy5fcGVuZGluZ0ZldGNofX1jb25zdCB4ZT1OO2NsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBSe2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZT1lPz90Py5tZXNzYWdlPz9cIkFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBhdXRoZW50aWNhdGlvblwiLHQpfX1jbGFzcyBMb2dvdXRFcnJvciBleHRlbmRzIFJ7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlPWU/P3Q/Lm1lc3NhZ2U/P1wiQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGxvZ291dFwiLHQpfX1jb25zdCBqZT1cIjEuMC4wXCIsJGU9XCJPSURDXCIsSmU9KCk9PntKKCRlKX0sVWU9KCk9PntVKCRlLGplKX07XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmaW4mJk9iamVjdC5hc3NpZ24od2luZG93LHtmaW46e319KSxPYmplY3QuYXNzaWduKGZpbix7SW50ZWdyYXRpb25zOntPSURDOntlbmFibGVMb2dnaW5nOlVlLGRpc2FibGVMb2dnaW5nOkplfX19KSk7Y29uc3QgS2U9ZT0+YCR7ZS5yZXBsYWNlKC9cXC8kLyxcIlwiKX0vLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb25gO3ZhciBEZTshZnVuY3Rpb24oZSl7ZS5PcGVuSWRDb25uZWN0PVwiT3BlbklELUNvbm5lY3RcIn0oRGV8fChEZT17fSkpO2NsYXNzIExlIGV4dGVuZHMgV3tnZXQgaWRUb2tlbigpe3JldHVybiB0aGlzLl9pZFRva2VufWdldCBvcGVuSWRQcm92aWRlclVybCgpe3JldHVybiB0aGlzLl9vcGVuSWRQcm92aWRlclVybH1nZXQgcmVkaXJlY3RVcmkoKXtyZXR1cm4gdGhpcy5fcmVkaXJlY3RVcml9Z2V0IHNjb3BlKCl7cmV0dXJuIHRoaXMuX3Njb3BlfWdldCB1c2VySW5mbygpe3JldHVybiB0aGlzLl91c2VySW5mb31hc3luYyBhdXRob3JpemUoZSx0LHIpe2F3YWl0IHN1cGVyLmF1dGhvcml6ZShlLHQsciksdGhpcy5faWRUb2tlbj1hd2FpdCB0aGlzLmdldElkVG9rZW4oKSx0aGlzLl91c2VySW5mbz1hd2FpdChhc3luYyBlPT57Y29uc3QgdD1lLm1ldGFkYXRhPy51c2VyaW5mb19lbmRwb2ludDtpZighdClyZXR1cm47Y29uc3R7ZGF0YTpyfT1hd2FpdCBlLmV4ZWN1dGVBcGlSZXF1ZXN0KHQpO3JldHVybiByfSkodGhpcyl9YXN5bmMgY2xvc2UoKXthd2FpdCBzdXBlci5jbG9zZSgpLHRoaXMuX2lkVG9rZW49dm9pZCAwLHRoaXMuX29wZW5JZFByb3ZpZGVyVXJsPXZvaWQgMCx0aGlzLl9yZWRpcmVjdFVyaT12b2lkIDAsdGhpcy5fc2NvcGU9dm9pZCAwLHRoaXMuX3VzZXJJbmZvPXZvaWQgMH1nZXRFcnJvck1lc3NhZ2VGcm9tU2VydmVyUmVzcG9uc2UoZSl7cmV0dXJuIGV9c3RhdGljIGFzeW5jIGluaXQoZSx0LHIsbyxuLGEsaSl7Y29uc3Qgcz1uZXcgQyhvKTtzLmxvZ0luZm8oXCJJbml0IHN0YXJ0ZWRcIixlLHQscixvLG4sYSxpKTt0cnl7Y29uc3R7YWRkaXRpb25hbE1ldGFkYXRhOnQsZGlzY292ZXJ5RW5kcG9pbnQ6b309ZSxjPXsuLi5hd2FpdCBLKG8pLC4uLnQ/P3t9fTtpZighYy5yZXNwb25zZV90eXBlc19zdXBwb3J0ZWQuZmluZCgoZT0+XCJjb2RlXCI9PT1lLnRvTG93ZXJDYXNlKCkpKSl0aHJvdyBuZXcgUChcIk9wZW5JRCBQcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBhdXRob3JpemF0aW9uIGNvZGUgcmVzcG9uc2UgdHlwZVwiKTtjb25zdCBkPWF3YWl0IEQoYyxyLHMpLGw9bmV3IExlKHZvaWQgMCxyLGMsZCxzKTtyZXR1cm4gbC5fb3BlbklkUHJvdmlkZXJVcmw9bixsLl9yZWRpcmVjdFVyaT1hLGwuX3Njb3BlPWkscy5sb2dJbmZvKFwiSW5pdCBjb21wbGV0ZWRcIixsKSwoYXN5bmMoZSx0KT0+e3RyeXthd2FpdCBmaW4uU3lzdGVtLnJlZ2lzdGVyVXNhZ2Uoe3R5cGU6XCJpbnRlZ3JhdGlvbi1mZWF0dXJlXCIsZGF0YTp7YXBpVmVyc2lvbjpqZSxjb21wb25lbnROYW1lOmV9fSl9Y2F0Y2gocil7dC5sb2dXYXJuaW5nKGBVbmFibGUgdG8gcmVnaXN0ZXIgdXNhZ2UgZm9yIGZlYXR1cmUgJHtlfTogJHtyPy5tZXNzYWdlfWApfX0pKERlLk9wZW5JZENvbm5lY3QscyksbH1jYXRjaChlKXtsZXQgdDt0aHJvdyB0PWUgaW5zdGFuY2VvZiBSP2U6bmV3IFAodm9pZCAwLGUpLHMubG9nRXJyb3IodCksdH19fWNvbnN0IEhlPWFzeW5jKGUsdCxyKT0+e2NvbnN0IG89bmV3IEMoJGUpLG49S2Uocik7bGV0IGE7dHJ5e2E9YXdhaXQgSyhuKX1jYXRjaChlKXtjb25zdCB0PW5ldyBqKGBGYWlsZWQgdG8gcmV0cmlldmUgT3BlbklEIENvbm5lY3QgbWV0YWRhdGEgZnJvbSAke259YCk7dGhyb3cgby5sb2dFcnJvcih0KSx0fWNvbnN0e2ludHJvc3BlY3Rpb25fZW5kcG9pbnQ6aSxqd2tzX3VyaTpzfT1hO2lmKGkpdHJ5e3JldHVybiBhd2FpdCBMKG8pKGUsdCxpKX1jYXRjaChlKXt9ZWxzZSBvPy5sb2dXYXJuaW5nKFwiTm8gaW50cm9zcGVjdGlvbiBlbmRwb2ludCBmb3VuZCBpbiBPcGVuSUQgQ29ubmVjdCBtZXRhZGF0YVwiKTtpZighcyl7Y29uc3QgZT1uZXcgaihgRmFpbGVkIHRvIHJldHJpZXZlIEpTT04gV2ViIEtleSBTZXQgKEpXS1MpIGZyb20gJHtzfWApO3Rocm93IG8ubG9nRXJyb3IoZSksZX1vPy5sb2dJbmZvKFwiVmFsaWRhdGluZyBpZCB0b2tlbiBhZ2FpbnN0IEpXS1MgZW5kcG9pbnRcIixzKTt0cnl7Y29uc3R7cGF5bG9hZDpufT1hd2FpdCBhc3luYyBmdW5jdGlvbihlLHQscil7dmFyIG87Y29uc3Qgbj1hd2FpdCBTZShlLHQscik7aWYoKG51bGw9PT0obz1uLnByb3RlY3RlZEhlYWRlci5jcml0KXx8dm9pZCAwPT09bz92b2lkIDA6by5pbmNsdWRlcyhcImI2NFwiKSkmJiExPT09bi5wcm90ZWN0ZWRIZWFkZXIuYjY0KXRocm93IG5ldyBYKFwiSldUcyBNVVNUIE5PVCB1c2UgdW5lbmNvZGVkIHBheWxvYWRcIik7Y29uc3QgYT17cGF5bG9hZDpJZShuLnByb3RlY3RlZEhlYWRlcixuLnBheWxvYWQscikscHJvdGVjdGVkSGVhZGVyOm4ucHJvdGVjdGVkSGVhZGVyfTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3suLi5hLGtleTpuLmtleX06YX0oZSxmdW5jdGlvbihlLHQpe2NvbnN0IHI9bmV3IFdlKGUsdCk7cmV0dXJuIGFzeW5jIGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHIuZ2V0S2V5KGUsdCl9fShuZXcgVVJMKHMpKSx7YXVkaWVuY2U6dCxpc3N1ZXI6cn0pO3JldHVybiBvPy5sb2dJbmZvKFwiSUQgdG9rZW4gdmFsaWRhdGlvbiBzdWNjZXNzZnVsXCIsbikse3ZhbGlkOiEwLC4uLm59fWNhdGNoKGUpe2lmKCEoZSBpbnN0YW5jZW9mIEZ8fGUgaW5zdGFuY2VvZiBxfHxlIGluc3RhbmNlb2YgWHx8ZSBpbnN0YW5jZW9mIHRlKSl7Y29uc3QgdD1uZXcgaih2b2lkIDAsZSk7dGhyb3cgby5sb2dFcnJvcih0KSx0fXJldHVybiBvLmxvZ1dhcm5pbmcoYElEIHRva2VuIHZhbGlkYXRpb24gZmFpbGVkOiAke2UubWVzc2FnZX1gKSx7dmFsaWQ6ITF9fX0sTWU9W1wib3BlbmlkXCIsXCJwcm9maWxlXCIsXCJlbWFpbFwiXSx6ZT1hc3luYyhlLHQscixvPVtdLG4sYSxpKT0+e2lmKGU9ZT8udHJpbSgpLnJlcGxhY2UoL1xcLyQvLFwiXCIpLCFlKXRocm93IG5ldyB4KFwiT3BlbklEIFByb3ZpZGVyIFVSTCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKTtpZighdCl0aHJvdyBuZXcgeChcIkNsaWVudCBJZGVudGlmaWVyIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO2lmKCFyKXRocm93IG5ldyB4KFwiUmVkaXJlY3Rpb24gVVJJIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO2NvbnN0IHM9YXdhaXQgRmUoZSx0LHIsbyxuKTtpZighcyl0aHJvdyBuZXcgUChcIlByb3ZpZGVyIG5vdCBpbml0aWFsaXplZFwiKTtjb25zdCBjPXMubWV0YWRhdGE/LnNjb3Blc19zdXBwb3J0ZWQ7aWYoIWMpe2NvbnN0IGU9bmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJPcGVuSUQgUHJvdmlkZXIgbWV0YWRhdGEgZG9lcyBub3QgZGVmaW5lIHN1cHBvcnRlZCBzY29wZXNcIik7dGhyb3cgcy5sb2dnZXIubG9nRXJyb3IoZSksZX1jb25zdCBkPU1lLmZpbHRlcigoZT0+IWMuaW5jbHVkZXMoZSkpKTtpZihkLmxlbmd0aD4wKXtjb25zdCBlPW5ldyBBdXRoZW50aWNhdGlvbkVycm9yKGBPcGVuSUQgUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCByZXF1aXJlZCBzY29wZXM6ICR7ZC5qb2luKFwiLCBcIil9YCk7dGhyb3cgcy5sb2dnZXIubG9nRXJyb3IoZSksZX1jb25zdCBsPW5ldyBTZXQoWy4uLk1lLC4uLm9dKTthd2FpdCBzLmF1dGhvcml6ZShyLHtkaXNwbGF5OlwicG9wdXBcIixzY29wZTpbLi4ubF0uam9pbihcIiBcIiksLi4uYX0saSk7Y29uc3R7aWRUb2tlbjp1fT1zO2lmKCF1KXtjb25zdCBlPW5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm8gSUQgdG9rZW4gcmV0dXJuZWRcIik7dGhyb3cgcy5sb2dnZXIubG9nRXJyb3IoZSksZX1jb25zdCBoPWZ1bmN0aW9uKGUpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXRocm93IG5ldyBYKFwiSldUcyBtdXN0IHVzZSBDb21wYWN0IEpXUyBzZXJpYWxpemF0aW9uLCBKV1QgbXVzdCBiZSBhIHN0cmluZ1wiKTtjb25zdHsxOnQsbGVuZ3RoOnJ9PWUuc3BsaXQoXCIuXCIpO2lmKDU9PT1yKXRocm93IG5ldyBYKFwiT25seSBKV1RzIHVzaW5nIENvbXBhY3QgSldTIHNlcmlhbGl6YXRpb24gY2FuIGJlIGRlY29kZWRcIik7aWYoMyE9PXIpdGhyb3cgbmV3IFgoXCJJbnZhbGlkIEpXVFwiKTtpZighdCl0aHJvdyBuZXcgWChcIkpXVHMgbXVzdCBjb250YWluIGEgcGF5bG9hZFwiKTtsZXQgbyxuO3RyeXtvPXhlKHQpfWNhdGNoKGUpe3Rocm93IG5ldyBYKFwiRmFpbGVkIHRvIHBhcnNlIHRoZSBiYXNlNjR1cmwgZW5jb2RlZCBwYXlsb2FkXCIpfXRyeXtuPUpTT04ucGFyc2UoTS5kZWNvZGUobykpfWNhdGNoKGUpe3Rocm93IG5ldyBYKFwiRmFpbGVkIHRvIHBhcnNlIHRoZSBkZWNvZGVkIHBheWxvYWQgYXMgSlNPTlwiKX1pZighYWUobikpdGhyb3cgbmV3IFgoXCJJbnZhbGlkIEpXVCBDbGFpbXMgU2V0XCIpO3JldHVybiBufSh1KTtpZighaCl7Y29uc3QgZT1uZXcgQXV0aGVudGljYXRpb25FcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgSUQgdG9rZW5cIik7dGhyb3cgcy5sb2dnZXIubG9nRXJyb3IoZSksZX1jb25zdHthdWQ6cCxpc3M6d309aDtyZXR1cm4gYXdhaXQgSGUodSxBcnJheS5pc0FycmF5KHApP3BbMF06cCx3KSx7Y2xhaW1zOmgsY2xpZW50SWQ6dCxpZFRva2VuOnUsbG9nb3V0OnFlKHQsdSxzKSxvcGVuSWRQcm92aWRlclVybDplLHVzZXJJbmZvOnMudXNlckluZm99fSxOZT0oZSx0LHIsbyxuLGEpPT5hc3luYyBuPT57aWYoMCE9PW5ldyBVUkwobikuaHJlZi50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoci50b0xvd2VyQ2FzZSgpKSlyZXR1cm4hMTt3aW5kb3cuY2xlYXJJbnRlcnZhbChhKSx3aW5kb3cuY2xlYXJUaW1lb3V0KHQpO3RyeXtlLnJlbW92ZUFsbExpc3RlbmVycygpLGUuY2xvc2UoITApfWNhdGNoKGUpe31yZXR1cm4gbygpLCEwfSxGZT1hc3luYyhlLHQscixvLG4pPT57Y29uc3QgYT17YWRkaXRpb25hbE1ldGFkYXRhOm4sZGlzY292ZXJ5RW5kcG9pbnQ6S2UoZSl9O3JldHVybiBMZS5pbml0KGEsdm9pZCAwLHQsJGUsZSxyLG8pfSxxZT0oZSx0LHIpPT5hc3luYyhvLG4pPT57aWYoIW8pdGhyb3cgbmV3IHgoXCJMb2dvdXQgUmVkaXJlY3Rpb24gVVJJIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO2NvbnN0e2xvZ2dlcjphLG1ldGFkYXRhOml9PXI7YS5sb2dJbmZvKFwiTG9nb3V0IHN0YXJ0ZWRcIixlLHQsbyxuKTtjb25zdHtlbmRfc2Vzc2lvbl9lbmRwb2ludDpzfT1pPz97fTtpZighcyl7Y29uc3QgZT1uZXcgTG9nb3V0RXJyb3IoXCJPcGVuSUQgUHJvdmlkZXIgbWV0YWRhdGEgZG9lcyBub3QgZGVmaW5lIGVuZCBzZXNzaW9uIGVuZHBvaW50XCIpO3Rocm93IGEubG9nRXJyb3IoZSksZX1jb25zdCBjPWAke3N9P2lkX3Rva2VuX2hpbnQ9JHt0fSZjbGllbnRfaWQ9JHtlfSZwb3N0X2xvZ291dF9yZWRpcmVjdF91cmk9JHtlbmNvZGVVUklDb21wb25lbnQobyl9JHtuP2AmbG9nb3V0X2hpbnQ9JHtlbmNvZGVVUklDb21wb25lbnQobil9YDpcIlwifWA7YXdhaXQgJChjLEdlKG8sYSkpLGF3YWl0KHI/LmNsb3NlKCkpLGEubG9nSW5mbyhcIkxvZ291dCBjb21wbGV0ZWRcIil9LEdlPShlLHQpPT5yPT5uZXcgUHJvbWlzZSgoKG8sbik9PntsZXQgYTtyLmFkZExpc3RlbmVyKFwiY2xvc2luZ1wiLChhc3luYygpPT57dC5sb2dJbmZvKFwiVXNlciBjbG9zZWQgYXV0aCB3aW5kb3dcIiksd2luZG93LmNsZWFySW50ZXJ2YWwoYSksci5yZW1vdmVBbGxMaXN0ZW5lcnMoKSxuKG5ldyBMb2dvdXRFcnJvcihcIkZhaWxlZCB0byBjb21wbGV0ZSBsb2dvdXQgcHJvY2Vzc1wiKSl9KSk7Y29uc3QgaT13aW5kb3cuc2V0VGltZW91dCgoYXN5bmMoKT0+e3RyeXthd2FpdCByLmlzU2hvd2luZygpfHwodC5sb2dJbmZvKFwiU2hvd2luZyBhdXRoIHdpbmRvd1wiKSxhd2FpdCByLnNob3coITApLGF3YWl0IHIuZm9jdXMoKSl9Y2F0Y2h7dC5sb2dXYXJuaW5nKFwiVW5hYmxlIHRvIHNob3cgYXV0aCB3aW5kb3dcIil9fSksMmUzKTsoYXN5bmMoKT0+e2NvbnN0e3ZlcnNpb246c309YXdhaXQgZmluLlN5c3RlbS5nZXRSdW50aW1lSW5mbygpO2lmKHBhcnNlSW50KHMuc3BsaXQoXCIuXCIpWzBdLDEwKT49MzApe2F3YWl0IE5lKHIsaSxlLG8sbikoKGF3YWl0IHIuZ2V0SW5mbygpKS51cmwpfHxhd2FpdCByLmFkZExpc3RlbmVyKFwidXJsLWNoYW5nZWRcIiwoYT0+e3QubG9nSW5mbyhcIkF1dGggd2luZG93IG5hdmlnYXRlZCB0b1wiLGEudXJsKSxOZShyLGksZSxvLG4pKGEudXJsKX0pKX1lbHNlIGE9d2luZG93LnNldEludGVydmFsKCgoKT0+KGFzeW5jKGUsdCxyLG8sbixhKT0+e2xldCBpO3RyeXtpPWF3YWl0IGUuZ2V0SW5mbygpfWNhdGNoKGUpe3JldHVybiB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0KSx3aW5kb3cuY2xlYXJUaW1lb3V0KHIpLGEobmV3IExvZ291dEVycm9yKFwiQ291bGQgbm90IGxvY2F0ZSBhdXRoIHdpbmRvd1wiKSksITF9cmV0dXJuIE5lKGUscixvLG4sYSx0KShpLnVybCl9KShyLGEsaSxlLG8sbikpLDUwMCl9KSgpfSkpO3ZhciBWZT10Lk1TLEJlPXQuXzcsWGU9dC5jWCxZZT10LnpMLFFlPXQuX1csWmU9dC5wOCxldD10LllSLHR0PXQuVSQscnQ9dC5VNyxvdD10Lk9GO2V4cG9ydHtWZSBhcyBBcGlFcnJvcixCZSBhcyBBdXRoZW50aWNhdGlvbkVycm9yLFhlIGFzIEluaXRpYWxpemF0aW9uRXJyb3IsWWUgYXMgTG9nb3V0RXJyb3IsUWUgYXMgUGFyYW1ldGVyRXJyb3IsWmUgYXMgVmFsaWRhdGlvbkVycm9yLGV0IGFzIGF1dGhlbnRpY2F0ZSx0dCBhcyBkaXNhYmxlTG9nZ2luZyxydCBhcyBlbmFibGVMb2dnaW5nLG90IGFzIHZhbGlkYXRlSWRUb2tlbn07IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgdHlwZSB7IE1vZHVsZUltcGxlbWVudGF0aW9uLCBNb2R1bGVUeXBlcyB9IGZyb20gXCJ3b3Jrc3BhY2UtcGxhdGZvcm0tc3RhcnRlci9zaGFwZXMvbW9kdWxlLXNoYXBlc1wiO1xuaW1wb3J0IHsgT3BlbklkQ29ubmVjdFByb3ZpZGVyIH0gZnJvbSBcIi4vYXV0aFwiO1xuXG4vKipcbiAqIERlZmluZSB0aGUgZW50cnkgcG9pbnRzIGZvciB0aGUgbW9kdWxlLlxuICovXG5leHBvcnQgY29uc3QgZW50cnlQb2ludHM6IHsgW3R5cGUgaW4gTW9kdWxlVHlwZXNdPzogTW9kdWxlSW1wbGVtZW50YXRpb24gfSA9IHtcblx0YXV0aDogbmV3IE9wZW5JZENvbm5lY3RQcm92aWRlcigpXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9