function t(t){return null==t}const i={lifecycle:new class{async initialize(t,i,n){this._definition=t,this._logger=i("ExampleNotificationServiceProvider"),this._helpers=n,this._logger.info("Initializing")}async closedown(){this._logger?.info("Closedown"),await this.stopNotificationService()}async get(){const t={};return t["after-bootstrap"]=async(t,i)=>{await this.startNotificationService()},t}async startNotificationService(){const i=this._definition?.data?.notificationSourceRootEndpointId??"notification-source",n=`${i}-create`,e=`${i}-update`,o=`${i}-clear`,a=`${i}-close`,s=`${i}-stream`,r="openfin.notificationoptions",c="openfin.updatablenotificationoptions",l="openfin.notification";if(!t(this._helpers?.getEndpointClient)){const i=await this._helpers.getEndpointClient();!t(i)&&i.hasEndpoint(n)&&i.hasEndpoint(e)&&i.hasEndpoint(o)&&i.hasEndpoint(a)&&i.hasEndpoint(s)&&(this._endpointClient=i)}if(!t(this._helpers?.getInteropClient)){const i=await this._helpers.getInteropClient();i&&(this._fdc3Client=await i.getFDC3("2.0")),i&&!t(this._endpointClient)&&!1!==this._definition?.data?.intentHandler?.enabled&&(this._interopClient=i,this._logger?.info("Registering intent service."),await(this._interopClient?.registerIntentHandler(async t=>{if(t.context.type===r){const i=t.context.notification,e=await(this._endpointClient?.action(n,{eventId:"create",payload:i}));this._logger?.info(`Intent handler called and notification sent: ${e}.`,t)}else this._logger?.warn(`A create notification intent was raised but it wasn't passed and ${r} context. Type: ${t.context.type}.`)},this._definition?.data?.intentHandler?.name?.create??"CreateNotification")),await(this._interopClient?.registerIntentHandler(async t=>{if(t.context.type===c){const i=t.context.notification,n=await(this._endpointClient?.action(e,{eventId:"update",payload:i}));this._logger?.info(`Intent handler called and notification sent: ${n}.`,t)}else this._logger?.warn(`A update notification intent was raised but it wasn't passed an ${c} context. Type: ${t.context.type}.`)},this._definition?.data?.intentHandler?.name?.update??"UpdateNotification")),await(this._interopClient?.registerIntentHandler(async i=>{if(i.context.type===l){const n=i.context.notification,e=n?.id;if(t(e))this._logger?.warn("A clear notification intent was raised but it wasn't passed a notification id.");else{const t=await(this._endpointClient?.action(o,{eventId:"clear",payload:{id:e}}));this._logger?.info(`Intent handler called and notification clear request sent: ${t}.`,i)}}else this._logger?.warn(`A clear notification intent was raised but it wasn't passed and ${l} context. Type: ${i.context.type}.`)},this._definition?.data?.intentHandler?.name?.clear??"ClearNotification")))}if(!t(!1!==this._definition?.data?.channelHandler?.enabled)){const i=`${fin.me.identity.uuid}/${this._definition?.data?.channelHandler?.name??"notification-service"}`,a=await fin.InterApplicationBus.Channel.create(i);a.onConnection(async(t,n)=>{if(this._logger?.info(`Channel connection request from: ${t.uuid}`,n),this._helpers?.getConnectionClient){const e=await this._helpers.getConnectionClient();if(!await e.isConnectionValid(t,n))throw this._logger?.warn(`Channel connection request from: ${t.uuid} to ${i} is not valid.`),new Error(`Connection to ${i} is not valid.`);this._logger?.info(`Channel connection request from: ${t.uuid} is valid.`)}}),a.register("create",async t=>{const e=t;if(e.type===r){const o=e.notification,a=await(this._endpointClient?.action(n,{eventId:"create",payload:o}));this._logger?.info(`${i} channel create function called and notification sent: ${a}.`,t)}else this._logger?.warn(`${i} channel create function called but it wasn't passed an ${r} context. Type: ${e.type}.`)}),a.register("update",async t=>{const n=t;if(n.type===c){const o=n.notification,a=await(this._endpointClient?.action(e,{eventId:"update",payload:o}));this._logger?.info(`${i} channel update function called and event sent: ${a}.`,t)}else this._logger?.warn(`${i} channel update function called but it wasn't passed an ${c} context. Type: ${n.type}.`)}),a.register("clear",async n=>{const e=n;if(e.type===l){const a=e.notification.id;if(t(a))this._logger?.warn(`${i} channel clear function called but it wasn't passed a notification id.`);else{const t=await(this._endpointClient?.action(o,{eventId:"clear",payload:{id:a}}));this._logger?.info(`${i} channel clear function called and event sent: ${t}.`,n)}}else this._logger?.warn(`${i} channel clear function called but it wasn't passed an ${l} context. Type: ${e.type}.`)})}if(this._helpers?.getNotificationClient&&(this._notificationSubscriptions||(this._notificationSubscriptions={}),this._notificationClient=await this._helpers.getNotificationClient(),this._notificationClient&&(await this.setupNotificationEventListeners(a),this._endpointClient))){const i=await this._endpointClient.requestStream(s);if(!t(i)){const t=i.getReader();this._logger?.info("Reading from stream");const n=this._logger,e=this._notificationClient;t.read().then(function i({done:o,value:a}){if(!o)return"create"===a.eventId?e?.create(a.payload):"update"===a.eventId?e?.update(a.payload):"clear"===a.eventId||"close"===a.eventId?e?.clear(a.payload.id):n?.warn("Unknown event type: received",a),t.read().then(i);n?.info("Stream ended")}).catch(t=>{this._logger?.error(`Error reading stream: ${t}`)})}}}async stopNotificationService(){this._logger?.info("Stopping notification service (This is an example.)"),await this.removeNotificationEventListeners()}async setupNotificationEventListeners(i){if(!t(this._notificationClient)&&!t(this._notificationSubscriptions)){const n=async i=>{if(t(i?.result))return void this._logger?.warn("Event for notification action received but it was empty or didn't have a result.");this._logger?.info("Event for notification action received.",i);const n=i.result.task,e=i.result.customData;await this.handleNotificationResponse(i.notification.id,n,e)};await this._notificationClient.addEventListener("notification-action",n),this._notificationSubscriptions["notification-action"]=n;const e=async i=>{if(t(i?.form))return void this._logger?.warn("Event for notification form received but it was empty or didn't have a form result.");if(t(i?.button?.onClick?.task)||t(i?.button?.onClick?.customData))return void this._logger?.warn("Event for notification form received but it was empty or didn't have a onclick customData result or task.");this._logger?.info("Event for notification form submitted received.",i);const n=i.button.onClick.customData,e=i.button?.onClick?.task;n.context||(n.context={type:"openfin.notification.form"}),n.context.form=i.form,await this.handleNotificationResponse(i.notification.id,e,n)};await this._notificationClient.addEventListener("notification-form-submitted",e),this._notificationSubscriptions["notification-form-submitted"]=e;const o=n=>{this._logger?.info("Event for notification closed received.",n);const e=n.notification.id;t(e)?this._logger?.warn("A notification was closed but it didn't have a notification id."):this._endpointClient?.action(i,{eventId:"close",payload:{id:e}}).then(t=>(this._logger?.info(`Notification was closed, sending clear request for other machines. Notification Id: ${e}. Sent: ${t}`),!0)).catch(t=>{this._logger?.error("A close event passed to the endpoint but had the following error.",t)})};await this._notificationClient.addEventListener("notification-closed",o),this._notificationSubscriptions["notification-closed"]=o}}async handleNotificationResponse(i,n,e){switch(n){case"raise-intent":{const i={name:e.id,context:e.context??{type:"fdc3.nothing"},metadata:{target:e?.target}};try{await(this._interopClient?.fireIntent(i))}catch(n){if(this._logger?.error("Error firing intent in response to a notification click.",n),"TargetInstanceUnavailable"===n?.message){this._logger?.error(`Error firing intent in response to a notification click as the target instance ${e?.target?.instanceId} is unavailable. Launch the app without a specific instance as it may have been closed.`);try{if(i.metadata.target){if(i.metadata.target.instanceId=void 0,"new"!==this._definition?.data?.intentLauncher?.instanceIdFallback){const n=await(this._interopClient?.getInfoForIntent(i));if(n?.apps){const e=n.apps.find(n=>n.appId===i.metadata.target?.appId&&!t(n.instanceId));e&&(i.metadata.target.instanceId=e.instanceId)}}await(this._interopClient?.fireIntent(i))}}catch(t){this._logger?.error("Error firing intent in response to a notification click after removing the instance id and just targeting the app.",t)}}}break}case"launch-app":try{if(this._fdc3Client&&e.id){const i=e.target??{appId:e.id};try{await this._fdc3Client.open(i,e.context)}catch(n){const o=n?.message;t(i.instanceId)||"AppTimeout"!==o?this._logger?.error(`Error showing app ${e?.id} in response to a notification click using fdc3.open.`,n):await this._fdc3Client.open({appId:e.id},e.context)}}else this._logger?.error(`Error showing app ${e?.id} in response to a notification click as the fdc3 api (through getInteropClient) is not available or the appId is not provided.`)}catch(t){this._logger?.error(`Error showing app ${e?.id} in response to a notification click.`,t)}break;case"launch-content":try{this._helpers?.launchPage&&e.id?await(this._helpers?.launchPage(e.id)):this._logger?.error(`Error launching content ${e?.id} in response to a notification click as the launchPage function is not available or the pageId is not provided.`)}catch(t){this._logger?.error(`Error launching page ${e?.id} in response to a notification click.`,t)}break;case"broadcast":try{if(this._helpers?.getInteropClient&&e?.context&&e?.id){const t=await this._helpers.getInteropClient();if(t&&e.broadcastOptions?.isUserChannel)await t.joinContextGroup(e.id),t.setContext(e.context);else if(t){const i=await t.joinSessionContextGroup(e.id);await i.setContext(e.context)}}else this._logger?.error("Error broadcasting context from a notification is not available as either an interop client is not available or no userChannel or appChannel was specified or context was not passed.")}catch(t){this._logger?.error("Error broadcasting context.",t)}break;case"endpoint":try{if(this._endpointClient&&e?.id)if(this._endpointClient.hasEndpoint(e.id)){this._logger?.info(`Sending request to endpoint ${e.id} as a result of an interaction with notification: ${i}`);const t=e.endpointOptions?.request??e.context;await this._endpointClient.action(e.id,t)}else this._logger?.warn(`Not sending request to endpoint ${e.id} as a result of an interaction with notification: ${i} because either the endpoint id doesn't exist or this module does not have permission to access it.`);else this._logger?.error("Error performing endpoint action on this notification as either an endpoint id was not specified or we do not have access to an endpoint client.")}catch(t){this._logger?.error(`Error calling an action on endpoint with id ${e.id}.`,t)}}}async removeNotificationEventListeners(){if(!t(this._notificationClient)&&!t(this._notificationSubscriptions))for(const[t,i]of Object.entries(this._notificationSubscriptions))await this._notificationClient.removeEventListener(t,i)}}};export{i as entryPoints};
//# sourceMappingURL=example-notification-service.bundle.js.map