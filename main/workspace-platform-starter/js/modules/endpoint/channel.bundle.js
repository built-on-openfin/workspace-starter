var o={};function n(o){return null==o}o.d=(n,t)=>{for(var e in t)o.o(t,e)&&!o.o(n,e)&&Object.defineProperty(n,e,{enumerable:!0,get:t[e]})},o.o=(o,n)=>Object.prototype.hasOwnProperty.call(o,n);const t={endpoint:new class{async initialize(o,n,t){this._logger=n("ChannelEndpoint"),this._logger.info("Was passed the following options",o.data)}async action(o,t){if(n(t))return this._logger?.warn(`A request is required for this action: ${o.id}. Returning false`),!1;if("module"!==o.type)return this._logger?.warn(`We only expect endpoints of type module. Unable to perform action: ${o.id}`),!1;const e=o?.options?.logInfo??!0,i=o?.options?.logWarn??!0,r=o?.options?.logError??!0;if(n(o.options)||n(o.options.actionName)||n(o.options.channelName))return i&&this._logger?.warn(`You need to provide actionName and channelName for endpoint: ${o.id}`),!1;try{const r=await fin.InterApplicationBus.Channel.connect(o.options.channelName,{wait:o.options.wait,payload:o.options.payload});return n(o.options.uuid)||o.options.uuid===r.providerIdentity.uuid?(e&&this._logger?.info(`Sending action for endpoint id: ${o.id}`),await r.dispatch(o.options.actionName,t?.payload),await r.disconnect(),!0):(i&&this._logger?.warn(`Endpoint Id: ${o.id} has the source running (${o.options.uuid}) but the provider of the channel: ${o.options.channelName} is not coming from the source. Returning false.`),!1)}catch(n){return r&&this._logger?.error(`Error executing/or connecting to action. Endpoint with id: ${o.id}`,n),!1}}async requestResponse(o,t){let e=null;if("module"!==o.type)return this._logger?.warn(`We only expect endpoints of type module. Unable to action request/response for: ${o.id}`),e;const i=o?.options?.logInfo??!0,r=o?.options?.logWarn??!0,a=o?.options?.logError??!0;if(n(o?.options?.default)||("array"===o.options.default?e=[]:"object"===o.options.default&&(e={})),n(o.options)||n(o.options.actionName)||n(o.options.channelName))return r&&this._logger?.warn(`You need to provide actionName and channelName for endpoint: ${o.id}`),e;try{const a=await fin.InterApplicationBus.Channel.connect(o.options.channelName,{wait:o.options.wait,payload:o.options.payload});if(!n(o.options.uuid)&&o.options.uuid!==a.providerIdentity.uuid)return r&&this._logger?.warn(`Endpoint Id: ${o.id} has the source running (${o.options.uuid}) but the provider of the channel: ${o.options.channelName} is not coming from the source. Returning false.`),e;i&&this._logger?.info(`Sending request response for endpoint: ${o.id}`);const s=await a.dispatch(o.options.actionName,t?.payload);return await a.disconnect(),s}catch(n){return a&&this._logger?.error(`Error executing request/response and connecting to endpoint with id: ${o.id}`,n),e}}}};export{t as entryPoints};
//# sourceMappingURL=channel.bundle.js.map