function n(n){return null==n}const o={endpoint:new class{async initialize(n,o,t){this._logger=o("ChannelEndpoint"),this._logger.info("Was passed the following options",n.data)}async action(o,t){if(n(t))return this._logger?.warn(`A request is required for this action: ${o.id}. Returning false`),!1;if("module"!==o.type)return this._logger?.warn(`We only expect endpoints of type module. Unable to perform action: ${o.id}`),!1;const i=o?.options?.logInfo??!0,e=o?.options?.logWarn??!0,r=o?.options?.logError??!0;if(n(o.options)||n(o.options.actionName)||n(o.options.channelName))return e&&this._logger?.warn(`You need to provide actionName and channelName for endpoint: ${o.id}`),!1;try{const r=await fin.InterApplicationBus.Channel.connect(o.options.channelName,{wait:o.options.wait,payload:o.options.payload});return n(o.options.uuid)||o.options.uuid===r.providerIdentity.uuid?(i&&this._logger?.info(`Sending action for endpoint id: ${o.id}`),await r.dispatch(o.options.actionName,t?.payload),await r.disconnect(),!0):(e&&this._logger?.warn(`Endpoint Id: ${o.id} has the source running (${o.options.uuid}) but the provider of the channel: ${o.options.channelName} is not coming from the source. Returning false.`),!1)}catch(n){return r&&this._logger?.error(`Error executing/or connecting to action. Endpoint with id: ${o.id}`,n),!1}}async requestResponse(o,t){let i=null;if("module"!==o.type)return this._logger?.warn(`We only expect endpoints of type module. Unable to action request/response for: ${o.id}`),i;const e=o?.options?.logInfo??!0,r=o?.options?.logWarn??!0,a=o?.options?.logError??!0;if(n(o?.options?.default)||("array"===o.options.default?i=[]:"object"===o.options.default&&(i={})),n(o.options)||n(o.options.actionName)||n(o.options.channelName))return r&&this._logger?.warn(`You need to provide actionName and channelName for endpoint: ${o.id}`),i;try{const a=await fin.InterApplicationBus.Channel.connect(o.options.channelName,{wait:o.options.wait,payload:o.options.payload});if(!n(o.options.uuid)&&o.options.uuid!==a.providerIdentity.uuid)return r&&this._logger?.warn(`Endpoint Id: ${o.id} has the source running (${o.options.uuid}) but the provider of the channel: ${o.options.channelName} is not coming from the source. Returning false.`),i;e&&this._logger?.info(`Sending request response for endpoint: ${o.id}`);const s=await a.dispatch(o.options.actionName,t?.payload);return await a.disconnect(),s}catch(n){return a&&this._logger?.error(`Error executing request/response and connecting to endpoint with id: ${o.id}`,n),i}}}};export{o as entryPoints};
//# sourceMappingURL=channel.bundle.js.map